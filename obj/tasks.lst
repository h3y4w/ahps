   1              		.syntax unified
   2              		.cpu cortex-m4
   3              		.eabi_attribute 27, 3
   4              		.fpu fpv4-sp-d16
   5              		.eabi_attribute 20, 1
   6              		.eabi_attribute 21, 1
   7              		.eabi_attribute 23, 3
   8              		.eabi_attribute 24, 1
   9              		.eabi_attribute 25, 1
  10              		.eabi_attribute 26, 1
  11              		.eabi_attribute 30, 1
  12              		.eabi_attribute 34, 1
  13              		.eabi_attribute 18, 4
  14              		.thumb
  15              		.file	"tasks.c"
  16              		.text
  17              	.Ltext0:
  18              		.cfi_sections	.debug_frame
  19              		.section	.text.usTaskCheckFreeStackSpace,"ax",%progbits
  20              		.align	2
  21              		.thumb
  22              		.thumb_func
  24              	usTaskCheckFreeStackSpace:
  25              	.LFB146:
  26              		.file 1 "FreeRTOS/Source/tasks.c"
   1:FreeRTOS/Source/tasks.c **** /*
   2:FreeRTOS/Source/tasks.c ****     FreeRTOS V7.0.2 - Copyright (C) 2011 Real Time Engineers Ltd.
   3:FreeRTOS/Source/tasks.c **** 	
   4:FreeRTOS/Source/tasks.c **** 
   5:FreeRTOS/Source/tasks.c ****     ***************************************************************************
   6:FreeRTOS/Source/tasks.c ****      *                                                                       *
   7:FreeRTOS/Source/tasks.c ****      *    FreeRTOS tutorial books are available in pdf and paperback.        *
   8:FreeRTOS/Source/tasks.c ****      *    Complete, revised, and edited pdf reference manuals are also       *
   9:FreeRTOS/Source/tasks.c ****      *    available.                                                         *
  10:FreeRTOS/Source/tasks.c ****      *                                                                       *
  11:FreeRTOS/Source/tasks.c ****      *    Purchasing FreeRTOS documentation will not only help you, by       *
  12:FreeRTOS/Source/tasks.c ****      *    ensuring you get running as quickly as possible and with an        *
  13:FreeRTOS/Source/tasks.c ****      *    in-depth knowledge of how to use FreeRTOS, it will also help       *
  14:FreeRTOS/Source/tasks.c ****      *    the FreeRTOS project to continue with its mission of providing     *
  15:FreeRTOS/Source/tasks.c ****      *    professional grade, cross platform, de facto standard solutions    *
  16:FreeRTOS/Source/tasks.c ****      *    for microcontrollers - completely free of charge!                  *
  17:FreeRTOS/Source/tasks.c ****      *                                                                       *
  18:FreeRTOS/Source/tasks.c ****      *    >>> See http://www.FreeRTOS.org/Documentation for details. <<<     *
  19:FreeRTOS/Source/tasks.c ****      *                                                                       *
  20:FreeRTOS/Source/tasks.c ****      *    Thank you for using FreeRTOS, and thank you for your support!      *
  21:FreeRTOS/Source/tasks.c ****      *                                                                       *
  22:FreeRTOS/Source/tasks.c ****     ***************************************************************************
  23:FreeRTOS/Source/tasks.c **** 
  24:FreeRTOS/Source/tasks.c **** 
  25:FreeRTOS/Source/tasks.c ****     This file is part of the FreeRTOS distribution.
  26:FreeRTOS/Source/tasks.c **** 
  27:FreeRTOS/Source/tasks.c ****     FreeRTOS is free software; you can redistribute it and/or modify it under
  28:FreeRTOS/Source/tasks.c ****     the terms of the GNU General Public License (version 2) as published by the
  29:FreeRTOS/Source/tasks.c ****     Free Software Foundation AND MODIFIED BY the FreeRTOS exception.
  30:FreeRTOS/Source/tasks.c ****     >>>NOTE<<< The modification to the GPL is included to allow you to
  31:FreeRTOS/Source/tasks.c ****     distribute a combined work that includes FreeRTOS without being obliged to
  32:FreeRTOS/Source/tasks.c ****     provide the source code for proprietary components outside of the FreeRTOS
  33:FreeRTOS/Source/tasks.c ****     kernel.  FreeRTOS is distributed in the hope that it will be useful, but
  34:FreeRTOS/Source/tasks.c ****     WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  35:FreeRTOS/Source/tasks.c ****     or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
  36:FreeRTOS/Source/tasks.c ****     more details. You should have received a copy of the GNU General Public
  37:FreeRTOS/Source/tasks.c ****     License and the FreeRTOS license exception along with FreeRTOS; if not it
  38:FreeRTOS/Source/tasks.c ****     can be viewed here: http://www.freertos.org/a00114.html and also obtained
  39:FreeRTOS/Source/tasks.c ****     by writing to Richard Barry, contact details for whom are available on the
  40:FreeRTOS/Source/tasks.c ****     FreeRTOS WEB site.
  41:FreeRTOS/Source/tasks.c **** 
  42:FreeRTOS/Source/tasks.c ****     1 tab == 4 spaces!
  43:FreeRTOS/Source/tasks.c **** 
  44:FreeRTOS/Source/tasks.c ****     http://www.FreeRTOS.org - Documentation, latest information, license and
  45:FreeRTOS/Source/tasks.c ****     contact details.
  46:FreeRTOS/Source/tasks.c **** 
  47:FreeRTOS/Source/tasks.c ****     http://www.SafeRTOS.com - A version that is certified for use in safety
  48:FreeRTOS/Source/tasks.c ****     critical systems.
  49:FreeRTOS/Source/tasks.c **** 
  50:FreeRTOS/Source/tasks.c ****     http://www.OpenRTOS.com - Commercial support, development, porting,
  51:FreeRTOS/Source/tasks.c ****     licensing and training services.
  52:FreeRTOS/Source/tasks.c **** */
  53:FreeRTOS/Source/tasks.c **** 
  54:FreeRTOS/Source/tasks.c **** 
  55:FreeRTOS/Source/tasks.c **** #include <stdio.h>
  56:FreeRTOS/Source/tasks.c **** #include <stdlib.h>
  57:FreeRTOS/Source/tasks.c **** #include <string.h>
  58:FreeRTOS/Source/tasks.c **** 
  59:FreeRTOS/Source/tasks.c **** /* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
  60:FreeRTOS/Source/tasks.c **** all the API functions to use the MPU wrappers.  That should only be done when
  61:FreeRTOS/Source/tasks.c **** task.h is included from an application file. */
  62:FreeRTOS/Source/tasks.c **** #define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
  63:FreeRTOS/Source/tasks.c **** 
  64:FreeRTOS/Source/tasks.c **** #include "FreeRTOS.h"
  65:FreeRTOS/Source/tasks.c **** #include "task.h"
  66:FreeRTOS/Source/tasks.c **** #include "timers.h"
  67:FreeRTOS/Source/tasks.c **** #include "StackMacros.h"
  68:FreeRTOS/Source/tasks.c **** 
  69:FreeRTOS/Source/tasks.c **** #undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE
  70:FreeRTOS/Source/tasks.c **** 
  71:FreeRTOS/Source/tasks.c **** /*
  72:FreeRTOS/Source/tasks.c ****  * Macro to define the amount of stack available to the idle task.
  73:FreeRTOS/Source/tasks.c ****  */
  74:FreeRTOS/Source/tasks.c **** #define tskIDLE_STACK_SIZE	configMINIMAL_STACK_SIZE
  75:FreeRTOS/Source/tasks.c **** 
  76:FreeRTOS/Source/tasks.c **** /*
  77:FreeRTOS/Source/tasks.c ****  * Task control block.  A task control block (TCB) is allocated to each task,
  78:FreeRTOS/Source/tasks.c ****  * and stores the context of the task.
  79:FreeRTOS/Source/tasks.c ****  */
  80:FreeRTOS/Source/tasks.c **** typedef struct tskTaskControlBlock
  81:FreeRTOS/Source/tasks.c **** {
  82:FreeRTOS/Source/tasks.c **** 	volatile portSTACK_TYPE	*pxTopOfStack;		/*< Points to the location of the last item placed on the 
  83:FreeRTOS/Source/tasks.c **** 
  84:FreeRTOS/Source/tasks.c **** 	#if ( portUSING_MPU_WRAPPERS == 1 )
  85:FreeRTOS/Source/tasks.c **** 		xMPU_SETTINGS xMPUSettings;				/*< The MPU settings are defined as part of the port layer.  THIS 
  86:FreeRTOS/Source/tasks.c **** 	#endif	
  87:FreeRTOS/Source/tasks.c **** 	
  88:FreeRTOS/Source/tasks.c **** 	xListItem				xGenericListItem;	/*< List item used to place the TCB in ready and blocked queues. */
  89:FreeRTOS/Source/tasks.c **** 	xListItem				xEventListItem;		/*< List item used to place the TCB in event lists. */
  90:FreeRTOS/Source/tasks.c **** 	unsigned portBASE_TYPE	uxPriority;			/*< The priority of the task where 0 is the lowest priority. 
  91:FreeRTOS/Source/tasks.c **** 	portSTACK_TYPE			*pxStack;			/*< Points to the start of the stack. */
  92:FreeRTOS/Source/tasks.c **** 	signed char				pcTaskName[ configMAX_TASK_NAME_LEN ];/*< Descriptive name given to the task when c
  93:FreeRTOS/Source/tasks.c **** 
  94:FreeRTOS/Source/tasks.c **** 	#if ( portSTACK_GROWTH > 0 )
  95:FreeRTOS/Source/tasks.c **** 		portSTACK_TYPE *pxEndOfStack;			/*< Used for stack overflow checking on architectures where the s
  96:FreeRTOS/Source/tasks.c **** 	#endif
  97:FreeRTOS/Source/tasks.c **** 
  98:FreeRTOS/Source/tasks.c **** 	#if ( portCRITICAL_NESTING_IN_TCB == 1 )
  99:FreeRTOS/Source/tasks.c **** 		unsigned portBASE_TYPE uxCriticalNesting;
 100:FreeRTOS/Source/tasks.c **** 	#endif
 101:FreeRTOS/Source/tasks.c **** 
 102:FreeRTOS/Source/tasks.c **** 	#if ( configUSE_TRACE_FACILITY == 1 )
 103:FreeRTOS/Source/tasks.c **** 		unsigned portBASE_TYPE	uxTCBNumber;	/*< This is used for tracing the scheduler and making debuggi
 104:FreeRTOS/Source/tasks.c **** 	#endif
 105:FreeRTOS/Source/tasks.c **** 
 106:FreeRTOS/Source/tasks.c **** 	#if ( configUSE_MUTEXES == 1 )
 107:FreeRTOS/Source/tasks.c **** 		unsigned portBASE_TYPE uxBasePriority;	/*< The priority last assigned to the task - used by the p
 108:FreeRTOS/Source/tasks.c **** 	#endif
 109:FreeRTOS/Source/tasks.c **** 
 110:FreeRTOS/Source/tasks.c **** 	#if ( configUSE_APPLICATION_TASK_TAG == 1 )
 111:FreeRTOS/Source/tasks.c **** 		pdTASK_HOOK_CODE pxTaskTag;
 112:FreeRTOS/Source/tasks.c **** 	#endif
 113:FreeRTOS/Source/tasks.c **** 
 114:FreeRTOS/Source/tasks.c **** 	#if ( configGENERATE_RUN_TIME_STATS == 1 )
 115:FreeRTOS/Source/tasks.c **** 		unsigned long ulRunTimeCounter;		/*< Used for calculating how much CPU time each task is utilisin
 116:FreeRTOS/Source/tasks.c **** 	#endif
 117:FreeRTOS/Source/tasks.c **** 
 118:FreeRTOS/Source/tasks.c **** } tskTCB;
 119:FreeRTOS/Source/tasks.c **** 
 120:FreeRTOS/Source/tasks.c **** 
 121:FreeRTOS/Source/tasks.c **** /*
 122:FreeRTOS/Source/tasks.c ****  * Some kernel aware debuggers require data to be viewed to be global, rather
 123:FreeRTOS/Source/tasks.c ****  * than file scope.
 124:FreeRTOS/Source/tasks.c ****  */
 125:FreeRTOS/Source/tasks.c **** #ifdef portREMOVE_STATIC_QUALIFIER
 126:FreeRTOS/Source/tasks.c **** 	#define static
 127:FreeRTOS/Source/tasks.c **** #endif
 128:FreeRTOS/Source/tasks.c **** 
 129:FreeRTOS/Source/tasks.c **** /*lint -e956 */
 130:FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA tskTCB * volatile pxCurrentTCB = NULL;
 131:FreeRTOS/Source/tasks.c **** 
 132:FreeRTOS/Source/tasks.c **** /* Lists for ready and blocked tasks. --------------------*/
 133:FreeRTOS/Source/tasks.c **** 
 134:FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static xList pxReadyTasksLists[ configMAX_PRIORITIES ];	/*< Prioritised ready tasks
 135:FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static xList xDelayedTaskList1;							/*< Delayed tasks. */
 136:FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static xList xDelayedTaskList2;							/*< Delayed tasks (two lists are used - one f
 137:FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static xList * volatile pxDelayedTaskList ;				/*< Points to the delayed task list 
 138:FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static xList * volatile pxOverflowDelayedTaskList;		/*< Points to the delayed task 
 139:FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static xList xPendingReadyList;							/*< Tasks that have been readied while the sc
 140:FreeRTOS/Source/tasks.c **** 
 141:FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskDelete == 1 )
 142:FreeRTOS/Source/tasks.c **** 
 143:FreeRTOS/Source/tasks.c **** 	PRIVILEGED_DATA static xList xTasksWaitingTermination;				/*< Tasks that have been deleted - but t
 144:FreeRTOS/Source/tasks.c **** 	PRIVILEGED_DATA static volatile unsigned portBASE_TYPE uxTasksDeleted = ( unsigned portBASE_TYPE )
 145:FreeRTOS/Source/tasks.c **** 
 146:FreeRTOS/Source/tasks.c **** #endif
 147:FreeRTOS/Source/tasks.c **** 
 148:FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
 149:FreeRTOS/Source/tasks.c **** 
 150:FreeRTOS/Source/tasks.c **** 	PRIVILEGED_DATA static xList xSuspendedTaskList;					/*< Tasks that are currently suspended. */
 151:FreeRTOS/Source/tasks.c **** 
 152:FreeRTOS/Source/tasks.c **** #endif
 153:FreeRTOS/Source/tasks.c **** 
 154:FreeRTOS/Source/tasks.c **** #if ( INCLUDE_xTaskGetIdleTaskHandle == 1 )
 155:FreeRTOS/Source/tasks.c **** 	
 156:FreeRTOS/Source/tasks.c **** 	PRIVILEGED_DATA static xTaskHandle xIdleTaskHandle = NULL;
 157:FreeRTOS/Source/tasks.c **** 	
 158:FreeRTOS/Source/tasks.c **** #endif
 159:FreeRTOS/Source/tasks.c **** 
 160:FreeRTOS/Source/tasks.c **** /* File private variables. --------------------------------*/
 161:FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static volatile unsigned portBASE_TYPE uxCurrentNumberOfTasks 	= ( unsigned portBAS
 162:FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static volatile portTickType xTickCount 						= ( portTickType ) 0U;
 163:FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static unsigned portBASE_TYPE uxTopUsedPriority	 				= tskIDLE_PRIORITY;
 164:FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static volatile unsigned portBASE_TYPE uxTopReadyPriority 		= tskIDLE_PRIORITY;
 165:FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static volatile signed portBASE_TYPE xSchedulerRunning 			= pdFALSE;
 166:FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static volatile unsigned portBASE_TYPE uxSchedulerSuspended	 	= ( unsigned portBASE
 167:FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static volatile unsigned portBASE_TYPE uxMissedTicks 			= ( unsigned portBASE_TYPE 
 168:FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static volatile portBASE_TYPE xMissedYield 						= ( portBASE_TYPE ) pdFALSE;
 169:FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static volatile portBASE_TYPE xNumOfOverflows 					= ( portBASE_TYPE ) 0;
 170:FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static unsigned portBASE_TYPE uxTaskNumber 						= ( unsigned portBASE_TYPE ) 0U;
 171:FreeRTOS/Source/tasks.c **** PRIVILEGED_DATA static portTickType xNextTaskUnblockTime						= ( portTickType ) portMAX_DELAY;
 172:FreeRTOS/Source/tasks.c **** 
 173:FreeRTOS/Source/tasks.c **** #if ( configGENERATE_RUN_TIME_STATS == 1 )
 174:FreeRTOS/Source/tasks.c **** 
 175:FreeRTOS/Source/tasks.c **** 	PRIVILEGED_DATA static char pcStatsString[ 50 ] ;
 176:FreeRTOS/Source/tasks.c **** 	PRIVILEGED_DATA static unsigned long ulTaskSwitchedInTime = 0UL;	/*< Holds the value of a timer/co
 177:FreeRTOS/Source/tasks.c **** 	static void prvGenerateRunTimeStatsForTasksInList( const signed char *pcWriteBuffer, xList *pxList
 178:FreeRTOS/Source/tasks.c **** 
 179:FreeRTOS/Source/tasks.c **** #endif
 180:FreeRTOS/Source/tasks.c **** 
 181:FreeRTOS/Source/tasks.c **** /* Debugging and trace facilities private variables and macros. ------------*/
 182:FreeRTOS/Source/tasks.c **** 
 183:FreeRTOS/Source/tasks.c **** /*
 184:FreeRTOS/Source/tasks.c ****  * The value used to fill the stack of a task when the task is created.  This
 185:FreeRTOS/Source/tasks.c ****  * is used purely for checking the high water mark for tasks.
 186:FreeRTOS/Source/tasks.c ****  */
 187:FreeRTOS/Source/tasks.c **** #define tskSTACK_FILL_BYTE	( 0xa5U )
 188:FreeRTOS/Source/tasks.c **** 
 189:FreeRTOS/Source/tasks.c **** /*
 190:FreeRTOS/Source/tasks.c ****  * Macros used by vListTask to indicate which state a task is in.
 191:FreeRTOS/Source/tasks.c ****  */
 192:FreeRTOS/Source/tasks.c **** #define tskBLOCKED_CHAR		( ( signed char ) 'B' )
 193:FreeRTOS/Source/tasks.c **** #define tskREADY_CHAR		( ( signed char ) 'R' )
 194:FreeRTOS/Source/tasks.c **** #define tskDELETED_CHAR		( ( signed char ) 'D' )
 195:FreeRTOS/Source/tasks.c **** #define tskSUSPENDED_CHAR	( ( signed char ) 'S' )
 196:FreeRTOS/Source/tasks.c **** 
 197:FreeRTOS/Source/tasks.c **** /*
 198:FreeRTOS/Source/tasks.c ****  * Macros and private variables used by the trace facility.
 199:FreeRTOS/Source/tasks.c ****  */
 200:FreeRTOS/Source/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
 201:FreeRTOS/Source/tasks.c **** 
 202:FreeRTOS/Source/tasks.c **** 	#define tskSIZE_OF_EACH_TRACE_LINE			( ( unsigned long ) ( sizeof( unsigned long ) + sizeof( unsig
 203:FreeRTOS/Source/tasks.c **** 	PRIVILEGED_DATA static volatile signed char * volatile pcTraceBuffer;
 204:FreeRTOS/Source/tasks.c **** 	PRIVILEGED_DATA static signed char *pcTraceBufferStart;
 205:FreeRTOS/Source/tasks.c **** 	PRIVILEGED_DATA static signed char *pcTraceBufferEnd;
 206:FreeRTOS/Source/tasks.c **** 	PRIVILEGED_DATA static signed portBASE_TYPE xTracing = pdFALSE;
 207:FreeRTOS/Source/tasks.c **** 	static unsigned portBASE_TYPE uxPreviousTask = 255U;
 208:FreeRTOS/Source/tasks.c **** 	PRIVILEGED_DATA static char pcStatusString[ 50 ];
 209:FreeRTOS/Source/tasks.c **** 
 210:FreeRTOS/Source/tasks.c **** #endif
 211:FreeRTOS/Source/tasks.c **** 
 212:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 213:FreeRTOS/Source/tasks.c **** 
 214:FreeRTOS/Source/tasks.c **** /*
 215:FreeRTOS/Source/tasks.c ****  * Macro that writes a trace of scheduler activity to a buffer.  This trace
 216:FreeRTOS/Source/tasks.c ****  * shows which task is running when and is very useful as a debugging tool.
 217:FreeRTOS/Source/tasks.c ****  * As this macro is called each context switch it is a good idea to undefine
 218:FreeRTOS/Source/tasks.c ****  * it if not using the facility.
 219:FreeRTOS/Source/tasks.c ****  */
 220:FreeRTOS/Source/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
 221:FreeRTOS/Source/tasks.c **** 
 222:FreeRTOS/Source/tasks.c **** 	#define vWriteTraceToBuffer()																	\
 223:FreeRTOS/Source/tasks.c **** 	{																								\
 224:FreeRTOS/Source/tasks.c **** 		if( xTracing != pdFALSE )																	\
 225:FreeRTOS/Source/tasks.c **** 		{																							\
 226:FreeRTOS/Source/tasks.c **** 			if( uxPreviousTask != pxCurrentTCB->uxTCBNumber )										\
 227:FreeRTOS/Source/tasks.c **** 			{																						\
 228:FreeRTOS/Source/tasks.c **** 				if( ( pcTraceBuffer + tskSIZE_OF_EACH_TRACE_LINE ) < pcTraceBufferEnd )				\
 229:FreeRTOS/Source/tasks.c **** 				{																					\
 230:FreeRTOS/Source/tasks.c **** 					uxPreviousTask = pxCurrentTCB->uxTCBNumber;										\
 231:FreeRTOS/Source/tasks.c **** 					*( unsigned long * ) pcTraceBuffer = ( unsigned long ) xTickCount;				\
 232:FreeRTOS/Source/tasks.c **** 					pcTraceBuffer += sizeof( unsigned long );										\
 233:FreeRTOS/Source/tasks.c **** 					*( unsigned long * ) pcTraceBuffer = ( unsigned long ) uxPreviousTask;			\
 234:FreeRTOS/Source/tasks.c **** 					pcTraceBuffer += sizeof( unsigned long );										\
 235:FreeRTOS/Source/tasks.c **** 				}																					\
 236:FreeRTOS/Source/tasks.c **** 				else																				\
 237:FreeRTOS/Source/tasks.c **** 				{																					\
 238:FreeRTOS/Source/tasks.c **** 					xTracing = pdFALSE;																\
 239:FreeRTOS/Source/tasks.c **** 				}																					\
 240:FreeRTOS/Source/tasks.c **** 			}																						\
 241:FreeRTOS/Source/tasks.c **** 		}																							\
 242:FreeRTOS/Source/tasks.c **** 	}
 243:FreeRTOS/Source/tasks.c **** 
 244:FreeRTOS/Source/tasks.c **** #else
 245:FreeRTOS/Source/tasks.c **** 
 246:FreeRTOS/Source/tasks.c **** 	#define vWriteTraceToBuffer()
 247:FreeRTOS/Source/tasks.c **** 
 248:FreeRTOS/Source/tasks.c **** #endif
 249:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 250:FreeRTOS/Source/tasks.c **** 
 251:FreeRTOS/Source/tasks.c **** /*
 252:FreeRTOS/Source/tasks.c ****  * Place the task represented by pxTCB into the appropriate ready queue for
 253:FreeRTOS/Source/tasks.c ****  * the task.  It is inserted at the end of the list.  One quirk of this is
 254:FreeRTOS/Source/tasks.c ****  * that if the task being inserted is at the same priority as the currently
 255:FreeRTOS/Source/tasks.c ****  * executing task, then it will only be rescheduled after the currently
 256:FreeRTOS/Source/tasks.c ****  * executing task has been rescheduled.
 257:FreeRTOS/Source/tasks.c ****  */
 258:FreeRTOS/Source/tasks.c **** #define prvAddTaskToReadyQueue( pxTCB )																					\
 259:FreeRTOS/Source/tasks.c **** 	if( ( pxTCB )->uxPriority > uxTopReadyPriority )																	\
 260:FreeRTOS/Source/tasks.c **** 	{																													\
 261:FreeRTOS/Source/tasks.c **** 		uxTopReadyPriority = ( pxTCB )->uxPriority;																		\
 262:FreeRTOS/Source/tasks.c **** 	}																													\
 263:FreeRTOS/Source/tasks.c **** 	vListInsertEnd( ( xList * ) &( pxReadyTasksLists[ ( pxTCB )->uxPriority ] ), &( ( pxTCB )->xGeneri
 264:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 265:FreeRTOS/Source/tasks.c **** 
 266:FreeRTOS/Source/tasks.c **** /*
 267:FreeRTOS/Source/tasks.c ****  * Macro that looks at the list of tasks that are currently delayed to see if
 268:FreeRTOS/Source/tasks.c ****  * any require waking.
 269:FreeRTOS/Source/tasks.c ****  *
 270:FreeRTOS/Source/tasks.c ****  * Tasks are stored in the queue in the order of their wake time - meaning
 271:FreeRTOS/Source/tasks.c ****  * once one tasks has been found whose timer has not expired we need not look
 272:FreeRTOS/Source/tasks.c ****  * any further down the list.
 273:FreeRTOS/Source/tasks.c ****  */
 274:FreeRTOS/Source/tasks.c **** #define prvCheckDelayedTasks()															\
 275:FreeRTOS/Source/tasks.c **** {																						\
 276:FreeRTOS/Source/tasks.c **** portTickType xItemValue;																\
 277:FreeRTOS/Source/tasks.c **** 																						\
 278:FreeRTOS/Source/tasks.c **** 	/* Is the tick count greater than or equal to the wake time of the first			\
 279:FreeRTOS/Source/tasks.c **** 	task referenced from the delayed tasks list? */										\
 280:FreeRTOS/Source/tasks.c **** 	if( xTickCount >= xNextTaskUnblockTime )											\
 281:FreeRTOS/Source/tasks.c **** 	{																					\
 282:FreeRTOS/Source/tasks.c **** 		for( ;; )																		\
 283:FreeRTOS/Source/tasks.c **** 		{																				\
 284:FreeRTOS/Source/tasks.c **** 			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )						\
 285:FreeRTOS/Source/tasks.c **** 			{																			\
 286:FreeRTOS/Source/tasks.c **** 				/* The delayed list is empty.  Set xNextTaskUnblockTime to the			\
 287:FreeRTOS/Source/tasks.c **** 				maximum possible value so it is extremely unlikely that the				\
 288:FreeRTOS/Source/tasks.c **** 				if( xTickCount >= xNextTaskUnblockTime ) test will pass next			\
 289:FreeRTOS/Source/tasks.c **** 				time through. */														\
 290:FreeRTOS/Source/tasks.c **** 				xNextTaskUnblockTime = portMAX_DELAY;									\
 291:FreeRTOS/Source/tasks.c **** 				break;																	\
 292:FreeRTOS/Source/tasks.c **** 			}																			\
 293:FreeRTOS/Source/tasks.c **** 			else																		\
 294:FreeRTOS/Source/tasks.c **** 			{																			\
 295:FreeRTOS/Source/tasks.c **** 				/* The delayed list is not empty, get the value of the item at			\
 296:FreeRTOS/Source/tasks.c **** 				the head of the delayed list.  This is the time at which the			\
 297:FreeRTOS/Source/tasks.c **** 				task at the head of the delayed list should be removed from				\
 298:FreeRTOS/Source/tasks.c **** 				the Blocked state. */													\
 299:FreeRTOS/Source/tasks.c **** 				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );	\
 300:FreeRTOS/Source/tasks.c **** 				xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );	\
 301:FreeRTOS/Source/tasks.c **** 																						\
 302:FreeRTOS/Source/tasks.c **** 				if( xTickCount < xItemValue )											\
 303:FreeRTOS/Source/tasks.c **** 				{																		\
 304:FreeRTOS/Source/tasks.c **** 					/* It is not time to unblock this item yet, but the item			\
 305:FreeRTOS/Source/tasks.c **** 					value is the time at which the task at the head of the				\
 306:FreeRTOS/Source/tasks.c **** 					blocked list should be removed from the Blocked state -				\
 307:FreeRTOS/Source/tasks.c **** 					so record the item value in xNextTaskUnblockTime. */				\
 308:FreeRTOS/Source/tasks.c **** 					xNextTaskUnblockTime = xItemValue;									\
 309:FreeRTOS/Source/tasks.c **** 					break;																\
 310:FreeRTOS/Source/tasks.c **** 				}																		\
 311:FreeRTOS/Source/tasks.c **** 																						\
 312:FreeRTOS/Source/tasks.c **** 				/* It is time to remove the item from the Blocked state. */				\
 313:FreeRTOS/Source/tasks.c **** 				vListRemove( &( pxTCB->xGenericListItem ) );							\
 314:FreeRTOS/Source/tasks.c **** 																						\
 315:FreeRTOS/Source/tasks.c **** 				/* Is the task waiting on an event also? */								\
 316:FreeRTOS/Source/tasks.c **** 				if( pxTCB->xEventListItem.pvContainer != NULL )							\
 317:FreeRTOS/Source/tasks.c **** 				{																		\
 318:FreeRTOS/Source/tasks.c **** 					vListRemove( &( pxTCB->xEventListItem ) );							\
 319:FreeRTOS/Source/tasks.c **** 				}																		\
 320:FreeRTOS/Source/tasks.c **** 				prvAddTaskToReadyQueue( pxTCB );										\
 321:FreeRTOS/Source/tasks.c **** 			}																			\
 322:FreeRTOS/Source/tasks.c **** 		}																				\
 323:FreeRTOS/Source/tasks.c **** 	}																					\
 324:FreeRTOS/Source/tasks.c **** }
 325:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 326:FreeRTOS/Source/tasks.c **** 
 327:FreeRTOS/Source/tasks.c **** /*
 328:FreeRTOS/Source/tasks.c ****  * Several functions take an xTaskHandle parameter that can optionally be NULL,
 329:FreeRTOS/Source/tasks.c ****  * where NULL is used to indicate that the handle of the currently executing
 330:FreeRTOS/Source/tasks.c ****  * task should be used in place of the parameter.  This macro simply checks to
 331:FreeRTOS/Source/tasks.c ****  * see if the parameter is NULL and returns a pointer to the appropriate TCB.
 332:FreeRTOS/Source/tasks.c ****  */
 333:FreeRTOS/Source/tasks.c **** #define prvGetTCBFromHandle( pxHandle ) ( ( ( pxHandle ) == NULL ) ? ( tskTCB * ) pxCurrentTCB : ( 
 334:FreeRTOS/Source/tasks.c **** 
 335:FreeRTOS/Source/tasks.c **** /* Callback function prototypes. --------------------------*/
 336:FreeRTOS/Source/tasks.c **** extern void vApplicationStackOverflowHook( xTaskHandle *pxTask, signed char *pcTaskName );
 337:FreeRTOS/Source/tasks.c **** extern void vApplicationTickHook( void );
 338:FreeRTOS/Source/tasks.c **** 		
 339:FreeRTOS/Source/tasks.c **** /* File private functions. --------------------------------*/
 340:FreeRTOS/Source/tasks.c **** 
 341:FreeRTOS/Source/tasks.c **** /*
 342:FreeRTOS/Source/tasks.c ****  * Utility to ready a TCB for a given task.  Mainly just copies the parameters
 343:FreeRTOS/Source/tasks.c ****  * into the TCB structure.
 344:FreeRTOS/Source/tasks.c ****  */
 345:FreeRTOS/Source/tasks.c **** static void prvInitialiseTCBVariables( tskTCB *pxTCB, const signed char * const pcName, unsigned po
 346:FreeRTOS/Source/tasks.c **** 
 347:FreeRTOS/Source/tasks.c **** /*
 348:FreeRTOS/Source/tasks.c ****  * Utility to ready all the lists used by the scheduler.  This is called
 349:FreeRTOS/Source/tasks.c ****  * automatically upon the creation of the first task.
 350:FreeRTOS/Source/tasks.c ****  */
 351:FreeRTOS/Source/tasks.c **** static void prvInitialiseTaskLists( void ) PRIVILEGED_FUNCTION;
 352:FreeRTOS/Source/tasks.c **** 
 353:FreeRTOS/Source/tasks.c **** /*
 354:FreeRTOS/Source/tasks.c ****  * The idle task, which as all tasks is implemented as a never ending loop.
 355:FreeRTOS/Source/tasks.c ****  * The idle task is automatically created and added to the ready lists upon
 356:FreeRTOS/Source/tasks.c ****  * creation of the first user task.
 357:FreeRTOS/Source/tasks.c ****  *
 358:FreeRTOS/Source/tasks.c ****  * The portTASK_FUNCTION_PROTO() macro is used to allow port/compiler specific
 359:FreeRTOS/Source/tasks.c ****  * language extensions.  The equivalent prototype for this function is:
 360:FreeRTOS/Source/tasks.c ****  *
 361:FreeRTOS/Source/tasks.c ****  * void prvIdleTask( void *pvParameters );
 362:FreeRTOS/Source/tasks.c ****  *
 363:FreeRTOS/Source/tasks.c ****  */
 364:FreeRTOS/Source/tasks.c **** static portTASK_FUNCTION_PROTO( prvIdleTask, pvParameters );
 365:FreeRTOS/Source/tasks.c **** 
 366:FreeRTOS/Source/tasks.c **** /*
 367:FreeRTOS/Source/tasks.c ****  * Utility to free all memory allocated by the scheduler to hold a TCB,
 368:FreeRTOS/Source/tasks.c ****  * including the stack pointed to by the TCB.
 369:FreeRTOS/Source/tasks.c ****  *
 370:FreeRTOS/Source/tasks.c ****  * This does not free memory allocated by the task itself (i.e. memory
 371:FreeRTOS/Source/tasks.c ****  * allocated by calls to pvPortMalloc from within the tasks application code).
 372:FreeRTOS/Source/tasks.c ****  */
 373:FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskDelete == 1 )
 374:FreeRTOS/Source/tasks.c **** 
 375:FreeRTOS/Source/tasks.c **** 	static void prvDeleteTCB( tskTCB *pxTCB ) PRIVILEGED_FUNCTION;
 376:FreeRTOS/Source/tasks.c **** 
 377:FreeRTOS/Source/tasks.c **** #endif
 378:FreeRTOS/Source/tasks.c **** 
 379:FreeRTOS/Source/tasks.c **** /*
 380:FreeRTOS/Source/tasks.c ****  * Used only by the idle task.  This checks to see if anything has been placed
 381:FreeRTOS/Source/tasks.c ****  * in the list of tasks waiting to be deleted.  If so the task is cleaned up
 382:FreeRTOS/Source/tasks.c ****  * and its TCB deleted.
 383:FreeRTOS/Source/tasks.c ****  */
 384:FreeRTOS/Source/tasks.c **** static void prvCheckTasksWaitingTermination( void ) PRIVILEGED_FUNCTION;
 385:FreeRTOS/Source/tasks.c **** 
 386:FreeRTOS/Source/tasks.c **** /*
 387:FreeRTOS/Source/tasks.c ****  * The currently executing task is entering the Blocked state.  Add the task to
 388:FreeRTOS/Source/tasks.c ****  * either the current or the overflow delayed task list.
 389:FreeRTOS/Source/tasks.c ****  */
 390:FreeRTOS/Source/tasks.c **** static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake ) PRIVILEGED_FUNCTION;
 391:FreeRTOS/Source/tasks.c **** 
 392:FreeRTOS/Source/tasks.c **** /*
 393:FreeRTOS/Source/tasks.c ****  * Allocates memory from the heap for a TCB and associated stack.  Checks the
 394:FreeRTOS/Source/tasks.c ****  * allocation was successful.
 395:FreeRTOS/Source/tasks.c ****  */
 396:FreeRTOS/Source/tasks.c **** static tskTCB *prvAllocateTCBAndStack( unsigned short usStackDepth, portSTACK_TYPE *puxStackBuffer 
 397:FreeRTOS/Source/tasks.c **** 
 398:FreeRTOS/Source/tasks.c **** /*
 399:FreeRTOS/Source/tasks.c ****  * Called from vTaskList.  vListTasks details all the tasks currently under
 400:FreeRTOS/Source/tasks.c ****  * control of the scheduler.  The tasks may be in one of a number of lists.
 401:FreeRTOS/Source/tasks.c ****  * prvListTaskWithinSingleList accepts a list and details the tasks from
 402:FreeRTOS/Source/tasks.c ****  * within just that list.
 403:FreeRTOS/Source/tasks.c ****  *
 404:FreeRTOS/Source/tasks.c ****  * THIS FUNCTION IS INTENDED FOR DEBUGGING ONLY, AND SHOULD NOT BE CALLED FROM
 405:FreeRTOS/Source/tasks.c ****  * NORMAL APPLICATION CODE.
 406:FreeRTOS/Source/tasks.c ****  */
 407:FreeRTOS/Source/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
 408:FreeRTOS/Source/tasks.c **** 
 409:FreeRTOS/Source/tasks.c **** 	static void prvListTaskWithinSingleList( const signed char *pcWriteBuffer, xList *pxList, signed c
 410:FreeRTOS/Source/tasks.c **** 
 411:FreeRTOS/Source/tasks.c **** #endif
 412:FreeRTOS/Source/tasks.c **** 
 413:FreeRTOS/Source/tasks.c **** /*
 414:FreeRTOS/Source/tasks.c ****  * When a task is created, the stack of the task is filled with a known value.
 415:FreeRTOS/Source/tasks.c ****  * This function determines the 'high water mark' of the task stack by
 416:FreeRTOS/Source/tasks.c ****  * determining how much of the stack remains at the original preset value.
 417:FreeRTOS/Source/tasks.c ****  */
 418:FreeRTOS/Source/tasks.c **** #if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )
 419:FreeRTOS/Source/tasks.c **** 
 420:FreeRTOS/Source/tasks.c **** 	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte ) PRIVILEGED_F
 421:FreeRTOS/Source/tasks.c **** 
 422:FreeRTOS/Source/tasks.c **** #endif
 423:FreeRTOS/Source/tasks.c **** 
 424:FreeRTOS/Source/tasks.c **** 
 425:FreeRTOS/Source/tasks.c **** /*lint +e956 */
 426:FreeRTOS/Source/tasks.c **** 
 427:FreeRTOS/Source/tasks.c **** 
 428:FreeRTOS/Source/tasks.c **** 
 429:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------
 430:FreeRTOS/Source/tasks.c ****  * TASK CREATION API documented in task.h
 431:FreeRTOS/Source/tasks.c ****  *----------------------------------------------------------*/
 432:FreeRTOS/Source/tasks.c **** 
 433:FreeRTOS/Source/tasks.c **** signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, 
 434:FreeRTOS/Source/tasks.c **** {
 435:FreeRTOS/Source/tasks.c **** signed portBASE_TYPE xReturn;
 436:FreeRTOS/Source/tasks.c **** tskTCB * pxNewTCB;
 437:FreeRTOS/Source/tasks.c **** 
 438:FreeRTOS/Source/tasks.c **** 	configASSERT( pxTaskCode );
 439:FreeRTOS/Source/tasks.c **** 	configASSERT( ( uxPriority < configMAX_PRIORITIES ) );
 440:FreeRTOS/Source/tasks.c **** 
 441:FreeRTOS/Source/tasks.c **** 	/* Allocate the memory required by the TCB and stack for the new task,
 442:FreeRTOS/Source/tasks.c **** 	checking that the allocation was successful. */
 443:FreeRTOS/Source/tasks.c **** 	pxNewTCB = prvAllocateTCBAndStack( usStackDepth, puxStackBuffer );
 444:FreeRTOS/Source/tasks.c **** 
 445:FreeRTOS/Source/tasks.c **** 	if( pxNewTCB != NULL )
 446:FreeRTOS/Source/tasks.c **** 	{
 447:FreeRTOS/Source/tasks.c **** 		portSTACK_TYPE *pxTopOfStack;
 448:FreeRTOS/Source/tasks.c **** 
 449:FreeRTOS/Source/tasks.c **** 		#if( portUSING_MPU_WRAPPERS == 1 )
 450:FreeRTOS/Source/tasks.c **** 			/* Should the task be created in privileged mode? */
 451:FreeRTOS/Source/tasks.c **** 			portBASE_TYPE xRunPrivileged;
 452:FreeRTOS/Source/tasks.c **** 			if( ( uxPriority & portPRIVILEGE_BIT ) != 0U )
 453:FreeRTOS/Source/tasks.c **** 			{
 454:FreeRTOS/Source/tasks.c **** 				xRunPrivileged = pdTRUE;
 455:FreeRTOS/Source/tasks.c **** 			}
 456:FreeRTOS/Source/tasks.c **** 			else
 457:FreeRTOS/Source/tasks.c **** 			{
 458:FreeRTOS/Source/tasks.c **** 				xRunPrivileged = pdFALSE;
 459:FreeRTOS/Source/tasks.c **** 			}
 460:FreeRTOS/Source/tasks.c **** 			uxPriority &= ~portPRIVILEGE_BIT;
 461:FreeRTOS/Source/tasks.c **** 		#endif /* portUSING_MPU_WRAPPERS == 1 */
 462:FreeRTOS/Source/tasks.c **** 
 463:FreeRTOS/Source/tasks.c **** 		/* Calculate the top of stack address.  This depends on whether the
 464:FreeRTOS/Source/tasks.c **** 		stack grows from high memory to low (as per the 80x86) or visa versa.
 465:FreeRTOS/Source/tasks.c **** 		portSTACK_GROWTH is used to make the result positive or negative as
 466:FreeRTOS/Source/tasks.c **** 		required by the port. */
 467:FreeRTOS/Source/tasks.c **** 		#if( portSTACK_GROWTH < 0 )
 468:FreeRTOS/Source/tasks.c **** 		{
 469:FreeRTOS/Source/tasks.c **** 			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
 470:FreeRTOS/Source/tasks.c **** 			pxTopOfStack = ( portSTACK_TYPE * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ( portPOINT
 471:FreeRTOS/Source/tasks.c **** 
 472:FreeRTOS/Source/tasks.c **** 			/* Check the alignment of the calculated top of stack is correct. */
 473:FreeRTOS/Source/tasks.c **** 			configASSERT( ( ( ( unsigned long ) pxTopOfStack & ( unsigned long ) portBYTE_ALIGNMENT_MASK ) =
 474:FreeRTOS/Source/tasks.c **** 		}
 475:FreeRTOS/Source/tasks.c **** 		#else
 476:FreeRTOS/Source/tasks.c **** 		{
 477:FreeRTOS/Source/tasks.c **** 			pxTopOfStack = pxNewTCB->pxStack;
 478:FreeRTOS/Source/tasks.c **** 			
 479:FreeRTOS/Source/tasks.c **** 			/* Check the alignment of the stack buffer is correct. */
 480:FreeRTOS/Source/tasks.c **** 			configASSERT( ( ( ( unsigned long ) pxNewTCB->pxStack & ( unsigned long ) portBYTE_ALIGNMENT_MAS
 481:FreeRTOS/Source/tasks.c **** 
 482:FreeRTOS/Source/tasks.c **** 			/* If we want to use stack checking on architectures that use
 483:FreeRTOS/Source/tasks.c **** 			a positive stack growth direction then we also need to store the
 484:FreeRTOS/Source/tasks.c **** 			other extreme of the stack space. */
 485:FreeRTOS/Source/tasks.c **** 			pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
 486:FreeRTOS/Source/tasks.c **** 		}
 487:FreeRTOS/Source/tasks.c **** 		#endif
 488:FreeRTOS/Source/tasks.c **** 
 489:FreeRTOS/Source/tasks.c **** 		/* Setup the newly allocated TCB with the initial state of the task. */
 490:FreeRTOS/Source/tasks.c **** 		prvInitialiseTCBVariables( pxNewTCB, pcName, uxPriority, xRegions, usStackDepth );
 491:FreeRTOS/Source/tasks.c **** 
 492:FreeRTOS/Source/tasks.c **** 		/* Initialize the TCB stack to look as if the task was already running,
 493:FreeRTOS/Source/tasks.c **** 		but had been interrupted by the scheduler.  The return address is set
 494:FreeRTOS/Source/tasks.c **** 		to the start of the task function. Once the stack has been initialised
 495:FreeRTOS/Source/tasks.c **** 		the	top of stack variable is updated. */
 496:FreeRTOS/Source/tasks.c **** 		#if( portUSING_MPU_WRAPPERS == 1 )
 497:FreeRTOS/Source/tasks.c **** 		{
 498:FreeRTOS/Source/tasks.c **** 			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPriv
 499:FreeRTOS/Source/tasks.c **** 		}
 500:FreeRTOS/Source/tasks.c **** 		#else
 501:FreeRTOS/Source/tasks.c **** 		{
 502:FreeRTOS/Source/tasks.c **** 			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 503:FreeRTOS/Source/tasks.c **** 		}
 504:FreeRTOS/Source/tasks.c **** 		#endif
 505:FreeRTOS/Source/tasks.c **** 
 506:FreeRTOS/Source/tasks.c **** 		/* Check the alignment of the initialised stack. */
 507:FreeRTOS/Source/tasks.c **** 		configASSERT( ( ( ( unsigned long ) pxNewTCB->pxTopOfStack & ( unsigned long ) portBYTE_ALIGNMENT
 508:FreeRTOS/Source/tasks.c **** 
 509:FreeRTOS/Source/tasks.c **** 		if( ( void * ) pxCreatedTask != NULL )
 510:FreeRTOS/Source/tasks.c **** 		{
 511:FreeRTOS/Source/tasks.c **** 			/* Pass the TCB out - in an anonymous way.  The calling function/
 512:FreeRTOS/Source/tasks.c **** 			task can use this as a handle to delete the task later if
 513:FreeRTOS/Source/tasks.c **** 			required.*/
 514:FreeRTOS/Source/tasks.c **** 			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
 515:FreeRTOS/Source/tasks.c **** 		}
 516:FreeRTOS/Source/tasks.c **** 		
 517:FreeRTOS/Source/tasks.c **** 		/* We are going to manipulate the task queues to add this task to a
 518:FreeRTOS/Source/tasks.c **** 		ready list, so must make sure no interrupts occur. */
 519:FreeRTOS/Source/tasks.c **** 		taskENTER_CRITICAL();
 520:FreeRTOS/Source/tasks.c **** 		{
 521:FreeRTOS/Source/tasks.c **** 			uxCurrentNumberOfTasks++;
 522:FreeRTOS/Source/tasks.c **** 			if( pxCurrentTCB == NULL )
 523:FreeRTOS/Source/tasks.c **** 			{
 524:FreeRTOS/Source/tasks.c **** 				/* There are no other tasks, or all the other tasks are in
 525:FreeRTOS/Source/tasks.c **** 				the suspended state - make this the current task. */
 526:FreeRTOS/Source/tasks.c **** 				pxCurrentTCB =  pxNewTCB;
 527:FreeRTOS/Source/tasks.c **** 
 528:FreeRTOS/Source/tasks.c **** 				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
 529:FreeRTOS/Source/tasks.c **** 				{
 530:FreeRTOS/Source/tasks.c **** 					/* This is the first task to be created so do the preliminary
 531:FreeRTOS/Source/tasks.c **** 					initialisation required.  We will not recover if this call
 532:FreeRTOS/Source/tasks.c **** 					fails, but we will report the failure. */
 533:FreeRTOS/Source/tasks.c **** 					prvInitialiseTaskLists();
 534:FreeRTOS/Source/tasks.c **** 				}
 535:FreeRTOS/Source/tasks.c **** 			}
 536:FreeRTOS/Source/tasks.c **** 			else
 537:FreeRTOS/Source/tasks.c **** 			{
 538:FreeRTOS/Source/tasks.c **** 				/* If the scheduler is not already running, make this task the
 539:FreeRTOS/Source/tasks.c **** 				current task if it is the highest priority task to be created
 540:FreeRTOS/Source/tasks.c **** 				so far. */
 541:FreeRTOS/Source/tasks.c **** 				if( xSchedulerRunning == pdFALSE )
 542:FreeRTOS/Source/tasks.c **** 				{
 543:FreeRTOS/Source/tasks.c **** 					if( pxCurrentTCB->uxPriority <= uxPriority )
 544:FreeRTOS/Source/tasks.c **** 					{
 545:FreeRTOS/Source/tasks.c **** 						pxCurrentTCB = pxNewTCB;
 546:FreeRTOS/Source/tasks.c **** 					}
 547:FreeRTOS/Source/tasks.c **** 				}
 548:FreeRTOS/Source/tasks.c **** 			}
 549:FreeRTOS/Source/tasks.c **** 
 550:FreeRTOS/Source/tasks.c **** 			/* Remember the top priority to make context switching faster.  Use
 551:FreeRTOS/Source/tasks.c **** 			the priority in pxNewTCB as this has been capped to a valid value. */
 552:FreeRTOS/Source/tasks.c **** 			if( pxNewTCB->uxPriority > uxTopUsedPriority )
 553:FreeRTOS/Source/tasks.c **** 			{
 554:FreeRTOS/Source/tasks.c **** 				uxTopUsedPriority = pxNewTCB->uxPriority;
 555:FreeRTOS/Source/tasks.c **** 			}
 556:FreeRTOS/Source/tasks.c **** 
 557:FreeRTOS/Source/tasks.c **** 			#if ( configUSE_TRACE_FACILITY == 1 )
 558:FreeRTOS/Source/tasks.c **** 			{
 559:FreeRTOS/Source/tasks.c **** 				/* Add a counter into the TCB for tracing only. */
 560:FreeRTOS/Source/tasks.c **** 				pxNewTCB->uxTCBNumber = uxTaskNumber;
 561:FreeRTOS/Source/tasks.c **** 			}
 562:FreeRTOS/Source/tasks.c **** 			#endif
 563:FreeRTOS/Source/tasks.c **** 			uxTaskNumber++;
 564:FreeRTOS/Source/tasks.c **** 
 565:FreeRTOS/Source/tasks.c **** 			prvAddTaskToReadyQueue( pxNewTCB );
 566:FreeRTOS/Source/tasks.c **** 
 567:FreeRTOS/Source/tasks.c **** 			xReturn = pdPASS;
 568:FreeRTOS/Source/tasks.c **** 			traceTASK_CREATE( pxNewTCB );
 569:FreeRTOS/Source/tasks.c **** 		}
 570:FreeRTOS/Source/tasks.c **** 		taskEXIT_CRITICAL();
 571:FreeRTOS/Source/tasks.c **** 	}
 572:FreeRTOS/Source/tasks.c **** 	else
 573:FreeRTOS/Source/tasks.c **** 	{
 574:FreeRTOS/Source/tasks.c **** 		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
 575:FreeRTOS/Source/tasks.c **** 		traceTASK_CREATE_FAILED();
 576:FreeRTOS/Source/tasks.c **** 	}
 577:FreeRTOS/Source/tasks.c **** 
 578:FreeRTOS/Source/tasks.c **** 	if( xReturn == pdPASS )
 579:FreeRTOS/Source/tasks.c **** 	{
 580:FreeRTOS/Source/tasks.c **** 		if( xSchedulerRunning != pdFALSE )
 581:FreeRTOS/Source/tasks.c **** 		{
 582:FreeRTOS/Source/tasks.c **** 			/* If the created task is of a higher priority than the current task
 583:FreeRTOS/Source/tasks.c **** 			then it should run now. */
 584:FreeRTOS/Source/tasks.c **** 			if( pxCurrentTCB->uxPriority < uxPriority )
 585:FreeRTOS/Source/tasks.c **** 			{
 586:FreeRTOS/Source/tasks.c **** 				portYIELD_WITHIN_API();
 587:FreeRTOS/Source/tasks.c **** 			}
 588:FreeRTOS/Source/tasks.c **** 		}
 589:FreeRTOS/Source/tasks.c **** 	}
 590:FreeRTOS/Source/tasks.c **** 
 591:FreeRTOS/Source/tasks.c **** 	return xReturn;
 592:FreeRTOS/Source/tasks.c **** }
 593:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 594:FreeRTOS/Source/tasks.c **** 
 595:FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskDelete == 1 )
 596:FreeRTOS/Source/tasks.c **** 
 597:FreeRTOS/Source/tasks.c **** 	void vTaskDelete( xTaskHandle pxTaskToDelete )
 598:FreeRTOS/Source/tasks.c **** 	{
 599:FreeRTOS/Source/tasks.c **** 	tskTCB *pxTCB;
 600:FreeRTOS/Source/tasks.c **** 
 601:FreeRTOS/Source/tasks.c **** 		taskENTER_CRITICAL();
 602:FreeRTOS/Source/tasks.c **** 		{
 603:FreeRTOS/Source/tasks.c **** 			/* Ensure a yield is performed if the current task is being
 604:FreeRTOS/Source/tasks.c **** 			deleted. */
 605:FreeRTOS/Source/tasks.c **** 			if( pxTaskToDelete == pxCurrentTCB )
 606:FreeRTOS/Source/tasks.c **** 			{
 607:FreeRTOS/Source/tasks.c **** 				pxTaskToDelete = NULL;
 608:FreeRTOS/Source/tasks.c **** 			}
 609:FreeRTOS/Source/tasks.c **** 
 610:FreeRTOS/Source/tasks.c **** 			/* If null is passed in here then we are deleting ourselves. */
 611:FreeRTOS/Source/tasks.c **** 			pxTCB = prvGetTCBFromHandle( pxTaskToDelete );
 612:FreeRTOS/Source/tasks.c **** 
 613:FreeRTOS/Source/tasks.c **** 			/* Remove task from the ready list and place in the	termination list.
 614:FreeRTOS/Source/tasks.c **** 			This will stop the task from be scheduled.  The idle task will check
 615:FreeRTOS/Source/tasks.c **** 			the termination list and free up any memory allocated by the
 616:FreeRTOS/Source/tasks.c **** 			scheduler for the TCB and stack. */
 617:FreeRTOS/Source/tasks.c **** 			vListRemove( &( pxTCB->xGenericListItem ) );
 618:FreeRTOS/Source/tasks.c **** 
 619:FreeRTOS/Source/tasks.c **** 			/* Is the task waiting on an event also? */
 620:FreeRTOS/Source/tasks.c **** 			if( pxTCB->xEventListItem.pvContainer != NULL )
 621:FreeRTOS/Source/tasks.c **** 			{
 622:FreeRTOS/Source/tasks.c **** 				vListRemove( &( pxTCB->xEventListItem ) );
 623:FreeRTOS/Source/tasks.c **** 			}
 624:FreeRTOS/Source/tasks.c **** 
 625:FreeRTOS/Source/tasks.c **** 			vListInsertEnd( ( xList * ) &xTasksWaitingTermination, &( pxTCB->xGenericListItem ) );
 626:FreeRTOS/Source/tasks.c **** 
 627:FreeRTOS/Source/tasks.c **** 			/* Increment the ucTasksDeleted variable so the idle task knows
 628:FreeRTOS/Source/tasks.c **** 			there is a task that has been deleted and that it should therefore
 629:FreeRTOS/Source/tasks.c **** 			check the xTasksWaitingTermination list. */
 630:FreeRTOS/Source/tasks.c **** 			++uxTasksDeleted;
 631:FreeRTOS/Source/tasks.c **** 
 632:FreeRTOS/Source/tasks.c **** 			/* Increment the uxTaskNumberVariable also so kernel aware debuggers
 633:FreeRTOS/Source/tasks.c **** 			can detect that the task lists need re-generating. */
 634:FreeRTOS/Source/tasks.c **** 			uxTaskNumber++;
 635:FreeRTOS/Source/tasks.c **** 
 636:FreeRTOS/Source/tasks.c **** 			traceTASK_DELETE( pxTCB );
 637:FreeRTOS/Source/tasks.c **** 		}
 638:FreeRTOS/Source/tasks.c **** 		taskEXIT_CRITICAL();
 639:FreeRTOS/Source/tasks.c **** 
 640:FreeRTOS/Source/tasks.c **** 		/* Force a reschedule if we have just deleted the current task. */
 641:FreeRTOS/Source/tasks.c **** 		if( xSchedulerRunning != pdFALSE )
 642:FreeRTOS/Source/tasks.c **** 		{
 643:FreeRTOS/Source/tasks.c **** 			if( ( void * ) pxTaskToDelete == NULL )
 644:FreeRTOS/Source/tasks.c **** 			{
 645:FreeRTOS/Source/tasks.c **** 				portYIELD_WITHIN_API();
 646:FreeRTOS/Source/tasks.c **** 			}
 647:FreeRTOS/Source/tasks.c **** 		}
 648:FreeRTOS/Source/tasks.c **** 	}
 649:FreeRTOS/Source/tasks.c **** 
 650:FreeRTOS/Source/tasks.c **** #endif
 651:FreeRTOS/Source/tasks.c **** 
 652:FreeRTOS/Source/tasks.c **** 
 653:FreeRTOS/Source/tasks.c **** 
 654:FreeRTOS/Source/tasks.c **** 
 655:FreeRTOS/Source/tasks.c **** 
 656:FreeRTOS/Source/tasks.c **** 
 657:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------
 658:FreeRTOS/Source/tasks.c ****  * TASK CONTROL API documented in task.h
 659:FreeRTOS/Source/tasks.c ****  *----------------------------------------------------------*/
 660:FreeRTOS/Source/tasks.c **** 
 661:FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskDelayUntil == 1 )
 662:FreeRTOS/Source/tasks.c **** 
 663:FreeRTOS/Source/tasks.c **** 	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
 664:FreeRTOS/Source/tasks.c **** 	{
 665:FreeRTOS/Source/tasks.c **** 	portTickType xTimeToWake;
 666:FreeRTOS/Source/tasks.c **** 	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;
 667:FreeRTOS/Source/tasks.c **** 
 668:FreeRTOS/Source/tasks.c **** 		configASSERT( pxPreviousWakeTime );
 669:FreeRTOS/Source/tasks.c **** 		configASSERT( ( xTimeIncrement > 0U ) );
 670:FreeRTOS/Source/tasks.c **** 
 671:FreeRTOS/Source/tasks.c **** 		vTaskSuspendAll();
 672:FreeRTOS/Source/tasks.c **** 		{
 673:FreeRTOS/Source/tasks.c **** 			/* Generate the tick time at which the task wants to wake. */
 674:FreeRTOS/Source/tasks.c **** 			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
 675:FreeRTOS/Source/tasks.c **** 
 676:FreeRTOS/Source/tasks.c **** 			if( xTickCount < *pxPreviousWakeTime )
 677:FreeRTOS/Source/tasks.c **** 			{
 678:FreeRTOS/Source/tasks.c **** 				/* The tick count has overflowed since this function was
 679:FreeRTOS/Source/tasks.c **** 				lasted called.  In this case the only time we should ever
 680:FreeRTOS/Source/tasks.c **** 				actually delay is if the wake time has also	overflowed,
 681:FreeRTOS/Source/tasks.c **** 				and the wake time is greater than the tick time.  When this
 682:FreeRTOS/Source/tasks.c **** 				is the case it is as if neither time had overflowed. */
 683:FreeRTOS/Source/tasks.c **** 				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
 684:FreeRTOS/Source/tasks.c **** 				{
 685:FreeRTOS/Source/tasks.c **** 					xShouldDelay = pdTRUE;
 686:FreeRTOS/Source/tasks.c **** 				}
 687:FreeRTOS/Source/tasks.c **** 			}
 688:FreeRTOS/Source/tasks.c **** 			else
 689:FreeRTOS/Source/tasks.c **** 			{
 690:FreeRTOS/Source/tasks.c **** 				/* The tick time has not overflowed.  In this case we will
 691:FreeRTOS/Source/tasks.c **** 				delay if either the wake time has overflowed, and/or the
 692:FreeRTOS/Source/tasks.c **** 				tick time is less than the wake time. */
 693:FreeRTOS/Source/tasks.c **** 				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
 694:FreeRTOS/Source/tasks.c **** 				{
 695:FreeRTOS/Source/tasks.c **** 					xShouldDelay = pdTRUE;
 696:FreeRTOS/Source/tasks.c **** 				}
 697:FreeRTOS/Source/tasks.c **** 			}
 698:FreeRTOS/Source/tasks.c **** 
 699:FreeRTOS/Source/tasks.c **** 			/* Update the wake time ready for the next call. */
 700:FreeRTOS/Source/tasks.c **** 			*pxPreviousWakeTime = xTimeToWake;
 701:FreeRTOS/Source/tasks.c **** 
 702:FreeRTOS/Source/tasks.c **** 			if( xShouldDelay != pdFALSE )
 703:FreeRTOS/Source/tasks.c **** 			{
 704:FreeRTOS/Source/tasks.c **** 				traceTASK_DELAY_UNTIL();
 705:FreeRTOS/Source/tasks.c **** 
 706:FreeRTOS/Source/tasks.c **** 				/* We must remove ourselves from the ready list before adding
 707:FreeRTOS/Source/tasks.c **** 				ourselves to the blocked list as the same list item is used for
 708:FreeRTOS/Source/tasks.c **** 				both lists. */
 709:FreeRTOS/Source/tasks.c **** 				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
 710:FreeRTOS/Source/tasks.c **** 				prvAddCurrentTaskToDelayedList( xTimeToWake );
 711:FreeRTOS/Source/tasks.c **** 			}
 712:FreeRTOS/Source/tasks.c **** 		}
 713:FreeRTOS/Source/tasks.c **** 		xAlreadyYielded = xTaskResumeAll();
 714:FreeRTOS/Source/tasks.c **** 
 715:FreeRTOS/Source/tasks.c **** 		/* Force a reschedule if xTaskResumeAll has not already done so, we may
 716:FreeRTOS/Source/tasks.c **** 		have put ourselves to sleep. */
 717:FreeRTOS/Source/tasks.c **** 		if( xAlreadyYielded == pdFALSE )
 718:FreeRTOS/Source/tasks.c **** 		{
 719:FreeRTOS/Source/tasks.c **** 			portYIELD_WITHIN_API();
 720:FreeRTOS/Source/tasks.c **** 		}
 721:FreeRTOS/Source/tasks.c **** 	}
 722:FreeRTOS/Source/tasks.c **** 
 723:FreeRTOS/Source/tasks.c **** #endif
 724:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 725:FreeRTOS/Source/tasks.c **** 
 726:FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskDelay == 1 )
 727:FreeRTOS/Source/tasks.c **** 
 728:FreeRTOS/Source/tasks.c **** 	void vTaskDelay( portTickType xTicksToDelay )
 729:FreeRTOS/Source/tasks.c **** 	{
 730:FreeRTOS/Source/tasks.c **** 	portTickType xTimeToWake;
 731:FreeRTOS/Source/tasks.c **** 	signed portBASE_TYPE xAlreadyYielded = pdFALSE;
 732:FreeRTOS/Source/tasks.c **** 
 733:FreeRTOS/Source/tasks.c **** 		/* A delay time of zero just forces a reschedule. */
 734:FreeRTOS/Source/tasks.c **** 		if( xTicksToDelay > ( portTickType ) 0U )
 735:FreeRTOS/Source/tasks.c **** 		{
 736:FreeRTOS/Source/tasks.c **** 			vTaskSuspendAll();
 737:FreeRTOS/Source/tasks.c **** 			{
 738:FreeRTOS/Source/tasks.c **** 				traceTASK_DELAY();
 739:FreeRTOS/Source/tasks.c **** 
 740:FreeRTOS/Source/tasks.c **** 				/* A task that is removed from the event list while the
 741:FreeRTOS/Source/tasks.c **** 				scheduler is suspended will not get placed in the ready
 742:FreeRTOS/Source/tasks.c **** 				list or removed from the blocked list until the scheduler
 743:FreeRTOS/Source/tasks.c **** 				is resumed.
 744:FreeRTOS/Source/tasks.c **** 
 745:FreeRTOS/Source/tasks.c **** 				This task cannot be in an event list as it is the currently
 746:FreeRTOS/Source/tasks.c **** 				executing task. */
 747:FreeRTOS/Source/tasks.c **** 
 748:FreeRTOS/Source/tasks.c **** 				/* Calculate the time to wake - this may overflow but this is
 749:FreeRTOS/Source/tasks.c **** 				not a problem. */
 750:FreeRTOS/Source/tasks.c **** 				xTimeToWake = xTickCount + xTicksToDelay;
 751:FreeRTOS/Source/tasks.c **** 
 752:FreeRTOS/Source/tasks.c **** 				/* We must remove ourselves from the ready list before adding
 753:FreeRTOS/Source/tasks.c **** 				ourselves to the blocked list as the same list item is used for
 754:FreeRTOS/Source/tasks.c **** 				both lists. */
 755:FreeRTOS/Source/tasks.c **** 				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
 756:FreeRTOS/Source/tasks.c **** 				prvAddCurrentTaskToDelayedList( xTimeToWake );
 757:FreeRTOS/Source/tasks.c **** 			}
 758:FreeRTOS/Source/tasks.c **** 			xAlreadyYielded = xTaskResumeAll();
 759:FreeRTOS/Source/tasks.c **** 		}
 760:FreeRTOS/Source/tasks.c **** 
 761:FreeRTOS/Source/tasks.c **** 		/* Force a reschedule if xTaskResumeAll has not already done so, we may
 762:FreeRTOS/Source/tasks.c **** 		have put ourselves to sleep. */
 763:FreeRTOS/Source/tasks.c **** 		if( xAlreadyYielded == pdFALSE )
 764:FreeRTOS/Source/tasks.c **** 		{
 765:FreeRTOS/Source/tasks.c **** 			portYIELD_WITHIN_API();
 766:FreeRTOS/Source/tasks.c **** 		}
 767:FreeRTOS/Source/tasks.c **** 	}
 768:FreeRTOS/Source/tasks.c **** 
 769:FreeRTOS/Source/tasks.c **** #endif
 770:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 771:FreeRTOS/Source/tasks.c **** 
 772:FreeRTOS/Source/tasks.c **** #if ( INCLUDE_uxTaskPriorityGet == 1 )
 773:FreeRTOS/Source/tasks.c **** 
 774:FreeRTOS/Source/tasks.c **** 	unsigned portBASE_TYPE uxTaskPriorityGet( xTaskHandle pxTask )
 775:FreeRTOS/Source/tasks.c **** 	{
 776:FreeRTOS/Source/tasks.c **** 	tskTCB *pxTCB;
 777:FreeRTOS/Source/tasks.c **** 	unsigned portBASE_TYPE uxReturn;
 778:FreeRTOS/Source/tasks.c **** 
 779:FreeRTOS/Source/tasks.c **** 		taskENTER_CRITICAL();
 780:FreeRTOS/Source/tasks.c **** 		{
 781:FreeRTOS/Source/tasks.c **** 			/* If null is passed in here then we are changing the
 782:FreeRTOS/Source/tasks.c **** 			priority of the calling function. */
 783:FreeRTOS/Source/tasks.c **** 			pxTCB = prvGetTCBFromHandle( pxTask );
 784:FreeRTOS/Source/tasks.c **** 			uxReturn = pxTCB->uxPriority;
 785:FreeRTOS/Source/tasks.c **** 		}
 786:FreeRTOS/Source/tasks.c **** 		taskEXIT_CRITICAL();
 787:FreeRTOS/Source/tasks.c **** 
 788:FreeRTOS/Source/tasks.c **** 		return uxReturn;
 789:FreeRTOS/Source/tasks.c **** 	}
 790:FreeRTOS/Source/tasks.c **** 
 791:FreeRTOS/Source/tasks.c **** #endif
 792:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 793:FreeRTOS/Source/tasks.c **** 
 794:FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskPrioritySet == 1 )
 795:FreeRTOS/Source/tasks.c **** 
 796:FreeRTOS/Source/tasks.c **** 	void vTaskPrioritySet( xTaskHandle pxTask, unsigned portBASE_TYPE uxNewPriority )
 797:FreeRTOS/Source/tasks.c **** 	{
 798:FreeRTOS/Source/tasks.c **** 	tskTCB *pxTCB;
 799:FreeRTOS/Source/tasks.c **** 	unsigned portBASE_TYPE uxCurrentPriority;
 800:FreeRTOS/Source/tasks.c **** 	portBASE_TYPE xYieldRequired = pdFALSE;
 801:FreeRTOS/Source/tasks.c **** 
 802:FreeRTOS/Source/tasks.c **** 		configASSERT( ( uxNewPriority < configMAX_PRIORITIES ) );
 803:FreeRTOS/Source/tasks.c **** 
 804:FreeRTOS/Source/tasks.c **** 		/* Ensure the new priority is valid. */
 805:FreeRTOS/Source/tasks.c **** 		if( uxNewPriority >= configMAX_PRIORITIES )
 806:FreeRTOS/Source/tasks.c **** 		{
 807:FreeRTOS/Source/tasks.c **** 			uxNewPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
 808:FreeRTOS/Source/tasks.c **** 		}
 809:FreeRTOS/Source/tasks.c **** 
 810:FreeRTOS/Source/tasks.c **** 		taskENTER_CRITICAL();
 811:FreeRTOS/Source/tasks.c **** 		{
 812:FreeRTOS/Source/tasks.c **** 			if( pxTask == pxCurrentTCB )
 813:FreeRTOS/Source/tasks.c **** 			{
 814:FreeRTOS/Source/tasks.c **** 				pxTask = NULL;
 815:FreeRTOS/Source/tasks.c **** 			}
 816:FreeRTOS/Source/tasks.c **** 
 817:FreeRTOS/Source/tasks.c **** 			/* If null is passed in here then we are changing the
 818:FreeRTOS/Source/tasks.c **** 			priority of the calling function. */
 819:FreeRTOS/Source/tasks.c **** 			pxTCB = prvGetTCBFromHandle( pxTask );
 820:FreeRTOS/Source/tasks.c **** 
 821:FreeRTOS/Source/tasks.c **** 			traceTASK_PRIORITY_SET( pxTask, uxNewPriority );
 822:FreeRTOS/Source/tasks.c **** 
 823:FreeRTOS/Source/tasks.c **** 			#if ( configUSE_MUTEXES == 1 )
 824:FreeRTOS/Source/tasks.c **** 			{
 825:FreeRTOS/Source/tasks.c **** 				uxCurrentPriority = pxTCB->uxBasePriority;
 826:FreeRTOS/Source/tasks.c **** 			}
 827:FreeRTOS/Source/tasks.c **** 			#else
 828:FreeRTOS/Source/tasks.c **** 			{
 829:FreeRTOS/Source/tasks.c **** 				uxCurrentPriority = pxTCB->uxPriority;
 830:FreeRTOS/Source/tasks.c **** 			}
 831:FreeRTOS/Source/tasks.c **** 			#endif
 832:FreeRTOS/Source/tasks.c **** 
 833:FreeRTOS/Source/tasks.c **** 			if( uxCurrentPriority != uxNewPriority )
 834:FreeRTOS/Source/tasks.c **** 			{
 835:FreeRTOS/Source/tasks.c **** 				/* The priority change may have readied a task of higher
 836:FreeRTOS/Source/tasks.c **** 				priority than the calling task. */
 837:FreeRTOS/Source/tasks.c **** 				if( uxNewPriority > uxCurrentPriority )
 838:FreeRTOS/Source/tasks.c **** 				{
 839:FreeRTOS/Source/tasks.c **** 					if( pxTask != NULL )
 840:FreeRTOS/Source/tasks.c **** 					{
 841:FreeRTOS/Source/tasks.c **** 						/* The priority of another task is being raised.  If we
 842:FreeRTOS/Source/tasks.c **** 						were raising the priority of the currently running task
 843:FreeRTOS/Source/tasks.c **** 						there would be no need to switch as it must have already
 844:FreeRTOS/Source/tasks.c **** 						been the highest priority task. */
 845:FreeRTOS/Source/tasks.c **** 						xYieldRequired = pdTRUE;
 846:FreeRTOS/Source/tasks.c **** 					}
 847:FreeRTOS/Source/tasks.c **** 				}
 848:FreeRTOS/Source/tasks.c **** 				else if( pxTask == NULL )
 849:FreeRTOS/Source/tasks.c **** 				{
 850:FreeRTOS/Source/tasks.c **** 					/* Setting our own priority down means there may now be another
 851:FreeRTOS/Source/tasks.c **** 					task of higher priority that is ready to execute. */
 852:FreeRTOS/Source/tasks.c **** 					xYieldRequired = pdTRUE;
 853:FreeRTOS/Source/tasks.c **** 				}
 854:FreeRTOS/Source/tasks.c **** 
 855:FreeRTOS/Source/tasks.c **** 
 856:FreeRTOS/Source/tasks.c **** 
 857:FreeRTOS/Source/tasks.c **** 				#if ( configUSE_MUTEXES == 1 )
 858:FreeRTOS/Source/tasks.c **** 				{
 859:FreeRTOS/Source/tasks.c **** 					/* Only change the priority being used if the task is not
 860:FreeRTOS/Source/tasks.c **** 					currently using an inherited priority. */
 861:FreeRTOS/Source/tasks.c **** 					if( pxTCB->uxBasePriority == pxTCB->uxPriority )
 862:FreeRTOS/Source/tasks.c **** 					{
 863:FreeRTOS/Source/tasks.c **** 						pxTCB->uxPriority = uxNewPriority;
 864:FreeRTOS/Source/tasks.c **** 					}
 865:FreeRTOS/Source/tasks.c **** 
 866:FreeRTOS/Source/tasks.c **** 					/* The base priority gets set whatever. */
 867:FreeRTOS/Source/tasks.c **** 					pxTCB->uxBasePriority = uxNewPriority;
 868:FreeRTOS/Source/tasks.c **** 				}
 869:FreeRTOS/Source/tasks.c **** 				#else
 870:FreeRTOS/Source/tasks.c **** 				{
 871:FreeRTOS/Source/tasks.c **** 					pxTCB->uxPriority = uxNewPriority;
 872:FreeRTOS/Source/tasks.c **** 				}
 873:FreeRTOS/Source/tasks.c **** 				#endif
 874:FreeRTOS/Source/tasks.c **** 
 875:FreeRTOS/Source/tasks.c **** 				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( configMAX_PRIORITIES - ( portTickType ) 
 876:FreeRTOS/Source/tasks.c **** 
 877:FreeRTOS/Source/tasks.c **** 				/* If the task is in the blocked or suspended list we need do
 878:FreeRTOS/Source/tasks.c **** 				nothing more than change it's priority variable. However, if
 879:FreeRTOS/Source/tasks.c **** 				the task is in a ready list it needs to be removed and placed
 880:FreeRTOS/Source/tasks.c **** 				in the queue appropriate to its new priority. */
 881:FreeRTOS/Source/tasks.c **** 				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxCurrentPriority ] ), &( pxTCB->xGenericLis
 882:FreeRTOS/Source/tasks.c **** 				{
 883:FreeRTOS/Source/tasks.c **** 					/* The task is currently in its ready list - remove before adding
 884:FreeRTOS/Source/tasks.c **** 					it to it's new ready list.  As we are in a critical section we
 885:FreeRTOS/Source/tasks.c **** 					can do this even if the scheduler is suspended. */
 886:FreeRTOS/Source/tasks.c **** 					vListRemove( &( pxTCB->xGenericListItem ) );
 887:FreeRTOS/Source/tasks.c **** 					prvAddTaskToReadyQueue( pxTCB );
 888:FreeRTOS/Source/tasks.c **** 				}
 889:FreeRTOS/Source/tasks.c **** 
 890:FreeRTOS/Source/tasks.c **** 				if( xYieldRequired == pdTRUE )
 891:FreeRTOS/Source/tasks.c **** 				{
 892:FreeRTOS/Source/tasks.c **** 					portYIELD_WITHIN_API();
 893:FreeRTOS/Source/tasks.c **** 				}
 894:FreeRTOS/Source/tasks.c **** 			}
 895:FreeRTOS/Source/tasks.c **** 		}
 896:FreeRTOS/Source/tasks.c **** 		taskEXIT_CRITICAL();
 897:FreeRTOS/Source/tasks.c **** 	}
 898:FreeRTOS/Source/tasks.c **** 
 899:FreeRTOS/Source/tasks.c **** #endif
 900:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 901:FreeRTOS/Source/tasks.c **** 
 902:FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
 903:FreeRTOS/Source/tasks.c **** 
 904:FreeRTOS/Source/tasks.c **** 	void vTaskSuspend( xTaskHandle pxTaskToSuspend )
 905:FreeRTOS/Source/tasks.c **** 	{
 906:FreeRTOS/Source/tasks.c **** 	tskTCB *pxTCB;
 907:FreeRTOS/Source/tasks.c **** 
 908:FreeRTOS/Source/tasks.c **** 		taskENTER_CRITICAL();
 909:FreeRTOS/Source/tasks.c **** 		{
 910:FreeRTOS/Source/tasks.c **** 			/* Ensure a yield is performed if the current task is being
 911:FreeRTOS/Source/tasks.c **** 			suspended. */
 912:FreeRTOS/Source/tasks.c **** 			if( pxTaskToSuspend == pxCurrentTCB )
 913:FreeRTOS/Source/tasks.c **** 			{
 914:FreeRTOS/Source/tasks.c **** 				pxTaskToSuspend = NULL;
 915:FreeRTOS/Source/tasks.c **** 			}
 916:FreeRTOS/Source/tasks.c **** 
 917:FreeRTOS/Source/tasks.c **** 			/* If null is passed in here then we are suspending ourselves. */
 918:FreeRTOS/Source/tasks.c **** 			pxTCB = prvGetTCBFromHandle( pxTaskToSuspend );
 919:FreeRTOS/Source/tasks.c **** 
 920:FreeRTOS/Source/tasks.c **** 			traceTASK_SUSPEND( pxTCB );
 921:FreeRTOS/Source/tasks.c **** 
 922:FreeRTOS/Source/tasks.c **** 			/* Remove task from the ready/delayed list and place in the	suspended list. */
 923:FreeRTOS/Source/tasks.c **** 			vListRemove( &( pxTCB->xGenericListItem ) );
 924:FreeRTOS/Source/tasks.c **** 
 925:FreeRTOS/Source/tasks.c **** 			/* Is the task waiting on an event also? */
 926:FreeRTOS/Source/tasks.c **** 			if( pxTCB->xEventListItem.pvContainer != NULL )
 927:FreeRTOS/Source/tasks.c **** 			{
 928:FreeRTOS/Source/tasks.c **** 				vListRemove( &( pxTCB->xEventListItem ) );
 929:FreeRTOS/Source/tasks.c **** 			}
 930:FreeRTOS/Source/tasks.c **** 
 931:FreeRTOS/Source/tasks.c **** 			vListInsertEnd( ( xList * ) &xSuspendedTaskList, &( pxTCB->xGenericListItem ) );
 932:FreeRTOS/Source/tasks.c **** 		}
 933:FreeRTOS/Source/tasks.c **** 		taskEXIT_CRITICAL();
 934:FreeRTOS/Source/tasks.c **** 
 935:FreeRTOS/Source/tasks.c **** 		if( ( void * ) pxTaskToSuspend == NULL )
 936:FreeRTOS/Source/tasks.c **** 		{
 937:FreeRTOS/Source/tasks.c **** 			if( xSchedulerRunning != pdFALSE )
 938:FreeRTOS/Source/tasks.c **** 			{
 939:FreeRTOS/Source/tasks.c **** 				/* We have just suspended the current task. */
 940:FreeRTOS/Source/tasks.c **** 				portYIELD_WITHIN_API();
 941:FreeRTOS/Source/tasks.c **** 			}
 942:FreeRTOS/Source/tasks.c **** 			else
 943:FreeRTOS/Source/tasks.c **** 			{
 944:FreeRTOS/Source/tasks.c **** 				/* The scheduler is not running, but the task that was pointed
 945:FreeRTOS/Source/tasks.c **** 				to by pxCurrentTCB has just been suspended and pxCurrentTCB
 946:FreeRTOS/Source/tasks.c **** 				must be adjusted to point to a different task. */
 947:FreeRTOS/Source/tasks.c **** 				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks )
 948:FreeRTOS/Source/tasks.c **** 				{
 949:FreeRTOS/Source/tasks.c **** 					/* No other tasks are ready, so set pxCurrentTCB back to
 950:FreeRTOS/Source/tasks.c **** 					NULL so when the next task is created pxCurrentTCB will
 951:FreeRTOS/Source/tasks.c **** 					be set to point to it no matter what its relative priority
 952:FreeRTOS/Source/tasks.c **** 					is. */
 953:FreeRTOS/Source/tasks.c **** 					pxCurrentTCB = NULL;
 954:FreeRTOS/Source/tasks.c **** 				}
 955:FreeRTOS/Source/tasks.c **** 				else
 956:FreeRTOS/Source/tasks.c **** 				{
 957:FreeRTOS/Source/tasks.c **** 					vTaskSwitchContext();
 958:FreeRTOS/Source/tasks.c **** 				}
 959:FreeRTOS/Source/tasks.c **** 			}
 960:FreeRTOS/Source/tasks.c **** 		}
 961:FreeRTOS/Source/tasks.c **** 	}
 962:FreeRTOS/Source/tasks.c **** 
 963:FreeRTOS/Source/tasks.c **** #endif
 964:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 965:FreeRTOS/Source/tasks.c **** 
 966:FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
 967:FreeRTOS/Source/tasks.c **** 
 968:FreeRTOS/Source/tasks.c **** 	signed portBASE_TYPE xTaskIsTaskSuspended( xTaskHandle xTask )
 969:FreeRTOS/Source/tasks.c **** 	{
 970:FreeRTOS/Source/tasks.c **** 	portBASE_TYPE xReturn = pdFALSE;
 971:FreeRTOS/Source/tasks.c **** 	const tskTCB * const pxTCB = ( tskTCB * ) xTask;
 972:FreeRTOS/Source/tasks.c **** 
 973:FreeRTOS/Source/tasks.c **** 		/* It does not make sense to check if the calling task is suspended. */
 974:FreeRTOS/Source/tasks.c **** 		configASSERT( xTask );
 975:FreeRTOS/Source/tasks.c **** 
 976:FreeRTOS/Source/tasks.c **** 		/* Is the task we are attempting to resume actually in the
 977:FreeRTOS/Source/tasks.c **** 		suspended list? */
 978:FreeRTOS/Source/tasks.c **** 		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xGenericListItem ) ) != pdFALSE )
 979:FreeRTOS/Source/tasks.c **** 		{
 980:FreeRTOS/Source/tasks.c **** 			/* Has the task already been resumed from within an ISR? */
 981:FreeRTOS/Source/tasks.c **** 			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) != pdTRUE )
 982:FreeRTOS/Source/tasks.c **** 			{
 983:FreeRTOS/Source/tasks.c **** 				/* Is it in the suspended list because it is in the
 984:FreeRTOS/Source/tasks.c **** 				Suspended state?  It is possible to be in the suspended
 985:FreeRTOS/Source/tasks.c **** 				list because it is blocked on a task with no timeout
 986:FreeRTOS/Source/tasks.c **** 				specified. */
 987:FreeRTOS/Source/tasks.c **** 				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) == pdTRUE )
 988:FreeRTOS/Source/tasks.c **** 				{
 989:FreeRTOS/Source/tasks.c **** 					xReturn = pdTRUE;
 990:FreeRTOS/Source/tasks.c **** 				}
 991:FreeRTOS/Source/tasks.c **** 			}
 992:FreeRTOS/Source/tasks.c **** 		}
 993:FreeRTOS/Source/tasks.c **** 
 994:FreeRTOS/Source/tasks.c **** 		return xReturn;
 995:FreeRTOS/Source/tasks.c **** 	}
 996:FreeRTOS/Source/tasks.c **** 
 997:FreeRTOS/Source/tasks.c **** #endif
 998:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 999:FreeRTOS/Source/tasks.c **** 
1000:FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
1001:FreeRTOS/Source/tasks.c **** 
1002:FreeRTOS/Source/tasks.c **** 	void vTaskResume( xTaskHandle pxTaskToResume )
1003:FreeRTOS/Source/tasks.c **** 	{
1004:FreeRTOS/Source/tasks.c **** 	tskTCB *pxTCB;
1005:FreeRTOS/Source/tasks.c **** 
1006:FreeRTOS/Source/tasks.c **** 		/* It does not make sense to resume the calling task. */
1007:FreeRTOS/Source/tasks.c **** 		configASSERT( pxTaskToResume );
1008:FreeRTOS/Source/tasks.c **** 
1009:FreeRTOS/Source/tasks.c **** 		/* Remove the task from whichever list it is currently in, and place
1010:FreeRTOS/Source/tasks.c **** 		it in the ready list. */
1011:FreeRTOS/Source/tasks.c **** 		pxTCB = ( tskTCB * ) pxTaskToResume;
1012:FreeRTOS/Source/tasks.c **** 
1013:FreeRTOS/Source/tasks.c **** 		/* The parameter cannot be NULL as it is impossible to resume the
1014:FreeRTOS/Source/tasks.c **** 		currently executing task. */
1015:FreeRTOS/Source/tasks.c **** 		if( ( pxTCB != NULL ) && ( pxTCB != pxCurrentTCB ) )
1016:FreeRTOS/Source/tasks.c **** 		{
1017:FreeRTOS/Source/tasks.c **** 			taskENTER_CRITICAL();
1018:FreeRTOS/Source/tasks.c **** 			{
1019:FreeRTOS/Source/tasks.c **** 				if( xTaskIsTaskSuspended( pxTCB ) == pdTRUE )
1020:FreeRTOS/Source/tasks.c **** 				{
1021:FreeRTOS/Source/tasks.c **** 					traceTASK_RESUME( pxTCB );
1022:FreeRTOS/Source/tasks.c **** 
1023:FreeRTOS/Source/tasks.c **** 					/* As we are in a critical section we can access the ready
1024:FreeRTOS/Source/tasks.c **** 					lists even if the scheduler is suspended. */
1025:FreeRTOS/Source/tasks.c **** 					vListRemove(  &( pxTCB->xGenericListItem ) );
1026:FreeRTOS/Source/tasks.c **** 					prvAddTaskToReadyQueue( pxTCB );
1027:FreeRTOS/Source/tasks.c **** 
1028:FreeRTOS/Source/tasks.c **** 					/* We may have just resumed a higher priority task. */
1029:FreeRTOS/Source/tasks.c **** 					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
1030:FreeRTOS/Source/tasks.c **** 					{
1031:FreeRTOS/Source/tasks.c **** 						/* This yield may not cause the task just resumed to run, but
1032:FreeRTOS/Source/tasks.c **** 						will leave the lists in the correct state for the next yield. */
1033:FreeRTOS/Source/tasks.c **** 						portYIELD_WITHIN_API();
1034:FreeRTOS/Source/tasks.c **** 					}
1035:FreeRTOS/Source/tasks.c **** 				}
1036:FreeRTOS/Source/tasks.c **** 			}
1037:FreeRTOS/Source/tasks.c **** 			taskEXIT_CRITICAL();
1038:FreeRTOS/Source/tasks.c **** 		}
1039:FreeRTOS/Source/tasks.c **** 	}
1040:FreeRTOS/Source/tasks.c **** 
1041:FreeRTOS/Source/tasks.c **** #endif
1042:FreeRTOS/Source/tasks.c **** 
1043:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1044:FreeRTOS/Source/tasks.c **** 
1045:FreeRTOS/Source/tasks.c **** #if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )
1046:FreeRTOS/Source/tasks.c **** 
1047:FreeRTOS/Source/tasks.c **** 	portBASE_TYPE xTaskResumeFromISR( xTaskHandle pxTaskToResume )
1048:FreeRTOS/Source/tasks.c **** 	{
1049:FreeRTOS/Source/tasks.c **** 	portBASE_TYPE xYieldRequired = pdFALSE;
1050:FreeRTOS/Source/tasks.c **** 	tskTCB *pxTCB;
1051:FreeRTOS/Source/tasks.c **** 
1052:FreeRTOS/Source/tasks.c **** 		configASSERT( pxTaskToResume );
1053:FreeRTOS/Source/tasks.c **** 
1054:FreeRTOS/Source/tasks.c **** 		pxTCB = ( tskTCB * ) pxTaskToResume;
1055:FreeRTOS/Source/tasks.c **** 
1056:FreeRTOS/Source/tasks.c **** 		if( xTaskIsTaskSuspended( pxTCB ) == pdTRUE )
1057:FreeRTOS/Source/tasks.c **** 		{
1058:FreeRTOS/Source/tasks.c **** 			traceTASK_RESUME_FROM_ISR( pxTCB );
1059:FreeRTOS/Source/tasks.c **** 
1060:FreeRTOS/Source/tasks.c **** 			if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
1061:FreeRTOS/Source/tasks.c **** 			{
1062:FreeRTOS/Source/tasks.c **** 				xYieldRequired = ( pxTCB->uxPriority >= pxCurrentTCB->uxPriority );
1063:FreeRTOS/Source/tasks.c **** 				vListRemove(  &( pxTCB->xGenericListItem ) );
1064:FreeRTOS/Source/tasks.c **** 				prvAddTaskToReadyQueue( pxTCB );
1065:FreeRTOS/Source/tasks.c **** 			}
1066:FreeRTOS/Source/tasks.c **** 			else
1067:FreeRTOS/Source/tasks.c **** 			{
1068:FreeRTOS/Source/tasks.c **** 				/* We cannot access the delayed or ready lists, so will hold this
1069:FreeRTOS/Source/tasks.c **** 				task pending until the scheduler is resumed, at which point a
1070:FreeRTOS/Source/tasks.c **** 				yield will be performed if necessary. */
1071:FreeRTOS/Source/tasks.c **** 				vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
1072:FreeRTOS/Source/tasks.c **** 			}
1073:FreeRTOS/Source/tasks.c **** 		}
1074:FreeRTOS/Source/tasks.c **** 
1075:FreeRTOS/Source/tasks.c **** 		return xYieldRequired;
1076:FreeRTOS/Source/tasks.c **** 	}
1077:FreeRTOS/Source/tasks.c **** 
1078:FreeRTOS/Source/tasks.c **** #endif
1079:FreeRTOS/Source/tasks.c **** 
1080:FreeRTOS/Source/tasks.c **** 
1081:FreeRTOS/Source/tasks.c **** 
1082:FreeRTOS/Source/tasks.c **** 
1083:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------
1084:FreeRTOS/Source/tasks.c ****  * PUBLIC SCHEDULER CONTROL documented in task.h
1085:FreeRTOS/Source/tasks.c ****  *----------------------------------------------------------*/
1086:FreeRTOS/Source/tasks.c **** 
1087:FreeRTOS/Source/tasks.c **** 
1088:FreeRTOS/Source/tasks.c **** void vTaskStartScheduler( void )
1089:FreeRTOS/Source/tasks.c **** {
1090:FreeRTOS/Source/tasks.c **** portBASE_TYPE xReturn;
1091:FreeRTOS/Source/tasks.c **** 
1092:FreeRTOS/Source/tasks.c **** 	/* Add the idle task at the lowest priority. */
1093:FreeRTOS/Source/tasks.c **** 	#if ( INCLUDE_xTaskGetIdleTaskHandle == 1 )
1094:FreeRTOS/Source/tasks.c **** 	{
1095:FreeRTOS/Source/tasks.c **** 		/* Create the idle task, storing its handle in xIdleTaskHandle so it can
1096:FreeRTOS/Source/tasks.c **** 		be returned by the xTaskGetIdleTaskHandle() function. */
1097:FreeRTOS/Source/tasks.c **** 		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL
1098:FreeRTOS/Source/tasks.c **** 	}
1099:FreeRTOS/Source/tasks.c **** 	#else
1100:FreeRTOS/Source/tasks.c **** 	{
1101:FreeRTOS/Source/tasks.c **** 		/* Create the idle task without storing its handle. */
1102:FreeRTOS/Source/tasks.c **** 		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL
1103:FreeRTOS/Source/tasks.c **** 	}
1104:FreeRTOS/Source/tasks.c **** 	#endif
1105:FreeRTOS/Source/tasks.c **** 
1106:FreeRTOS/Source/tasks.c **** 	#if ( configUSE_TIMERS == 1 )
1107:FreeRTOS/Source/tasks.c **** 	{
1108:FreeRTOS/Source/tasks.c **** 		if( xReturn == pdPASS )
1109:FreeRTOS/Source/tasks.c **** 		{
1110:FreeRTOS/Source/tasks.c **** 			xReturn = xTimerCreateTimerTask();
1111:FreeRTOS/Source/tasks.c **** 		}
1112:FreeRTOS/Source/tasks.c **** 	}
1113:FreeRTOS/Source/tasks.c **** 	#endif
1114:FreeRTOS/Source/tasks.c **** 
1115:FreeRTOS/Source/tasks.c **** 	if( xReturn == pdPASS )
1116:FreeRTOS/Source/tasks.c **** 	{
1117:FreeRTOS/Source/tasks.c **** 		/* Interrupts are turned off here, to ensure a tick does not occur
1118:FreeRTOS/Source/tasks.c **** 		before or during the call to xPortStartScheduler().  The stacks of
1119:FreeRTOS/Source/tasks.c **** 		the created tasks contain a status word with interrupts switched on
1120:FreeRTOS/Source/tasks.c **** 		so interrupts will automatically get re-enabled when the first task
1121:FreeRTOS/Source/tasks.c **** 		starts to run.
1122:FreeRTOS/Source/tasks.c **** 
1123:FreeRTOS/Source/tasks.c **** 		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
1124:FreeRTOS/Source/tasks.c **** 		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
1125:FreeRTOS/Source/tasks.c **** 		portDISABLE_INTERRUPTS();
1126:FreeRTOS/Source/tasks.c **** 
1127:FreeRTOS/Source/tasks.c **** 		xSchedulerRunning = pdTRUE;
1128:FreeRTOS/Source/tasks.c **** 		xTickCount = ( portTickType ) 0U;
1129:FreeRTOS/Source/tasks.c **** 
1130:FreeRTOS/Source/tasks.c **** 		/* If configGENERATE_RUN_TIME_STATS is defined then the following
1131:FreeRTOS/Source/tasks.c **** 		macro must be defined to configure the timer/counter used to generate
1132:FreeRTOS/Source/tasks.c **** 		the run time counter time base. */
1133:FreeRTOS/Source/tasks.c **** 		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();
1134:FreeRTOS/Source/tasks.c **** 		
1135:FreeRTOS/Source/tasks.c **** 		/* Setting up the timer tick is hardware specific and thus in the
1136:FreeRTOS/Source/tasks.c **** 		portable interface. */
1137:FreeRTOS/Source/tasks.c **** 		if( xPortStartScheduler() != pdFALSE )
1138:FreeRTOS/Source/tasks.c **** 		{
1139:FreeRTOS/Source/tasks.c **** 			/* Should not reach here as if the scheduler is running the
1140:FreeRTOS/Source/tasks.c **** 			function will not return. */
1141:FreeRTOS/Source/tasks.c **** 		}
1142:FreeRTOS/Source/tasks.c **** 		else
1143:FreeRTOS/Source/tasks.c **** 		{
1144:FreeRTOS/Source/tasks.c **** 			/* Should only reach here if a task calls xTaskEndScheduler(). */
1145:FreeRTOS/Source/tasks.c **** 		}
1146:FreeRTOS/Source/tasks.c **** 	}
1147:FreeRTOS/Source/tasks.c **** 
1148:FreeRTOS/Source/tasks.c **** 	/* This line will only be reached if the kernel could not be started. */
1149:FreeRTOS/Source/tasks.c **** 	configASSERT( xReturn );
1150:FreeRTOS/Source/tasks.c **** }
1151:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1152:FreeRTOS/Source/tasks.c **** 
1153:FreeRTOS/Source/tasks.c **** void vTaskEndScheduler( void )
1154:FreeRTOS/Source/tasks.c **** {
1155:FreeRTOS/Source/tasks.c **** 	/* Stop the scheduler interrupts and call the portable scheduler end
1156:FreeRTOS/Source/tasks.c **** 	routine so the original ISRs can be restored if necessary.  The port
1157:FreeRTOS/Source/tasks.c **** 	layer must ensure interrupts enable	bit is left in the correct state. */
1158:FreeRTOS/Source/tasks.c **** 	portDISABLE_INTERRUPTS();
1159:FreeRTOS/Source/tasks.c **** 	xSchedulerRunning = pdFALSE;
1160:FreeRTOS/Source/tasks.c **** 	vPortEndScheduler();
1161:FreeRTOS/Source/tasks.c **** }
1162:FreeRTOS/Source/tasks.c **** /*----------------------------------------------------------*/
1163:FreeRTOS/Source/tasks.c **** 
1164:FreeRTOS/Source/tasks.c **** void vTaskSuspendAll( void )
1165:FreeRTOS/Source/tasks.c **** {
1166:FreeRTOS/Source/tasks.c **** 	/* A critical section is not required as the variable is of type
1167:FreeRTOS/Source/tasks.c **** 	portBASE_TYPE. */
1168:FreeRTOS/Source/tasks.c **** 	++uxSchedulerSuspended;
1169:FreeRTOS/Source/tasks.c **** }
1170:FreeRTOS/Source/tasks.c **** /*----------------------------------------------------------*/
1171:FreeRTOS/Source/tasks.c **** 
1172:FreeRTOS/Source/tasks.c **** signed portBASE_TYPE xTaskResumeAll( void )
1173:FreeRTOS/Source/tasks.c **** {
1174:FreeRTOS/Source/tasks.c **** register tskTCB *pxTCB;
1175:FreeRTOS/Source/tasks.c **** signed portBASE_TYPE xAlreadyYielded = pdFALSE;
1176:FreeRTOS/Source/tasks.c **** 
1177:FreeRTOS/Source/tasks.c **** 	/* If uxSchedulerSuspended is zero then this function does not match a
1178:FreeRTOS/Source/tasks.c **** 	previous call to vTaskSuspendAll(). */
1179:FreeRTOS/Source/tasks.c **** 	configASSERT( uxSchedulerSuspended );
1180:FreeRTOS/Source/tasks.c **** 
1181:FreeRTOS/Source/tasks.c **** 	/* It is possible that an ISR caused a task to be removed from an event
1182:FreeRTOS/Source/tasks.c **** 	list while the scheduler was suspended.  If this was the case then the
1183:FreeRTOS/Source/tasks.c **** 	removed task will have been added to the xPendingReadyList.  Once the
1184:FreeRTOS/Source/tasks.c **** 	scheduler has been resumed it is safe to move all the pending ready
1185:FreeRTOS/Source/tasks.c **** 	tasks from this list into their appropriate ready list. */
1186:FreeRTOS/Source/tasks.c **** 	taskENTER_CRITICAL();
1187:FreeRTOS/Source/tasks.c **** 	{
1188:FreeRTOS/Source/tasks.c **** 		--uxSchedulerSuspended;
1189:FreeRTOS/Source/tasks.c **** 
1190:FreeRTOS/Source/tasks.c **** 		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
1191:FreeRTOS/Source/tasks.c **** 		{
1192:FreeRTOS/Source/tasks.c **** 			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
1193:FreeRTOS/Source/tasks.c **** 			{
1194:FreeRTOS/Source/tasks.c **** 				portBASE_TYPE xYieldRequired = pdFALSE;
1195:FreeRTOS/Source/tasks.c **** 
1196:FreeRTOS/Source/tasks.c **** 				/* Move any readied tasks from the pending list into the
1197:FreeRTOS/Source/tasks.c **** 				appropriate ready list. */
1198:FreeRTOS/Source/tasks.c **** 				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
1199:FreeRTOS/Source/tasks.c **** 				{
1200:FreeRTOS/Source/tasks.c **** 					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
1201:FreeRTOS/Source/tasks.c **** 					vListRemove( &( pxTCB->xEventListItem ) );
1202:FreeRTOS/Source/tasks.c **** 					vListRemove( &( pxTCB->xGenericListItem ) );
1203:FreeRTOS/Source/tasks.c **** 					prvAddTaskToReadyQueue( pxTCB );
1204:FreeRTOS/Source/tasks.c **** 
1205:FreeRTOS/Source/tasks.c **** 					/* If we have moved a task that has a priority higher than
1206:FreeRTOS/Source/tasks.c **** 					the current task then we should yield. */
1207:FreeRTOS/Source/tasks.c **** 					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
1208:FreeRTOS/Source/tasks.c **** 					{
1209:FreeRTOS/Source/tasks.c **** 						xYieldRequired = pdTRUE;
1210:FreeRTOS/Source/tasks.c **** 					}
1211:FreeRTOS/Source/tasks.c **** 				}
1212:FreeRTOS/Source/tasks.c **** 
1213:FreeRTOS/Source/tasks.c **** 				/* If any ticks occurred while the scheduler was suspended then
1214:FreeRTOS/Source/tasks.c **** 				they should be processed now.  This ensures the tick count does not
1215:FreeRTOS/Source/tasks.c **** 				slip, and that any delayed tasks are resumed at the correct time. */
1216:FreeRTOS/Source/tasks.c **** 				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
1217:FreeRTOS/Source/tasks.c **** 				{
1218:FreeRTOS/Source/tasks.c **** 					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
1219:FreeRTOS/Source/tasks.c **** 					{
1220:FreeRTOS/Source/tasks.c **** 						vTaskIncrementTick();
1221:FreeRTOS/Source/tasks.c **** 						--uxMissedTicks;
1222:FreeRTOS/Source/tasks.c **** 					}
1223:FreeRTOS/Source/tasks.c **** 
1224:FreeRTOS/Source/tasks.c **** 					/* As we have processed some ticks it is appropriate to yield
1225:FreeRTOS/Source/tasks.c **** 					to ensure the highest priority task that is ready to run is
1226:FreeRTOS/Source/tasks.c **** 					the task actually running. */
1227:FreeRTOS/Source/tasks.c **** 					#if configUSE_PREEMPTION == 1
1228:FreeRTOS/Source/tasks.c **** 					{
1229:FreeRTOS/Source/tasks.c **** 						xYieldRequired = pdTRUE;
1230:FreeRTOS/Source/tasks.c **** 					}
1231:FreeRTOS/Source/tasks.c **** 					#endif
1232:FreeRTOS/Source/tasks.c **** 				}
1233:FreeRTOS/Source/tasks.c **** 
1234:FreeRTOS/Source/tasks.c **** 				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
1235:FreeRTOS/Source/tasks.c **** 				{
1236:FreeRTOS/Source/tasks.c **** 					xAlreadyYielded = pdTRUE;
1237:FreeRTOS/Source/tasks.c **** 					xMissedYield = pdFALSE;
1238:FreeRTOS/Source/tasks.c **** 					portYIELD_WITHIN_API();
1239:FreeRTOS/Source/tasks.c **** 				}
1240:FreeRTOS/Source/tasks.c **** 			}
1241:FreeRTOS/Source/tasks.c **** 		}
1242:FreeRTOS/Source/tasks.c **** 	}
1243:FreeRTOS/Source/tasks.c **** 	taskEXIT_CRITICAL();
1244:FreeRTOS/Source/tasks.c **** 
1245:FreeRTOS/Source/tasks.c **** 	return xAlreadyYielded;
1246:FreeRTOS/Source/tasks.c **** }
1247:FreeRTOS/Source/tasks.c **** 
1248:FreeRTOS/Source/tasks.c **** 
1249:FreeRTOS/Source/tasks.c **** 
1250:FreeRTOS/Source/tasks.c **** 
1251:FreeRTOS/Source/tasks.c **** 
1252:FreeRTOS/Source/tasks.c **** 
1253:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------
1254:FreeRTOS/Source/tasks.c ****  * PUBLIC TASK UTILITIES documented in task.h
1255:FreeRTOS/Source/tasks.c ****  *----------------------------------------------------------*/
1256:FreeRTOS/Source/tasks.c **** 
1257:FreeRTOS/Source/tasks.c **** 
1258:FreeRTOS/Source/tasks.c **** 
1259:FreeRTOS/Source/tasks.c **** portTickType xTaskGetTickCount( void )
1260:FreeRTOS/Source/tasks.c **** {
1261:FreeRTOS/Source/tasks.c **** portTickType xTicks;
1262:FreeRTOS/Source/tasks.c **** 
1263:FreeRTOS/Source/tasks.c **** 	/* Critical section required if running on a 16 bit processor. */
1264:FreeRTOS/Source/tasks.c **** 	taskENTER_CRITICAL();
1265:FreeRTOS/Source/tasks.c **** 	{
1266:FreeRTOS/Source/tasks.c **** 		xTicks = xTickCount;
1267:FreeRTOS/Source/tasks.c **** 	}
1268:FreeRTOS/Source/tasks.c **** 	taskEXIT_CRITICAL();
1269:FreeRTOS/Source/tasks.c **** 
1270:FreeRTOS/Source/tasks.c **** 	return xTicks;
1271:FreeRTOS/Source/tasks.c **** }
1272:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1273:FreeRTOS/Source/tasks.c **** 
1274:FreeRTOS/Source/tasks.c **** portTickType xTaskGetTickCountFromISR( void )
1275:FreeRTOS/Source/tasks.c **** {
1276:FreeRTOS/Source/tasks.c **** portTickType xReturn;
1277:FreeRTOS/Source/tasks.c **** unsigned portBASE_TYPE uxSavedInterruptStatus;
1278:FreeRTOS/Source/tasks.c **** 
1279:FreeRTOS/Source/tasks.c **** 	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
1280:FreeRTOS/Source/tasks.c **** 	xReturn = xTickCount;
1281:FreeRTOS/Source/tasks.c **** 	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
1282:FreeRTOS/Source/tasks.c **** 
1283:FreeRTOS/Source/tasks.c **** 	return xReturn;
1284:FreeRTOS/Source/tasks.c **** }
1285:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1286:FreeRTOS/Source/tasks.c **** 
1287:FreeRTOS/Source/tasks.c **** unsigned portBASE_TYPE uxTaskGetNumberOfTasks( void )
1288:FreeRTOS/Source/tasks.c **** {
1289:FreeRTOS/Source/tasks.c **** 	/* A critical section is not required because the variables are of type
1290:FreeRTOS/Source/tasks.c **** 	portBASE_TYPE. */
1291:FreeRTOS/Source/tasks.c **** 	return uxCurrentNumberOfTasks;
1292:FreeRTOS/Source/tasks.c **** }
1293:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1294:FreeRTOS/Source/tasks.c **** 
1295:FreeRTOS/Source/tasks.c **** #if ( INCLUDE_pcTaskGetTaskName == 1 )
1296:FreeRTOS/Source/tasks.c **** 
1297:FreeRTOS/Source/tasks.c **** 	signed char *pcTaskGetTaskName( xTaskHandle xTaskToQuery )
1298:FreeRTOS/Source/tasks.c **** 	{
1299:FreeRTOS/Source/tasks.c **** 	tskTCB *pxTCB;
1300:FreeRTOS/Source/tasks.c **** 
1301:FreeRTOS/Source/tasks.c **** 		/* If null is passed in here then the name of the calling task is being queried. */
1302:FreeRTOS/Source/tasks.c **** 		pxTCB = prvGetTCBFromHandle( xTaskToQuery );
1303:FreeRTOS/Source/tasks.c **** 		configASSERT( pxTCB );
1304:FreeRTOS/Source/tasks.c **** 		return &( pxTCB->pcTaskName[ 0 ] );
1305:FreeRTOS/Source/tasks.c **** 	}
1306:FreeRTOS/Source/tasks.c **** 
1307:FreeRTOS/Source/tasks.c **** #endif
1308:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1309:FreeRTOS/Source/tasks.c **** 
1310:FreeRTOS/Source/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
1311:FreeRTOS/Source/tasks.c **** 
1312:FreeRTOS/Source/tasks.c **** 	void vTaskList( signed char *pcWriteBuffer )
1313:FreeRTOS/Source/tasks.c **** 	{
1314:FreeRTOS/Source/tasks.c **** 	unsigned portBASE_TYPE uxQueue;
1315:FreeRTOS/Source/tasks.c **** 
1316:FreeRTOS/Source/tasks.c **** 		/* This is a VERY costly function that should be used for debug only.
1317:FreeRTOS/Source/tasks.c **** 		It leaves interrupts disabled for a LONG time. */
1318:FreeRTOS/Source/tasks.c **** 
1319:FreeRTOS/Source/tasks.c **** 		vTaskSuspendAll();
1320:FreeRTOS/Source/tasks.c **** 		{
1321:FreeRTOS/Source/tasks.c **** 			/* Run through all the lists that could potentially contain a TCB and
1322:FreeRTOS/Source/tasks.c **** 			report the task name, state and stack high water mark. */
1323:FreeRTOS/Source/tasks.c **** 
1324:FreeRTOS/Source/tasks.c **** 			*pcWriteBuffer = ( signed char ) 0x00;
1325:FreeRTOS/Source/tasks.c **** 			strcat( ( char * ) pcWriteBuffer, ( const char * ) "\r\n" );
1326:FreeRTOS/Source/tasks.c **** 
1327:FreeRTOS/Source/tasks.c **** 			uxQueue = uxTopUsedPriority + ( unsigned portBASE_TYPE ) 1U;
1328:FreeRTOS/Source/tasks.c **** 
1329:FreeRTOS/Source/tasks.c **** 			do
1330:FreeRTOS/Source/tasks.c **** 			{
1331:FreeRTOS/Source/tasks.c **** 				uxQueue--;
1332:FreeRTOS/Source/tasks.c **** 
1333:FreeRTOS/Source/tasks.c **** 				if( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxQueue ] ) ) == pdFALSE )
1334:FreeRTOS/Source/tasks.c **** 				{
1335:FreeRTOS/Source/tasks.c **** 					prvListTaskWithinSingleList( pcWriteBuffer, ( xList * ) &( pxReadyTasksLists[ uxQueue ] ), tsk
1336:FreeRTOS/Source/tasks.c **** 				}
1337:FreeRTOS/Source/tasks.c **** 			}while( uxQueue > ( unsigned short ) tskIDLE_PRIORITY );
1338:FreeRTOS/Source/tasks.c **** 
1339:FreeRTOS/Source/tasks.c **** 			if( listLIST_IS_EMPTY( pxDelayedTaskList ) == pdFALSE )
1340:FreeRTOS/Source/tasks.c **** 			{
1341:FreeRTOS/Source/tasks.c **** 				prvListTaskWithinSingleList( pcWriteBuffer, ( xList * ) pxDelayedTaskList, tskBLOCKED_CHAR );
1342:FreeRTOS/Source/tasks.c **** 			}
1343:FreeRTOS/Source/tasks.c **** 
1344:FreeRTOS/Source/tasks.c **** 			if( listLIST_IS_EMPTY( pxOverflowDelayedTaskList ) == pdFALSE )
1345:FreeRTOS/Source/tasks.c **** 			{
1346:FreeRTOS/Source/tasks.c **** 				prvListTaskWithinSingleList( pcWriteBuffer, ( xList * ) pxOverflowDelayedTaskList, tskBLOCKED_C
1347:FreeRTOS/Source/tasks.c **** 			}
1348:FreeRTOS/Source/tasks.c **** 
1349:FreeRTOS/Source/tasks.c **** 			#if( INCLUDE_vTaskDelete == 1 )
1350:FreeRTOS/Source/tasks.c **** 			{
1351:FreeRTOS/Source/tasks.c **** 				if( listLIST_IS_EMPTY( &xTasksWaitingTermination ) == pdFALSE )
1352:FreeRTOS/Source/tasks.c **** 				{
1353:FreeRTOS/Source/tasks.c **** 					prvListTaskWithinSingleList( pcWriteBuffer, &xTasksWaitingTermination, tskDELETED_CHAR );
1354:FreeRTOS/Source/tasks.c **** 				}
1355:FreeRTOS/Source/tasks.c **** 			}
1356:FreeRTOS/Source/tasks.c **** 			#endif
1357:FreeRTOS/Source/tasks.c **** 
1358:FreeRTOS/Source/tasks.c **** 			#if ( INCLUDE_vTaskSuspend == 1 )
1359:FreeRTOS/Source/tasks.c **** 			{
1360:FreeRTOS/Source/tasks.c **** 				if( listLIST_IS_EMPTY( &xSuspendedTaskList ) == pdFALSE )
1361:FreeRTOS/Source/tasks.c **** 				{
1362:FreeRTOS/Source/tasks.c **** 					prvListTaskWithinSingleList( pcWriteBuffer, &xSuspendedTaskList, tskSUSPENDED_CHAR );
1363:FreeRTOS/Source/tasks.c **** 				}
1364:FreeRTOS/Source/tasks.c **** 			}
1365:FreeRTOS/Source/tasks.c **** 			#endif
1366:FreeRTOS/Source/tasks.c **** 		}
1367:FreeRTOS/Source/tasks.c **** 		xTaskResumeAll();
1368:FreeRTOS/Source/tasks.c **** 	}
1369:FreeRTOS/Source/tasks.c **** 
1370:FreeRTOS/Source/tasks.c **** #endif
1371:FreeRTOS/Source/tasks.c **** /*----------------------------------------------------------*/
1372:FreeRTOS/Source/tasks.c **** 
1373:FreeRTOS/Source/tasks.c **** #if ( configGENERATE_RUN_TIME_STATS == 1 )
1374:FreeRTOS/Source/tasks.c **** 
1375:FreeRTOS/Source/tasks.c **** 	void vTaskGetRunTimeStats( signed char *pcWriteBuffer )
1376:FreeRTOS/Source/tasks.c **** 	{
1377:FreeRTOS/Source/tasks.c **** 	unsigned portBASE_TYPE uxQueue;
1378:FreeRTOS/Source/tasks.c **** 	unsigned long ulTotalRunTime;
1379:FreeRTOS/Source/tasks.c **** 
1380:FreeRTOS/Source/tasks.c **** 		/* This is a VERY costly function that should be used for debug only.
1381:FreeRTOS/Source/tasks.c **** 		It leaves interrupts disabled for a LONG time. */
1382:FreeRTOS/Source/tasks.c **** 
1383:FreeRTOS/Source/tasks.c **** 		vTaskSuspendAll();
1384:FreeRTOS/Source/tasks.c **** 		{
1385:FreeRTOS/Source/tasks.c **** 			#ifdef portALT_GET_RUN_TIME_COUNTER_VALUE
1386:FreeRTOS/Source/tasks.c **** 				portALT_GET_RUN_TIME_COUNTER_VALUE( ulTotalRunTime );
1387:FreeRTOS/Source/tasks.c **** 			#else
1388:FreeRTOS/Source/tasks.c **** 				ulTotalRunTime = portGET_RUN_TIME_COUNTER_VALUE();
1389:FreeRTOS/Source/tasks.c **** 			#endif
1390:FreeRTOS/Source/tasks.c **** 
1391:FreeRTOS/Source/tasks.c **** 			/* Divide ulTotalRunTime by 100 to make the percentage caluclations
1392:FreeRTOS/Source/tasks.c **** 			simpler in the prvGenerateRunTimeStatsForTasksInList() function. */
1393:FreeRTOS/Source/tasks.c **** 			ulTotalRunTime /= 100UL;
1394:FreeRTOS/Source/tasks.c **** 			
1395:FreeRTOS/Source/tasks.c **** 			/* Run through all the lists that could potentially contain a TCB,
1396:FreeRTOS/Source/tasks.c **** 			generating a table of run timer percentages in the provided
1397:FreeRTOS/Source/tasks.c **** 			buffer. */
1398:FreeRTOS/Source/tasks.c **** 
1399:FreeRTOS/Source/tasks.c **** 			*pcWriteBuffer = ( signed char ) 0x00;
1400:FreeRTOS/Source/tasks.c **** 			strcat( ( char * ) pcWriteBuffer, ( const char * ) "\r\n" );
1401:FreeRTOS/Source/tasks.c **** 
1402:FreeRTOS/Source/tasks.c **** 			uxQueue = uxTopUsedPriority + ( unsigned portBASE_TYPE ) 1U;
1403:FreeRTOS/Source/tasks.c **** 
1404:FreeRTOS/Source/tasks.c **** 			do
1405:FreeRTOS/Source/tasks.c **** 			{
1406:FreeRTOS/Source/tasks.c **** 				uxQueue--;
1407:FreeRTOS/Source/tasks.c **** 
1408:FreeRTOS/Source/tasks.c **** 				if( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxQueue ] ) ) == pdFALSE )
1409:FreeRTOS/Source/tasks.c **** 				{
1410:FreeRTOS/Source/tasks.c **** 					prvGenerateRunTimeStatsForTasksInList( pcWriteBuffer, ( xList * ) &( pxReadyTasksLists[ uxQueu
1411:FreeRTOS/Source/tasks.c **** 				}
1412:FreeRTOS/Source/tasks.c **** 			}while( uxQueue > ( unsigned short ) tskIDLE_PRIORITY );
1413:FreeRTOS/Source/tasks.c **** 
1414:FreeRTOS/Source/tasks.c **** 			if( listLIST_IS_EMPTY( pxDelayedTaskList ) == pdFALSE )
1415:FreeRTOS/Source/tasks.c **** 			{
1416:FreeRTOS/Source/tasks.c **** 				prvGenerateRunTimeStatsForTasksInList( pcWriteBuffer, ( xList * ) pxDelayedTaskList, ulTotalRun
1417:FreeRTOS/Source/tasks.c **** 			}
1418:FreeRTOS/Source/tasks.c **** 
1419:FreeRTOS/Source/tasks.c **** 			if( listLIST_IS_EMPTY( pxOverflowDelayedTaskList ) == pdFALSE )
1420:FreeRTOS/Source/tasks.c **** 			{
1421:FreeRTOS/Source/tasks.c **** 				prvGenerateRunTimeStatsForTasksInList( pcWriteBuffer, ( xList * ) pxOverflowDelayedTaskList, ul
1422:FreeRTOS/Source/tasks.c **** 			}
1423:FreeRTOS/Source/tasks.c **** 
1424:FreeRTOS/Source/tasks.c **** 			#if ( INCLUDE_vTaskDelete == 1 )
1425:FreeRTOS/Source/tasks.c **** 			{
1426:FreeRTOS/Source/tasks.c **** 				if( listLIST_IS_EMPTY( &xTasksWaitingTermination ) == pdFALSE )
1427:FreeRTOS/Source/tasks.c **** 				{
1428:FreeRTOS/Source/tasks.c **** 					prvGenerateRunTimeStatsForTasksInList( pcWriteBuffer, &xTasksWaitingTermination, ulTotalRunTim
1429:FreeRTOS/Source/tasks.c **** 				}
1430:FreeRTOS/Source/tasks.c **** 			}
1431:FreeRTOS/Source/tasks.c **** 			#endif
1432:FreeRTOS/Source/tasks.c **** 
1433:FreeRTOS/Source/tasks.c **** 			#if ( INCLUDE_vTaskSuspend == 1 )
1434:FreeRTOS/Source/tasks.c **** 			{
1435:FreeRTOS/Source/tasks.c **** 				if( listLIST_IS_EMPTY( &xSuspendedTaskList ) == pdFALSE )
1436:FreeRTOS/Source/tasks.c **** 				{
1437:FreeRTOS/Source/tasks.c **** 					prvGenerateRunTimeStatsForTasksInList( pcWriteBuffer, &xSuspendedTaskList, ulTotalRunTime, tsk
1438:FreeRTOS/Source/tasks.c **** 				}
1439:FreeRTOS/Source/tasks.c **** 			}
1440:FreeRTOS/Source/tasks.c **** 			#endif
1441:FreeRTOS/Source/tasks.c **** 		}
1442:FreeRTOS/Source/tasks.c **** 		xTaskResumeAll();
1443:FreeRTOS/Source/tasks.c **** 	}
1444:FreeRTOS/Source/tasks.c **** 
1445:FreeRTOS/Source/tasks.c **** #endif
1446:FreeRTOS/Source/tasks.c **** /*----------------------------------------------------------*/
1447:FreeRTOS/Source/tasks.c **** 
1448:FreeRTOS/Source/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
1449:FreeRTOS/Source/tasks.c **** 
1450:FreeRTOS/Source/tasks.c **** 	void vTaskStartTrace( signed char * pcBuffer, unsigned long ulBufferSize )
1451:FreeRTOS/Source/tasks.c **** 	{
1452:FreeRTOS/Source/tasks.c **** 		configASSERT( pcBuffer );
1453:FreeRTOS/Source/tasks.c **** 		configASSERT( ulBufferSize );
1454:FreeRTOS/Source/tasks.c **** 
1455:FreeRTOS/Source/tasks.c **** 		taskENTER_CRITICAL();
1456:FreeRTOS/Source/tasks.c **** 		{
1457:FreeRTOS/Source/tasks.c **** 			pcTraceBuffer = ( signed char * )pcBuffer;
1458:FreeRTOS/Source/tasks.c **** 			pcTraceBufferStart = pcBuffer;
1459:FreeRTOS/Source/tasks.c **** 			pcTraceBufferEnd = pcBuffer + ( ulBufferSize - tskSIZE_OF_EACH_TRACE_LINE );
1460:FreeRTOS/Source/tasks.c **** 			xTracing = pdTRUE;
1461:FreeRTOS/Source/tasks.c **** 		}
1462:FreeRTOS/Source/tasks.c **** 		taskEXIT_CRITICAL();
1463:FreeRTOS/Source/tasks.c **** 	}
1464:FreeRTOS/Source/tasks.c **** 
1465:FreeRTOS/Source/tasks.c **** #endif
1466:FreeRTOS/Source/tasks.c **** /*----------------------------------------------------------*/
1467:FreeRTOS/Source/tasks.c **** 
1468:FreeRTOS/Source/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
1469:FreeRTOS/Source/tasks.c **** 
1470:FreeRTOS/Source/tasks.c **** 	unsigned long ulTaskEndTrace( void )
1471:FreeRTOS/Source/tasks.c **** 	{
1472:FreeRTOS/Source/tasks.c **** 	unsigned long ulBufferLength;
1473:FreeRTOS/Source/tasks.c **** 
1474:FreeRTOS/Source/tasks.c **** 		taskENTER_CRITICAL();
1475:FreeRTOS/Source/tasks.c **** 			xTracing = pdFALSE;
1476:FreeRTOS/Source/tasks.c **** 		taskEXIT_CRITICAL();
1477:FreeRTOS/Source/tasks.c **** 
1478:FreeRTOS/Source/tasks.c **** 		ulBufferLength = ( unsigned long ) ( pcTraceBuffer - pcTraceBufferStart );
1479:FreeRTOS/Source/tasks.c **** 
1480:FreeRTOS/Source/tasks.c **** 		return ulBufferLength;
1481:FreeRTOS/Source/tasks.c **** 	}
1482:FreeRTOS/Source/tasks.c **** 
1483:FreeRTOS/Source/tasks.c **** #endif
1484:FreeRTOS/Source/tasks.c **** /*----------------------------------------------------------*/
1485:FreeRTOS/Source/tasks.c **** 
1486:FreeRTOS/Source/tasks.c **** #if ( INCLUDE_xTaskGetIdleTaskHandle == 1 )
1487:FreeRTOS/Source/tasks.c **** 
1488:FreeRTOS/Source/tasks.c **** 	xTaskHandle xTaskGetIdleTaskHandle( void )
1489:FreeRTOS/Source/tasks.c **** 	{
1490:FreeRTOS/Source/tasks.c **** 		/* If xTaskGetIdleTaskHandle() is called before the scheduler has been
1491:FreeRTOS/Source/tasks.c **** 		started, then xIdleTaskHandle will be NULL. */
1492:FreeRTOS/Source/tasks.c **** 		configASSERT( ( xIdleTaskHandle != NULL ) );
1493:FreeRTOS/Source/tasks.c **** 		return xIdleTaskHandle;
1494:FreeRTOS/Source/tasks.c **** 	}
1495:FreeRTOS/Source/tasks.c **** 	
1496:FreeRTOS/Source/tasks.c **** #endif
1497:FreeRTOS/Source/tasks.c **** 
1498:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------
1499:FreeRTOS/Source/tasks.c ****  * SCHEDULER INTERNALS AVAILABLE FOR PORTING PURPOSES
1500:FreeRTOS/Source/tasks.c ****  * documented in task.h
1501:FreeRTOS/Source/tasks.c ****  *----------------------------------------------------------*/
1502:FreeRTOS/Source/tasks.c **** 
1503:FreeRTOS/Source/tasks.c **** void vTaskIncrementTick( void )
1504:FreeRTOS/Source/tasks.c **** {
1505:FreeRTOS/Source/tasks.c **** tskTCB * pxTCB;
1506:FreeRTOS/Source/tasks.c **** 
1507:FreeRTOS/Source/tasks.c **** 	/* Called by the portable layer each time a tick interrupt occurs.
1508:FreeRTOS/Source/tasks.c **** 	Increments the tick then checks to see if the new tick value will cause any
1509:FreeRTOS/Source/tasks.c **** 	tasks to be unblocked. */
1510:FreeRTOS/Source/tasks.c **** 	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
1511:FreeRTOS/Source/tasks.c **** 	{
1512:FreeRTOS/Source/tasks.c **** 		++xTickCount;
1513:FreeRTOS/Source/tasks.c **** 		if( xTickCount == ( portTickType ) 0U )
1514:FreeRTOS/Source/tasks.c **** 		{
1515:FreeRTOS/Source/tasks.c **** 			xList *pxTemp;
1516:FreeRTOS/Source/tasks.c **** 
1517:FreeRTOS/Source/tasks.c **** 			/* Tick count has overflowed so we need to swap the delay lists.
1518:FreeRTOS/Source/tasks.c **** 			If there are any items in pxDelayedTaskList here then there is
1519:FreeRTOS/Source/tasks.c **** 			an error! */
1520:FreeRTOS/Source/tasks.c **** 			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );
1521:FreeRTOS/Source/tasks.c **** 			
1522:FreeRTOS/Source/tasks.c **** 			pxTemp = pxDelayedTaskList;
1523:FreeRTOS/Source/tasks.c **** 			pxDelayedTaskList = pxOverflowDelayedTaskList;
1524:FreeRTOS/Source/tasks.c **** 			pxOverflowDelayedTaskList = pxTemp;
1525:FreeRTOS/Source/tasks.c **** 			xNumOfOverflows++;
1526:FreeRTOS/Source/tasks.c **** 	
1527:FreeRTOS/Source/tasks.c **** 			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
1528:FreeRTOS/Source/tasks.c **** 			{
1529:FreeRTOS/Source/tasks.c **** 				/* The new current delayed list is empty.  Set
1530:FreeRTOS/Source/tasks.c **** 				xNextTaskUnblockTime to the maximum possible value so it is
1531:FreeRTOS/Source/tasks.c **** 				extremely unlikely that the	
1532:FreeRTOS/Source/tasks.c **** 				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
1533:FreeRTOS/Source/tasks.c **** 				there is an item in the delayed list. */
1534:FreeRTOS/Source/tasks.c **** 				xNextTaskUnblockTime = portMAX_DELAY;
1535:FreeRTOS/Source/tasks.c **** 			}
1536:FreeRTOS/Source/tasks.c **** 			else
1537:FreeRTOS/Source/tasks.c **** 			{
1538:FreeRTOS/Source/tasks.c **** 				/* The new current delayed list is not empty, get the value of
1539:FreeRTOS/Source/tasks.c **** 				the item at the head of the delayed list.  This is the time at
1540:FreeRTOS/Source/tasks.c **** 				which the task at the head of the delayed list should be removed
1541:FreeRTOS/Source/tasks.c **** 				from the Blocked state. */
1542:FreeRTOS/Source/tasks.c **** 				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
1543:FreeRTOS/Source/tasks.c **** 				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
1544:FreeRTOS/Source/tasks.c **** 			}
1545:FreeRTOS/Source/tasks.c **** 		}
1546:FreeRTOS/Source/tasks.c **** 
1547:FreeRTOS/Source/tasks.c **** 		/* See if this tick has made a timeout expire. */
1548:FreeRTOS/Source/tasks.c **** 		prvCheckDelayedTasks();
1549:FreeRTOS/Source/tasks.c **** 	}
1550:FreeRTOS/Source/tasks.c **** 	else
1551:FreeRTOS/Source/tasks.c **** 	{
1552:FreeRTOS/Source/tasks.c **** 		++uxMissedTicks;
1553:FreeRTOS/Source/tasks.c **** 
1554:FreeRTOS/Source/tasks.c **** 		/* The tick hook gets called at regular intervals, even if the
1555:FreeRTOS/Source/tasks.c **** 		scheduler is locked. */
1556:FreeRTOS/Source/tasks.c **** 		#if ( configUSE_TICK_HOOK == 1 )
1557:FreeRTOS/Source/tasks.c **** 		{
1558:FreeRTOS/Source/tasks.c **** 			vApplicationTickHook();
1559:FreeRTOS/Source/tasks.c **** 		}
1560:FreeRTOS/Source/tasks.c **** 		#endif
1561:FreeRTOS/Source/tasks.c **** 	}
1562:FreeRTOS/Source/tasks.c **** 
1563:FreeRTOS/Source/tasks.c **** 	#if ( configUSE_TICK_HOOK == 1 )
1564:FreeRTOS/Source/tasks.c **** 	{
1565:FreeRTOS/Source/tasks.c **** 		/* Guard against the tick hook being called when the missed tick
1566:FreeRTOS/Source/tasks.c **** 		count is being unwound (when the scheduler is being unlocked. */
1567:FreeRTOS/Source/tasks.c **** 		if( uxMissedTicks == ( unsigned portBASE_TYPE ) 0U )
1568:FreeRTOS/Source/tasks.c **** 		{
1569:FreeRTOS/Source/tasks.c **** 			vApplicationTickHook();
1570:FreeRTOS/Source/tasks.c **** 		}
1571:FreeRTOS/Source/tasks.c **** 	}
1572:FreeRTOS/Source/tasks.c **** 	#endif
1573:FreeRTOS/Source/tasks.c **** 
1574:FreeRTOS/Source/tasks.c **** 	traceTASK_INCREMENT_TICK( xTickCount );
1575:FreeRTOS/Source/tasks.c **** }
1576:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1577:FreeRTOS/Source/tasks.c **** 
1578:FreeRTOS/Source/tasks.c **** #if ( configUSE_APPLICATION_TASK_TAG == 1 )
1579:FreeRTOS/Source/tasks.c **** 
1580:FreeRTOS/Source/tasks.c **** 	void vTaskSetApplicationTaskTag( xTaskHandle xTask, pdTASK_HOOK_CODE pxHookFunction )
1581:FreeRTOS/Source/tasks.c **** 	{
1582:FreeRTOS/Source/tasks.c **** 	tskTCB *xTCB;
1583:FreeRTOS/Source/tasks.c **** 
1584:FreeRTOS/Source/tasks.c **** 		/* If xTask is NULL then we are setting our own task hook. */
1585:FreeRTOS/Source/tasks.c **** 		if( xTask == NULL )
1586:FreeRTOS/Source/tasks.c **** 		{
1587:FreeRTOS/Source/tasks.c **** 			xTCB = ( tskTCB * ) pxCurrentTCB;
1588:FreeRTOS/Source/tasks.c **** 		}
1589:FreeRTOS/Source/tasks.c **** 		else
1590:FreeRTOS/Source/tasks.c **** 		{
1591:FreeRTOS/Source/tasks.c **** 			xTCB = ( tskTCB * ) xTask;
1592:FreeRTOS/Source/tasks.c **** 		}
1593:FreeRTOS/Source/tasks.c **** 
1594:FreeRTOS/Source/tasks.c **** 		/* Save the hook function in the TCB.  A critical section is required as
1595:FreeRTOS/Source/tasks.c **** 		the value can be accessed from an interrupt. */
1596:FreeRTOS/Source/tasks.c **** 		taskENTER_CRITICAL();
1597:FreeRTOS/Source/tasks.c **** 			xTCB->pxTaskTag = pxHookFunction;
1598:FreeRTOS/Source/tasks.c **** 		taskEXIT_CRITICAL();
1599:FreeRTOS/Source/tasks.c **** 	}
1600:FreeRTOS/Source/tasks.c **** 
1601:FreeRTOS/Source/tasks.c **** #endif
1602:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1603:FreeRTOS/Source/tasks.c **** 
1604:FreeRTOS/Source/tasks.c **** #if ( configUSE_APPLICATION_TASK_TAG == 1 )
1605:FreeRTOS/Source/tasks.c **** 
1606:FreeRTOS/Source/tasks.c **** 	pdTASK_HOOK_CODE xTaskGetApplicationTaskTag( xTaskHandle xTask )
1607:FreeRTOS/Source/tasks.c **** 	{
1608:FreeRTOS/Source/tasks.c **** 	tskTCB *xTCB;
1609:FreeRTOS/Source/tasks.c **** 	pdTASK_HOOK_CODE xReturn;
1610:FreeRTOS/Source/tasks.c **** 
1611:FreeRTOS/Source/tasks.c **** 		/* If xTask is NULL then we are setting our own task hook. */
1612:FreeRTOS/Source/tasks.c **** 		if( xTask == NULL )
1613:FreeRTOS/Source/tasks.c **** 		{
1614:FreeRTOS/Source/tasks.c **** 			xTCB = ( tskTCB * ) pxCurrentTCB;
1615:FreeRTOS/Source/tasks.c **** 		}
1616:FreeRTOS/Source/tasks.c **** 		else
1617:FreeRTOS/Source/tasks.c **** 		{
1618:FreeRTOS/Source/tasks.c **** 			xTCB = ( tskTCB * ) xTask;
1619:FreeRTOS/Source/tasks.c **** 		}
1620:FreeRTOS/Source/tasks.c **** 
1621:FreeRTOS/Source/tasks.c **** 		/* Save the hook function in the TCB.  A critical section is required as
1622:FreeRTOS/Source/tasks.c **** 		the value can be accessed from an interrupt. */
1623:FreeRTOS/Source/tasks.c **** 		taskENTER_CRITICAL();
1624:FreeRTOS/Source/tasks.c **** 			xReturn = xTCB->pxTaskTag;
1625:FreeRTOS/Source/tasks.c **** 		taskEXIT_CRITICAL();
1626:FreeRTOS/Source/tasks.c **** 
1627:FreeRTOS/Source/tasks.c **** 		return xReturn;
1628:FreeRTOS/Source/tasks.c **** 	}
1629:FreeRTOS/Source/tasks.c **** 
1630:FreeRTOS/Source/tasks.c **** #endif
1631:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1632:FreeRTOS/Source/tasks.c **** 
1633:FreeRTOS/Source/tasks.c **** #if ( configUSE_APPLICATION_TASK_TAG == 1 )
1634:FreeRTOS/Source/tasks.c **** 
1635:FreeRTOS/Source/tasks.c **** 	portBASE_TYPE xTaskCallApplicationTaskHook( xTaskHandle xTask, void *pvParameter )
1636:FreeRTOS/Source/tasks.c **** 	{
1637:FreeRTOS/Source/tasks.c **** 	tskTCB *xTCB;
1638:FreeRTOS/Source/tasks.c **** 	portBASE_TYPE xReturn;
1639:FreeRTOS/Source/tasks.c **** 
1640:FreeRTOS/Source/tasks.c **** 		/* If xTask is NULL then we are calling our own task hook. */
1641:FreeRTOS/Source/tasks.c **** 		if( xTask == NULL )
1642:FreeRTOS/Source/tasks.c **** 		{
1643:FreeRTOS/Source/tasks.c **** 			xTCB = ( tskTCB * ) pxCurrentTCB;
1644:FreeRTOS/Source/tasks.c **** 		}
1645:FreeRTOS/Source/tasks.c **** 		else
1646:FreeRTOS/Source/tasks.c **** 		{
1647:FreeRTOS/Source/tasks.c **** 			xTCB = ( tskTCB * ) xTask;
1648:FreeRTOS/Source/tasks.c **** 		}
1649:FreeRTOS/Source/tasks.c **** 
1650:FreeRTOS/Source/tasks.c **** 		if( xTCB->pxTaskTag != NULL )
1651:FreeRTOS/Source/tasks.c **** 		{
1652:FreeRTOS/Source/tasks.c **** 			xReturn = xTCB->pxTaskTag( pvParameter );
1653:FreeRTOS/Source/tasks.c **** 		}
1654:FreeRTOS/Source/tasks.c **** 		else
1655:FreeRTOS/Source/tasks.c **** 		{
1656:FreeRTOS/Source/tasks.c **** 			xReturn = pdFAIL;
1657:FreeRTOS/Source/tasks.c **** 		}
1658:FreeRTOS/Source/tasks.c **** 
1659:FreeRTOS/Source/tasks.c **** 		return xReturn;
1660:FreeRTOS/Source/tasks.c **** 	}
1661:FreeRTOS/Source/tasks.c **** 
1662:FreeRTOS/Source/tasks.c **** #endif
1663:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1664:FreeRTOS/Source/tasks.c **** 
1665:FreeRTOS/Source/tasks.c **** void vTaskSwitchContext( void )
1666:FreeRTOS/Source/tasks.c **** {
1667:FreeRTOS/Source/tasks.c **** 	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
1668:FreeRTOS/Source/tasks.c **** 	{
1669:FreeRTOS/Source/tasks.c **** 		/* The scheduler is currently suspended - do not allow a context
1670:FreeRTOS/Source/tasks.c **** 		switch. */
1671:FreeRTOS/Source/tasks.c **** 		xMissedYield = pdTRUE;
1672:FreeRTOS/Source/tasks.c **** 	}
1673:FreeRTOS/Source/tasks.c **** 	else
1674:FreeRTOS/Source/tasks.c **** 	{
1675:FreeRTOS/Source/tasks.c **** 		traceTASK_SWITCHED_OUT();
1676:FreeRTOS/Source/tasks.c **** 	
1677:FreeRTOS/Source/tasks.c **** 		#if ( configGENERATE_RUN_TIME_STATS == 1 )
1678:FreeRTOS/Source/tasks.c **** 		{
1679:FreeRTOS/Source/tasks.c **** 			unsigned long ulTempCounter;
1680:FreeRTOS/Source/tasks.c **** 			
1681:FreeRTOS/Source/tasks.c **** 				#ifdef portALT_GET_RUN_TIME_COUNTER_VALUE
1682:FreeRTOS/Source/tasks.c **** 					portALT_GET_RUN_TIME_COUNTER_VALUE( ulTempCounter );
1683:FreeRTOS/Source/tasks.c **** 				#else
1684:FreeRTOS/Source/tasks.c **** 					ulTempCounter = portGET_RUN_TIME_COUNTER_VALUE();
1685:FreeRTOS/Source/tasks.c **** 				#endif
1686:FreeRTOS/Source/tasks.c **** 	
1687:FreeRTOS/Source/tasks.c **** 				/* Add the amount of time the task has been running to the accumulated
1688:FreeRTOS/Source/tasks.c **** 				time so far.  The time the task started running was stored in
1689:FreeRTOS/Source/tasks.c **** 				ulTaskSwitchedInTime.  Note that there is no overflow protection here
1690:FreeRTOS/Source/tasks.c **** 				so count values are only valid until the timer overflows.  Generally
1691:FreeRTOS/Source/tasks.c **** 				this will be about 1 hour assuming a 1uS timer increment. */
1692:FreeRTOS/Source/tasks.c **** 				pxCurrentTCB->ulRunTimeCounter += ( ulTempCounter - ulTaskSwitchedInTime );
1693:FreeRTOS/Source/tasks.c **** 				ulTaskSwitchedInTime = ulTempCounter;
1694:FreeRTOS/Source/tasks.c **** 		}
1695:FreeRTOS/Source/tasks.c **** 		#endif
1696:FreeRTOS/Source/tasks.c **** 	
1697:FreeRTOS/Source/tasks.c **** 		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
1698:FreeRTOS/Source/tasks.c **** 		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
1699:FreeRTOS/Source/tasks.c **** 	
1700:FreeRTOS/Source/tasks.c **** 		/* Find the highest priority queue that contains ready tasks. */
1701:FreeRTOS/Source/tasks.c **** 		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
1702:FreeRTOS/Source/tasks.c **** 		{
1703:FreeRTOS/Source/tasks.c **** 			configASSERT( uxTopReadyPriority );
1704:FreeRTOS/Source/tasks.c **** 			--uxTopReadyPriority;
1705:FreeRTOS/Source/tasks.c **** 		}
1706:FreeRTOS/Source/tasks.c **** 	
1707:FreeRTOS/Source/tasks.c **** 		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
1708:FreeRTOS/Source/tasks.c **** 		same priority get an equal share of the processor time. */
1709:FreeRTOS/Source/tasks.c **** 		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
1710:FreeRTOS/Source/tasks.c **** 	
1711:FreeRTOS/Source/tasks.c **** 		traceTASK_SWITCHED_IN();
1712:FreeRTOS/Source/tasks.c **** 		vWriteTraceToBuffer();
1713:FreeRTOS/Source/tasks.c **** 	}
1714:FreeRTOS/Source/tasks.c **** }
1715:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1716:FreeRTOS/Source/tasks.c **** 
1717:FreeRTOS/Source/tasks.c **** void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
1718:FreeRTOS/Source/tasks.c **** {
1719:FreeRTOS/Source/tasks.c **** portTickType xTimeToWake;
1720:FreeRTOS/Source/tasks.c **** 
1721:FreeRTOS/Source/tasks.c **** 	configASSERT( pxEventList );
1722:FreeRTOS/Source/tasks.c **** 
1723:FreeRTOS/Source/tasks.c **** 	/* THIS FUNCTION MUST BE CALLED WITH INTERRUPTS DISABLED OR THE
1724:FreeRTOS/Source/tasks.c **** 	SCHEDULER SUSPENDED. */
1725:FreeRTOS/Source/tasks.c **** 
1726:FreeRTOS/Source/tasks.c **** 	/* Place the event list item of the TCB in the appropriate event list.
1727:FreeRTOS/Source/tasks.c **** 	This is placed in the list in priority order so the highest priority task
1728:FreeRTOS/Source/tasks.c **** 	is the first to be woken by the event. */
1729:FreeRTOS/Source/tasks.c **** 	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
1730:FreeRTOS/Source/tasks.c **** 
1731:FreeRTOS/Source/tasks.c **** 	/* We must remove ourselves from the ready list before adding ourselves
1732:FreeRTOS/Source/tasks.c **** 	to the blocked list as the same list item is used for both lists.  We have
1733:FreeRTOS/Source/tasks.c **** 	exclusive access to the ready lists as the scheduler is locked. */
1734:FreeRTOS/Source/tasks.c **** 	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
1735:FreeRTOS/Source/tasks.c **** 
1736:FreeRTOS/Source/tasks.c **** 
1737:FreeRTOS/Source/tasks.c **** 	#if ( INCLUDE_vTaskSuspend == 1 )
1738:FreeRTOS/Source/tasks.c **** 	{
1739:FreeRTOS/Source/tasks.c **** 		if( xTicksToWait == portMAX_DELAY )
1740:FreeRTOS/Source/tasks.c **** 		{
1741:FreeRTOS/Source/tasks.c **** 			/* Add ourselves to the suspended task list instead of a delayed task
1742:FreeRTOS/Source/tasks.c **** 			list to ensure we are not woken by a timing event.  We will block
1743:FreeRTOS/Source/tasks.c **** 			indefinitely. */
1744:FreeRTOS/Source/tasks.c **** 			vListInsertEnd( ( xList * ) &xSuspendedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListIt
1745:FreeRTOS/Source/tasks.c **** 		}
1746:FreeRTOS/Source/tasks.c **** 		else
1747:FreeRTOS/Source/tasks.c **** 		{
1748:FreeRTOS/Source/tasks.c **** 			/* Calculate the time at which the task should be woken if the event does
1749:FreeRTOS/Source/tasks.c **** 			not occur.  This may overflow but this doesn't matter. */
1750:FreeRTOS/Source/tasks.c **** 			xTimeToWake = xTickCount + xTicksToWait;
1751:FreeRTOS/Source/tasks.c **** 			prvAddCurrentTaskToDelayedList( xTimeToWake );
1752:FreeRTOS/Source/tasks.c **** 		}
1753:FreeRTOS/Source/tasks.c **** 	}
1754:FreeRTOS/Source/tasks.c **** 	#else
1755:FreeRTOS/Source/tasks.c **** 	{
1756:FreeRTOS/Source/tasks.c **** 			/* Calculate the time at which the task should be woken if the event does
1757:FreeRTOS/Source/tasks.c **** 			not occur.  This may overflow but this doesn't matter. */
1758:FreeRTOS/Source/tasks.c **** 			xTimeToWake = xTickCount + xTicksToWait;
1759:FreeRTOS/Source/tasks.c **** 			prvAddCurrentTaskToDelayedList( xTimeToWake );
1760:FreeRTOS/Source/tasks.c **** 	}
1761:FreeRTOS/Source/tasks.c **** 	#endif
1762:FreeRTOS/Source/tasks.c **** }
1763:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1764:FreeRTOS/Source/tasks.c **** 
1765:FreeRTOS/Source/tasks.c **** #if configUSE_TIMERS == 1
1766:FreeRTOS/Source/tasks.c **** 
1767:FreeRTOS/Source/tasks.c **** 	void vTaskPlaceOnEventListRestricted( const xList * const pxEventList, portTickType xTicksToWait )
1768:FreeRTOS/Source/tasks.c **** 	{
1769:FreeRTOS/Source/tasks.c **** 	portTickType xTimeToWake;
1770:FreeRTOS/Source/tasks.c **** 
1771:FreeRTOS/Source/tasks.c **** 		configASSERT( pxEventList );
1772:FreeRTOS/Source/tasks.c **** 
1773:FreeRTOS/Source/tasks.c **** 		/* This function should not be called by application code hence the
1774:FreeRTOS/Source/tasks.c **** 		'Restricted' in its name.  It is not part of the public API.  It is
1775:FreeRTOS/Source/tasks.c **** 		designed for use by kernel code, and has special calling requirements -
1776:FreeRTOS/Source/tasks.c **** 		it should be called from a critical section. */
1777:FreeRTOS/Source/tasks.c **** 
1778:FreeRTOS/Source/tasks.c **** 	
1779:FreeRTOS/Source/tasks.c **** 		/* Place the event list item of the TCB in the appropriate event list.
1780:FreeRTOS/Source/tasks.c **** 		In this case it is assume that this is the only task that is going to
1781:FreeRTOS/Source/tasks.c **** 		be waiting on this event list, so the faster vListInsertEnd() function
1782:FreeRTOS/Source/tasks.c **** 		can be used in place of vListInsert. */
1783:FreeRTOS/Source/tasks.c **** 		vListInsertEnd( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
1784:FreeRTOS/Source/tasks.c **** 
1785:FreeRTOS/Source/tasks.c **** 		/* We must remove this task from the ready list before adding it to the
1786:FreeRTOS/Source/tasks.c **** 		blocked list as the same list item is used for both lists.  This
1787:FreeRTOS/Source/tasks.c **** 		function is called form a critical section. */
1788:FreeRTOS/Source/tasks.c **** 		vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
1789:FreeRTOS/Source/tasks.c **** 
1790:FreeRTOS/Source/tasks.c **** 		/* Calculate the time at which the task should be woken if the event does
1791:FreeRTOS/Source/tasks.c **** 		not occur.  This may overflow but this doesn't matter. */
1792:FreeRTOS/Source/tasks.c **** 		xTimeToWake = xTickCount + xTicksToWait;
1793:FreeRTOS/Source/tasks.c **** 		prvAddCurrentTaskToDelayedList( xTimeToWake );
1794:FreeRTOS/Source/tasks.c **** 	}
1795:FreeRTOS/Source/tasks.c **** 	
1796:FreeRTOS/Source/tasks.c **** #endif /* configUSE_TIMERS */
1797:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1798:FreeRTOS/Source/tasks.c **** 
1799:FreeRTOS/Source/tasks.c **** signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
1800:FreeRTOS/Source/tasks.c **** {
1801:FreeRTOS/Source/tasks.c **** tskTCB *pxUnblockedTCB;
1802:FreeRTOS/Source/tasks.c **** portBASE_TYPE xReturn;
1803:FreeRTOS/Source/tasks.c **** 
1804:FreeRTOS/Source/tasks.c **** 	/* THIS FUNCTION MUST BE CALLED WITH INTERRUPTS DISABLED OR THE
1805:FreeRTOS/Source/tasks.c **** 	SCHEDULER SUSPENDED.  It can also be called from within an ISR. */
1806:FreeRTOS/Source/tasks.c **** 
1807:FreeRTOS/Source/tasks.c **** 	/* The event list is sorted in priority order, so we can remove the
1808:FreeRTOS/Source/tasks.c **** 	first in the list, remove the TCB from the delayed list, and add
1809:FreeRTOS/Source/tasks.c **** 	it to the ready list.
1810:FreeRTOS/Source/tasks.c **** 
1811:FreeRTOS/Source/tasks.c **** 	If an event is for a queue that is locked then this function will never
1812:FreeRTOS/Source/tasks.c **** 	get called - the lock count on the queue will get modified instead.  This
1813:FreeRTOS/Source/tasks.c **** 	means we can always expect exclusive access to the event list here.
1814:FreeRTOS/Source/tasks.c **** 	
1815:FreeRTOS/Source/tasks.c **** 	This function assumes that a check has already been made to ensure that
1816:FreeRTOS/Source/tasks.c **** 	pxEventList is not empty. */
1817:FreeRTOS/Source/tasks.c **** 	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
1818:FreeRTOS/Source/tasks.c **** 	configASSERT( pxUnblockedTCB );
1819:FreeRTOS/Source/tasks.c **** 	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
1820:FreeRTOS/Source/tasks.c **** 
1821:FreeRTOS/Source/tasks.c **** 	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
1822:FreeRTOS/Source/tasks.c **** 	{
1823:FreeRTOS/Source/tasks.c **** 		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
1824:FreeRTOS/Source/tasks.c **** 		prvAddTaskToReadyQueue( pxUnblockedTCB );
1825:FreeRTOS/Source/tasks.c **** 	}
1826:FreeRTOS/Source/tasks.c **** 	else
1827:FreeRTOS/Source/tasks.c **** 	{
1828:FreeRTOS/Source/tasks.c **** 		/* We cannot access the delayed or ready lists, so will hold this
1829:FreeRTOS/Source/tasks.c **** 		task pending until the scheduler is resumed. */
1830:FreeRTOS/Source/tasks.c **** 		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
1831:FreeRTOS/Source/tasks.c **** 	}
1832:FreeRTOS/Source/tasks.c **** 
1833:FreeRTOS/Source/tasks.c **** 	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
1834:FreeRTOS/Source/tasks.c **** 	{
1835:FreeRTOS/Source/tasks.c **** 		/* Return true if the task removed from the event list has
1836:FreeRTOS/Source/tasks.c **** 		a higher priority than the calling task.  This allows
1837:FreeRTOS/Source/tasks.c **** 		the calling task to know if it should force a context
1838:FreeRTOS/Source/tasks.c **** 		switch now. */
1839:FreeRTOS/Source/tasks.c **** 		xReturn = pdTRUE;
1840:FreeRTOS/Source/tasks.c **** 	}
1841:FreeRTOS/Source/tasks.c **** 	else
1842:FreeRTOS/Source/tasks.c **** 	{
1843:FreeRTOS/Source/tasks.c **** 		xReturn = pdFALSE;
1844:FreeRTOS/Source/tasks.c **** 	}
1845:FreeRTOS/Source/tasks.c **** 
1846:FreeRTOS/Source/tasks.c **** 	return xReturn;
1847:FreeRTOS/Source/tasks.c **** }
1848:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1849:FreeRTOS/Source/tasks.c **** 
1850:FreeRTOS/Source/tasks.c **** void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
1851:FreeRTOS/Source/tasks.c **** {
1852:FreeRTOS/Source/tasks.c **** 	configASSERT( pxTimeOut );
1853:FreeRTOS/Source/tasks.c **** 	pxTimeOut->xOverflowCount = xNumOfOverflows;
1854:FreeRTOS/Source/tasks.c **** 	pxTimeOut->xTimeOnEntering = xTickCount;
1855:FreeRTOS/Source/tasks.c **** }
1856:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1857:FreeRTOS/Source/tasks.c **** 
1858:FreeRTOS/Source/tasks.c **** portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToW
1859:FreeRTOS/Source/tasks.c **** {
1860:FreeRTOS/Source/tasks.c **** portBASE_TYPE xReturn;
1861:FreeRTOS/Source/tasks.c **** 
1862:FreeRTOS/Source/tasks.c **** 	configASSERT( pxTimeOut );
1863:FreeRTOS/Source/tasks.c **** 	configASSERT( pxTicksToWait );
1864:FreeRTOS/Source/tasks.c **** 
1865:FreeRTOS/Source/tasks.c **** 	taskENTER_CRITICAL();
1866:FreeRTOS/Source/tasks.c **** 	{
1867:FreeRTOS/Source/tasks.c **** 		#if ( INCLUDE_vTaskSuspend == 1 )
1868:FreeRTOS/Source/tasks.c **** 			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
1869:FreeRTOS/Source/tasks.c **** 			the maximum block time then the task should block indefinitely, and
1870:FreeRTOS/Source/tasks.c **** 			therefore never time out. */
1871:FreeRTOS/Source/tasks.c **** 			if( *pxTicksToWait == portMAX_DELAY )
1872:FreeRTOS/Source/tasks.c **** 			{
1873:FreeRTOS/Source/tasks.c **** 				xReturn = pdFALSE;
1874:FreeRTOS/Source/tasks.c **** 			}
1875:FreeRTOS/Source/tasks.c **** 			else /* We are not blocking indefinitely, perform the checks below. */
1876:FreeRTOS/Source/tasks.c **** 		#endif
1877:FreeRTOS/Source/tasks.c **** 
1878:FreeRTOS/Source/tasks.c **** 		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTi
1879:FreeRTOS/Source/tasks.c **** 		{
1880:FreeRTOS/Source/tasks.c **** 			/* The tick count is greater than the time at which vTaskSetTimeout()
1881:FreeRTOS/Source/tasks.c **** 			was called, but has also overflowed since vTaskSetTimeOut() was called.
1882:FreeRTOS/Source/tasks.c **** 			It must have wrapped all the way around and gone past us again. This
1883:FreeRTOS/Source/tasks.c **** 			passed since vTaskSetTimeout() was called. */
1884:FreeRTOS/Source/tasks.c **** 			xReturn = pdTRUE;
1885:FreeRTOS/Source/tasks.c **** 		}
1886:FreeRTOS/Source/tasks.c **** 		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEn
1887:FreeRTOS/Source/tasks.c **** 		{
1888:FreeRTOS/Source/tasks.c **** 			/* Not a genuine timeout. Adjust parameters for time remaining. */
1889:FreeRTOS/Source/tasks.c **** 			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
1890:FreeRTOS/Source/tasks.c **** 			vTaskSetTimeOutState( pxTimeOut );
1891:FreeRTOS/Source/tasks.c **** 			xReturn = pdFALSE;
1892:FreeRTOS/Source/tasks.c **** 		}
1893:FreeRTOS/Source/tasks.c **** 		else
1894:FreeRTOS/Source/tasks.c **** 		{
1895:FreeRTOS/Source/tasks.c **** 			xReturn = pdTRUE;
1896:FreeRTOS/Source/tasks.c **** 		}
1897:FreeRTOS/Source/tasks.c **** 	}
1898:FreeRTOS/Source/tasks.c **** 	taskEXIT_CRITICAL();
1899:FreeRTOS/Source/tasks.c **** 
1900:FreeRTOS/Source/tasks.c **** 	return xReturn;
1901:FreeRTOS/Source/tasks.c **** }
1902:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
1903:FreeRTOS/Source/tasks.c **** 
1904:FreeRTOS/Source/tasks.c **** void vTaskMissedYield( void )
1905:FreeRTOS/Source/tasks.c **** {
1906:FreeRTOS/Source/tasks.c **** 	xMissedYield = pdTRUE;
1907:FreeRTOS/Source/tasks.c **** }
1908:FreeRTOS/Source/tasks.c **** 
1909:FreeRTOS/Source/tasks.c **** /*
1910:FreeRTOS/Source/tasks.c ****  * -----------------------------------------------------------
1911:FreeRTOS/Source/tasks.c ****  * The Idle task.
1912:FreeRTOS/Source/tasks.c ****  * ----------------------------------------------------------
1913:FreeRTOS/Source/tasks.c ****  *
1914:FreeRTOS/Source/tasks.c ****  * The portTASK_FUNCTION() macro is used to allow port/compiler specific
1915:FreeRTOS/Source/tasks.c ****  * language extensions.  The equivalent prototype for this function is:
1916:FreeRTOS/Source/tasks.c ****  *
1917:FreeRTOS/Source/tasks.c ****  * void prvIdleTask( void *pvParameters );
1918:FreeRTOS/Source/tasks.c ****  *
1919:FreeRTOS/Source/tasks.c ****  */
1920:FreeRTOS/Source/tasks.c **** static portTASK_FUNCTION( prvIdleTask, pvParameters )
1921:FreeRTOS/Source/tasks.c **** {
1922:FreeRTOS/Source/tasks.c **** 	/* Stop warnings. */
1923:FreeRTOS/Source/tasks.c **** 	( void ) pvParameters;
1924:FreeRTOS/Source/tasks.c **** 
1925:FreeRTOS/Source/tasks.c **** 	for( ;; )
1926:FreeRTOS/Source/tasks.c **** 	{
1927:FreeRTOS/Source/tasks.c **** 		/* See if any tasks have been deleted. */
1928:FreeRTOS/Source/tasks.c **** 		prvCheckTasksWaitingTermination();
1929:FreeRTOS/Source/tasks.c **** 
1930:FreeRTOS/Source/tasks.c **** 		#if ( configUSE_PREEMPTION == 0 )
1931:FreeRTOS/Source/tasks.c **** 		{
1932:FreeRTOS/Source/tasks.c **** 			/* If we are not using preemption we keep forcing a task switch to
1933:FreeRTOS/Source/tasks.c **** 			see if any other task has become available.  If we are using
1934:FreeRTOS/Source/tasks.c **** 			preemption we don't need to do this as any task becoming available
1935:FreeRTOS/Source/tasks.c **** 			will automatically get the processor anyway. */
1936:FreeRTOS/Source/tasks.c **** 			taskYIELD();
1937:FreeRTOS/Source/tasks.c **** 		}
1938:FreeRTOS/Source/tasks.c **** 		#endif
1939:FreeRTOS/Source/tasks.c **** 
1940:FreeRTOS/Source/tasks.c **** 		#if ( ( configUSE_PREEMPTION == 1 ) && ( configIDLE_SHOULD_YIELD == 1 ) )
1941:FreeRTOS/Source/tasks.c **** 		{
1942:FreeRTOS/Source/tasks.c **** 			/* When using preemption tasks of equal priority will be
1943:FreeRTOS/Source/tasks.c **** 			timesliced.  If a task that is sharing the idle priority is ready
1944:FreeRTOS/Source/tasks.c **** 			to run then the idle task should yield before the end of the
1945:FreeRTOS/Source/tasks.c **** 			timeslice.
1946:FreeRTOS/Source/tasks.c **** 
1947:FreeRTOS/Source/tasks.c **** 			A critical region is not required here as we are just reading from
1948:FreeRTOS/Source/tasks.c **** 			the list, and an occasional incorrect value will not matter.  If
1949:FreeRTOS/Source/tasks.c **** 			the ready list at the idle priority contains more than one task
1950:FreeRTOS/Source/tasks.c **** 			then a task other than the idle task is ready to execute. */
1951:FreeRTOS/Source/tasks.c **** 			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_
1952:FreeRTOS/Source/tasks.c **** 			{
1953:FreeRTOS/Source/tasks.c **** 				taskYIELD();
1954:FreeRTOS/Source/tasks.c **** 			}
1955:FreeRTOS/Source/tasks.c **** 		}
1956:FreeRTOS/Source/tasks.c **** 		#endif
1957:FreeRTOS/Source/tasks.c **** 
1958:FreeRTOS/Source/tasks.c **** 		#if ( configUSE_IDLE_HOOK == 1 )
1959:FreeRTOS/Source/tasks.c **** 		{
1960:FreeRTOS/Source/tasks.c **** 			extern void vApplicationIdleHook( void );
1961:FreeRTOS/Source/tasks.c **** 
1962:FreeRTOS/Source/tasks.c **** 			/* Call the user defined function from within the idle task.  This
1963:FreeRTOS/Source/tasks.c **** 			allows the application designer to add background functionality
1964:FreeRTOS/Source/tasks.c **** 			without the overhead of a separate task.
1965:FreeRTOS/Source/tasks.c **** 			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
1966:FreeRTOS/Source/tasks.c **** 			CALL A FUNCTION THAT MIGHT BLOCK. */
1967:FreeRTOS/Source/tasks.c **** 			vApplicationIdleHook();
1968:FreeRTOS/Source/tasks.c **** 		}
1969:FreeRTOS/Source/tasks.c **** 		#endif
1970:FreeRTOS/Source/tasks.c **** 	}
1971:FreeRTOS/Source/tasks.c **** } /*lint !e715 pvParameters is not accessed but all task functions require the same prototype. */
1972:FreeRTOS/Source/tasks.c **** 
1973:FreeRTOS/Source/tasks.c **** 
1974:FreeRTOS/Source/tasks.c **** 
1975:FreeRTOS/Source/tasks.c **** 
1976:FreeRTOS/Source/tasks.c **** 
1977:FreeRTOS/Source/tasks.c **** 
1978:FreeRTOS/Source/tasks.c **** 
1979:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------
1980:FreeRTOS/Source/tasks.c ****  * File private functions documented at the top of the file.
1981:FreeRTOS/Source/tasks.c ****  *----------------------------------------------------------*/
1982:FreeRTOS/Source/tasks.c **** 
1983:FreeRTOS/Source/tasks.c **** 
1984:FreeRTOS/Source/tasks.c **** 
1985:FreeRTOS/Source/tasks.c **** static void prvInitialiseTCBVariables( tskTCB *pxTCB, const signed char * const pcName, unsigned po
1986:FreeRTOS/Source/tasks.c **** {
1987:FreeRTOS/Source/tasks.c **** 	/* Store the function name in the TCB. */
1988:FreeRTOS/Source/tasks.c **** 	#if configMAX_TASK_NAME_LEN > 1
1989:FreeRTOS/Source/tasks.c **** 	{
1990:FreeRTOS/Source/tasks.c **** 		/* Don't bring strncpy into the build unnecessarily. */
1991:FreeRTOS/Source/tasks.c **** 		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK
1992:FreeRTOS/Source/tasks.c **** 	}
1993:FreeRTOS/Source/tasks.c **** 	#endif
1994:FreeRTOS/Source/tasks.c **** 	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed 
1995:FreeRTOS/Source/tasks.c **** 
1996:FreeRTOS/Source/tasks.c **** 	/* This is used as an array index so must ensure it's not too large.  First
1997:FreeRTOS/Source/tasks.c **** 	remove the privilege bit if one is present. */
1998:FreeRTOS/Source/tasks.c **** 	if( uxPriority >= configMAX_PRIORITIES )
1999:FreeRTOS/Source/tasks.c **** 	{
2000:FreeRTOS/Source/tasks.c **** 		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
2001:FreeRTOS/Source/tasks.c **** 	}
2002:FreeRTOS/Source/tasks.c **** 
2003:FreeRTOS/Source/tasks.c **** 	pxTCB->uxPriority = uxPriority;
2004:FreeRTOS/Source/tasks.c **** 	#if ( configUSE_MUTEXES == 1 )
2005:FreeRTOS/Source/tasks.c **** 	{
2006:FreeRTOS/Source/tasks.c **** 		pxTCB->uxBasePriority = uxPriority;
2007:FreeRTOS/Source/tasks.c **** 	}
2008:FreeRTOS/Source/tasks.c **** 	#endif
2009:FreeRTOS/Source/tasks.c **** 
2010:FreeRTOS/Source/tasks.c **** 	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
2011:FreeRTOS/Source/tasks.c **** 	vListInitialiseItem( &( pxTCB->xEventListItem ) );
2012:FreeRTOS/Source/tasks.c **** 
2013:FreeRTOS/Source/tasks.c **** 	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
2014:FreeRTOS/Source/tasks.c **** 	back to	the containing TCB from a generic item in a list. */
2015:FreeRTOS/Source/tasks.c **** 	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
2016:FreeRTOS/Source/tasks.c **** 
2017:FreeRTOS/Source/tasks.c **** 	/* Event lists are always in priority order. */
2018:FreeRTOS/Source/tasks.c **** 	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPri
2019:FreeRTOS/Source/tasks.c **** 	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
2020:FreeRTOS/Source/tasks.c **** 
2021:FreeRTOS/Source/tasks.c **** 	#if ( portCRITICAL_NESTING_IN_TCB == 1 )
2022:FreeRTOS/Source/tasks.c **** 	{
2023:FreeRTOS/Source/tasks.c **** 		pxTCB->uxCriticalNesting = ( unsigned portBASE_TYPE ) 0U;
2024:FreeRTOS/Source/tasks.c **** 	}
2025:FreeRTOS/Source/tasks.c **** 	#endif
2026:FreeRTOS/Source/tasks.c **** 
2027:FreeRTOS/Source/tasks.c **** 	#if ( configUSE_APPLICATION_TASK_TAG == 1 )
2028:FreeRTOS/Source/tasks.c **** 	{
2029:FreeRTOS/Source/tasks.c **** 		pxTCB->pxTaskTag = NULL;
2030:FreeRTOS/Source/tasks.c **** 	}
2031:FreeRTOS/Source/tasks.c **** 	#endif
2032:FreeRTOS/Source/tasks.c **** 
2033:FreeRTOS/Source/tasks.c **** 	#if ( configGENERATE_RUN_TIME_STATS == 1 )
2034:FreeRTOS/Source/tasks.c **** 	{
2035:FreeRTOS/Source/tasks.c **** 		pxTCB->ulRunTimeCounter = 0UL;
2036:FreeRTOS/Source/tasks.c **** 	}
2037:FreeRTOS/Source/tasks.c **** 	#endif
2038:FreeRTOS/Source/tasks.c **** 
2039:FreeRTOS/Source/tasks.c **** 	#if ( portUSING_MPU_WRAPPERS == 1 )
2040:FreeRTOS/Source/tasks.c **** 	{
2041:FreeRTOS/Source/tasks.c **** 		vPortStoreTaskMPUSettings( &( pxTCB->xMPUSettings ), xRegions, pxTCB->pxStack, usStackDepth );
2042:FreeRTOS/Source/tasks.c **** 	}
2043:FreeRTOS/Source/tasks.c **** 	#else
2044:FreeRTOS/Source/tasks.c **** 	{
2045:FreeRTOS/Source/tasks.c **** 		( void ) xRegions;
2046:FreeRTOS/Source/tasks.c **** 		( void ) usStackDepth;
2047:FreeRTOS/Source/tasks.c **** 	}
2048:FreeRTOS/Source/tasks.c **** 	#endif
2049:FreeRTOS/Source/tasks.c **** }
2050:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2051:FreeRTOS/Source/tasks.c **** 
2052:FreeRTOS/Source/tasks.c **** #if ( portUSING_MPU_WRAPPERS == 1 )
2053:FreeRTOS/Source/tasks.c **** 
2054:FreeRTOS/Source/tasks.c **** 	void vTaskAllocateMPURegions( xTaskHandle xTaskToModify, const xMemoryRegion * const xRegions )
2055:FreeRTOS/Source/tasks.c **** 	{
2056:FreeRTOS/Source/tasks.c **** 	tskTCB *pxTCB;
2057:FreeRTOS/Source/tasks.c **** 	
2058:FreeRTOS/Source/tasks.c **** 		if( xTaskToModify == pxCurrentTCB )
2059:FreeRTOS/Source/tasks.c **** 		{
2060:FreeRTOS/Source/tasks.c **** 			xTaskToModify = NULL;
2061:FreeRTOS/Source/tasks.c **** 		}
2062:FreeRTOS/Source/tasks.c **** 
2063:FreeRTOS/Source/tasks.c **** 		/* If null is passed in here then we are deleting ourselves. */
2064:FreeRTOS/Source/tasks.c **** 		pxTCB = prvGetTCBFromHandle( xTaskToModify );
2065:FreeRTOS/Source/tasks.c **** 
2066:FreeRTOS/Source/tasks.c ****         vPortStoreTaskMPUSettings( &( pxTCB->xMPUSettings ), xRegions, NULL, 0 );
2067:FreeRTOS/Source/tasks.c **** 	}
2068:FreeRTOS/Source/tasks.c **** 	/*-----------------------------------------------------------*/
2069:FreeRTOS/Source/tasks.c **** #endif
2070:FreeRTOS/Source/tasks.c **** 
2071:FreeRTOS/Source/tasks.c **** static void prvInitialiseTaskLists( void )
2072:FreeRTOS/Source/tasks.c **** {
2073:FreeRTOS/Source/tasks.c **** unsigned portBASE_TYPE uxPriority;
2074:FreeRTOS/Source/tasks.c **** 
2075:FreeRTOS/Source/tasks.c **** 	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
2076:FreeRTOS/Source/tasks.c **** 	{
2077:FreeRTOS/Source/tasks.c **** 		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
2078:FreeRTOS/Source/tasks.c **** 	}
2079:FreeRTOS/Source/tasks.c **** 
2080:FreeRTOS/Source/tasks.c **** 	vListInitialise( ( xList * ) &xDelayedTaskList1 );
2081:FreeRTOS/Source/tasks.c **** 	vListInitialise( ( xList * ) &xDelayedTaskList2 );
2082:FreeRTOS/Source/tasks.c **** 	vListInitialise( ( xList * ) &xPendingReadyList );
2083:FreeRTOS/Source/tasks.c **** 
2084:FreeRTOS/Source/tasks.c **** 	#if ( INCLUDE_vTaskDelete == 1 )
2085:FreeRTOS/Source/tasks.c **** 	{
2086:FreeRTOS/Source/tasks.c **** 		vListInitialise( ( xList * ) &xTasksWaitingTermination );
2087:FreeRTOS/Source/tasks.c **** 	}
2088:FreeRTOS/Source/tasks.c **** 	#endif
2089:FreeRTOS/Source/tasks.c **** 
2090:FreeRTOS/Source/tasks.c **** 	#if ( INCLUDE_vTaskSuspend == 1 )
2091:FreeRTOS/Source/tasks.c **** 	{
2092:FreeRTOS/Source/tasks.c **** 		vListInitialise( ( xList * ) &xSuspendedTaskList );
2093:FreeRTOS/Source/tasks.c **** 	}
2094:FreeRTOS/Source/tasks.c **** 	#endif
2095:FreeRTOS/Source/tasks.c **** 
2096:FreeRTOS/Source/tasks.c **** 	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
2097:FreeRTOS/Source/tasks.c **** 	using list2. */
2098:FreeRTOS/Source/tasks.c **** 	pxDelayedTaskList = &xDelayedTaskList1;
2099:FreeRTOS/Source/tasks.c **** 	pxOverflowDelayedTaskList = &xDelayedTaskList2;
2100:FreeRTOS/Source/tasks.c **** }
2101:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2102:FreeRTOS/Source/tasks.c **** 
2103:FreeRTOS/Source/tasks.c **** static void prvCheckTasksWaitingTermination( void )
2104:FreeRTOS/Source/tasks.c **** {
2105:FreeRTOS/Source/tasks.c **** 	#if ( INCLUDE_vTaskDelete == 1 )
2106:FreeRTOS/Source/tasks.c **** 	{
2107:FreeRTOS/Source/tasks.c **** 		portBASE_TYPE xListIsEmpty;
2108:FreeRTOS/Source/tasks.c **** 
2109:FreeRTOS/Source/tasks.c **** 		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
2110:FreeRTOS/Source/tasks.c **** 		too often in the idle task. */
2111:FreeRTOS/Source/tasks.c **** 		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0U )
2112:FreeRTOS/Source/tasks.c **** 		{
2113:FreeRTOS/Source/tasks.c **** 			vTaskSuspendAll();
2114:FreeRTOS/Source/tasks.c **** 				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
2115:FreeRTOS/Source/tasks.c **** 			xTaskResumeAll();
2116:FreeRTOS/Source/tasks.c **** 
2117:FreeRTOS/Source/tasks.c **** 			if( xListIsEmpty == pdFALSE )
2118:FreeRTOS/Source/tasks.c **** 			{
2119:FreeRTOS/Source/tasks.c **** 				tskTCB *pxTCB;
2120:FreeRTOS/Source/tasks.c **** 
2121:FreeRTOS/Source/tasks.c **** 				taskENTER_CRITICAL();
2122:FreeRTOS/Source/tasks.c **** 				{
2123:FreeRTOS/Source/tasks.c **** 					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
2124:FreeRTOS/Source/tasks.c **** 					vListRemove( &( pxTCB->xGenericListItem ) );
2125:FreeRTOS/Source/tasks.c **** 					--uxCurrentNumberOfTasks;
2126:FreeRTOS/Source/tasks.c **** 					--uxTasksDeleted;
2127:FreeRTOS/Source/tasks.c **** 				}
2128:FreeRTOS/Source/tasks.c **** 				taskEXIT_CRITICAL();
2129:FreeRTOS/Source/tasks.c **** 
2130:FreeRTOS/Source/tasks.c **** 				prvDeleteTCB( pxTCB );
2131:FreeRTOS/Source/tasks.c **** 			}
2132:FreeRTOS/Source/tasks.c **** 		}
2133:FreeRTOS/Source/tasks.c **** 	}
2134:FreeRTOS/Source/tasks.c **** 	#endif
2135:FreeRTOS/Source/tasks.c **** }
2136:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2137:FreeRTOS/Source/tasks.c **** 
2138:FreeRTOS/Source/tasks.c **** static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
2139:FreeRTOS/Source/tasks.c **** {
2140:FreeRTOS/Source/tasks.c **** 	/* The list item will be inserted in wake time order. */
2141:FreeRTOS/Source/tasks.c **** 	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
2142:FreeRTOS/Source/tasks.c **** 
2143:FreeRTOS/Source/tasks.c **** 	if( xTimeToWake < xTickCount )
2144:FreeRTOS/Source/tasks.c **** 	{
2145:FreeRTOS/Source/tasks.c **** 		/* Wake time has overflowed.  Place this item in the overflow list. */
2146:FreeRTOS/Source/tasks.c **** 		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericList
2147:FreeRTOS/Source/tasks.c **** 	}
2148:FreeRTOS/Source/tasks.c **** 	else
2149:FreeRTOS/Source/tasks.c **** 	{
2150:FreeRTOS/Source/tasks.c **** 		/* The wake time has not overflowed, so we can use the current block list. */
2151:FreeRTOS/Source/tasks.c **** 		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) )
2152:FreeRTOS/Source/tasks.c **** 
2153:FreeRTOS/Source/tasks.c **** 		/* If the task entering the blocked state was placed at the head of the
2154:FreeRTOS/Source/tasks.c **** 		list of blocked tasks then xNextTaskUnblockTime needs to be updated
2155:FreeRTOS/Source/tasks.c **** 		too. */
2156:FreeRTOS/Source/tasks.c **** 		if( xTimeToWake < xNextTaskUnblockTime )
2157:FreeRTOS/Source/tasks.c **** 		{
2158:FreeRTOS/Source/tasks.c **** 			xNextTaskUnblockTime = xTimeToWake;
2159:FreeRTOS/Source/tasks.c **** 		}
2160:FreeRTOS/Source/tasks.c **** 	}
2161:FreeRTOS/Source/tasks.c **** }
2162:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2163:FreeRTOS/Source/tasks.c **** 
2164:FreeRTOS/Source/tasks.c **** static tskTCB *prvAllocateTCBAndStack( unsigned short usStackDepth, portSTACK_TYPE *puxStackBuffer 
2165:FreeRTOS/Source/tasks.c **** {
2166:FreeRTOS/Source/tasks.c **** tskTCB *pxNewTCB;
2167:FreeRTOS/Source/tasks.c **** 
2168:FreeRTOS/Source/tasks.c **** 	/* Allocate space for the TCB.  Where the memory comes from depends on
2169:FreeRTOS/Source/tasks.c **** 	the implementation of the port malloc function. */
2170:FreeRTOS/Source/tasks.c **** 	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
2171:FreeRTOS/Source/tasks.c **** 
2172:FreeRTOS/Source/tasks.c **** 	if( pxNewTCB != NULL )
2173:FreeRTOS/Source/tasks.c **** 	{
2174:FreeRTOS/Source/tasks.c **** 		/* Allocate space for the stack used by the task being created.
2175:FreeRTOS/Source/tasks.c **** 		The base of the stack memory stored in the TCB so the task can
2176:FreeRTOS/Source/tasks.c **** 		be deleted later if required. */
2177:FreeRTOS/Source/tasks.c **** 		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * size
2178:FreeRTOS/Source/tasks.c **** 
2179:FreeRTOS/Source/tasks.c **** 		if( pxNewTCB->pxStack == NULL )
2180:FreeRTOS/Source/tasks.c **** 		{
2181:FreeRTOS/Source/tasks.c **** 			/* Could not allocate the stack.  Delete the allocated TCB. */
2182:FreeRTOS/Source/tasks.c **** 			vPortFree( pxNewTCB );
2183:FreeRTOS/Source/tasks.c **** 			pxNewTCB = NULL;
2184:FreeRTOS/Source/tasks.c **** 		}
2185:FreeRTOS/Source/tasks.c **** 		else
2186:FreeRTOS/Source/tasks.c **** 		{
2187:FreeRTOS/Source/tasks.c **** 			/* Just to help debugging. */
2188:FreeRTOS/Source/tasks.c **** 			memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) usStackDepth * sizeof( portSTA
2189:FreeRTOS/Source/tasks.c **** 		}
2190:FreeRTOS/Source/tasks.c **** 	}
2191:FreeRTOS/Source/tasks.c **** 
2192:FreeRTOS/Source/tasks.c **** 	return pxNewTCB;
2193:FreeRTOS/Source/tasks.c **** }
2194:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2195:FreeRTOS/Source/tasks.c **** 
2196:FreeRTOS/Source/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
2197:FreeRTOS/Source/tasks.c **** 
2198:FreeRTOS/Source/tasks.c **** 	static void prvListTaskWithinSingleList( const signed char *pcWriteBuffer, xList *pxList, signed c
2199:FreeRTOS/Source/tasks.c **** 	{
2200:FreeRTOS/Source/tasks.c **** 	volatile tskTCB *pxNextTCB, *pxFirstTCB;
2201:FreeRTOS/Source/tasks.c **** 	unsigned short usStackRemaining;
2202:FreeRTOS/Source/tasks.c **** 
2203:FreeRTOS/Source/tasks.c **** 		/* Write the details of all the TCB's in pxList into the buffer. */
2204:FreeRTOS/Source/tasks.c **** 		listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList );
2205:FreeRTOS/Source/tasks.c **** 		do
2206:FreeRTOS/Source/tasks.c **** 		{
2207:FreeRTOS/Source/tasks.c **** 			listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList );
2208:FreeRTOS/Source/tasks.c **** 			#if ( portSTACK_GROWTH > 0 )
2209:FreeRTOS/Source/tasks.c **** 			{
2210:FreeRTOS/Source/tasks.c **** 				usStackRemaining = usTaskCheckFreeStackSpace( ( unsigned char * ) pxNextTCB->pxEndOfStack );
2211:FreeRTOS/Source/tasks.c **** 			}
2212:FreeRTOS/Source/tasks.c **** 			#else
2213:FreeRTOS/Source/tasks.c **** 			{
2214:FreeRTOS/Source/tasks.c **** 				usStackRemaining = usTaskCheckFreeStackSpace( ( unsigned char * ) pxNextTCB->pxStack );
2215:FreeRTOS/Source/tasks.c **** 			}
2216:FreeRTOS/Source/tasks.c **** 			#endif			
2217:FreeRTOS/Source/tasks.c **** 			
2218:FreeRTOS/Source/tasks.c **** 			sprintf( pcStatusString, ( char * ) "%s\t\t%c\t%u\t%u\t%u\r\n", pxNextTCB->pcTaskName, cStatus, 
2219:FreeRTOS/Source/tasks.c **** 			strcat( ( char * ) pcWriteBuffer, ( char * ) pcStatusString );
2220:FreeRTOS/Source/tasks.c **** 
2221:FreeRTOS/Source/tasks.c **** 		} while( pxNextTCB != pxFirstTCB );
2222:FreeRTOS/Source/tasks.c **** 	}
2223:FreeRTOS/Source/tasks.c **** 
2224:FreeRTOS/Source/tasks.c **** #endif
2225:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2226:FreeRTOS/Source/tasks.c **** 
2227:FreeRTOS/Source/tasks.c **** #if ( configGENERATE_RUN_TIME_STATS == 1 )
2228:FreeRTOS/Source/tasks.c **** 
2229:FreeRTOS/Source/tasks.c **** 	static void prvGenerateRunTimeStatsForTasksInList( const signed char *pcWriteBuffer, xList *pxList
2230:FreeRTOS/Source/tasks.c **** 	{
2231:FreeRTOS/Source/tasks.c **** 	volatile tskTCB *pxNextTCB, *pxFirstTCB;
2232:FreeRTOS/Source/tasks.c **** 	unsigned long ulStatsAsPercentage;
2233:FreeRTOS/Source/tasks.c **** 
2234:FreeRTOS/Source/tasks.c **** 		/* Write the run time stats of all the TCB's in pxList into the buffer. */
2235:FreeRTOS/Source/tasks.c **** 		listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList );
2236:FreeRTOS/Source/tasks.c **** 		do
2237:FreeRTOS/Source/tasks.c **** 		{
2238:FreeRTOS/Source/tasks.c **** 			/* Get next TCB in from the list. */
2239:FreeRTOS/Source/tasks.c **** 			listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList );
2240:FreeRTOS/Source/tasks.c **** 
2241:FreeRTOS/Source/tasks.c **** 			/* Divide by zero check. */
2242:FreeRTOS/Source/tasks.c **** 			if( ulTotalRunTime > 0UL )
2243:FreeRTOS/Source/tasks.c **** 			{
2244:FreeRTOS/Source/tasks.c **** 				/* Has the task run at all? */
2245:FreeRTOS/Source/tasks.c **** 				if( pxNextTCB->ulRunTimeCounter == 0UL )
2246:FreeRTOS/Source/tasks.c **** 				{
2247:FreeRTOS/Source/tasks.c **** 					/* The task has used no CPU time at all. */
2248:FreeRTOS/Source/tasks.c **** 					sprintf( pcStatsString, ( char * ) "%u  %c  %-16s          0   0%%  %5u\r\n", (unsigned int) p
2249:FreeRTOS/Source/tasks.c **** 				}
2250:FreeRTOS/Source/tasks.c **** 				else
2251:FreeRTOS/Source/tasks.c **** 				{
2252:FreeRTOS/Source/tasks.c **** 					/* What percentage of the total run time has the task used?
2253:FreeRTOS/Source/tasks.c **** 					This will always be rounded down to the nearest integer.
2254:FreeRTOS/Source/tasks.c **** 					ulTotalRunTime has already been divided by 100. */
2255:FreeRTOS/Source/tasks.c **** 					ulStatsAsPercentage = pxNextTCB->ulRunTimeCounter / ulTotalRunTime;
2256:FreeRTOS/Source/tasks.c **** 
2257:FreeRTOS/Source/tasks.c **** 					if( ulStatsAsPercentage > 0UL )
2258:FreeRTOS/Source/tasks.c **** 					{
2259:FreeRTOS/Source/tasks.c **** 						#ifdef portLU_PRINTF_SPECIFIER_REQUIRED
2260:FreeRTOS/Source/tasks.c **** 						{
2261:FreeRTOS/Source/tasks.c **** 							sprintf( pcStatsString, ( char * ) "%s\t\t%lu\t\t%lu%%\r\n", pxNextTCB->pcTaskName, pxNextTC
2262:FreeRTOS/Source/tasks.c **** 						}
2263:FreeRTOS/Source/tasks.c **** 						#else
2264:FreeRTOS/Source/tasks.c **** 						{
2265:FreeRTOS/Source/tasks.c **** 							/* sizeof( int ) == sizeof( long ) so a smaller
2266:FreeRTOS/Source/tasks.c **** 							printf() library can be used. */
2267:FreeRTOS/Source/tasks.c **** 							sprintf( pcStatsString, ( char * ) "%u  %c  %-16s %10u %3u%%  %5u\r\n", (unsigned int) pxNex
2268:FreeRTOS/Source/tasks.c **** 						}
2269:FreeRTOS/Source/tasks.c **** 						#endif
2270:FreeRTOS/Source/tasks.c **** 					}
2271:FreeRTOS/Source/tasks.c **** 					else
2272:FreeRTOS/Source/tasks.c **** 					{
2273:FreeRTOS/Source/tasks.c **** 						/* If the percentage is zero here then the task has
2274:FreeRTOS/Source/tasks.c **** 						consumed less than 1% of the total run time. */
2275:FreeRTOS/Source/tasks.c **** 						#ifdef portLU_PRINTF_SPECIFIER_REQUIRED
2276:FreeRTOS/Source/tasks.c **** 						{
2277:FreeRTOS/Source/tasks.c **** 							sprintf( pcStatsString, ( char * ) "%s\t\t%lu\t\t<1%%\r\n", pxNextTCB->pcTaskName, pxNextTCB
2278:FreeRTOS/Source/tasks.c **** 						}
2279:FreeRTOS/Source/tasks.c **** 						#else
2280:FreeRTOS/Source/tasks.c **** 						{
2281:FreeRTOS/Source/tasks.c **** 							/* sizeof( int ) == sizeof( long ) so a smaller
2282:FreeRTOS/Source/tasks.c **** 							printf() library can be used. */
2283:FreeRTOS/Source/tasks.c **** 							sprintf( pcStatsString, ( char * ) "%u  %c  %-16s %10u  <1%%  %5u\r\n",  (unsigned int) pxNe
2284:FreeRTOS/Source/tasks.c **** 						}
2285:FreeRTOS/Source/tasks.c **** 						#endif
2286:FreeRTOS/Source/tasks.c **** 					}
2287:FreeRTOS/Source/tasks.c **** 				}
2288:FreeRTOS/Source/tasks.c **** 
2289:FreeRTOS/Source/tasks.c **** 				strcat( ( char * ) pcWriteBuffer, ( char * ) pcStatsString );
2290:FreeRTOS/Source/tasks.c **** 			}
2291:FreeRTOS/Source/tasks.c **** 
2292:FreeRTOS/Source/tasks.c **** 		} while( pxNextTCB != pxFirstTCB );
2293:FreeRTOS/Source/tasks.c **** 	}
2294:FreeRTOS/Source/tasks.c **** 
2295:FreeRTOS/Source/tasks.c **** #endif
2296:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2297:FreeRTOS/Source/tasks.c **** 
2298:FreeRTOS/Source/tasks.c **** #if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )
2299:FreeRTOS/Source/tasks.c **** 
2300:FreeRTOS/Source/tasks.c **** 	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
2301:FreeRTOS/Source/tasks.c **** 	{
  27              		.loc 1 2301 0
  28              		.cfi_startproc
  29              		@ args = 0, pretend = 0, frame = 0
  30              		@ frame_needed = 0, uses_anonymous_args = 0
  31              		@ link register save eliminated.
  32              	.LVL0:
2302:FreeRTOS/Source/tasks.c **** 	register unsigned short usCount = 0U;
  33              		.loc 1 2302 0
  34 0000 0023     		movs	r3, #0
2303:FreeRTOS/Source/tasks.c **** 
2304:FreeRTOS/Source/tasks.c **** 		while( *pucStackByte == tskSTACK_FILL_BYTE )
  35              		.loc 1 2304 0
  36 0002 02E0     		b	.L2
  37              	.LVL1:
  38              	.L3:
2305:FreeRTOS/Source/tasks.c **** 		{
2306:FreeRTOS/Source/tasks.c **** 			pucStackByte -= portSTACK_GROWTH;
  39              		.loc 1 2306 0
  40 0004 0130     		adds	r0, r0, #1
  41              	.LVL2:
2307:FreeRTOS/Source/tasks.c **** 			usCount++;
  42              		.loc 1 2307 0
  43 0006 0133     		adds	r3, r3, #1
  44              	.LVL3:
  45 0008 9BB2     		uxth	r3, r3
  46              	.LVL4:
  47              	.L2:
2304:FreeRTOS/Source/tasks.c **** 		{
  48              		.loc 1 2304 0 discriminator 1
  49 000a 0278     		ldrb	r2, [r0]	@ zero_extendqisi2
  50 000c A52A     		cmp	r2, #165
  51 000e F9D0     		beq	.L3
  52              	.LVL5:
2308:FreeRTOS/Source/tasks.c **** 		}
2309:FreeRTOS/Source/tasks.c **** 
2310:FreeRTOS/Source/tasks.c **** 		usCount /= sizeof( portSTACK_TYPE );
2311:FreeRTOS/Source/tasks.c **** 
2312:FreeRTOS/Source/tasks.c **** 		return usCount;
2313:FreeRTOS/Source/tasks.c **** 	}
  53              		.loc 1 2313 0
  54 0010 9808     		lsrs	r0, r3, #2
  55              	.LVL6:
  56 0012 7047     		bx	lr
  57              		.cfi_endproc
  58              	.LFE146:
  60              		.section	.text.prvDeleteTCB,"ax",%progbits
  61              		.align	2
  62              		.thumb
  63              		.thumb_func
  65              	prvDeleteTCB:
  66              	.LFB148:
2314:FreeRTOS/Source/tasks.c **** 
2315:FreeRTOS/Source/tasks.c **** #endif
2316:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2317:FreeRTOS/Source/tasks.c **** 
2318:FreeRTOS/Source/tasks.c **** #if ( INCLUDE_uxTaskGetStackHighWaterMark == 1 )
2319:FreeRTOS/Source/tasks.c **** 
2320:FreeRTOS/Source/tasks.c **** 	unsigned portBASE_TYPE uxTaskGetStackHighWaterMark( xTaskHandle xTask )
2321:FreeRTOS/Source/tasks.c **** 	{
2322:FreeRTOS/Source/tasks.c **** 	tskTCB *pxTCB;
2323:FreeRTOS/Source/tasks.c **** 	unsigned char *pcEndOfStack;
2324:FreeRTOS/Source/tasks.c **** 	unsigned portBASE_TYPE uxReturn;
2325:FreeRTOS/Source/tasks.c **** 
2326:FreeRTOS/Source/tasks.c **** 		pxTCB = prvGetTCBFromHandle( xTask );
2327:FreeRTOS/Source/tasks.c **** 
2328:FreeRTOS/Source/tasks.c **** 		#if portSTACK_GROWTH < 0
2329:FreeRTOS/Source/tasks.c **** 		{
2330:FreeRTOS/Source/tasks.c **** 			pcEndOfStack = ( unsigned char * ) pxTCB->pxStack;
2331:FreeRTOS/Source/tasks.c **** 		}
2332:FreeRTOS/Source/tasks.c **** 		#else
2333:FreeRTOS/Source/tasks.c **** 		{
2334:FreeRTOS/Source/tasks.c **** 			pcEndOfStack = ( unsigned char * ) pxTCB->pxEndOfStack;
2335:FreeRTOS/Source/tasks.c **** 		}
2336:FreeRTOS/Source/tasks.c **** 		#endif
2337:FreeRTOS/Source/tasks.c **** 
2338:FreeRTOS/Source/tasks.c **** 		uxReturn = ( unsigned portBASE_TYPE ) usTaskCheckFreeStackSpace( pcEndOfStack );
2339:FreeRTOS/Source/tasks.c **** 
2340:FreeRTOS/Source/tasks.c **** 		return uxReturn;
2341:FreeRTOS/Source/tasks.c **** 	}
2342:FreeRTOS/Source/tasks.c **** 
2343:FreeRTOS/Source/tasks.c **** #endif
2344:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2345:FreeRTOS/Source/tasks.c **** 
2346:FreeRTOS/Source/tasks.c **** #if ( INCLUDE_vTaskDelete == 1 )
2347:FreeRTOS/Source/tasks.c **** 
2348:FreeRTOS/Source/tasks.c **** 	static void prvDeleteTCB( tskTCB *pxTCB )
2349:FreeRTOS/Source/tasks.c **** 	{
  67              		.loc 1 2349 0
  68              		.cfi_startproc
  69              		@ args = 0, pretend = 0, frame = 0
  70              		@ frame_needed = 0, uses_anonymous_args = 0
  71              	.LVL7:
  72 0000 10B5     		push	{r4, lr}
  73              	.LCFI0:
  74              		.cfi_def_cfa_offset 8
  75              		.cfi_offset 4, -8
  76              		.cfi_offset 14, -4
  77 0002 0446     		mov	r4, r0
2350:FreeRTOS/Source/tasks.c **** 		/* Free up the memory allocated by the scheduler for the task.  It is up to
2351:FreeRTOS/Source/tasks.c **** 		the task to free any memory allocated at the application level. */
2352:FreeRTOS/Source/tasks.c **** 		vPortFreeAligned( pxTCB->pxStack );
  78              		.loc 1 2352 0
  79 0004 006B     		ldr	r0, [r0, #48]
  80              	.LVL8:
  81 0006 FFF7FEFF 		bl	free
  82              	.LVL9:
2353:FreeRTOS/Source/tasks.c **** 		vPortFree( pxTCB );
  83              		.loc 1 2353 0
  84 000a 2046     		mov	r0, r4
  85 000c FFF7FEFF 		bl	free
  86              	.LVL10:
  87 0010 10BD     		pop	{r4, pc}
  88              		.cfi_endproc
  89              	.LFE148:
  91 0012 00BF     		.section	.text.prvAllocateTCBAndStack,"ax",%progbits
  92              		.align	2
  93              		.thumb
  94              		.thumb_func
  96              	prvAllocateTCBAndStack:
  97              	.LFB144:
2165:FreeRTOS/Source/tasks.c **** tskTCB *pxNewTCB;
  98              		.loc 1 2165 0
  99              		.cfi_startproc
 100              		@ args = 0, pretend = 0, frame = 0
 101              		@ frame_needed = 0, uses_anonymous_args = 0
 102              	.LVL11:
 103 0000 70B5     		push	{r4, r5, r6, lr}
 104              	.LCFI1:
 105              		.cfi_def_cfa_offset 16
 106              		.cfi_offset 4, -16
 107              		.cfi_offset 5, -12
 108              		.cfi_offset 6, -8
 109              		.cfi_offset 14, -4
 110 0002 0646     		mov	r6, r0
 111 0004 0D46     		mov	r5, r1
2170:FreeRTOS/Source/tasks.c **** 
 112              		.loc 1 2170 0
 113 0006 5020     		movs	r0, #80
 114              	.LVL12:
 115 0008 FFF7FEFF 		bl	malloc
 116              	.LVL13:
2172:FreeRTOS/Source/tasks.c **** 	{
 117              		.loc 1 2172 0
 118 000c 0446     		mov	r4, r0
 119 000e 80B1     		cbz	r0, .L6
2177:FreeRTOS/Source/tasks.c **** 
 120              		.loc 1 2177 0
 121 0010 2846     		mov	r0, r5
 122              	.LVL14:
 123 0012 1DB9     		cbnz	r5, .L7
2177:FreeRTOS/Source/tasks.c **** 
 124              		.loc 1 2177 0 is_stmt 0 discriminator 1
 125 0014 B000     		lsls	r0, r6, #2
 126 0016 FFF7FEFF 		bl	malloc
 127              	.LVL15:
 128 001a FFE7     		b	.L7
 129              	.L7:
2177:FreeRTOS/Source/tasks.c **** 
 130              		.loc 1 2177 0 discriminator 3
 131 001c 2063     		str	r0, [r4, #48]
2179:FreeRTOS/Source/tasks.c **** 		{
 132              		.loc 1 2179 0 is_stmt 1 discriminator 3
 133 001e 20B9     		cbnz	r0, .L8
2182:FreeRTOS/Source/tasks.c **** 			pxNewTCB = NULL;
 134              		.loc 1 2182 0
 135 0020 2046     		mov	r0, r4
 136 0022 FFF7FEFF 		bl	free
 137              	.LVL16:
2183:FreeRTOS/Source/tasks.c **** 		}
 138              		.loc 1 2183 0
 139 0026 0024     		movs	r4, #0
 140 0028 03E0     		b	.L6
 141              	.LVL17:
 142              	.L8:
2188:FreeRTOS/Source/tasks.c **** 		}
 143              		.loc 1 2188 0
 144 002a A521     		movs	r1, #165
 145 002c B200     		lsls	r2, r6, #2
 146 002e FFF7FEFF 		bl	memset
 147              	.LVL18:
 148              	.L6:
2193:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 149              		.loc 1 2193 0
 150 0032 2046     		mov	r0, r4
 151 0034 70BD     		pop	{r4, r5, r6, pc}
 152              		.cfi_endproc
 153              	.LFE144:
 155 0036 00BF     		.section	.text.prvInitialiseTCBVariables,"ax",%progbits
 156              		.align	2
 157              		.thumb
 158              		.thumb_func
 160              	prvInitialiseTCBVariables:
 161              	.LFB140:
1986:FreeRTOS/Source/tasks.c **** 	/* Store the function name in the TCB. */
 162              		.loc 1 1986 0
 163              		.cfi_startproc
 164              		@ args = 4, pretend = 0, frame = 0
 165              		@ frame_needed = 0, uses_anonymous_args = 0
 166              	.LVL19:
 167 0000 38B5     		push	{r3, r4, r5, lr}
 168              	.LCFI2:
 169              		.cfi_def_cfa_offset 16
 170              		.cfi_offset 3, -16
 171              		.cfi_offset 4, -12
 172              		.cfi_offset 5, -8
 173              		.cfi_offset 14, -4
 174 0002 0446     		mov	r4, r0
 175 0004 1546     		mov	r5, r2
1991:FreeRTOS/Source/tasks.c **** 	}
 176              		.loc 1 1991 0
 177 0006 3430     		adds	r0, r0, #52
 178              	.LVL20:
 179 0008 1022     		movs	r2, #16
 180              	.LVL21:
 181 000a FFF7FEFF 		bl	strncpy
 182              	.LVL22:
1994:FreeRTOS/Source/tasks.c **** 
 183              		.loc 1 1994 0
 184 000e 0023     		movs	r3, #0
 185 0010 84F84330 		strb	r3, [r4, #67]
2000:FreeRTOS/Source/tasks.c **** 	}
 186              		.loc 1 2000 0
 187 0014 042D     		cmp	r5, #4
 188 0016 28BF     		it	cs
 189 0018 0425     		movcs	r5, #4
 190              	.LVL23:
2003:FreeRTOS/Source/tasks.c **** 	#if ( configUSE_MUTEXES == 1 )
 191              		.loc 1 2003 0
 192 001a E562     		str	r5, [r4, #44]
2006:FreeRTOS/Source/tasks.c **** 	}
 193              		.loc 1 2006 0
 194 001c 6564     		str	r5, [r4, #68]
2010:FreeRTOS/Source/tasks.c **** 	vListInitialiseItem( &( pxTCB->xEventListItem ) );
 195              		.loc 1 2010 0
 196 001e 201D     		adds	r0, r4, #4
 197 0020 FFF7FEFF 		bl	vListInitialiseItem
 198              	.LVL24:
2011:FreeRTOS/Source/tasks.c **** 
 199              		.loc 1 2011 0
 200 0024 04F11800 		add	r0, r4, #24
 201 0028 FFF7FEFF 		bl	vListInitialiseItem
 202              	.LVL25:
2015:FreeRTOS/Source/tasks.c **** 
 203              		.loc 1 2015 0
 204 002c 2461     		str	r4, [r4, #16]
2018:FreeRTOS/Source/tasks.c **** 	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
 205              		.loc 1 2018 0
 206 002e C5F10505 		rsb	r5, r5, #5
 207              	.LVL26:
 208 0032 A561     		str	r5, [r4, #24]
2019:FreeRTOS/Source/tasks.c **** 
 209              		.loc 1 2019 0
 210 0034 6462     		str	r4, [r4, #36]
2029:FreeRTOS/Source/tasks.c **** 	}
 211              		.loc 1 2029 0
 212 0036 0023     		movs	r3, #0
 213 0038 A364     		str	r3, [r4, #72]
2035:FreeRTOS/Source/tasks.c **** 	}
 214              		.loc 1 2035 0
 215 003a E364     		str	r3, [r4, #76]
 216 003c 38BD     		pop	{r3, r4, r5, pc}
 217              		.cfi_endproc
 218              	.LFE140:
 220 003e 00BF     		.section	.text.prvInitialiseTaskLists,"ax",%progbits
 221              		.align	2
 222              		.thumb
 223              		.thumb_func
 225              	prvInitialiseTaskLists:
 226              	.LFB141:
2072:FreeRTOS/Source/tasks.c **** unsigned portBASE_TYPE uxPriority;
 227              		.loc 1 2072 0
 228              		.cfi_startproc
 229              		@ args = 0, pretend = 0, frame = 0
 230              		@ frame_needed = 0, uses_anonymous_args = 0
 231 0000 38B5     		push	{r3, r4, r5, lr}
 232              	.LCFI3:
 233              		.cfi_def_cfa_offset 16
 234              		.cfi_offset 3, -16
 235              		.cfi_offset 4, -12
 236              		.cfi_offset 5, -8
 237              		.cfi_offset 14, -4
 238              	.LVL27:
2075:FreeRTOS/Source/tasks.c **** 	{
 239              		.loc 1 2075 0
 240 0002 0024     		movs	r4, #0
2077:FreeRTOS/Source/tasks.c **** 	}
 241              		.loc 1 2077 0
 242 0004 40F20005 		movw	r5, #:lower16:.LANCHOR0
 243 0008 C0F20005 		movt	r5, #:upper16:.LANCHOR0
2075:FreeRTOS/Source/tasks.c **** 	{
 244              		.loc 1 2075 0
 245 000c 06E0     		b	.L14
 246              	.LVL28:
 247              	.L15:
2077:FreeRTOS/Source/tasks.c **** 	}
 248              		.loc 1 2077 0 discriminator 2
 249 000e 04EB8400 		add	r0, r4, r4, lsl #2
 250 0012 05EB8000 		add	r0, r5, r0, lsl #2
 251 0016 FFF7FEFF 		bl	vListInitialise
 252              	.LVL29:
2075:FreeRTOS/Source/tasks.c **** 	{
 253              		.loc 1 2075 0 discriminator 2
 254 001a 0134     		adds	r4, r4, #1
 255              	.LVL30:
 256              	.L14:
2075:FreeRTOS/Source/tasks.c **** 	{
 257              		.loc 1 2075 0 is_stmt 0 discriminator 1
 258 001c 042C     		cmp	r4, #4
 259 001e F6D9     		bls	.L15
2080:FreeRTOS/Source/tasks.c **** 	vListInitialise( ( xList * ) &xDelayedTaskList2 );
 260              		.loc 1 2080 0 is_stmt 1
 261 0020 40F20005 		movw	r5, #:lower16:.LANCHOR1
 262 0024 C0F20005 		movt	r5, #:upper16:.LANCHOR1
 263 0028 2846     		mov	r0, r5
 264 002a FFF7FEFF 		bl	vListInitialise
 265              	.LVL31:
2081:FreeRTOS/Source/tasks.c **** 	vListInitialise( ( xList * ) &xPendingReadyList );
 266              		.loc 1 2081 0
 267 002e 40F20004 		movw	r4, #:lower16:.LANCHOR2
 268              	.LVL32:
 269 0032 C0F20004 		movt	r4, #:upper16:.LANCHOR2
 270 0036 2046     		mov	r0, r4
 271 0038 FFF7FEFF 		bl	vListInitialise
 272              	.LVL33:
2082:FreeRTOS/Source/tasks.c **** 
 273              		.loc 1 2082 0
 274 003c 40F20000 		movw	r0, #:lower16:.LANCHOR3
 275 0040 C0F20000 		movt	r0, #:upper16:.LANCHOR3
 276 0044 FFF7FEFF 		bl	vListInitialise
 277              	.LVL34:
2086:FreeRTOS/Source/tasks.c **** 	}
 278              		.loc 1 2086 0
 279 0048 40F20000 		movw	r0, #:lower16:.LANCHOR4
 280 004c C0F20000 		movt	r0, #:upper16:.LANCHOR4
 281 0050 FFF7FEFF 		bl	vListInitialise
 282              	.LVL35:
2092:FreeRTOS/Source/tasks.c **** 	}
 283              		.loc 1 2092 0
 284 0054 40F20000 		movw	r0, #:lower16:.LANCHOR5
 285 0058 C0F20000 		movt	r0, #:upper16:.LANCHOR5
 286 005c FFF7FEFF 		bl	vListInitialise
 287              	.LVL36:
2098:FreeRTOS/Source/tasks.c **** 	pxOverflowDelayedTaskList = &xDelayedTaskList2;
 288              		.loc 1 2098 0
 289 0060 40F20003 		movw	r3, #:lower16:.LANCHOR6
 290 0064 C0F20003 		movt	r3, #:upper16:.LANCHOR6
 291 0068 1D60     		str	r5, [r3]
2099:FreeRTOS/Source/tasks.c **** }
 292              		.loc 1 2099 0
 293 006a 40F20003 		movw	r3, #:lower16:.LANCHOR7
 294 006e C0F20003 		movt	r3, #:upper16:.LANCHOR7
 295 0072 1C60     		str	r4, [r3]
 296 0074 38BD     		pop	{r3, r4, r5, pc}
 297              		.cfi_endproc
 298              	.LFE141:
 300 0076 00BF     		.section	.text.prvAddCurrentTaskToDelayedList,"ax",%progbits
 301              		.align	2
 302              		.thumb
 303              		.thumb_func
 305              	prvAddCurrentTaskToDelayedList:
 306              	.LFB143:
2139:FreeRTOS/Source/tasks.c **** 	/* The list item will be inserted in wake time order. */
 307              		.loc 1 2139 0
 308              		.cfi_startproc
 309              		@ args = 0, pretend = 0, frame = 0
 310              		@ frame_needed = 0, uses_anonymous_args = 0
 311              	.LVL37:
 312 0000 10B5     		push	{r4, lr}
 313              	.LCFI4:
 314              		.cfi_def_cfa_offset 8
 315              		.cfi_offset 4, -8
 316              		.cfi_offset 14, -4
 317 0002 0446     		mov	r4, r0
2141:FreeRTOS/Source/tasks.c **** 
 318              		.loc 1 2141 0
 319 0004 40F20003 		movw	r3, #:lower16:.LANCHOR8
 320 0008 C0F20003 		movt	r3, #:upper16:.LANCHOR8
 321 000c 1B68     		ldr	r3, [r3]
 322 000e 5860     		str	r0, [r3, #4]
2143:FreeRTOS/Source/tasks.c **** 	{
 323              		.loc 1 2143 0
 324 0010 40F20003 		movw	r3, #:lower16:.LANCHOR9
 325 0014 C0F20003 		movt	r3, #:upper16:.LANCHOR9
 326 0018 1B68     		ldr	r3, [r3]
 327 001a 9842     		cmp	r0, r3
 328 001c 0DD2     		bcs	.L17
2146:FreeRTOS/Source/tasks.c **** 	}
 329              		.loc 1 2146 0
 330 001e 40F20003 		movw	r3, #:lower16:.LANCHOR7
 331 0022 C0F20003 		movt	r3, #:upper16:.LANCHOR7
 332 0026 1868     		ldr	r0, [r3]
 333              	.LVL38:
 334 0028 40F20003 		movw	r3, #:lower16:.LANCHOR8
 335 002c C0F20003 		movt	r3, #:upper16:.LANCHOR8
 336 0030 1968     		ldr	r1, [r3]
 337 0032 0431     		adds	r1, r1, #4
 338 0034 FFF7FEFF 		bl	vListInsert
 339              	.LVL39:
 340 0038 10BD     		pop	{r4, pc}
 341              	.LVL40:
 342              	.L17:
2151:FreeRTOS/Source/tasks.c **** 
 343              		.loc 1 2151 0
 344 003a 40F20003 		movw	r3, #:lower16:.LANCHOR6
 345 003e C0F20003 		movt	r3, #:upper16:.LANCHOR6
 346 0042 1868     		ldr	r0, [r3]
 347              	.LVL41:
 348 0044 40F20003 		movw	r3, #:lower16:.LANCHOR8
 349 0048 C0F20003 		movt	r3, #:upper16:.LANCHOR8
 350 004c 1968     		ldr	r1, [r3]
 351 004e 0431     		adds	r1, r1, #4
 352 0050 FFF7FEFF 		bl	vListInsert
 353              	.LVL42:
2156:FreeRTOS/Source/tasks.c **** 		{
 354              		.loc 1 2156 0
 355 0054 40F20003 		movw	r3, #:lower16:.LANCHOR10
 356 0058 C0F20003 		movt	r3, #:upper16:.LANCHOR10
 357 005c 1B68     		ldr	r3, [r3]
 358 005e 9C42     		cmp	r4, r3
2158:FreeRTOS/Source/tasks.c **** 		}
 359              		.loc 1 2158 0
 360 0060 3EBF     		ittt	cc
 361 0062 40F20003 		movwcc	r3, #:lower16:.LANCHOR10
 362 0066 C0F20003 		movtcc	r3, #:upper16:.LANCHOR10
 363 006a 1C60     		strcc	r4, [r3]
 364 006c 10BD     		pop	{r4, pc}
 365              		.cfi_endproc
 366              	.LFE143:
 368 006e 00BF     		.section	.text.prvGenerateRunTimeStatsForTasksInList,"ax",%progbits
 369              		.align	2
 370              		.thumb
 371              		.thumb_func
 373              	prvGenerateRunTimeStatsForTasksInList:
 374              	.LFB145:
2230:FreeRTOS/Source/tasks.c **** 	volatile tskTCB *pxNextTCB, *pxFirstTCB;
 375              		.loc 1 2230 0
 376              		.cfi_startproc
 377              		@ args = 0, pretend = 0, frame = 32
 378              		@ frame_needed = 0, uses_anonymous_args = 0
 379              	.LVL43:
 380 0000 2DE9F04F 		push	{r4, r5, r6, r7, r8, r9, r10, fp, lr}
 381              	.LCFI5:
 382              		.cfi_def_cfa_offset 36
 383              		.cfi_offset 4, -36
 384              		.cfi_offset 5, -32
 385              		.cfi_offset 6, -28
 386              		.cfi_offset 7, -24
 387              		.cfi_offset 8, -20
 388              		.cfi_offset 9, -16
 389              		.cfi_offset 10, -12
 390              		.cfi_offset 11, -8
 391              		.cfi_offset 14, -4
 392 0004 8DB0     		sub	sp, sp, #52
 393              	.LCFI6:
 394              		.cfi_def_cfa_offset 88
 395 0006 0690     		str	r0, [sp, #24]
 396 0008 0D46     		mov	r5, r1
 397 000a 1646     		mov	r6, r2
 398 000c 0793     		str	r3, [sp, #28]
 399              	.LVL44:
 400              	.LBB2:
2235:FreeRTOS/Source/tasks.c **** 		do
 401              		.loc 1 2235 0
 402 000e 4B68     		ldr	r3, [r1, #4]
 403              	.LVL45:
 404 0010 5B68     		ldr	r3, [r3, #4]
 405 0012 4B60     		str	r3, [r1, #4]
 406 0014 01F1080A 		add	r10, r1, #8
 407 0018 5345     		cmp	r3, r10
 408 001a 04BF     		itt	eq
 409 001c 5B68     		ldreq	r3, [r3, #4]
 410 001e 4B60     		streq	r3, [r1, #4]
 411 0020 4B68     		ldr	r3, [r1, #4]
 412 0022 D3F80CB0 		ldr	fp, [r3, #12]
 413              	.LVL46:
 414              	.LBE2:
2289:FreeRTOS/Source/tasks.c **** 			}
 415              		.loc 1 2289 0
 416 0026 40F20007 		movw	r7, #:lower16:.LANCHOR11
 417 002a C0F20007 		movt	r7, #:upper16:.LANCHOR11
2283:FreeRTOS/Source/tasks.c **** 						}
 418              		.loc 1 2283 0
 419 002e 40F20003 		movw	r3, #:lower16:.LC2
 420 0032 C0F20003 		movt	r3, #:upper16:.LC2
 421 0036 0893     		str	r3, [sp, #32]
2267:FreeRTOS/Source/tasks.c **** 						}
 422              		.loc 1 2267 0
 423 0038 40F20003 		movw	r3, #:lower16:.LC1
 424 003c C0F20003 		movt	r3, #:upper16:.LC1
 425 0040 0993     		str	r3, [sp, #36]
2248:FreeRTOS/Source/tasks.c **** 				}
 426              		.loc 1 2248 0
 427 0042 40F20003 		movw	r3, #:lower16:.LC0
 428 0046 C0F20003 		movt	r3, #:upper16:.LC0
 429 004a 0A93     		str	r3, [sp, #40]
 430              	.LVL47:
 431              	.L26:
 432              	.LBB3:
2239:FreeRTOS/Source/tasks.c **** 
 433              		.loc 1 2239 0
 434 004c 6B68     		ldr	r3, [r5, #4]
 435 004e 5B68     		ldr	r3, [r3, #4]
 436 0050 6B60     		str	r3, [r5, #4]
 437 0052 9A45     		cmp	r10, r3
 438 0054 04BF     		itt	eq
 439 0056 5B68     		ldreq	r3, [r3, #4]
 440 0058 6B60     		streq	r3, [r5, #4]
 441 005a 6B68     		ldr	r3, [r5, #4]
 442 005c DC68     		ldr	r4, [r3, #12]
 443              	.LVL48:
 444              	.LBE3:
2242:FreeRTOS/Source/tasks.c **** 			{
 445              		.loc 1 2242 0
 446 005e 002E     		cmp	r6, #0
 447 0060 47D0     		beq	.L22
2245:FreeRTOS/Source/tasks.c **** 				{
 448              		.loc 1 2245 0
 449 0062 E36C     		ldr	r3, [r4, #76]
 450 0064 83B9     		cbnz	r3, .L23
2248:FreeRTOS/Source/tasks.c **** 				}
 451              		.loc 1 2248 0
 452 0066 D4F82C80 		ldr	r8, [r4, #44]
 453 006a 04F13409 		add	r9, r4, #52
 454 006e 206B     		ldr	r0, [r4, #48]
 455 0070 FFF7FEFF 		bl	usTaskCheckFreeStackSpace
 456              	.LVL49:
 457 0074 CDF80090 		str	r9, [sp]
 458 0078 0190     		str	r0, [sp, #4]
 459 007a 3846     		mov	r0, r7
 460 007c 0A99     		ldr	r1, [sp, #40]
 461 007e 4246     		mov	r2, r8
 462 0080 079B     		ldr	r3, [sp, #28]
 463 0082 FFF7FEFF 		bl	sprintf
 464              	.LVL50:
 465 0086 30E0     		b	.L24
 466              	.L23:
2255:FreeRTOS/Source/tasks.c **** 
 467              		.loc 1 2255 0
 468 0088 E36C     		ldr	r3, [r4, #76]
 469 008a B3FBF6F8 		udiv	r8, r3, r6
 470              	.LVL51:
2257:FreeRTOS/Source/tasks.c **** 					{
 471              		.loc 1 2257 0
 472 008e B8F1000F 		cmp	r8, #0
 473 0092 16D0     		beq	.L25
2267:FreeRTOS/Source/tasks.c **** 						}
 474              		.loc 1 2267 0
 475 0094 E36A     		ldr	r3, [r4, #44]
 476 0096 0593     		str	r3, [sp, #20]
 477 0098 04F13409 		add	r9, r4, #52
 478 009c E36C     		ldr	r3, [r4, #76]
 479 009e 0B93     		str	r3, [sp, #44]
 480 00a0 206B     		ldr	r0, [r4, #48]
 481 00a2 FFF7FEFF 		bl	usTaskCheckFreeStackSpace
 482              	.LVL52:
 483 00a6 CDF80090 		str	r9, [sp]
 484 00aa 0B9B     		ldr	r3, [sp, #44]
 485 00ac 0193     		str	r3, [sp, #4]
 486 00ae CDF80880 		str	r8, [sp, #8]
 487 00b2 0390     		str	r0, [sp, #12]
 488 00b4 3846     		mov	r0, r7
 489 00b6 0999     		ldr	r1, [sp, #36]
 490 00b8 059A     		ldr	r2, [sp, #20]
 491 00ba 079B     		ldr	r3, [sp, #28]
 492 00bc FFF7FEFF 		bl	sprintf
 493              	.LVL53:
 494 00c0 13E0     		b	.L24
 495              	.L25:
2283:FreeRTOS/Source/tasks.c **** 						}
 496              		.loc 1 2283 0
 497 00c2 D4F82C80 		ldr	r8, [r4, #44]
 498              	.LVL54:
 499 00c6 04F13409 		add	r9, r4, #52
 500 00ca E36C     		ldr	r3, [r4, #76]
 501              	.LVL55:
 502 00cc 0593     		str	r3, [sp, #20]
 503 00ce 206B     		ldr	r0, [r4, #48]
 504 00d0 FFF7FEFF 		bl	usTaskCheckFreeStackSpace
 505              	.LVL56:
 506 00d4 CDF80090 		str	r9, [sp]
 507 00d8 059B     		ldr	r3, [sp, #20]
 508 00da 0193     		str	r3, [sp, #4]
 509 00dc 0290     		str	r0, [sp, #8]
 510 00de 3846     		mov	r0, r7
 511 00e0 0899     		ldr	r1, [sp, #32]
 512 00e2 4246     		mov	r2, r8
 513 00e4 079B     		ldr	r3, [sp, #28]
 514 00e6 FFF7FEFF 		bl	sprintf
 515              	.LVL57:
 516              	.L24:
2289:FreeRTOS/Source/tasks.c **** 			}
 517              		.loc 1 2289 0
 518 00ea 0698     		ldr	r0, [sp, #24]
 519 00ec 3946     		mov	r1, r7
 520 00ee FFF7FEFF 		bl	strcat
 521              	.LVL58:
 522              	.L22:
2292:FreeRTOS/Source/tasks.c **** 	}
 523              		.loc 1 2292 0
 524 00f2 5C45     		cmp	r4, fp
 525 00f4 AAD1     		bne	.L26
2293:FreeRTOS/Source/tasks.c **** 
 526              		.loc 1 2293 0
 527 00f6 0DB0     		add	sp, sp, #52
 528              		@ sp needed
 529 00f8 BDE8F08F 		pop	{r4, r5, r6, r7, r8, r9, r10, fp, pc}
 530              		.cfi_endproc
 531              	.LFE145:
 533              		.section	.text.xTaskGenericCreate,"ax",%progbits
 534              		.align	2
 535              		.global	xTaskGenericCreate
 536              		.thumb
 537              		.thumb_func
 539              	xTaskGenericCreate:
 540              	.LFB110:
 434:FreeRTOS/Source/tasks.c **** signed portBASE_TYPE xReturn;
 541              		.loc 1 434 0
 542              		.cfi_startproc
 543              		@ args = 16, pretend = 0, frame = 0
 544              		@ frame_needed = 0, uses_anonymous_args = 0
 545              	.LVL59:
 546 0000 2DE9F04F 		push	{r4, r5, r6, r7, r8, r9, r10, fp, lr}
 547              	.LCFI7:
 548              		.cfi_def_cfa_offset 36
 549              		.cfi_offset 4, -36
 550              		.cfi_offset 5, -32
 551              		.cfi_offset 6, -28
 552              		.cfi_offset 7, -24
 553              		.cfi_offset 8, -20
 554              		.cfi_offset 9, -16
 555              		.cfi_offset 10, -12
 556              		.cfi_offset 11, -8
 557              		.cfi_offset 14, -4
 558 0004 83B0     		sub	sp, sp, #12
 559              	.LCFI8:
 560              		.cfi_def_cfa_offset 48
 561 0006 8246     		mov	r10, r0
 562 0008 8B46     		mov	fp, r1
 563 000a 1546     		mov	r5, r2
 564 000c 9946     		mov	r9, r3
 565 000e 0C9E     		ldr	r6, [sp, #48]
 566 0010 DDF83480 		ldr	r8, [sp, #52]
 443:FreeRTOS/Source/tasks.c **** 
 567              		.loc 1 443 0
 568 0014 1046     		mov	r0, r2
 569              	.LVL60:
 570 0016 0E99     		ldr	r1, [sp, #56]
 571              	.LVL61:
 572 0018 FFF7FEFF 		bl	prvAllocateTCBAndStack
 573              	.LVL62:
 445:FreeRTOS/Source/tasks.c **** 	{
 574              		.loc 1 445 0
 575 001c 0446     		mov	r4, r0
 576 001e 0028     		cmp	r0, #0
 577 0020 77D0     		beq	.L36
 578              	.LBB4:
 469:FreeRTOS/Source/tasks.c **** 			pxTopOfStack = ( portSTACK_TYPE * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ( portPOINT
 579              		.loc 1 469 0
 580 0022 036B     		ldr	r3, [r0, #48]
 581 0024 05F18047 		add	r7, r5, #1073741824
 582 0028 013F     		subs	r7, r7, #1
 583 002a 03EB8707 		add	r7, r3, r7, lsl #2
 584              	.LVL63:
 470:FreeRTOS/Source/tasks.c **** 
 585              		.loc 1 470 0
 586 002e 27F00707 		bic	r7, r7, #7
 587              	.LVL64:
 490:FreeRTOS/Source/tasks.c **** 
 588              		.loc 1 490 0
 589 0032 0095     		str	r5, [sp]
 590 0034 5946     		mov	r1, fp
 591 0036 3246     		mov	r2, r6
 592 0038 0F9B     		ldr	r3, [sp, #60]
 593 003a FFF7FEFF 		bl	prvInitialiseTCBVariables
 594              	.LVL65:
 502:FreeRTOS/Source/tasks.c **** 		}
 595              		.loc 1 502 0
 596 003e 3846     		mov	r0, r7
 597 0040 5146     		mov	r1, r10
 598 0042 4A46     		mov	r2, r9
 599 0044 FFF7FEFF 		bl	pxPortInitialiseStack
 600              	.LVL66:
 601 0048 2060     		str	r0, [r4]
 509:FreeRTOS/Source/tasks.c **** 		{
 602              		.loc 1 509 0
 603 004a B8F1000F 		cmp	r8, #0
 604 004e 01D0     		beq	.L30
 514:FreeRTOS/Source/tasks.c **** 		}
 605              		.loc 1 514 0
 606 0050 C8F80040 		str	r4, [r8]
 607              	.L30:
 519:FreeRTOS/Source/tasks.c **** 		{
 608              		.loc 1 519 0
 609 0054 FFF7FEFF 		bl	vPortEnterCritical
 610              	.LVL67:
 521:FreeRTOS/Source/tasks.c **** 			if( pxCurrentTCB == NULL )
 611              		.loc 1 521 0
 612 0058 40F20003 		movw	r3, #:lower16:.LANCHOR12
 613 005c C0F20003 		movt	r3, #:upper16:.LANCHOR12
 614 0060 1A68     		ldr	r2, [r3]
 615 0062 0132     		adds	r2, r2, #1
 616 0064 1A60     		str	r2, [r3]
 522:FreeRTOS/Source/tasks.c **** 			{
 617              		.loc 1 522 0
 618 0066 40F20003 		movw	r3, #:lower16:.LANCHOR8
 619 006a C0F20003 		movt	r3, #:upper16:.LANCHOR8
 620 006e 1B68     		ldr	r3, [r3]
 621 0070 73B9     		cbnz	r3, .L31
 526:FreeRTOS/Source/tasks.c **** 
 622              		.loc 1 526 0
 623 0072 40F20003 		movw	r3, #:lower16:.LANCHOR8
 624 0076 C0F20003 		movt	r3, #:upper16:.LANCHOR8
 625 007a 1C60     		str	r4, [r3]
 528:FreeRTOS/Source/tasks.c **** 				{
 626              		.loc 1 528 0
 627 007c 40F20003 		movw	r3, #:lower16:.LANCHOR12
 628 0080 C0F20003 		movt	r3, #:upper16:.LANCHOR12
 629 0084 1B68     		ldr	r3, [r3]
 630 0086 012B     		cmp	r3, #1
 631 0088 15D1     		bne	.L32
 533:FreeRTOS/Source/tasks.c **** 				}
 632              		.loc 1 533 0
 633 008a FFF7FEFF 		bl	prvInitialiseTaskLists
 634              	.LVL68:
 635 008e 12E0     		b	.L32
 636              	.L31:
 541:FreeRTOS/Source/tasks.c **** 				{
 637              		.loc 1 541 0
 638 0090 40F20003 		movw	r3, #:lower16:.LANCHOR13
 639 0094 C0F20003 		movt	r3, #:upper16:.LANCHOR13
 640 0098 1B68     		ldr	r3, [r3]
 641 009a 63B9     		cbnz	r3, .L32
 543:FreeRTOS/Source/tasks.c **** 					{
 642              		.loc 1 543 0
 643 009c 40F20003 		movw	r3, #:lower16:.LANCHOR8
 644 00a0 C0F20003 		movt	r3, #:upper16:.LANCHOR8
 645 00a4 1B68     		ldr	r3, [r3]
 646 00a6 DB6A     		ldr	r3, [r3, #44]
 647 00a8 B342     		cmp	r3, r6
 545:FreeRTOS/Source/tasks.c **** 					}
 648              		.loc 1 545 0
 649 00aa 9EBF     		ittt	ls
 650 00ac 40F20003 		movwls	r3, #:lower16:.LANCHOR8
 651 00b0 C0F20003 		movtls	r3, #:upper16:.LANCHOR8
 652 00b4 1C60     		strls	r4, [r3]
 653              	.L32:
 552:FreeRTOS/Source/tasks.c **** 			{
 654              		.loc 1 552 0
 655 00b6 E36A     		ldr	r3, [r4, #44]
 656 00b8 40F20002 		movw	r2, #:lower16:.LANCHOR14
 657 00bc C0F20002 		movt	r2, #:upper16:.LANCHOR14
 658 00c0 1268     		ldr	r2, [r2]
 659 00c2 9342     		cmp	r3, r2
 554:FreeRTOS/Source/tasks.c **** 			}
 660              		.loc 1 554 0
 661 00c4 82BF     		ittt	hi
 662 00c6 40F20002 		movwhi	r2, #:lower16:.LANCHOR14
 663 00ca C0F20002 		movthi	r2, #:upper16:.LANCHOR14
 664 00ce 1360     		strhi	r3, [r2]
 563:FreeRTOS/Source/tasks.c **** 
 665              		.loc 1 563 0
 666 00d0 40F20001 		movw	r1, #:lower16:.LANCHOR15
 667 00d4 C0F20001 		movt	r1, #:upper16:.LANCHOR15
 668 00d8 0A68     		ldr	r2, [r1]
 669 00da 0132     		adds	r2, r2, #1
 670 00dc 0A60     		str	r2, [r1]
 565:FreeRTOS/Source/tasks.c **** 
 671              		.loc 1 565 0
 672 00de 40F20001 		movw	r1, #:lower16:.LANCHOR16
 673 00e2 C0F20001 		movt	r1, #:upper16:.LANCHOR16
 674 00e6 0A68     		ldr	r2, [r1]
 675 00e8 9342     		cmp	r3, r2
 676 00ea 82BF     		ittt	hi
 677 00ec 40F20002 		movwhi	r2, #:lower16:.LANCHOR16
 678 00f0 0A46     		movhi	r2, r1
 679 00f2 1360     		strhi	r3, [r2]
 680 00f4 40F20000 		movw	r0, #:lower16:.LANCHOR0
 681 00f8 C0F20000 		movt	r0, #:upper16:.LANCHOR0
 682 00fc 03EB8303 		add	r3, r3, r3, lsl #2
 683 0100 00EB8300 		add	r0, r0, r3, lsl #2
 684 0104 211D     		adds	r1, r4, #4
 685 0106 FFF7FEFF 		bl	vListInsertEnd
 686              	.LVL69:
 570:FreeRTOS/Source/tasks.c **** 	}
 687              		.loc 1 570 0
 688 010a FFF7FEFF 		bl	vPortExitCritical
 689              	.LVL70:
 567:FreeRTOS/Source/tasks.c **** 			traceTASK_CREATE( pxNewTCB );
 690              		.loc 1 567 0
 691 010e 0124     		movs	r4, #1
 692              	.LVL71:
 693              	.LBE4:
 694 0110 01E0     		b	.L29
 695              	.LVL72:
 696              	.L36:
 574:FreeRTOS/Source/tasks.c **** 		traceTASK_CREATE_FAILED();
 697              		.loc 1 574 0
 698 0112 4FF0FF34 		mov	r4, #-1
 699              	.LVL73:
 700              	.L29:
 578:FreeRTOS/Source/tasks.c **** 	{
 701              		.loc 1 578 0
 702 0116 012C     		cmp	r4, #1
 703 0118 0FD1     		bne	.L35
 580:FreeRTOS/Source/tasks.c **** 		{
 704              		.loc 1 580 0
 705 011a 40F20003 		movw	r3, #:lower16:.LANCHOR13
 706 011e C0F20003 		movt	r3, #:upper16:.LANCHOR13
 707 0122 1B68     		ldr	r3, [r3]
 708 0124 4BB1     		cbz	r3, .L35
 584:FreeRTOS/Source/tasks.c **** 			{
 709              		.loc 1 584 0
 710 0126 40F20003 		movw	r3, #:lower16:.LANCHOR8
 711 012a C0F20003 		movt	r3, #:upper16:.LANCHOR8
 712 012e 1B68     		ldr	r3, [r3]
 713 0130 DB6A     		ldr	r3, [r3, #44]
 714 0132 B342     		cmp	r3, r6
 715 0134 01D2     		bcs	.L35
 586:FreeRTOS/Source/tasks.c **** 			}
 716              		.loc 1 586 0
 717 0136 FFF7FEFF 		bl	vPortYieldFromISR
 718              	.LVL74:
 719              	.L35:
 592:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 720              		.loc 1 592 0
 721 013a 2046     		mov	r0, r4
 722 013c 03B0     		add	sp, sp, #12
 723              		@ sp needed
 724 013e BDE8F08F 		pop	{r4, r5, r6, r7, r8, r9, r10, fp, pc}
 725              		.cfi_endproc
 726              	.LFE110:
 728              		.section	.text.vTaskDelete,"ax",%progbits
 729              		.align	2
 730              		.global	vTaskDelete
 731              		.thumb
 732              		.thumb_func
 734              	vTaskDelete:
 735              	.LFB111:
 598:FreeRTOS/Source/tasks.c **** 	tskTCB *pxTCB;
 736              		.loc 1 598 0
 737              		.cfi_startproc
 738              		@ args = 0, pretend = 0, frame = 0
 739              		@ frame_needed = 0, uses_anonymous_args = 0
 740              	.LVL75:
 741 0000 70B5     		push	{r4, r5, r6, lr}
 742              	.LCFI9:
 743              		.cfi_def_cfa_offset 16
 744              		.cfi_offset 4, -16
 745              		.cfi_offset 5, -12
 746              		.cfi_offset 6, -8
 747              		.cfi_offset 14, -4
 748 0002 0446     		mov	r4, r0
 601:FreeRTOS/Source/tasks.c **** 		{
 749              		.loc 1 601 0
 750 0004 FFF7FEFF 		bl	vPortEnterCritical
 751              	.LVL76:
 605:FreeRTOS/Source/tasks.c **** 			{
 752              		.loc 1 605 0
 753 0008 40F20003 		movw	r3, #:lower16:.LANCHOR8
 754 000c C0F20003 		movt	r3, #:upper16:.LANCHOR8
 755 0010 1B68     		ldr	r3, [r3]
 607:FreeRTOS/Source/tasks.c **** 			}
 756              		.loc 1 607 0
 757 0012 9C42     		cmp	r4, r3
 758 0014 08BF     		it	eq
 759 0016 0024     		moveq	r4, #0
 760              	.LVL77:
 611:FreeRTOS/Source/tasks.c **** 
 761              		.loc 1 611 0
 762 0018 2546     		mov	r5, r4
 763 001a 2CB9     		cbnz	r4, .L39
 611:FreeRTOS/Source/tasks.c **** 
 764              		.loc 1 611 0 is_stmt 0 discriminator 1
 765 001c 40F20003 		movw	r3, #:lower16:.LANCHOR8
 766 0020 C0F20003 		movt	r3, #:upper16:.LANCHOR8
 767 0024 1D68     		ldr	r5, [r3]
 768              	.LVL78:
 769 0026 FFE7     		b	.L39
 770              	.L39:
 771              	.LVL79:
 617:FreeRTOS/Source/tasks.c **** 
 772              		.loc 1 617 0 is_stmt 1 discriminator 3
 773 0028 2E1D     		adds	r6, r5, #4
 774 002a 3046     		mov	r0, r6
 775 002c FFF7FEFF 		bl	vListRemove
 776              	.LVL80:
 620:FreeRTOS/Source/tasks.c **** 			{
 777              		.loc 1 620 0 discriminator 3
 778 0030 AB6A     		ldr	r3, [r5, #40]
 779 0032 1BB1     		cbz	r3, .L40
 622:FreeRTOS/Source/tasks.c **** 			}
 780              		.loc 1 622 0
 781 0034 05F11800 		add	r0, r5, #24
 782 0038 FFF7FEFF 		bl	vListRemove
 783              	.LVL81:
 784              	.L40:
 625:FreeRTOS/Source/tasks.c **** 
 785              		.loc 1 625 0
 786 003c 40F20000 		movw	r0, #:lower16:.LANCHOR4
 787 0040 C0F20000 		movt	r0, #:upper16:.LANCHOR4
 788 0044 3146     		mov	r1, r6
 789 0046 FFF7FEFF 		bl	vListInsertEnd
 790              	.LVL82:
 630:FreeRTOS/Source/tasks.c **** 
 791              		.loc 1 630 0
 792 004a 40F20003 		movw	r3, #:lower16:.LANCHOR17
 793 004e C0F20003 		movt	r3, #:upper16:.LANCHOR17
 794 0052 1A68     		ldr	r2, [r3]
 795 0054 0132     		adds	r2, r2, #1
 796 0056 1A60     		str	r2, [r3]
 634:FreeRTOS/Source/tasks.c **** 
 797              		.loc 1 634 0
 798 0058 40F20003 		movw	r3, #:lower16:.LANCHOR15
 799 005c C0F20003 		movt	r3, #:upper16:.LANCHOR15
 800 0060 1A68     		ldr	r2, [r3]
 801 0062 0132     		adds	r2, r2, #1
 802 0064 1A60     		str	r2, [r3]
 638:FreeRTOS/Source/tasks.c **** 
 803              		.loc 1 638 0
 804 0066 FFF7FEFF 		bl	vPortExitCritical
 805              	.LVL83:
 641:FreeRTOS/Source/tasks.c **** 		{
 806              		.loc 1 641 0
 807 006a 40F20003 		movw	r3, #:lower16:.LANCHOR13
 808 006e C0F20003 		movt	r3, #:upper16:.LANCHOR13
 809 0072 1B68     		ldr	r3, [r3]
 810 0074 13B1     		cbz	r3, .L37
 643:FreeRTOS/Source/tasks.c **** 			{
 811              		.loc 1 643 0
 812 0076 0CB9     		cbnz	r4, .L37
 645:FreeRTOS/Source/tasks.c **** 			}
 813              		.loc 1 645 0
 814 0078 FFF7FEFF 		bl	vPortYieldFromISR
 815              	.LVL84:
 816              	.L37:
 817 007c 70BD     		pop	{r4, r5, r6, pc}
 818              		.cfi_endproc
 819              	.LFE111:
 821 007e 00BF     		.section	.text.uxTaskPriorityGet,"ax",%progbits
 822              		.align	2
 823              		.global	uxTaskPriorityGet
 824              		.thumb
 825              		.thumb_func
 827              	uxTaskPriorityGet:
 828              	.LFB114:
 775:FreeRTOS/Source/tasks.c **** 	tskTCB *pxTCB;
 829              		.loc 1 775 0
 830              		.cfi_startproc
 831              		@ args = 0, pretend = 0, frame = 0
 832              		@ frame_needed = 0, uses_anonymous_args = 0
 833              	.LVL85:
 834 0000 10B5     		push	{r4, lr}
 835              	.LCFI10:
 836              		.cfi_def_cfa_offset 8
 837              		.cfi_offset 4, -8
 838              		.cfi_offset 14, -4
 839 0002 0446     		mov	r4, r0
 779:FreeRTOS/Source/tasks.c **** 		{
 840              		.loc 1 779 0
 841 0004 FFF7FEFF 		bl	vPortEnterCritical
 842              	.LVL86:
 783:FreeRTOS/Source/tasks.c **** 			uxReturn = pxTCB->uxPriority;
 843              		.loc 1 783 0
 844 0008 24B9     		cbnz	r4, .L45
 783:FreeRTOS/Source/tasks.c **** 			uxReturn = pxTCB->uxPriority;
 845              		.loc 1 783 0 is_stmt 0 discriminator 1
 846 000a 40F20003 		movw	r3, #:lower16:.LANCHOR8
 847 000e C0F20003 		movt	r3, #:upper16:.LANCHOR8
 848 0012 1C68     		ldr	r4, [r3]
 849              	.LVL87:
 850              	.L45:
 784:FreeRTOS/Source/tasks.c **** 		}
 851              		.loc 1 784 0 is_stmt 1 discriminator 3
 852 0014 E46A     		ldr	r4, [r4, #44]
 853              	.LVL88:
 786:FreeRTOS/Source/tasks.c **** 
 854              		.loc 1 786 0 discriminator 3
 855 0016 FFF7FEFF 		bl	vPortExitCritical
 856              	.LVL89:
 789:FreeRTOS/Source/tasks.c **** 
 857              		.loc 1 789 0 discriminator 3
 858 001a 2046     		mov	r0, r4
 859 001c 10BD     		pop	{r4, pc}
 860              		.cfi_endproc
 861              	.LFE114:
 863 001e 00BF     		.section	.text.vTaskPrioritySet,"ax",%progbits
 864              		.align	2
 865              		.global	vTaskPrioritySet
 866              		.thumb
 867              		.thumb_func
 869              	vTaskPrioritySet:
 870              	.LFB115:
 797:FreeRTOS/Source/tasks.c **** 	tskTCB *pxTCB;
 871              		.loc 1 797 0
 872              		.cfi_startproc
 873              		@ args = 0, pretend = 0, frame = 0
 874              		@ frame_needed = 0, uses_anonymous_args = 0
 875              	.LVL90:
 876 0000 70B5     		push	{r4, r5, r6, lr}
 877              	.LCFI11:
 878              		.cfi_def_cfa_offset 16
 879              		.cfi_offset 4, -16
 880              		.cfi_offset 5, -12
 881              		.cfi_offset 6, -8
 882              		.cfi_offset 14, -4
 883 0002 0446     		mov	r4, r0
 884 0004 0D46     		mov	r5, r1
 885              	.LVL91:
 807:FreeRTOS/Source/tasks.c **** 		}
 886              		.loc 1 807 0
 887 0006 042D     		cmp	r5, #4
 888 0008 28BF     		it	cs
 889 000a 0425     		movcs	r5, #4
 890              	.LVL92:
 810:FreeRTOS/Source/tasks.c **** 		{
 891              		.loc 1 810 0
 892 000c FFF7FEFF 		bl	vPortEnterCritical
 893              	.LVL93:
 812:FreeRTOS/Source/tasks.c **** 			{
 894              		.loc 1 812 0
 895 0010 40F20003 		movw	r3, #:lower16:.LANCHOR8
 896 0014 C0F20003 		movt	r3, #:upper16:.LANCHOR8
 897 0018 1B68     		ldr	r3, [r3]
 814:FreeRTOS/Source/tasks.c **** 			}
 898              		.loc 1 814 0
 899 001a 9C42     		cmp	r4, r3
 900 001c 08BF     		it	eq
 901 001e 0024     		moveq	r4, #0
 902              	.LVL94:
 819:FreeRTOS/Source/tasks.c **** 
 903              		.loc 1 819 0
 904 0020 2646     		mov	r6, r4
 905 0022 2CB9     		cbnz	r4, .L49
 819:FreeRTOS/Source/tasks.c **** 
 906              		.loc 1 819 0 is_stmt 0 discriminator 1
 907 0024 40F20003 		movw	r3, #:lower16:.LANCHOR8
 908 0028 C0F20003 		movt	r3, #:upper16:.LANCHOR8
 909 002c 1E68     		ldr	r6, [r3]
 910              	.LVL95:
 911 002e FFE7     		b	.L49
 912              	.L49:
 913              	.LVL96:
 825:FreeRTOS/Source/tasks.c **** 			}
 914              		.loc 1 825 0 is_stmt 1 discriminator 3
 915 0030 736C     		ldr	r3, [r6, #68]
 916              	.LVL97:
 833:FreeRTOS/Source/tasks.c **** 			{
 917              		.loc 1 833 0 discriminator 3
 918 0032 AB42     		cmp	r3, r5
 919 0034 3BD0     		beq	.L50
 837:FreeRTOS/Source/tasks.c **** 				{
 920              		.loc 1 837 0
 921 0036 9D42     		cmp	r5, r3
 922 0038 03D9     		bls	.L51
 800:FreeRTOS/Source/tasks.c **** 
 923              		.loc 1 800 0
 924 003a 0034     		adds	r4, r4, #0
 925 003c 18BF     		it	ne
 926 003e 0124     		movne	r4, #1
 927 0040 03E0     		b	.L52
 928              	.L51:
 929 0042 D4F10104 		rsbs	r4, r4, #1
 930 0046 38BF     		it	cc
 931 0048 0024     		movcc	r4, #0
 932              	.L52:
 933              	.LVL98:
 861:FreeRTOS/Source/tasks.c **** 					{
 934              		.loc 1 861 0
 935 004a F26A     		ldr	r2, [r6, #44]
 936 004c 9342     		cmp	r3, r2
 863:FreeRTOS/Source/tasks.c **** 					}
 937              		.loc 1 863 0
 938 004e 08BF     		it	eq
 939 0050 F562     		streq	r5, [r6, #44]
 867:FreeRTOS/Source/tasks.c **** 				}
 940              		.loc 1 867 0
 941 0052 7564     		str	r5, [r6, #68]
 875:FreeRTOS/Source/tasks.c **** 
 942              		.loc 1 875 0
 943 0054 C5F10505 		rsb	r5, r5, #5
 944              	.LVL99:
 945 0058 B561     		str	r5, [r6, #24]
 881:FreeRTOS/Source/tasks.c **** 				{
 946              		.loc 1 881 0
 947 005a 7169     		ldr	r1, [r6, #20]
 948 005c 40F20002 		movw	r2, #:lower16:.LANCHOR0
 949 0060 C0F20002 		movt	r2, #:upper16:.LANCHOR0
 950 0064 03EB8303 		add	r3, r3, r3, lsl #2
 951              	.LVL100:
 952 0068 02EB8302 		add	r2, r2, r3, lsl #2
 953 006c 9142     		cmp	r1, r2
 954 006e 1BD1     		bne	.L54
 886:FreeRTOS/Source/tasks.c **** 					prvAddTaskToReadyQueue( pxTCB );
 955              		.loc 1 886 0
 956 0070 351D     		adds	r5, r6, #4
 957 0072 2846     		mov	r0, r5
 958 0074 FFF7FEFF 		bl	vListRemove
 959              	.LVL101:
 887:FreeRTOS/Source/tasks.c **** 				}
 960              		.loc 1 887 0
 961 0078 F36A     		ldr	r3, [r6, #44]
 962 007a 40F20002 		movw	r2, #:lower16:.LANCHOR16
 963 007e C0F20002 		movt	r2, #:upper16:.LANCHOR16
 964 0082 1268     		ldr	r2, [r2]
 965 0084 9342     		cmp	r3, r2
 966 0086 82BF     		ittt	hi
 967 0088 40F20002 		movwhi	r2, #:lower16:.LANCHOR16
 968 008c C0F20002 		movthi	r2, #:upper16:.LANCHOR16
 969 0090 1360     		strhi	r3, [r2]
 970 0092 40F20000 		movw	r0, #:lower16:.LANCHOR0
 971 0096 C0F20000 		movt	r0, #:upper16:.LANCHOR0
 972 009a 03EB8303 		add	r3, r3, r3, lsl #2
 973 009e 00EB8300 		add	r0, r0, r3, lsl #2
 974 00a2 2946     		mov	r1, r5
 975 00a4 FFF7FEFF 		bl	vListInsertEnd
 976              	.LVL102:
 977              	.L54:
 890:FreeRTOS/Source/tasks.c **** 				{
 978              		.loc 1 890 0
 979 00a8 0CB1     		cbz	r4, .L50
 892:FreeRTOS/Source/tasks.c **** 				}
 980              		.loc 1 892 0
 981 00aa FFF7FEFF 		bl	vPortYieldFromISR
 982              	.LVL103:
 983              	.L50:
 896:FreeRTOS/Source/tasks.c **** 	}
 984              		.loc 1 896 0
 985 00ae FFF7FEFF 		bl	vPortExitCritical
 986              	.LVL104:
 987 00b2 70BD     		pop	{r4, r5, r6, pc}
 988              		.cfi_endproc
 989              	.LFE115:
 991              		.section	.text.xTaskIsTaskSuspended,"ax",%progbits
 992              		.align	2
 993              		.global	xTaskIsTaskSuspended
 994              		.thumb
 995              		.thumb_func
 997              	xTaskIsTaskSuspended:
 998              	.LFB117:
 969:FreeRTOS/Source/tasks.c **** 	portBASE_TYPE xReturn = pdFALSE;
 999              		.loc 1 969 0
 1000              		.cfi_startproc
 1001              		@ args = 0, pretend = 0, frame = 0
 1002              		@ frame_needed = 0, uses_anonymous_args = 0
 1003              		@ link register save eliminated.
 1004              	.LVL105:
 978:FreeRTOS/Source/tasks.c **** 		{
 1005              		.loc 1 978 0
 1006 0000 4269     		ldr	r2, [r0, #20]
 1007 0002 40F20003 		movw	r3, #:lower16:.LANCHOR5
 1008 0006 C0F20003 		movt	r3, #:upper16:.LANCHOR5
 1009 000a 9A42     		cmp	r2, r3
 1010 000c 0BD1     		bne	.L63
 981:FreeRTOS/Source/tasks.c **** 			{
 1011              		.loc 1 981 0
 1012 000e 806A     		ldr	r0, [r0, #40]
 1013              	.LVL106:
 1014 0010 40F20003 		movw	r3, #:lower16:.LANCHOR3
 1015 0014 C0F20003 		movt	r3, #:upper16:.LANCHOR3
 1016 0018 9842     		cmp	r0, r3
 1017 001a 06D0     		beq	.L64
 970:FreeRTOS/Source/tasks.c **** 	const tskTCB * const pxTCB = ( tskTCB * ) xTask;
 1018              		.loc 1 970 0
 1019 001c D0F10100 		rsbs	r0, r0, #1
 1020 0020 38BF     		it	cc
 1021 0022 0020     		movcc	r0, #0
 1022 0024 7047     		bx	lr
 1023              	.LVL107:
 1024              	.L63:
 1025 0026 0020     		movs	r0, #0
 1026              	.LVL108:
 1027 0028 7047     		bx	lr
 1028              	.L64:
 1029 002a 0020     		movs	r0, #0
 1030              	.LVL109:
 995:FreeRTOS/Source/tasks.c **** 
 1031              		.loc 1 995 0
 1032 002c 7047     		bx	lr
 1033              		.cfi_endproc
 1034              	.LFE117:
 1036 002e 00BF     		.section	.text.vTaskResume,"ax",%progbits
 1037              		.align	2
 1038              		.global	vTaskResume
 1039              		.thumb
 1040              		.thumb_func
 1042              	vTaskResume:
 1043              	.LFB118:
1003:FreeRTOS/Source/tasks.c **** 	tskTCB *pxTCB;
 1044              		.loc 1 1003 0
 1045              		.cfi_startproc
 1046              		@ args = 0, pretend = 0, frame = 0
 1047              		@ frame_needed = 0, uses_anonymous_args = 0
 1048              	.LVL110:
 1049 0000 38B5     		push	{r3, r4, r5, lr}
 1050              	.LCFI12:
 1051              		.cfi_def_cfa_offset 16
 1052              		.cfi_offset 3, -16
 1053              		.cfi_offset 4, -12
 1054              		.cfi_offset 5, -8
 1055              		.cfi_offset 14, -4
 1056              	.LVL111:
1015:FreeRTOS/Source/tasks.c **** 		{
 1057              		.loc 1 1015 0
 1058 0002 0446     		mov	r4, r0
 1059 0004 0028     		cmp	r0, #0
 1060 0006 36D0     		beq	.L66
1015:FreeRTOS/Source/tasks.c **** 		{
 1061              		.loc 1 1015 0 is_stmt 0 discriminator 1
 1062 0008 40F20003 		movw	r3, #:lower16:.LANCHOR8
 1063 000c C0F20003 		movt	r3, #:upper16:.LANCHOR8
 1064 0010 1B68     		ldr	r3, [r3]
 1065 0012 9842     		cmp	r0, r3
 1066 0014 2FD0     		beq	.L66
1017:FreeRTOS/Source/tasks.c **** 			{
 1067              		.loc 1 1017 0 is_stmt 1
 1068 0016 FFF7FEFF 		bl	vPortEnterCritical
 1069              	.LVL112:
1019:FreeRTOS/Source/tasks.c **** 				{
 1070              		.loc 1 1019 0
 1071 001a 2046     		mov	r0, r4
 1072 001c FFF7FEFF 		bl	xTaskIsTaskSuspended
 1073              	.LVL113:
 1074 0020 0128     		cmp	r0, #1
 1075 0022 26D1     		bne	.L68
1025:FreeRTOS/Source/tasks.c **** 					prvAddTaskToReadyQueue( pxTCB );
 1076              		.loc 1 1025 0
 1077 0024 251D     		adds	r5, r4, #4
 1078 0026 2846     		mov	r0, r5
 1079 0028 FFF7FEFF 		bl	vListRemove
 1080              	.LVL114:
1026:FreeRTOS/Source/tasks.c **** 
 1081              		.loc 1 1026 0
 1082 002c E36A     		ldr	r3, [r4, #44]
 1083 002e 40F20002 		movw	r2, #:lower16:.LANCHOR16
 1084 0032 C0F20002 		movt	r2, #:upper16:.LANCHOR16
 1085 0036 1268     		ldr	r2, [r2]
 1086 0038 9342     		cmp	r3, r2
 1087 003a 82BF     		ittt	hi
 1088 003c 40F20002 		movwhi	r2, #:lower16:.LANCHOR16
 1089 0040 C0F20002 		movthi	r2, #:upper16:.LANCHOR16
 1090 0044 1360     		strhi	r3, [r2]
 1091 0046 40F20000 		movw	r0, #:lower16:.LANCHOR0
 1092 004a C0F20000 		movt	r0, #:upper16:.LANCHOR0
 1093 004e 03EB8303 		add	r3, r3, r3, lsl #2
 1094 0052 00EB8300 		add	r0, r0, r3, lsl #2
 1095 0056 2946     		mov	r1, r5
 1096 0058 FFF7FEFF 		bl	vListInsertEnd
 1097              	.LVL115:
1029:FreeRTOS/Source/tasks.c **** 					{
 1098              		.loc 1 1029 0
 1099 005c E26A     		ldr	r2, [r4, #44]
 1100 005e 40F20003 		movw	r3, #:lower16:.LANCHOR8
 1101 0062 C0F20003 		movt	r3, #:upper16:.LANCHOR8
 1102 0066 1B68     		ldr	r3, [r3]
 1103 0068 DB6A     		ldr	r3, [r3, #44]
 1104 006a 9A42     		cmp	r2, r3
 1105 006c 01D3     		bcc	.L68
1033:FreeRTOS/Source/tasks.c **** 					}
 1106              		.loc 1 1033 0
 1107 006e FFF7FEFF 		bl	vPortYieldFromISR
 1108              	.LVL116:
 1109              	.L68:
1037:FreeRTOS/Source/tasks.c **** 		}
 1110              		.loc 1 1037 0
 1111 0072 FFF7FEFF 		bl	vPortExitCritical
 1112              	.LVL117:
 1113              	.L66:
 1114 0076 38BD     		pop	{r3, r4, r5, pc}
 1115              		.cfi_endproc
 1116              	.LFE118:
 1118              		.section	.text.xTaskResumeFromISR,"ax",%progbits
 1119              		.align	2
 1120              		.global	xTaskResumeFromISR
 1121              		.thumb
 1122              		.thumb_func
 1124              	xTaskResumeFromISR:
 1125              	.LFB119:
1048:FreeRTOS/Source/tasks.c **** 	portBASE_TYPE xYieldRequired = pdFALSE;
 1126              		.loc 1 1048 0
 1127              		.cfi_startproc
 1128              		@ args = 0, pretend = 0, frame = 0
 1129              		@ frame_needed = 0, uses_anonymous_args = 0
 1130              	.LVL118:
 1131 0000 70B5     		push	{r4, r5, r6, lr}
 1132              	.LCFI13:
 1133              		.cfi_def_cfa_offset 16
 1134              		.cfi_offset 4, -16
 1135              		.cfi_offset 5, -12
 1136              		.cfi_offset 6, -8
 1137              		.cfi_offset 14, -4
 1138 0002 0546     		mov	r5, r0
 1139              	.LVL119:
1056:FreeRTOS/Source/tasks.c **** 		{
 1140              		.loc 1 1056 0
 1141 0004 FFF7FEFF 		bl	xTaskIsTaskSuspended
 1142              	.LVL120:
 1143 0008 0128     		cmp	r0, #1
1049:FreeRTOS/Source/tasks.c **** 	tskTCB *pxTCB;
 1144              		.loc 1 1049 0
 1145 000a 18BF     		it	ne
 1146 000c 0024     		movne	r4, #0
1056:FreeRTOS/Source/tasks.c **** 		{
 1147              		.loc 1 1056 0
 1148 000e 37D1     		bne	.L71
1060:FreeRTOS/Source/tasks.c **** 			{
 1149              		.loc 1 1060 0
 1150 0010 40F20003 		movw	r3, #:lower16:.LANCHOR18
 1151 0014 C0F20003 		movt	r3, #:upper16:.LANCHOR18
 1152 0018 1B68     		ldr	r3, [r3]
 1153 001a 3BBB     		cbnz	r3, .L72
1062:FreeRTOS/Source/tasks.c **** 				vListRemove(  &( pxTCB->xGenericListItem ) );
 1154              		.loc 1 1062 0
 1155 001c EA6A     		ldr	r2, [r5, #44]
 1156 001e 40F20003 		movw	r3, #:lower16:.LANCHOR8
 1157 0022 C0F20003 		movt	r3, #:upper16:.LANCHOR8
 1158 0026 1B68     		ldr	r3, [r3]
 1159 0028 DC6A     		ldr	r4, [r3, #44]
 1160 002a A242     		cmp	r2, r4
 1161 002c 34BF     		ite	cc
 1162 002e 0024     		movcc	r4, #0
 1163 0030 0124     		movcs	r4, #1
 1164              	.LVL121:
1063:FreeRTOS/Source/tasks.c **** 				prvAddTaskToReadyQueue( pxTCB );
 1165              		.loc 1 1063 0
 1166 0032 2E1D     		adds	r6, r5, #4
 1167 0034 3046     		mov	r0, r6
 1168 0036 FFF7FEFF 		bl	vListRemove
 1169              	.LVL122:
1064:FreeRTOS/Source/tasks.c **** 			}
 1170              		.loc 1 1064 0
 1171 003a EB6A     		ldr	r3, [r5, #44]
 1172 003c 40F20002 		movw	r2, #:lower16:.LANCHOR16
 1173 0040 C0F20002 		movt	r2, #:upper16:.LANCHOR16
 1174 0044 1268     		ldr	r2, [r2]
 1175 0046 9342     		cmp	r3, r2
 1176 0048 82BF     		ittt	hi
 1177 004a 40F20002 		movwhi	r2, #:lower16:.LANCHOR16
 1178 004e C0F20002 		movthi	r2, #:upper16:.LANCHOR16
 1179 0052 1360     		strhi	r3, [r2]
 1180 0054 40F20000 		movw	r0, #:lower16:.LANCHOR0
 1181 0058 C0F20000 		movt	r0, #:upper16:.LANCHOR0
 1182 005c 03EB8303 		add	r3, r3, r3, lsl #2
 1183 0060 00EB8300 		add	r0, r0, r3, lsl #2
 1184 0064 3146     		mov	r1, r6
 1185 0066 FFF7FEFF 		bl	vListInsertEnd
 1186              	.LVL123:
 1187 006a 09E0     		b	.L71
 1188              	.LVL124:
 1189              	.L72:
1071:FreeRTOS/Source/tasks.c **** 			}
 1190              		.loc 1 1071 0
 1191 006c 40F20000 		movw	r0, #:lower16:.LANCHOR3
 1192 0070 C0F20000 		movt	r0, #:upper16:.LANCHOR3
 1193 0074 05F11801 		add	r1, r5, #24
 1194 0078 FFF7FEFF 		bl	vListInsertEnd
 1195              	.LVL125:
1049:FreeRTOS/Source/tasks.c **** 	tskTCB *pxTCB;
 1196              		.loc 1 1049 0
 1197 007c 0024     		movs	r4, #0
 1198 007e FFE7     		b	.L71
 1199              	.LVL126:
 1200              	.L71:
1076:FreeRTOS/Source/tasks.c **** 
 1201              		.loc 1 1076 0
 1202 0080 2046     		mov	r0, r4
 1203 0082 70BD     		pop	{r4, r5, r6, pc}
 1204              		.cfi_endproc
 1205              	.LFE119:
 1207              		.section	.text.vTaskStartScheduler,"ax",%progbits
 1208              		.align	2
 1209              		.global	vTaskStartScheduler
 1210              		.thumb
 1211              		.thumb_func
 1213              	vTaskStartScheduler:
 1214              	.LFB120:
1089:FreeRTOS/Source/tasks.c **** portBASE_TYPE xReturn;
 1215              		.loc 1 1089 0
 1216              		.cfi_startproc
 1217              		@ args = 0, pretend = 0, frame = 0
 1218              		@ frame_needed = 0, uses_anonymous_args = 0
 1219 0000 00B5     		push	{lr}
 1220              	.LCFI14:
 1221              		.cfi_def_cfa_offset 4
 1222              		.cfi_offset 14, -4
 1223 0002 85B0     		sub	sp, sp, #20
 1224              	.LCFI15:
 1225              		.cfi_def_cfa_offset 24
1097:FreeRTOS/Source/tasks.c **** 	}
 1226              		.loc 1 1097 0
 1227 0004 0023     		movs	r3, #0
 1228 0006 0093     		str	r3, [sp]
 1229 0008 40F20002 		movw	r2, #:lower16:.LANCHOR19
 1230 000c C0F20002 		movt	r2, #:upper16:.LANCHOR19
 1231 0010 0192     		str	r2, [sp, #4]
 1232 0012 0293     		str	r3, [sp, #8]
 1233 0014 0393     		str	r3, [sp, #12]
 1234 0016 40F20000 		movw	r0, #:lower16:prvIdleTask
 1235 001a C0F20000 		movt	r0, #:upper16:prvIdleTask
 1236 001e 40F20001 		movw	r1, #:lower16:.LC3
 1237 0022 C0F20001 		movt	r1, #:upper16:.LC3
 1238 0026 4FF48072 		mov	r2, #256
 1239 002a FFF7FEFF 		bl	xTaskGenericCreate
 1240              	.LVL127:
1115:FreeRTOS/Source/tasks.c **** 	{
 1241              		.loc 1 1115 0
 1242 002e 0128     		cmp	r0, #1
 1243 0030 13D1     		bne	.L75
1125:FreeRTOS/Source/tasks.c **** 
 1244              		.loc 1 1125 0
 1245              	@ 1125 "FreeRTOS/Source/tasks.c" 1
 1246 0032 4FF0BF00 			mov r0, #191								
 1247 0036 80F31188 		msr basepri, r0							
 1248              	
 1249              	@ 0 "" 2
 1250              	.LVL128:
1127:FreeRTOS/Source/tasks.c **** 		xTickCount = ( portTickType ) 0U;
 1251              		.loc 1 1127 0
 1252              		.thumb
 1253 003a 40F20003 		movw	r3, #:lower16:.LANCHOR13
 1254 003e C0F20003 		movt	r3, #:upper16:.LANCHOR13
 1255 0042 0122     		movs	r2, #1
 1256 0044 1A60     		str	r2, [r3]
1128:FreeRTOS/Source/tasks.c **** 
 1257              		.loc 1 1128 0
 1258 0046 40F20003 		movw	r3, #:lower16:.LANCHOR9
 1259 004a C0F20003 		movt	r3, #:upper16:.LANCHOR9
 1260 004e 0022     		movs	r2, #0
 1261 0050 1A60     		str	r2, [r3]
1133:FreeRTOS/Source/tasks.c **** 		
 1262              		.loc 1 1133 0
 1263 0052 FFF7FEFF 		bl	init_us_timer
 1264              	.LVL129:
1137:FreeRTOS/Source/tasks.c **** 		{
 1265              		.loc 1 1137 0
 1266 0056 FFF7FEFF 		bl	xPortStartScheduler
 1267              	.LVL130:
 1268              	.L75:
1150:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 1269              		.loc 1 1150 0
 1270 005a 05B0     		add	sp, sp, #20
 1271              		@ sp needed
 1272 005c 5DF804FB 		ldr	pc, [sp], #4
 1273              		.cfi_endproc
 1274              	.LFE120:
 1276              		.section	.text.vTaskEndScheduler,"ax",%progbits
 1277              		.align	2
 1278              		.global	vTaskEndScheduler
 1279              		.thumb
 1280              		.thumb_func
 1282              	vTaskEndScheduler:
 1283              	.LFB121:
1154:FreeRTOS/Source/tasks.c **** 	/* Stop the scheduler interrupts and call the portable scheduler end
 1284              		.loc 1 1154 0
 1285              		.cfi_startproc
 1286              		@ args = 0, pretend = 0, frame = 0
 1287              		@ frame_needed = 0, uses_anonymous_args = 0
 1288 0000 08B5     		push	{r3, lr}
 1289              	.LCFI16:
 1290              		.cfi_def_cfa_offset 8
 1291              		.cfi_offset 3, -8
 1292              		.cfi_offset 14, -4
1158:FreeRTOS/Source/tasks.c **** 	xSchedulerRunning = pdFALSE;
 1293              		.loc 1 1158 0
 1294              	@ 1158 "FreeRTOS/Source/tasks.c" 1
 1295 0002 4FF0BF00 			mov r0, #191								
 1296 0006 80F31188 		msr basepri, r0							
 1297              	
 1298              	@ 0 "" 2
1159:FreeRTOS/Source/tasks.c **** 	vPortEndScheduler();
 1299              		.loc 1 1159 0
 1300              		.thumb
 1301 000a 40F20003 		movw	r3, #:lower16:.LANCHOR13
 1302 000e C0F20003 		movt	r3, #:upper16:.LANCHOR13
 1303 0012 0022     		movs	r2, #0
 1304 0014 1A60     		str	r2, [r3]
1160:FreeRTOS/Source/tasks.c **** }
 1305              		.loc 1 1160 0
 1306 0016 FFF7FEFF 		bl	vPortEndScheduler
 1307              	.LVL131:
 1308 001a 08BD     		pop	{r3, pc}
 1309              		.cfi_endproc
 1310              	.LFE121:
 1312              		.section	.text.vTaskSuspendAll,"ax",%progbits
 1313              		.align	2
 1314              		.global	vTaskSuspendAll
 1315              		.thumb
 1316              		.thumb_func
 1318              	vTaskSuspendAll:
 1319              	.LFB122:
1165:FreeRTOS/Source/tasks.c **** 	/* A critical section is not required as the variable is of type
 1320              		.loc 1 1165 0
 1321              		.cfi_startproc
 1322              		@ args = 0, pretend = 0, frame = 0
 1323              		@ frame_needed = 0, uses_anonymous_args = 0
 1324              		@ link register save eliminated.
1168:FreeRTOS/Source/tasks.c **** }
 1325              		.loc 1 1168 0
 1326 0000 40F20003 		movw	r3, #:lower16:.LANCHOR18
 1327 0004 C0F20003 		movt	r3, #:upper16:.LANCHOR18
 1328 0008 1A68     		ldr	r2, [r3]
 1329 000a 0132     		adds	r2, r2, #1
 1330 000c 1A60     		str	r2, [r3]
 1331 000e 7047     		bx	lr
 1332              		.cfi_endproc
 1333              	.LFE122:
 1335              		.section	.text.xTaskGetTickCount,"ax",%progbits
 1336              		.align	2
 1337              		.global	xTaskGetTickCount
 1338              		.thumb
 1339              		.thumb_func
 1341              	xTaskGetTickCount:
 1342              	.LFB124:
1260:FreeRTOS/Source/tasks.c **** portTickType xTicks;
 1343              		.loc 1 1260 0
 1344              		.cfi_startproc
 1345              		@ args = 0, pretend = 0, frame = 0
 1346              		@ frame_needed = 0, uses_anonymous_args = 0
 1347 0000 10B5     		push	{r4, lr}
 1348              	.LCFI17:
 1349              		.cfi_def_cfa_offset 8
 1350              		.cfi_offset 4, -8
 1351              		.cfi_offset 14, -4
1264:FreeRTOS/Source/tasks.c **** 	{
 1352              		.loc 1 1264 0
 1353 0002 FFF7FEFF 		bl	vPortEnterCritical
 1354              	.LVL132:
1266:FreeRTOS/Source/tasks.c **** 	}
 1355              		.loc 1 1266 0
 1356 0006 40F20003 		movw	r3, #:lower16:.LANCHOR9
 1357 000a C0F20003 		movt	r3, #:upper16:.LANCHOR9
 1358 000e 1C68     		ldr	r4, [r3]
 1359              	.LVL133:
1268:FreeRTOS/Source/tasks.c **** 
 1360              		.loc 1 1268 0
 1361 0010 FFF7FEFF 		bl	vPortExitCritical
 1362              	.LVL134:
1271:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 1363              		.loc 1 1271 0
 1364 0014 2046     		mov	r0, r4
 1365 0016 10BD     		pop	{r4, pc}
 1366              		.cfi_endproc
 1367              	.LFE124:
 1369              		.section	.text.xTaskGetTickCountFromISR,"ax",%progbits
 1370              		.align	2
 1371              		.global	xTaskGetTickCountFromISR
 1372              		.thumb
 1373              		.thumb_func
 1375              	xTaskGetTickCountFromISR:
 1376              	.LFB125:
1275:FreeRTOS/Source/tasks.c **** portTickType xReturn;
 1377              		.loc 1 1275 0
 1378              		.cfi_startproc
 1379              		@ args = 0, pretend = 0, frame = 0
 1380              		@ frame_needed = 0, uses_anonymous_args = 0
 1381              		@ link register save eliminated.
 1382              	.LVL135:
1279:FreeRTOS/Source/tasks.c **** 	xReturn = xTickCount;
 1383              		.loc 1 1279 0
 1384              	@ 1279 "FreeRTOS/Source/tasks.c" 1
 1385 0000 4FF0BF00 			mov r0, #191								
 1386 0004 80F31188 		msr basepri, r0							
 1387              	
 1388              	@ 0 "" 2
1280:FreeRTOS/Source/tasks.c **** 	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
 1389              		.loc 1 1280 0
 1390              		.thumb
 1391 0008 40F20003 		movw	r3, #:lower16:.LANCHOR9
 1392 000c C0F20003 		movt	r3, #:upper16:.LANCHOR9
 1393 0010 1B68     		ldr	r3, [r3]
 1394              	.LVL136:
1281:FreeRTOS/Source/tasks.c **** 
 1395              		.loc 1 1281 0
 1396              	@ 1281 "FreeRTOS/Source/tasks.c" 1
 1397 0012 4FF00000 			mov r0, #0					
 1398 0016 80F31188 		msr basepri, r0				
 1399              	
 1400              	@ 0 "" 2
1284:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 1401              		.loc 1 1284 0
 1402              		.thumb
 1403 001a 1846     		mov	r0, r3
 1404 001c 7047     		bx	lr
 1405              		.cfi_endproc
 1406              	.LFE125:
 1408 001e 00BF     		.section	.text.uxTaskGetNumberOfTasks,"ax",%progbits
 1409              		.align	2
 1410              		.global	uxTaskGetNumberOfTasks
 1411              		.thumb
 1412              		.thumb_func
 1414              	uxTaskGetNumberOfTasks:
 1415              	.LFB126:
1288:FreeRTOS/Source/tasks.c **** 	/* A critical section is not required because the variables are of type
 1416              		.loc 1 1288 0
 1417              		.cfi_startproc
 1418              		@ args = 0, pretend = 0, frame = 0
 1419              		@ frame_needed = 0, uses_anonymous_args = 0
 1420              		@ link register save eliminated.
1291:FreeRTOS/Source/tasks.c **** }
 1421              		.loc 1 1291 0
 1422 0000 40F20003 		movw	r3, #:lower16:.LANCHOR12
 1423 0004 C0F20003 		movt	r3, #:upper16:.LANCHOR12
 1424 0008 1868     		ldr	r0, [r3]
1292:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 1425              		.loc 1 1292 0
 1426 000a 7047     		bx	lr
 1427              		.cfi_endproc
 1428              	.LFE126:
 1430              		.section	.text.xTaskGetIdleTaskHandle,"ax",%progbits
 1431              		.align	2
 1432              		.global	xTaskGetIdleTaskHandle
 1433              		.thumb
 1434              		.thumb_func
 1436              	xTaskGetIdleTaskHandle:
 1437              	.LFB128:
1489:FreeRTOS/Source/tasks.c **** 		/* If xTaskGetIdleTaskHandle() is called before the scheduler has been
 1438              		.loc 1 1489 0
 1439              		.cfi_startproc
 1440              		@ args = 0, pretend = 0, frame = 0
 1441              		@ frame_needed = 0, uses_anonymous_args = 0
 1442              		@ link register save eliminated.
1493:FreeRTOS/Source/tasks.c **** 	}
 1443              		.loc 1 1493 0
 1444 0000 40F20003 		movw	r3, #:lower16:.LANCHOR19
 1445 0004 C0F20003 		movt	r3, #:upper16:.LANCHOR19
1494:FreeRTOS/Source/tasks.c **** 	
 1446              		.loc 1 1494 0
 1447 0008 1868     		ldr	r0, [r3]
 1448 000a 7047     		bx	lr
 1449              		.cfi_endproc
 1450              	.LFE128:
 1452              		.section	.text.vTaskIncrementTick,"ax",%progbits
 1453              		.align	2
 1454              		.global	vTaskIncrementTick
 1455              		.thumb
 1456              		.thumb_func
 1458              	vTaskIncrementTick:
 1459              	.LFB129:
1504:FreeRTOS/Source/tasks.c **** tskTCB * pxTCB;
 1460              		.loc 1 1504 0
 1461              		.cfi_startproc
 1462              		@ args = 0, pretend = 0, frame = 0
 1463              		@ frame_needed = 0, uses_anonymous_args = 0
 1464 0000 2DE9F843 		push	{r3, r4, r5, r6, r7, r8, r9, lr}
 1465              	.LCFI18:
 1466              		.cfi_def_cfa_offset 32
 1467              		.cfi_offset 3, -32
 1468              		.cfi_offset 4, -28
 1469              		.cfi_offset 5, -24
 1470              		.cfi_offset 6, -20
 1471              		.cfi_offset 7, -16
 1472              		.cfi_offset 8, -12
 1473              		.cfi_offset 9, -8
 1474              		.cfi_offset 14, -4
1510:FreeRTOS/Source/tasks.c **** 	{
 1475              		.loc 1 1510 0
 1476 0004 40F20003 		movw	r3, #:lower16:.LANCHOR18
 1477 0008 C0F20003 		movt	r3, #:upper16:.LANCHOR18
 1478 000c 1B68     		ldr	r3, [r3]
 1479 000e 002B     		cmp	r3, #0
 1480 0010 40F08280 		bne	.L84
1512:FreeRTOS/Source/tasks.c **** 		if( xTickCount == ( portTickType ) 0U )
 1481              		.loc 1 1512 0
 1482 0014 40F20003 		movw	r3, #:lower16:.LANCHOR9
 1483 0018 C0F20003 		movt	r3, #:upper16:.LANCHOR9
 1484 001c 1A68     		ldr	r2, [r3]
 1485 001e 0132     		adds	r2, r2, #1
 1486 0020 1A60     		str	r2, [r3]
1513:FreeRTOS/Source/tasks.c **** 		{
 1487              		.loc 1 1513 0
 1488 0022 1B68     		ldr	r3, [r3]
 1489 0024 53BB     		cbnz	r3, .L85
 1490              	.LBB5:
1522:FreeRTOS/Source/tasks.c **** 			pxDelayedTaskList = pxOverflowDelayedTaskList;
 1491              		.loc 1 1522 0
 1492 0026 40F20003 		movw	r3, #:lower16:.LANCHOR6
 1493 002a C0F20003 		movt	r3, #:upper16:.LANCHOR6
 1494 002e 1968     		ldr	r1, [r3]
 1495              	.LVL137:
1523:FreeRTOS/Source/tasks.c **** 			pxOverflowDelayedTaskList = pxTemp;
 1496              		.loc 1 1523 0
 1497 0030 40F20002 		movw	r2, #:lower16:.LANCHOR7
 1498 0034 C0F20002 		movt	r2, #:upper16:.LANCHOR7
 1499 0038 1068     		ldr	r0, [r2]
 1500 003a 1860     		str	r0, [r3]
1524:FreeRTOS/Source/tasks.c **** 			xNumOfOverflows++;
 1501              		.loc 1 1524 0
 1502 003c 1160     		str	r1, [r2]
1525:FreeRTOS/Source/tasks.c **** 	
 1503              		.loc 1 1525 0
 1504 003e 40F20002 		movw	r2, #:lower16:.LANCHOR20
 1505 0042 C0F20002 		movt	r2, #:upper16:.LANCHOR20
 1506 0046 1168     		ldr	r1, [r2]
 1507              	.LVL138:
 1508 0048 0131     		adds	r1, r1, #1
 1509 004a 1160     		str	r1, [r2]
 1510              	.LVL139:
1527:FreeRTOS/Source/tasks.c **** 			{
 1511              		.loc 1 1527 0
 1512 004c 1B68     		ldr	r3, [r3]
 1513 004e 1B68     		ldr	r3, [r3]
 1514 0050 3BB9     		cbnz	r3, .L86
1534:FreeRTOS/Source/tasks.c **** 			}
 1515              		.loc 1 1534 0
 1516 0052 40F20003 		movw	r3, #:lower16:.LANCHOR10
 1517 0056 C0F20003 		movt	r3, #:upper16:.LANCHOR10
 1518 005a 4FF0FF32 		mov	r2, #-1
 1519 005e 1A60     		str	r2, [r3]
 1520 0060 0CE0     		b	.L85
 1521              	.L86:
1542:FreeRTOS/Source/tasks.c **** 				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
 1522              		.loc 1 1542 0
 1523 0062 40F20003 		movw	r3, #:lower16:.LANCHOR6
 1524 0066 C0F20003 		movt	r3, #:upper16:.LANCHOR6
 1525 006a 1B68     		ldr	r3, [r3]
 1526 006c DB68     		ldr	r3, [r3, #12]
 1527 006e DB68     		ldr	r3, [r3, #12]
 1528              	.LVL140:
1543:FreeRTOS/Source/tasks.c **** 			}
 1529              		.loc 1 1543 0
 1530 0070 5A68     		ldr	r2, [r3, #4]
 1531 0072 40F20003 		movw	r3, #:lower16:.LANCHOR10
 1532              	.LVL141:
 1533 0076 C0F20003 		movt	r3, #:upper16:.LANCHOR10
 1534 007a 1A60     		str	r2, [r3]
 1535              	.L85:
 1536              	.LBE5:
 1537              	.LBB6:
1548:FreeRTOS/Source/tasks.c **** 	}
 1538              		.loc 1 1548 0
 1539 007c 40F20003 		movw	r3, #:lower16:.LANCHOR9
 1540 0080 C0F20003 		movt	r3, #:upper16:.LANCHOR9
 1541 0084 1A68     		ldr	r2, [r3]
 1542 0086 40F20003 		movw	r3, #:lower16:.LANCHOR10
 1543 008a C0F20003 		movt	r3, #:upper16:.LANCHOR10
 1544 008e 1B68     		ldr	r3, [r3]
 1545 0090 9A42     		cmp	r2, r3
 1546 0092 48D3     		bcc	.L83
1548:FreeRTOS/Source/tasks.c **** 	}
 1547              		.loc 1 1548 0 is_stmt 0 discriminator 1
 1548 0094 40F20006 		movw	r6, #:lower16:.LANCHOR6
 1549 0098 C0F20006 		movt	r6, #:upper16:.LANCHOR6
 1550 009c 40F20008 		movw	r8, #:lower16:.LANCHOR9
 1551 00a0 C0F20008 		movt	r8, #:upper16:.LANCHOR9
 1552 00a4 40F20007 		movw	r7, #:lower16:.LANCHOR16
 1553 00a8 C0F20007 		movt	r7, #:upper16:.LANCHOR16
 1554 00ac 40F20009 		movw	r9, #:lower16:.LANCHOR0
 1555 00b0 C0F20009 		movt	r9, #:upper16:.LANCHOR0
 1556              	.L93:
 1557 00b4 3368     		ldr	r3, [r6]
 1558 00b6 1B68     		ldr	r3, [r3]
 1559 00b8 43B9     		cbnz	r3, .L88
 1560 00ba 40F20003 		movw	r3, #:lower16:.LANCHOR10
 1561 00be C0F20003 		movt	r3, #:upper16:.LANCHOR10
 1562 00c2 4FF0FF32 		mov	r2, #-1
 1563 00c6 1A60     		str	r2, [r3]
 1564 00c8 BDE8F883 		pop	{r3, r4, r5, r6, r7, r8, r9, pc}
 1565              	.L88:
1548:FreeRTOS/Source/tasks.c **** 	}
 1566              		.loc 1 1548 0 discriminator 2
 1567 00cc 3368     		ldr	r3, [r6]
 1568 00ce DB68     		ldr	r3, [r3, #12]
 1569 00d0 DC68     		ldr	r4, [r3, #12]
 1570              	.LVL142:
 1571 00d2 6368     		ldr	r3, [r4, #4]
 1572              	.LVL143:
 1573 00d4 D8F80020 		ldr	r2, [r8]
 1574 00d8 9A42     		cmp	r2, r3
 1575 00da 06D2     		bcs	.L89
1548:FreeRTOS/Source/tasks.c **** 	}
 1576              		.loc 1 1548 0 discriminator 1
 1577 00dc 40F20002 		movw	r2, #:lower16:.LANCHOR10
 1578 00e0 C0F20002 		movt	r2, #:upper16:.LANCHOR10
 1579 00e4 1360     		str	r3, [r2]
 1580 00e6 BDE8F883 		pop	{r3, r4, r5, r6, r7, r8, r9, pc}
 1581              	.LVL144:
 1582              	.L89:
1548:FreeRTOS/Source/tasks.c **** 	}
 1583              		.loc 1 1548 0 discriminator 2
 1584 00ea 251D     		adds	r5, r4, #4
 1585 00ec 2846     		mov	r0, r5
 1586 00ee FFF7FEFF 		bl	vListRemove
 1587              	.LVL145:
 1588 00f2 A36A     		ldr	r3, [r4, #40]
 1589 00f4 1BB1     		cbz	r3, .L90
1548:FreeRTOS/Source/tasks.c **** 	}
 1590              		.loc 1 1548 0 discriminator 1
 1591 00f6 04F11800 		add	r0, r4, #24
 1592 00fa FFF7FEFF 		bl	vListRemove
 1593              	.LVL146:
 1594              	.L90:
1548:FreeRTOS/Source/tasks.c **** 	}
 1595              		.loc 1 1548 0 discriminator 2
 1596 00fe E36A     		ldr	r3, [r4, #44]
 1597 0100 3A68     		ldr	r2, [r7]
 1598 0102 9342     		cmp	r3, r2
 1599 0104 88BF     		it	hi
 1600 0106 3B60     		strhi	r3, [r7]
 1601 0108 03EB8300 		add	r0, r3, r3, lsl #2
 1602 010c 09EB8000 		add	r0, r9, r0, lsl #2
 1603 0110 2946     		mov	r1, r5
 1604 0112 FFF7FEFF 		bl	vListInsertEnd
 1605              	.LVL147:
 1606 0116 CDE7     		b	.L93
 1607              	.LVL148:
 1608              	.L84:
 1609              	.LBE6:
1552:FreeRTOS/Source/tasks.c **** 
 1610              		.loc 1 1552 0 is_stmt 1
 1611 0118 40F20003 		movw	r3, #:lower16:.LANCHOR21
 1612 011c C0F20003 		movt	r3, #:upper16:.LANCHOR21
 1613 0120 1A68     		ldr	r2, [r3]
 1614 0122 0132     		adds	r2, r2, #1
 1615 0124 1A60     		str	r2, [r3]
 1616              	.L83:
 1617 0126 BDE8F883 		pop	{r3, r4, r5, r6, r7, r8, r9, pc}
 1618              		.cfi_endproc
 1619              	.LFE129:
 1621 012a 00BF     		.section	.text.xTaskResumeAll,"ax",%progbits
 1622              		.align	2
 1623              		.global	xTaskResumeAll
 1624              		.thumb
 1625              		.thumb_func
 1627              	xTaskResumeAll:
 1628              	.LFB123:
1173:FreeRTOS/Source/tasks.c **** register tskTCB *pxTCB;
 1629              		.loc 1 1173 0
 1630              		.cfi_startproc
 1631              		@ args = 0, pretend = 0, frame = 0
 1632              		@ frame_needed = 0, uses_anonymous_args = 0
 1633 0000 2DE9F047 		push	{r4, r5, r6, r7, r8, r9, r10, lr}
 1634              	.LCFI19:
 1635              		.cfi_def_cfa_offset 32
 1636              		.cfi_offset 4, -32
 1637              		.cfi_offset 5, -28
 1638              		.cfi_offset 6, -24
 1639              		.cfi_offset 7, -20
 1640              		.cfi_offset 8, -16
 1641              		.cfi_offset 9, -12
 1642              		.cfi_offset 10, -8
 1643              		.cfi_offset 14, -4
 1644              	.LVL149:
1186:FreeRTOS/Source/tasks.c **** 	{
 1645              		.loc 1 1186 0
 1646 0004 FFF7FEFF 		bl	vPortEnterCritical
 1647              	.LVL150:
1188:FreeRTOS/Source/tasks.c **** 
 1648              		.loc 1 1188 0
 1649 0008 40F20003 		movw	r3, #:lower16:.LANCHOR18
 1650 000c C0F20003 		movt	r3, #:upper16:.LANCHOR18
 1651 0010 1A68     		ldr	r2, [r3]
 1652 0012 013A     		subs	r2, r2, #1
 1653 0014 1A60     		str	r2, [r3]
1190:FreeRTOS/Source/tasks.c **** 		{
 1654              		.loc 1 1190 0
 1655 0016 1B68     		ldr	r3, [r3]
1175:FreeRTOS/Source/tasks.c **** 
 1656              		.loc 1 1175 0
 1657 0018 0024     		movs	r4, #0
1190:FreeRTOS/Source/tasks.c **** 		{
 1658              		.loc 1 1190 0
 1659 001a 002B     		cmp	r3, #0
 1660 001c 65D1     		bne	.L95
1192:FreeRTOS/Source/tasks.c **** 			{
 1661              		.loc 1 1192 0
 1662 001e 40F20003 		movw	r3, #:lower16:.LANCHOR12
 1663 0022 C0F20003 		movt	r3, #:upper16:.LANCHOR12
 1664 0026 1B68     		ldr	r3, [r3]
 1665 0028 0BBB     		cbnz	r3, .L105
1175:FreeRTOS/Source/tasks.c **** 
 1666              		.loc 1 1175 0
 1667 002a 0024     		movs	r4, #0
 1668 002c 5DE0     		b	.L95
 1669              	.LVL151:
 1670              	.L99:
 1671              	.LBB7:
1200:FreeRTOS/Source/tasks.c **** 					vListRemove( &( pxTCB->xEventListItem ) );
 1672              		.loc 1 1200 0
 1673 002e F368     		ldr	r3, [r6, #12]
 1674 0030 DC68     		ldr	r4, [r3, #12]
 1675              	.LVL152:
1201:FreeRTOS/Source/tasks.c **** 					vListRemove( &( pxTCB->xGenericListItem ) );
 1676              		.loc 1 1201 0
 1677 0032 04F11800 		add	r0, r4, #24
 1678 0036 FFF7FEFF 		bl	vListRemove
 1679              	.LVL153:
1202:FreeRTOS/Source/tasks.c **** 					prvAddTaskToReadyQueue( pxTCB );
 1680              		.loc 1 1202 0
 1681 003a 251D     		adds	r5, r4, #4
 1682 003c 2846     		mov	r0, r5
 1683 003e FFF7FEFF 		bl	vListRemove
 1684              	.LVL154:
1203:FreeRTOS/Source/tasks.c **** 
 1685              		.loc 1 1203 0
 1686 0042 E36A     		ldr	r3, [r4, #44]
 1687 0044 D8F80020 		ldr	r2, [r8]
 1688 0048 9342     		cmp	r3, r2
 1689 004a 88BF     		it	hi
 1690 004c C8F80030 		strhi	r3, [r8]
 1691 0050 03EB8300 		add	r0, r3, r3, lsl #2
 1692 0054 0AEB8000 		add	r0, r10, r0, lsl #2
 1693 0058 2946     		mov	r1, r5
 1694 005a FFF7FEFF 		bl	vListInsertEnd
 1695              	.LVL155:
1207:FreeRTOS/Source/tasks.c **** 					{
 1696              		.loc 1 1207 0
 1697 005e E26A     		ldr	r2, [r4, #44]
 1698 0060 D9F80030 		ldr	r3, [r9]
 1699 0064 DB6A     		ldr	r3, [r3, #44]
1209:FreeRTOS/Source/tasks.c **** 					}
 1700              		.loc 1 1209 0
 1701 0066 9A42     		cmp	r2, r3
 1702 0068 28BF     		it	cs
 1703 006a 0127     		movcs	r7, #1
 1704              	.LVL156:
 1705 006c 10E0     		b	.L96
 1706              	.LVL157:
 1707              	.L105:
 1708              	.LBE7:
 1709 006e 0027     		movs	r7, #0
 1710              	.LBB8:
1198:FreeRTOS/Source/tasks.c **** 				{
 1711              		.loc 1 1198 0
 1712 0070 40F20006 		movw	r6, #:lower16:.LANCHOR3
 1713 0074 C0F20006 		movt	r6, #:upper16:.LANCHOR3
1203:FreeRTOS/Source/tasks.c **** 
 1714              		.loc 1 1203 0
 1715 0078 40F20008 		movw	r8, #:lower16:.LANCHOR16
 1716 007c C0F20008 		movt	r8, #:upper16:.LANCHOR16
 1717 0080 40F2000A 		movw	r10, #:lower16:.LANCHOR0
 1718 0084 C0F2000A 		movt	r10, #:upper16:.LANCHOR0
1207:FreeRTOS/Source/tasks.c **** 					{
 1719              		.loc 1 1207 0
 1720 0088 40F20009 		movw	r9, #:lower16:.LANCHOR8
 1721 008c C0F20009 		movt	r9, #:upper16:.LANCHOR8
 1722              	.L96:
 1723              	.LVL158:
1198:FreeRTOS/Source/tasks.c **** 				{
 1724              		.loc 1 1198 0 discriminator 1
 1725 0090 3368     		ldr	r3, [r6]
 1726 0092 002B     		cmp	r3, #0
 1727 0094 CBD1     		bne	.L99
1216:FreeRTOS/Source/tasks.c **** 				{
 1728              		.loc 1 1216 0
 1729 0096 40F20003 		movw	r3, #:lower16:.LANCHOR21
 1730 009a C0F20003 		movt	r3, #:upper16:.LANCHOR21
 1731 009e 1B68     		ldr	r3, [r3]
 1732 00a0 33B9     		cbnz	r3, .L100
 1733 00a2 0DE0     		b	.L101
 1734              	.L102:
1220:FreeRTOS/Source/tasks.c **** 						--uxMissedTicks;
 1735              		.loc 1 1220 0
 1736 00a4 FFF7FEFF 		bl	vTaskIncrementTick
 1737              	.LVL159:
1221:FreeRTOS/Source/tasks.c **** 					}
 1738              		.loc 1 1221 0
 1739 00a8 2368     		ldr	r3, [r4]
 1740 00aa 013B     		subs	r3, r3, #1
 1741 00ac 2360     		str	r3, [r4]
 1742 00ae 03E0     		b	.L108
 1743              	.L100:
1218:FreeRTOS/Source/tasks.c **** 					{
 1744              		.loc 1 1218 0 discriminator 1
 1745 00b0 40F20004 		movw	r4, #:lower16:.LANCHOR21
 1746 00b4 C0F20004 		movt	r4, #:upper16:.LANCHOR21
 1747              	.L108:
 1748 00b8 2368     		ldr	r3, [r4]
 1749 00ba 002B     		cmp	r3, #0
 1750 00bc F2D1     		bne	.L102
1229:FreeRTOS/Source/tasks.c **** 					}
 1751              		.loc 1 1229 0
 1752 00be 0127     		movs	r7, #1
 1753              	.LVL160:
 1754              	.L101:
1234:FreeRTOS/Source/tasks.c **** 				{
 1755              		.loc 1 1234 0
 1756 00c0 012F     		cmp	r7, #1
 1757 00c2 08D0     		beq	.L103
1234:FreeRTOS/Source/tasks.c **** 				{
 1758              		.loc 1 1234 0 is_stmt 0 discriminator 1
 1759 00c4 40F20003 		movw	r3, #:lower16:.LANCHOR22
 1760 00c8 C0F20003 		movt	r3, #:upper16:.LANCHOR22
 1761 00cc 1B68     		ldr	r3, [r3]
 1762 00ce 012B     		cmp	r3, #1
 1763              	.LBE8:
1175:FreeRTOS/Source/tasks.c **** 
 1764              		.loc 1 1175 0 is_stmt 1 discriminator 1
 1765 00d0 18BF     		it	ne
 1766 00d2 0024     		movne	r4, #0
 1767              	.LBB9:
1234:FreeRTOS/Source/tasks.c **** 				{
 1768              		.loc 1 1234 0 discriminator 1
 1769 00d4 09D1     		bne	.L95
 1770              	.L103:
 1771              	.LVL161:
1237:FreeRTOS/Source/tasks.c **** 					portYIELD_WITHIN_API();
 1772              		.loc 1 1237 0
 1773 00d6 40F20003 		movw	r3, #:lower16:.LANCHOR22
 1774 00da C0F20003 		movt	r3, #:upper16:.LANCHOR22
 1775 00de 0022     		movs	r2, #0
 1776 00e0 1A60     		str	r2, [r3]
1238:FreeRTOS/Source/tasks.c **** 				}
 1777              		.loc 1 1238 0
 1778 00e2 FFF7FEFF 		bl	vPortYieldFromISR
 1779              	.LVL162:
1236:FreeRTOS/Source/tasks.c **** 					xMissedYield = pdFALSE;
 1780              		.loc 1 1236 0
 1781 00e6 0124     		movs	r4, #1
 1782 00e8 FFE7     		b	.L95
 1783              	.LVL163:
 1784              	.L95:
 1785              	.LBE9:
1243:FreeRTOS/Source/tasks.c **** 
 1786              		.loc 1 1243 0
 1787 00ea FFF7FEFF 		bl	vPortExitCritical
 1788              	.LVL164:
1246:FreeRTOS/Source/tasks.c **** 
 1789              		.loc 1 1246 0
 1790 00ee 2046     		mov	r0, r4
 1791 00f0 BDE8F087 		pop	{r4, r5, r6, r7, r8, r9, r10, pc}
 1792              		.cfi_endproc
 1793              	.LFE123:
 1795              		.section	.text.vTaskDelayUntil,"ax",%progbits
 1796              		.align	2
 1797              		.global	vTaskDelayUntil
 1798              		.thumb
 1799              		.thumb_func
 1801              	vTaskDelayUntil:
 1802              	.LFB112:
 664:FreeRTOS/Source/tasks.c **** 	portTickType xTimeToWake;
 1803              		.loc 1 664 0
 1804              		.cfi_startproc
 1805              		@ args = 0, pretend = 0, frame = 0
 1806              		@ frame_needed = 0, uses_anonymous_args = 0
 1807              	.LVL165:
 1808 0000 38B5     		push	{r3, r4, r5, lr}
 1809              	.LCFI20:
 1810              		.cfi_def_cfa_offset 16
 1811              		.cfi_offset 3, -16
 1812              		.cfi_offset 4, -12
 1813              		.cfi_offset 5, -8
 1814              		.cfi_offset 14, -4
 1815 0002 0546     		mov	r5, r0
 1816 0004 0C46     		mov	r4, r1
 1817              	.LVL166:
 671:FreeRTOS/Source/tasks.c **** 		{
 1818              		.loc 1 671 0
 1819 0006 FFF7FEFF 		bl	vTaskSuspendAll
 1820              	.LVL167:
 674:FreeRTOS/Source/tasks.c **** 
 1821              		.loc 1 674 0
 1822 000a 2B68     		ldr	r3, [r5]
 1823 000c 1C44     		add	r4, r4, r3
 1824              	.LVL168:
 676:FreeRTOS/Source/tasks.c **** 			{
 1825              		.loc 1 676 0
 1826 000e 40F20002 		movw	r2, #:lower16:.LANCHOR9
 1827 0012 C0F20002 		movt	r2, #:upper16:.LANCHOR9
 1828 0016 1268     		ldr	r2, [r2]
 1829 0018 9342     		cmp	r3, r2
 1830 001a 0DD9     		bls	.L110
 683:FreeRTOS/Source/tasks.c **** 				{
 1831              		.loc 1 683 0
 1832 001c A342     		cmp	r3, r4
 666:FreeRTOS/Source/tasks.c **** 
 1833              		.loc 1 666 0
 1834 001e 98BF     		it	ls
 1835 0020 0023     		movls	r3, #0
 683:FreeRTOS/Source/tasks.c **** 				{
 1836              		.loc 1 683 0
 1837 0022 17D9     		bls	.L111
 683:FreeRTOS/Source/tasks.c **** 				{
 1838              		.loc 1 683 0 is_stmt 0 discriminator 1
 1839 0024 40F20003 		movw	r3, #:lower16:.LANCHOR9
 1840 0028 C0F20003 		movt	r3, #:upper16:.LANCHOR9
 1841 002c 1B68     		ldr	r3, [r3]
 666:FreeRTOS/Source/tasks.c **** 
 1842              		.loc 1 666 0 is_stmt 1 discriminator 1
 1843 002e 9C42     		cmp	r4, r3
 1844 0030 94BF     		ite	ls
 1845 0032 0023     		movls	r3, #0
 1846 0034 0123     		movhi	r3, #1
 1847 0036 0DE0     		b	.L111
 1848              	.L110:
 693:FreeRTOS/Source/tasks.c **** 				{
 1849              		.loc 1 693 0
 1850 0038 A342     		cmp	r3, r4
 695:FreeRTOS/Source/tasks.c **** 				}
 1851              		.loc 1 695 0
 1852 003a 88BF     		it	hi
 1853 003c 0123     		movhi	r3, #1
 693:FreeRTOS/Source/tasks.c **** 				{
 1854              		.loc 1 693 0
 1855 003e 09D8     		bhi	.L111
 693:FreeRTOS/Source/tasks.c **** 				{
 1856              		.loc 1 693 0 is_stmt 0 discriminator 1
 1857 0040 40F20003 		movw	r3, #:lower16:.LANCHOR9
 1858 0044 C0F20003 		movt	r3, #:upper16:.LANCHOR9
 1859 0048 1B68     		ldr	r3, [r3]
 666:FreeRTOS/Source/tasks.c **** 
 1860              		.loc 1 666 0 is_stmt 1 discriminator 1
 1861 004a 9C42     		cmp	r4, r3
 1862 004c 94BF     		ite	ls
 1863 004e 0023     		movls	r3, #0
 1864 0050 0123     		movhi	r3, #1
 1865 0052 FFE7     		b	.L111
 1866              	.L111:
 1867              	.LVL169:
 700:FreeRTOS/Source/tasks.c **** 
 1868              		.loc 1 700 0
 1869 0054 2C60     		str	r4, [r5]
 702:FreeRTOS/Source/tasks.c **** 			{
 1870              		.loc 1 702 0
 1871 0056 53B1     		cbz	r3, .L112
 709:FreeRTOS/Source/tasks.c **** 				prvAddCurrentTaskToDelayedList( xTimeToWake );
 1872              		.loc 1 709 0
 1873 0058 40F20003 		movw	r3, #:lower16:.LANCHOR8
 1874              	.LVL170:
 1875 005c C0F20003 		movt	r3, #:upper16:.LANCHOR8
 1876 0060 1868     		ldr	r0, [r3]
 1877 0062 0430     		adds	r0, r0, #4
 1878 0064 FFF7FEFF 		bl	vListRemove
 1879              	.LVL171:
 710:FreeRTOS/Source/tasks.c **** 			}
 1880              		.loc 1 710 0
 1881 0068 2046     		mov	r0, r4
 1882 006a FFF7FEFF 		bl	prvAddCurrentTaskToDelayedList
 1883              	.LVL172:
 1884              	.L112:
 713:FreeRTOS/Source/tasks.c **** 
 1885              		.loc 1 713 0
 1886 006e FFF7FEFF 		bl	xTaskResumeAll
 1887              	.LVL173:
 717:FreeRTOS/Source/tasks.c **** 		{
 1888              		.loc 1 717 0
 1889 0072 08B9     		cbnz	r0, .L109
 719:FreeRTOS/Source/tasks.c **** 		}
 1890              		.loc 1 719 0
 1891 0074 FFF7FEFF 		bl	vPortYieldFromISR
 1892              	.LVL174:
 1893              	.L109:
 1894 0078 38BD     		pop	{r3, r4, r5, pc}
 1895              		.cfi_endproc
 1896              	.LFE112:
 1898 007a 00BF     		.section	.text.vTaskDelay,"ax",%progbits
 1899              		.align	2
 1900              		.global	vTaskDelay
 1901              		.thumb
 1902              		.thumb_func
 1904              	vTaskDelay:
 1905              	.LFB113:
 729:FreeRTOS/Source/tasks.c **** 	portTickType xTimeToWake;
 1906              		.loc 1 729 0
 1907              		.cfi_startproc
 1908              		@ args = 0, pretend = 0, frame = 0
 1909              		@ frame_needed = 0, uses_anonymous_args = 0
 1910              	.LVL175:
 1911 0000 10B5     		push	{r4, lr}
 1912              	.LCFI21:
 1913              		.cfi_def_cfa_offset 8
 1914              		.cfi_offset 4, -8
 1915              		.cfi_offset 14, -4
 1916              	.LVL176:
 734:FreeRTOS/Source/tasks.c **** 		{
 1917              		.loc 1 734 0
 1918 0002 0446     		mov	r4, r0
 1919 0004 A8B1     		cbz	r0, .L121
 736:FreeRTOS/Source/tasks.c **** 			{
 1920              		.loc 1 736 0
 1921 0006 FFF7FEFF 		bl	vTaskSuspendAll
 1922              	.LVL177:
 750:FreeRTOS/Source/tasks.c **** 
 1923              		.loc 1 750 0
 1924 000a 40F20003 		movw	r3, #:lower16:.LANCHOR9
 1925 000e C0F20003 		movt	r3, #:upper16:.LANCHOR9
 1926 0012 1B68     		ldr	r3, [r3]
 1927 0014 1C44     		add	r4, r4, r3
 1928              	.LVL178:
 755:FreeRTOS/Source/tasks.c **** 				prvAddCurrentTaskToDelayedList( xTimeToWake );
 1929              		.loc 1 755 0
 1930 0016 40F20003 		movw	r3, #:lower16:.LANCHOR8
 1931 001a C0F20003 		movt	r3, #:upper16:.LANCHOR8
 1932 001e 1868     		ldr	r0, [r3]
 1933 0020 0430     		adds	r0, r0, #4
 1934 0022 FFF7FEFF 		bl	vListRemove
 1935              	.LVL179:
 756:FreeRTOS/Source/tasks.c **** 			}
 1936              		.loc 1 756 0
 1937 0026 2046     		mov	r0, r4
 1938 0028 FFF7FEFF 		bl	prvAddCurrentTaskToDelayedList
 1939              	.LVL180:
 758:FreeRTOS/Source/tasks.c **** 		}
 1940              		.loc 1 758 0
 1941 002c FFF7FEFF 		bl	xTaskResumeAll
 1942              	.LVL181:
 1943 0030 00E0     		b	.L119
 1944              	.LVL182:
 1945              	.L121:
 731:FreeRTOS/Source/tasks.c **** 
 1946              		.loc 1 731 0
 1947 0032 0020     		movs	r0, #0
 1948              	.LVL183:
 1949              	.L119:
 763:FreeRTOS/Source/tasks.c **** 		{
 1950              		.loc 1 763 0
 1951 0034 08B9     		cbnz	r0, .L118
 765:FreeRTOS/Source/tasks.c **** 		}
 1952              		.loc 1 765 0
 1953 0036 FFF7FEFF 		bl	vPortYieldFromISR
 1954              	.LVL184:
 1955              	.L118:
 1956 003a 10BD     		pop	{r4, pc}
 1957              		.cfi_endproc
 1958              	.LFE113:
 1960              		.section	.text.prvCheckTasksWaitingTermination,"ax",%progbits
 1961              		.align	2
 1962              		.thumb
 1963              		.thumb_func
 1965              	prvCheckTasksWaitingTermination:
 1966              	.LFB142:
2104:FreeRTOS/Source/tasks.c **** 	#if ( INCLUDE_vTaskDelete == 1 )
 1967              		.loc 1 2104 0
 1968              		.cfi_startproc
 1969              		@ args = 0, pretend = 0, frame = 0
 1970              		@ frame_needed = 0, uses_anonymous_args = 0
 1971 0000 10B5     		push	{r4, lr}
 1972              	.LCFI22:
 1973              		.cfi_def_cfa_offset 8
 1974              		.cfi_offset 4, -8
 1975              		.cfi_offset 14, -4
 1976              	.LBB10:
2111:FreeRTOS/Source/tasks.c **** 		{
 1977              		.loc 1 2111 0
 1978 0002 40F20003 		movw	r3, #:lower16:.LANCHOR17
 1979 0006 C0F20003 		movt	r3, #:upper16:.LANCHOR17
 1980 000a 1B68     		ldr	r3, [r3]
 1981 000c 3BB3     		cbz	r3, .L122
2113:FreeRTOS/Source/tasks.c **** 				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
 1982              		.loc 1 2113 0
 1983 000e FFF7FEFF 		bl	vTaskSuspendAll
 1984              	.LVL185:
2114:FreeRTOS/Source/tasks.c **** 			xTaskResumeAll();
 1985              		.loc 1 2114 0
 1986 0012 40F20003 		movw	r3, #:lower16:.LANCHOR4
 1987 0016 C0F20003 		movt	r3, #:upper16:.LANCHOR4
 1988 001a 1C68     		ldr	r4, [r3]
 1989              	.LVL186:
2115:FreeRTOS/Source/tasks.c **** 
 1990              		.loc 1 2115 0
 1991 001c FFF7FEFF 		bl	xTaskResumeAll
 1992              	.LVL187:
2117:FreeRTOS/Source/tasks.c **** 			{
 1993              		.loc 1 2117 0
 1994 0020 ECB1     		cbz	r4, .L122
 1995              	.LBB11:
2121:FreeRTOS/Source/tasks.c **** 				{
 1996              		.loc 1 2121 0
 1997 0022 FFF7FEFF 		bl	vPortEnterCritical
 1998              	.LVL188:
2123:FreeRTOS/Source/tasks.c **** 					vListRemove( &( pxTCB->xGenericListItem ) );
 1999              		.loc 1 2123 0
 2000 0026 40F20003 		movw	r3, #:lower16:.LANCHOR4
 2001 002a C0F20003 		movt	r3, #:upper16:.LANCHOR4
 2002 002e DB68     		ldr	r3, [r3, #12]
 2003 0030 DC68     		ldr	r4, [r3, #12]
 2004              	.LVL189:
2124:FreeRTOS/Source/tasks.c **** 					--uxCurrentNumberOfTasks;
 2005              		.loc 1 2124 0
 2006 0032 201D     		adds	r0, r4, #4
 2007 0034 FFF7FEFF 		bl	vListRemove
 2008              	.LVL190:
2125:FreeRTOS/Source/tasks.c **** 					--uxTasksDeleted;
 2009              		.loc 1 2125 0
 2010 0038 40F20003 		movw	r3, #:lower16:.LANCHOR12
 2011 003c C0F20003 		movt	r3, #:upper16:.LANCHOR12
 2012 0040 1A68     		ldr	r2, [r3]
 2013 0042 013A     		subs	r2, r2, #1
 2014 0044 1A60     		str	r2, [r3]
2126:FreeRTOS/Source/tasks.c **** 				}
 2015              		.loc 1 2126 0
 2016 0046 40F20003 		movw	r3, #:lower16:.LANCHOR17
 2017 004a C0F20003 		movt	r3, #:upper16:.LANCHOR17
 2018 004e 1A68     		ldr	r2, [r3]
 2019 0050 013A     		subs	r2, r2, #1
 2020 0052 1A60     		str	r2, [r3]
2128:FreeRTOS/Source/tasks.c **** 
 2021              		.loc 1 2128 0
 2022 0054 FFF7FEFF 		bl	vPortExitCritical
 2023              	.LVL191:
2130:FreeRTOS/Source/tasks.c **** 			}
 2024              		.loc 1 2130 0
 2025 0058 2046     		mov	r0, r4
 2026 005a FFF7FEFF 		bl	prvDeleteTCB
 2027              	.LVL192:
 2028              	.L122:
 2029 005e 10BD     		pop	{r4, pc}
 2030              	.LBE11:
 2031              	.LBE10:
 2032              		.cfi_endproc
 2033              	.LFE142:
 2035              		.section	.text.prvIdleTask,"ax",%progbits
 2036              		.align	2
 2037              		.thumb
 2038              		.thumb_func
 2040              	prvIdleTask:
 2041              	.LFB139:
1921:FreeRTOS/Source/tasks.c **** 	/* Stop warnings. */
 2042              		.loc 1 1921 0
 2043              		.cfi_startproc
 2044              		@ Volatile: function does not return.
 2045              		@ args = 0, pretend = 0, frame = 0
 2046              		@ frame_needed = 0, uses_anonymous_args = 0
 2047              	.LVL193:
 2048 0000 08B5     		push	{r3, lr}
 2049              	.LCFI23:
 2050              		.cfi_def_cfa_offset 8
 2051              		.cfi_offset 3, -8
 2052              		.cfi_offset 14, -4
1951:FreeRTOS/Source/tasks.c **** 			{
 2053              		.loc 1 1951 0
 2054 0002 40F20004 		movw	r4, #:lower16:.LANCHOR0
 2055 0006 C0F20004 		movt	r4, #:upper16:.LANCHOR0
 2056              	.LVL194:
 2057              	.L127:
1928:FreeRTOS/Source/tasks.c **** 
 2058              		.loc 1 1928 0
 2059 000a FFF7FEFF 		bl	prvCheckTasksWaitingTermination
 2060              	.LVL195:
1951:FreeRTOS/Source/tasks.c **** 			{
 2061              		.loc 1 1951 0
 2062 000e 2368     		ldr	r3, [r4]
 2063 0010 012B     		cmp	r3, #1
 2064 0012 FAD9     		bls	.L127
1953:FreeRTOS/Source/tasks.c **** 			}
 2065              		.loc 1 1953 0
 2066 0014 FFF7FEFF 		bl	vPortYieldFromISR
 2067              	.LVL196:
 2068 0018 F7E7     		b	.L127
 2069              		.cfi_endproc
 2070              	.LFE139:
 2072 001a 00BF     		.section	.text.vTaskGetRunTimeStats,"ax",%progbits
 2073              		.align	2
 2074              		.global	vTaskGetRunTimeStats
 2075              		.thumb
 2076              		.thumb_func
 2078              	vTaskGetRunTimeStats:
 2079              	.LFB127:
1376:FreeRTOS/Source/tasks.c **** 	unsigned portBASE_TYPE uxQueue;
 2080              		.loc 1 1376 0
 2081              		.cfi_startproc
 2082              		@ args = 0, pretend = 0, frame = 0
 2083              		@ frame_needed = 0, uses_anonymous_args = 0
 2084              	.LVL197:
 2085 0000 2DE9F041 		push	{r4, r5, r6, r7, r8, lr}
 2086              	.LCFI24:
 2087              		.cfi_def_cfa_offset 24
 2088              		.cfi_offset 4, -24
 2089              		.cfi_offset 5, -20
 2090              		.cfi_offset 6, -16
 2091              		.cfi_offset 7, -12
 2092              		.cfi_offset 8, -8
 2093              		.cfi_offset 14, -4
 2094 0004 0646     		mov	r6, r0
1383:FreeRTOS/Source/tasks.c **** 		{
 2095              		.loc 1 1383 0
 2096 0006 FFF7FEFF 		bl	vTaskSuspendAll
 2097              	.LVL198:
1388:FreeRTOS/Source/tasks.c **** 			#endif
 2098              		.loc 1 1388 0
 2099 000a FFF7FEFF 		bl	get_us_time
 2100              	.LVL199:
1393:FreeRTOS/Source/tasks.c **** 			
 2101              		.loc 1 1393 0
 2102 000e 48F21F53 		movw	r3, #34079
 2103 0012 C5F2EB13 		movt	r3, 20971
 2104 0016 A3FB0027 		umull	r2, r7, r3, r0
 2105 001a 7F09     		lsrs	r7, r7, #5
 2106              	.LVL200:
1399:FreeRTOS/Source/tasks.c **** 			strcat( ( char * ) pcWriteBuffer, ( const char * ) "\r\n" );
 2107              		.loc 1 1399 0
 2108 001c 0023     		movs	r3, #0
 2109 001e 3370     		strb	r3, [r6]
1400:FreeRTOS/Source/tasks.c **** 
 2110              		.loc 1 1400 0
 2111 0020 3046     		mov	r0, r6
 2112 0022 FFF7FEFF 		bl	strlen
 2113              	.LVL201:
 2114 0026 3218     		adds	r2, r6, r0
 2115 0028 40F20003 		movw	r3, #:lower16:.LC4
 2116 002c C0F20003 		movt	r3, #:upper16:.LC4
 2117 0030 1988     		ldrh	r1, [r3]	@ unaligned
 2118 0032 9B78     		ldrb	r3, [r3, #2]	@ zero_extendqisi2
 2119 0034 3152     		strh	r1, [r6, r0]	@ unaligned
 2120 0036 9370     		strb	r3, [r2, #2]
1402:FreeRTOS/Source/tasks.c **** 
 2121              		.loc 1 1402 0
 2122 0038 40F20003 		movw	r3, #:lower16:.LANCHOR14
 2123 003c C0F20003 		movt	r3, #:upper16:.LANCHOR14
 2124 0040 1C68     		ldr	r4, [r3]
 2125 0042 0134     		adds	r4, r4, #1
 2126              	.LVL202:
1408:FreeRTOS/Source/tasks.c **** 				{
 2127              		.loc 1 1408 0
 2128 0044 40F20005 		movw	r5, #:lower16:.LANCHOR0
 2129 0048 C0F20005 		movt	r5, #:upper16:.LANCHOR0
1410:FreeRTOS/Source/tasks.c **** 				}
 2130              		.loc 1 1410 0
 2131 004c 4FF05208 		mov	r8, #82
 2132              	.L130:
1406:FreeRTOS/Source/tasks.c **** 
 2133              		.loc 1 1406 0
 2134 0050 013C     		subs	r4, r4, #1
 2135              	.LVL203:
1408:FreeRTOS/Source/tasks.c **** 				{
 2136              		.loc 1 1408 0
 2137 0052 04EB8401 		add	r1, r4, r4, lsl #2
 2138 0056 55F82110 		ldr	r1, [r5, r1, lsl #2]
 2139 005a 41B1     		cbz	r1, .L129
1410:FreeRTOS/Source/tasks.c **** 				}
 2140              		.loc 1 1410 0
 2141 005c 04EB8401 		add	r1, r4, r4, lsl #2
 2142 0060 3046     		mov	r0, r6
 2143 0062 05EB8101 		add	r1, r5, r1, lsl #2
 2144 0066 3A46     		mov	r2, r7
 2145 0068 4346     		mov	r3, r8
 2146 006a FFF7FEFF 		bl	prvGenerateRunTimeStatsForTasksInList
 2147              	.LVL204:
 2148              	.L129:
1412:FreeRTOS/Source/tasks.c **** 
 2149              		.loc 1 1412 0
 2150 006e 002C     		cmp	r4, #0
 2151 0070 EED1     		bne	.L130
1414:FreeRTOS/Source/tasks.c **** 			{
 2152              		.loc 1 1414 0
 2153 0072 40F20003 		movw	r3, #:lower16:.LANCHOR6
 2154 0076 C0F20003 		movt	r3, #:upper16:.LANCHOR6
 2155 007a 1B68     		ldr	r3, [r3]
 2156 007c 1B68     		ldr	r3, [r3]
 2157 007e 4BB1     		cbz	r3, .L131
1416:FreeRTOS/Source/tasks.c **** 			}
 2158              		.loc 1 1416 0
 2159 0080 40F20003 		movw	r3, #:lower16:.LANCHOR6
 2160 0084 C0F20003 		movt	r3, #:upper16:.LANCHOR6
 2161 0088 1968     		ldr	r1, [r3]
 2162 008a 3046     		mov	r0, r6
 2163 008c 3A46     		mov	r2, r7
 2164 008e 4223     		movs	r3, #66
 2165 0090 FFF7FEFF 		bl	prvGenerateRunTimeStatsForTasksInList
 2166              	.LVL205:
 2167              	.L131:
1419:FreeRTOS/Source/tasks.c **** 			{
 2168              		.loc 1 1419 0
 2169 0094 40F20003 		movw	r3, #:lower16:.LANCHOR7
 2170 0098 C0F20003 		movt	r3, #:upper16:.LANCHOR7
 2171 009c 1B68     		ldr	r3, [r3]
 2172 009e 1B68     		ldr	r3, [r3]
 2173 00a0 4BB1     		cbz	r3, .L132
1421:FreeRTOS/Source/tasks.c **** 			}
 2174              		.loc 1 1421 0
 2175 00a2 40F20003 		movw	r3, #:lower16:.LANCHOR7
 2176 00a6 C0F20003 		movt	r3, #:upper16:.LANCHOR7
 2177 00aa 1968     		ldr	r1, [r3]
 2178 00ac 3046     		mov	r0, r6
 2179 00ae 3A46     		mov	r2, r7
 2180 00b0 4223     		movs	r3, #66
 2181 00b2 FFF7FEFF 		bl	prvGenerateRunTimeStatsForTasksInList
 2182              	.LVL206:
 2183              	.L132:
1426:FreeRTOS/Source/tasks.c **** 				{
 2184              		.loc 1 1426 0
 2185 00b6 40F20003 		movw	r3, #:lower16:.LANCHOR4
 2186 00ba C0F20003 		movt	r3, #:upper16:.LANCHOR4
 2187 00be 1B68     		ldr	r3, [r3]
 2188 00c0 43B1     		cbz	r3, .L133
1428:FreeRTOS/Source/tasks.c **** 				}
 2189              		.loc 1 1428 0
 2190 00c2 3046     		mov	r0, r6
 2191 00c4 40F20001 		movw	r1, #:lower16:.LANCHOR4
 2192 00c8 C0F20001 		movt	r1, #:upper16:.LANCHOR4
 2193 00cc 3A46     		mov	r2, r7
 2194 00ce 4423     		movs	r3, #68
 2195 00d0 FFF7FEFF 		bl	prvGenerateRunTimeStatsForTasksInList
 2196              	.LVL207:
 2197              	.L133:
1435:FreeRTOS/Source/tasks.c **** 				{
 2198              		.loc 1 1435 0
 2199 00d4 40F20003 		movw	r3, #:lower16:.LANCHOR5
 2200 00d8 C0F20003 		movt	r3, #:upper16:.LANCHOR5
 2201 00dc 1B68     		ldr	r3, [r3]
 2202 00de 43B1     		cbz	r3, .L134
1437:FreeRTOS/Source/tasks.c **** 				}
 2203              		.loc 1 1437 0
 2204 00e0 3046     		mov	r0, r6
 2205 00e2 40F20001 		movw	r1, #:lower16:.LANCHOR5
 2206 00e6 C0F20001 		movt	r1, #:upper16:.LANCHOR5
 2207 00ea 3A46     		mov	r2, r7
 2208 00ec 5323     		movs	r3, #83
 2209 00ee FFF7FEFF 		bl	prvGenerateRunTimeStatsForTasksInList
 2210              	.LVL208:
 2211              	.L134:
1442:FreeRTOS/Source/tasks.c **** 	}
 2212              		.loc 1 1442 0
 2213 00f2 FFF7FEFF 		bl	xTaskResumeAll
 2214              	.LVL209:
 2215 00f6 BDE8F081 		pop	{r4, r5, r6, r7, r8, pc}
 2216              		.cfi_endproc
 2217              	.LFE127:
 2219 00fa 00BF     		.section	.text.vTaskSetApplicationTaskTag,"ax",%progbits
 2220              		.align	2
 2221              		.global	vTaskSetApplicationTaskTag
 2222              		.thumb
 2223              		.thumb_func
 2225              	vTaskSetApplicationTaskTag:
 2226              	.LFB130:
1581:FreeRTOS/Source/tasks.c **** 	tskTCB *xTCB;
 2227              		.loc 1 1581 0
 2228              		.cfi_startproc
 2229              		@ args = 0, pretend = 0, frame = 0
 2230              		@ frame_needed = 0, uses_anonymous_args = 0
 2231              	.LVL210:
 2232 0000 38B5     		push	{r3, r4, r5, lr}
 2233              	.LCFI25:
 2234              		.cfi_def_cfa_offset 16
 2235              		.cfi_offset 3, -16
 2236              		.cfi_offset 4, -12
 2237              		.cfi_offset 5, -8
 2238              		.cfi_offset 14, -4
 2239 0002 0D46     		mov	r5, r1
1585:FreeRTOS/Source/tasks.c **** 		{
 2240              		.loc 1 1585 0
 2241 0004 0446     		mov	r4, r0
 2242 0006 20B9     		cbnz	r0, .L137
1587:FreeRTOS/Source/tasks.c **** 		}
 2243              		.loc 1 1587 0
 2244 0008 40F20003 		movw	r3, #:lower16:.LANCHOR8
 2245 000c C0F20003 		movt	r3, #:upper16:.LANCHOR8
 2246 0010 1C68     		ldr	r4, [r3]
 2247              	.LVL211:
 2248              	.L137:
1596:FreeRTOS/Source/tasks.c **** 			xTCB->pxTaskTag = pxHookFunction;
 2249              		.loc 1 1596 0
 2250 0012 FFF7FEFF 		bl	vPortEnterCritical
 2251              	.LVL212:
1597:FreeRTOS/Source/tasks.c **** 		taskEXIT_CRITICAL();
 2252              		.loc 1 1597 0
 2253 0016 A564     		str	r5, [r4, #72]
1598:FreeRTOS/Source/tasks.c **** 	}
 2254              		.loc 1 1598 0
 2255 0018 FFF7FEFF 		bl	vPortExitCritical
 2256              	.LVL213:
 2257 001c 38BD     		pop	{r3, r4, r5, pc}
 2258              		.cfi_endproc
 2259              	.LFE130:
 2261 001e 00BF     		.section	.text.xTaskGetApplicationTaskTag,"ax",%progbits
 2262              		.align	2
 2263              		.global	xTaskGetApplicationTaskTag
 2264              		.thumb
 2265              		.thumb_func
 2267              	xTaskGetApplicationTaskTag:
 2268              	.LFB131:
1607:FreeRTOS/Source/tasks.c **** 	tskTCB *xTCB;
 2269              		.loc 1 1607 0
 2270              		.cfi_startproc
 2271              		@ args = 0, pretend = 0, frame = 0
 2272              		@ frame_needed = 0, uses_anonymous_args = 0
 2273              	.LVL214:
 2274 0000 10B5     		push	{r4, lr}
 2275              	.LCFI26:
 2276              		.cfi_def_cfa_offset 8
 2277              		.cfi_offset 4, -8
 2278              		.cfi_offset 14, -4
1612:FreeRTOS/Source/tasks.c **** 		{
 2279              		.loc 1 1612 0
 2280 0002 0446     		mov	r4, r0
 2281 0004 20B9     		cbnz	r0, .L139
1614:FreeRTOS/Source/tasks.c **** 		}
 2282              		.loc 1 1614 0
 2283 0006 40F20003 		movw	r3, #:lower16:.LANCHOR8
 2284 000a C0F20003 		movt	r3, #:upper16:.LANCHOR8
 2285 000e 1C68     		ldr	r4, [r3]
 2286              	.LVL215:
 2287              	.L139:
1623:FreeRTOS/Source/tasks.c **** 			xReturn = xTCB->pxTaskTag;
 2288              		.loc 1 1623 0
 2289 0010 FFF7FEFF 		bl	vPortEnterCritical
 2290              	.LVL216:
1624:FreeRTOS/Source/tasks.c **** 		taskEXIT_CRITICAL();
 2291              		.loc 1 1624 0
 2292 0014 A46C     		ldr	r4, [r4, #72]
 2293              	.LVL217:
1625:FreeRTOS/Source/tasks.c **** 
 2294              		.loc 1 1625 0
 2295 0016 FFF7FEFF 		bl	vPortExitCritical
 2296              	.LVL218:
1628:FreeRTOS/Source/tasks.c **** 
 2297              		.loc 1 1628 0
 2298 001a 2046     		mov	r0, r4
 2299 001c 10BD     		pop	{r4, pc}
 2300              		.cfi_endproc
 2301              	.LFE131:
 2303 001e 00BF     		.section	.text.xTaskCallApplicationTaskHook,"ax",%progbits
 2304              		.align	2
 2305              		.global	xTaskCallApplicationTaskHook
 2306              		.thumb
 2307              		.thumb_func
 2309              	xTaskCallApplicationTaskHook:
 2310              	.LFB132:
1636:FreeRTOS/Source/tasks.c **** 	tskTCB *xTCB;
 2311              		.loc 1 1636 0
 2312              		.cfi_startproc
 2313              		@ args = 0, pretend = 0, frame = 0
 2314              		@ frame_needed = 0, uses_anonymous_args = 0
 2315              	.LVL219:
 2316 0000 08B5     		push	{r3, lr}
 2317              	.LCFI27:
 2318              		.cfi_def_cfa_offset 8
 2319              		.cfi_offset 3, -8
 2320              		.cfi_offset 14, -4
1641:FreeRTOS/Source/tasks.c **** 		{
 2321              		.loc 1 1641 0
 2322 0002 0346     		mov	r3, r0
 2323 0004 20B9     		cbnz	r0, .L141
1643:FreeRTOS/Source/tasks.c **** 		}
 2324              		.loc 1 1643 0
 2325 0006 40F20003 		movw	r3, #:lower16:.LANCHOR8
 2326 000a C0F20003 		movt	r3, #:upper16:.LANCHOR8
 2327 000e 1B68     		ldr	r3, [r3]
 2328              	.LVL220:
 2329              	.L141:
1650:FreeRTOS/Source/tasks.c **** 		{
 2330              		.loc 1 1650 0
 2331 0010 9B6C     		ldr	r3, [r3, #72]
 2332              	.LVL221:
 2333 0012 13B1     		cbz	r3, .L143
1652:FreeRTOS/Source/tasks.c **** 		}
 2334              		.loc 1 1652 0
 2335 0014 0846     		mov	r0, r1
 2336 0016 9847     		blx	r3
 2337              	.LVL222:
 2338 0018 08BD     		pop	{r3, pc}
 2339              	.LVL223:
 2340              	.L143:
1656:FreeRTOS/Source/tasks.c **** 		}
 2341              		.loc 1 1656 0
 2342 001a 0020     		movs	r0, #0
 2343              	.LVL224:
1660:FreeRTOS/Source/tasks.c **** 
 2344              		.loc 1 1660 0
 2345 001c 08BD     		pop	{r3, pc}
 2346              		.cfi_endproc
 2347              	.LFE132:
 2349 001e 00BF     		.section	.text.vTaskSwitchContext,"ax",%progbits
 2350              		.align	2
 2351              		.global	vTaskSwitchContext
 2352              		.thumb
 2353              		.thumb_func
 2355              	vTaskSwitchContext:
 2356              	.LFB133:
1666:FreeRTOS/Source/tasks.c **** 	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
 2357              		.loc 1 1666 0
 2358              		.cfi_startproc
 2359              		@ args = 0, pretend = 0, frame = 0
 2360              		@ frame_needed = 0, uses_anonymous_args = 0
 2361 0000 10B5     		push	{r4, lr}
 2362              	.LCFI28:
 2363              		.cfi_def_cfa_offset 8
 2364              		.cfi_offset 4, -8
 2365              		.cfi_offset 14, -4
1667:FreeRTOS/Source/tasks.c **** 	{
 2366              		.loc 1 1667 0
 2367 0002 40F20003 		movw	r3, #:lower16:.LANCHOR18
 2368 0006 C0F20003 		movt	r3, #:upper16:.LANCHOR18
 2369 000a 1B68     		ldr	r3, [r3]
 2370 000c 33B1     		cbz	r3, .L145
1671:FreeRTOS/Source/tasks.c **** 	}
 2371              		.loc 1 1671 0
 2372 000e 40F20003 		movw	r3, #:lower16:.LANCHOR22
 2373 0012 C0F20003 		movt	r3, #:upper16:.LANCHOR22
 2374 0016 0122     		movs	r2, #1
 2375 0018 1A60     		str	r2, [r3]
 2376 001a 10BD     		pop	{r4, pc}
 2377              	.L145:
 2378              	.LBB12:
1684:FreeRTOS/Source/tasks.c **** 				#endif
 2379              		.loc 1 1684 0
 2380 001c FFF7FEFF 		bl	get_us_time
 2381              	.LVL225:
1692:FreeRTOS/Source/tasks.c **** 				ulTaskSwitchedInTime = ulTempCounter;
 2382              		.loc 1 1692 0
 2383 0020 40F20003 		movw	r3, #:lower16:.LANCHOR8
 2384 0024 C0F20003 		movt	r3, #:upper16:.LANCHOR8
 2385 0028 1A68     		ldr	r2, [r3]
 2386 002a 40F20003 		movw	r3, #:lower16:.LANCHOR23
 2387 002e C0F20003 		movt	r3, #:upper16:.LANCHOR23
 2388 0032 1968     		ldr	r1, [r3]
 2389 0034 441A     		subs	r4, r0, r1
 2390 0036 D16C     		ldr	r1, [r2, #76]
 2391 0038 2144     		add	r1, r1, r4
 2392 003a D164     		str	r1, [r2, #76]
1693:FreeRTOS/Source/tasks.c **** 		}
 2393              		.loc 1 1693 0
 2394 003c 1860     		str	r0, [r3]
 2395              	.LBE12:
1701:FreeRTOS/Source/tasks.c **** 		{
 2396              		.loc 1 1701 0
 2397 003e 40F20003 		movw	r3, #:lower16:.LANCHOR16
 2398 0042 C0F20003 		movt	r3, #:upper16:.LANCHOR16
 2399 0046 40F20001 		movw	r1, #:lower16:.LANCHOR0
 2400 004a C0F20001 		movt	r1, #:upper16:.LANCHOR0
 2401 004e 02E0     		b	.L147
 2402              	.L148:
1704:FreeRTOS/Source/tasks.c **** 		}
 2403              		.loc 1 1704 0
 2404 0050 1A68     		ldr	r2, [r3]
 2405 0052 013A     		subs	r2, r2, #1
 2406 0054 1A60     		str	r2, [r3]
 2407              	.L147:
1701:FreeRTOS/Source/tasks.c **** 		{
 2408              		.loc 1 1701 0 discriminator 1
 2409 0056 1A68     		ldr	r2, [r3]
 2410 0058 02EB8202 		add	r2, r2, r2, lsl #2
 2411 005c 51F82220 		ldr	r2, [r1, r2, lsl #2]
 2412 0060 002A     		cmp	r2, #0
 2413 0062 F5D0     		beq	.L148
 2414              	.LBB13:
1709:FreeRTOS/Source/tasks.c **** 	
 2415              		.loc 1 1709 0
 2416 0064 40F20003 		movw	r3, #:lower16:.LANCHOR16
 2417 0068 C0F20003 		movt	r3, #:upper16:.LANCHOR16
 2418 006c 1B68     		ldr	r3, [r3]
 2419 006e 40F20002 		movw	r2, #:lower16:.LANCHOR0
 2420 0072 C0F20002 		movt	r2, #:upper16:.LANCHOR0
 2421 0076 03EB8303 		add	r3, r3, r3, lsl #2
 2422 007a 02EB8303 		add	r3, r2, r3, lsl #2
 2423              	.LVL226:
 2424 007e 5A68     		ldr	r2, [r3, #4]
 2425 0080 5268     		ldr	r2, [r2, #4]
 2426 0082 5A60     		str	r2, [r3, #4]
 2427 0084 03F10801 		add	r1, r3, #8
 2428 0088 8A42     		cmp	r2, r1
 2429 008a 04BF     		itt	eq
 2430 008c 5268     		ldreq	r2, [r2, #4]
 2431 008e 5A60     		streq	r2, [r3, #4]
 2432 0090 5B68     		ldr	r3, [r3, #4]
 2433              	.LVL227:
 2434 0092 DA68     		ldr	r2, [r3, #12]
 2435 0094 40F20003 		movw	r3, #:lower16:.LANCHOR8
 2436 0098 C0F20003 		movt	r3, #:upper16:.LANCHOR8
 2437 009c 1A60     		str	r2, [r3]
 2438              	.LBE13:
1711:FreeRTOS/Source/tasks.c **** 		vWriteTraceToBuffer();
 2439              		.loc 1 1711 0
 2440 009e 1B68     		ldr	r3, [r3]
 2441 00a0 9A6C     		ldr	r2, [r3, #72]
 2442 00a2 4FF4E843 		mov	r3, #29696
 2443 00a6 C4F20003 		movt	r3, 16384
 2444 00aa DA60     		str	r2, [r3, #12]
 2445 00ac 10BD     		pop	{r4, pc}
 2446              		.cfi_endproc
 2447              	.LFE133:
 2449 00ae 00BF     		.section	.text.vTaskSuspend,"ax",%progbits
 2450              		.align	2
 2451              		.global	vTaskSuspend
 2452              		.thumb
 2453              		.thumb_func
 2455              	vTaskSuspend:
 2456              	.LFB116:
 905:FreeRTOS/Source/tasks.c **** 	tskTCB *pxTCB;
 2457              		.loc 1 905 0
 2458              		.cfi_startproc
 2459              		@ args = 0, pretend = 0, frame = 0
 2460              		@ frame_needed = 0, uses_anonymous_args = 0
 2461              	.LVL228:
 2462 0000 70B5     		push	{r4, r5, r6, lr}
 2463              	.LCFI29:
 2464              		.cfi_def_cfa_offset 16
 2465              		.cfi_offset 4, -16
 2466              		.cfi_offset 5, -12
 2467              		.cfi_offset 6, -8
 2468              		.cfi_offset 14, -4
 2469 0002 0446     		mov	r4, r0
 908:FreeRTOS/Source/tasks.c **** 		{
 2470              		.loc 1 908 0
 2471 0004 FFF7FEFF 		bl	vPortEnterCritical
 2472              	.LVL229:
 912:FreeRTOS/Source/tasks.c **** 			{
 2473              		.loc 1 912 0
 2474 0008 40F20003 		movw	r3, #:lower16:.LANCHOR8
 2475 000c C0F20003 		movt	r3, #:upper16:.LANCHOR8
 2476 0010 1B68     		ldr	r3, [r3]
 914:FreeRTOS/Source/tasks.c **** 			}
 2477              		.loc 1 914 0
 2478 0012 9C42     		cmp	r4, r3
 2479 0014 08BF     		it	eq
 2480 0016 0024     		moveq	r4, #0
 2481              	.LVL230:
 918:FreeRTOS/Source/tasks.c **** 
 2482              		.loc 1 918 0
 2483 0018 2546     		mov	r5, r4
 2484 001a 2CB9     		cbnz	r4, .L152
 918:FreeRTOS/Source/tasks.c **** 
 2485              		.loc 1 918 0 is_stmt 0 discriminator 1
 2486 001c 40F20003 		movw	r3, #:lower16:.LANCHOR8
 2487 0020 C0F20003 		movt	r3, #:upper16:.LANCHOR8
 2488 0024 1D68     		ldr	r5, [r3]
 2489              	.LVL231:
 2490 0026 FFE7     		b	.L152
 2491              	.L152:
 2492              	.LVL232:
 923:FreeRTOS/Source/tasks.c **** 
 2493              		.loc 1 923 0 is_stmt 1 discriminator 3
 2494 0028 2E1D     		adds	r6, r5, #4
 2495 002a 3046     		mov	r0, r6
 2496 002c FFF7FEFF 		bl	vListRemove
 2497              	.LVL233:
 926:FreeRTOS/Source/tasks.c **** 			{
 2498              		.loc 1 926 0 discriminator 3
 2499 0030 AB6A     		ldr	r3, [r5, #40]
 2500 0032 1BB1     		cbz	r3, .L153
 928:FreeRTOS/Source/tasks.c **** 			}
 2501              		.loc 1 928 0
 2502 0034 05F11800 		add	r0, r5, #24
 2503 0038 FFF7FEFF 		bl	vListRemove
 2504              	.LVL234:
 2505              	.L153:
 931:FreeRTOS/Source/tasks.c **** 		}
 2506              		.loc 1 931 0
 2507 003c 40F20000 		movw	r0, #:lower16:.LANCHOR5
 2508 0040 C0F20000 		movt	r0, #:upper16:.LANCHOR5
 2509 0044 3146     		mov	r1, r6
 2510 0046 FFF7FEFF 		bl	vListInsertEnd
 2511              	.LVL235:
 933:FreeRTOS/Source/tasks.c **** 
 2512              		.loc 1 933 0
 2513 004a FFF7FEFF 		bl	vPortExitCritical
 2514              	.LVL236:
 935:FreeRTOS/Source/tasks.c **** 		{
 2515              		.loc 1 935 0
 2516 004e ECB9     		cbnz	r4, .L150
 937:FreeRTOS/Source/tasks.c **** 			{
 2517              		.loc 1 937 0
 2518 0050 40F20003 		movw	r3, #:lower16:.LANCHOR13
 2519 0054 C0F20003 		movt	r3, #:upper16:.LANCHOR13
 2520 0058 1B68     		ldr	r3, [r3]
 2521 005a 13B1     		cbz	r3, .L155
 940:FreeRTOS/Source/tasks.c **** 			}
 2522              		.loc 1 940 0
 2523 005c FFF7FEFF 		bl	vPortYieldFromISR
 2524              	.LVL237:
 2525 0060 70BD     		pop	{r4, r5, r6, pc}
 2526              	.LVL238:
 2527              	.L155:
 947:FreeRTOS/Source/tasks.c **** 				{
 2528              		.loc 1 947 0
 2529 0062 40F20003 		movw	r3, #:lower16:.LANCHOR5
 2530 0066 C0F20003 		movt	r3, #:upper16:.LANCHOR5
 2531 006a 1A68     		ldr	r2, [r3]
 2532 006c 40F20003 		movw	r3, #:lower16:.LANCHOR12
 2533 0070 C0F20003 		movt	r3, #:upper16:.LANCHOR12
 2534 0074 1B68     		ldr	r3, [r3]
 2535 0076 9A42     		cmp	r2, r3
 2536 0078 06D1     		bne	.L156
 953:FreeRTOS/Source/tasks.c **** 				}
 2537              		.loc 1 953 0
 2538 007a 40F20003 		movw	r3, #:lower16:.LANCHOR8
 2539 007e C0F20003 		movt	r3, #:upper16:.LANCHOR8
 2540 0082 0022     		movs	r2, #0
 2541 0084 1A60     		str	r2, [r3]
 2542 0086 70BD     		pop	{r4, r5, r6, pc}
 2543              	.LVL239:
 2544              	.L156:
 957:FreeRTOS/Source/tasks.c **** 				}
 2545              		.loc 1 957 0
 2546 0088 FFF7FEFF 		bl	vTaskSwitchContext
 2547              	.LVL240:
 2548              	.L150:
 2549 008c 70BD     		pop	{r4, r5, r6, pc}
 2550              		.cfi_endproc
 2551              	.LFE116:
 2553 008e 00BF     		.section	.text.vTaskPlaceOnEventList,"ax",%progbits
 2554              		.align	2
 2555              		.global	vTaskPlaceOnEventList
 2556              		.thumb
 2557              		.thumb_func
 2559              	vTaskPlaceOnEventList:
 2560              	.LFB134:
1718:FreeRTOS/Source/tasks.c **** portTickType xTimeToWake;
 2561              		.loc 1 1718 0
 2562              		.cfi_startproc
 2563              		@ args = 0, pretend = 0, frame = 0
 2564              		@ frame_needed = 0, uses_anonymous_args = 0
 2565              	.LVL241:
 2566 0000 38B5     		push	{r3, r4, r5, lr}
 2567              	.LCFI30:
 2568              		.cfi_def_cfa_offset 16
 2569              		.cfi_offset 3, -16
 2570              		.cfi_offset 4, -12
 2571              		.cfi_offset 5, -8
 2572              		.cfi_offset 14, -4
 2573 0002 0D46     		mov	r5, r1
1729:FreeRTOS/Source/tasks.c **** 
 2574              		.loc 1 1729 0
 2575 0004 40F20004 		movw	r4, #:lower16:.LANCHOR8
 2576 0008 C0F20004 		movt	r4, #:upper16:.LANCHOR8
 2577 000c 2168     		ldr	r1, [r4]
 2578              	.LVL242:
 2579 000e 1831     		adds	r1, r1, #24
 2580 0010 FFF7FEFF 		bl	vListInsert
 2581              	.LVL243:
1734:FreeRTOS/Source/tasks.c **** 
 2582              		.loc 1 1734 0
 2583 0014 2068     		ldr	r0, [r4]
 2584 0016 0430     		adds	r0, r0, #4
 2585 0018 FFF7FEFF 		bl	vListRemove
 2586              	.LVL244:
1739:FreeRTOS/Source/tasks.c **** 		{
 2587              		.loc 1 1739 0
 2588 001c B5F1FF3F 		cmp	r5, #-1
 2589 0020 08D1     		bne	.L160
1744:FreeRTOS/Source/tasks.c **** 		}
 2590              		.loc 1 1744 0
 2591 0022 2168     		ldr	r1, [r4]
 2592 0024 40F20000 		movw	r0, #:lower16:.LANCHOR5
 2593 0028 C0F20000 		movt	r0, #:upper16:.LANCHOR5
 2594 002c 0431     		adds	r1, r1, #4
 2595 002e FFF7FEFF 		bl	vListInsertEnd
 2596              	.LVL245:
 2597 0032 38BD     		pop	{r3, r4, r5, pc}
 2598              	.LVL246:
 2599              	.L160:
1750:FreeRTOS/Source/tasks.c **** 			prvAddCurrentTaskToDelayedList( xTimeToWake );
 2600              		.loc 1 1750 0
 2601 0034 40F20003 		movw	r3, #:lower16:.LANCHOR9
 2602 0038 C0F20003 		movt	r3, #:upper16:.LANCHOR9
 2603 003c 1868     		ldr	r0, [r3]
 2604              	.LVL247:
1751:FreeRTOS/Source/tasks.c **** 		}
 2605              		.loc 1 1751 0
 2606 003e 2844     		add	r0, r0, r5
 2607              	.LVL248:
 2608 0040 FFF7FEFF 		bl	prvAddCurrentTaskToDelayedList
 2609              	.LVL249:
 2610 0044 38BD     		pop	{r3, r4, r5, pc}
 2611              		.cfi_endproc
 2612              	.LFE134:
 2614 0046 00BF     		.section	.text.xTaskRemoveFromEventList,"ax",%progbits
 2615              		.align	2
 2616              		.global	xTaskRemoveFromEventList
 2617              		.thumb
 2618              		.thumb_func
 2620              	xTaskRemoveFromEventList:
 2621              	.LFB135:
1800:FreeRTOS/Source/tasks.c **** tskTCB *pxUnblockedTCB;
 2622              		.loc 1 1800 0
 2623              		.cfi_startproc
 2624              		@ args = 0, pretend = 0, frame = 0
 2625              		@ frame_needed = 0, uses_anonymous_args = 0
 2626              	.LVL250:
 2627 0000 38B5     		push	{r3, r4, r5, lr}
 2628              	.LCFI31:
 2629              		.cfi_def_cfa_offset 16
 2630              		.cfi_offset 3, -16
 2631              		.cfi_offset 4, -12
 2632              		.cfi_offset 5, -8
 2633              		.cfi_offset 14, -4
1817:FreeRTOS/Source/tasks.c **** 	configASSERT( pxUnblockedTCB );
 2634              		.loc 1 1817 0
 2635 0002 C368     		ldr	r3, [r0, #12]
 2636 0004 DC68     		ldr	r4, [r3, #12]
 2637              	.LVL251:
1819:FreeRTOS/Source/tasks.c **** 
 2638              		.loc 1 1819 0
 2639 0006 04F11805 		add	r5, r4, #24
 2640 000a 2846     		mov	r0, r5
 2641              	.LVL252:
 2642 000c FFF7FEFF 		bl	vListRemove
 2643              	.LVL253:
1821:FreeRTOS/Source/tasks.c **** 	{
 2644              		.loc 1 1821 0
 2645 0010 40F20003 		movw	r3, #:lower16:.LANCHOR18
 2646 0014 C0F20003 		movt	r3, #:upper16:.LANCHOR18
 2647 0018 1B68     		ldr	r3, [r3]
 2648 001a E3B9     		cbnz	r3, .L163
1823:FreeRTOS/Source/tasks.c **** 		prvAddTaskToReadyQueue( pxUnblockedTCB );
 2649              		.loc 1 1823 0
 2650 001c 251D     		adds	r5, r4, #4
 2651 001e 2846     		mov	r0, r5
 2652 0020 FFF7FEFF 		bl	vListRemove
 2653              	.LVL254:
1824:FreeRTOS/Source/tasks.c **** 	}
 2654              		.loc 1 1824 0
 2655 0024 E36A     		ldr	r3, [r4, #44]
 2656 0026 40F20002 		movw	r2, #:lower16:.LANCHOR16
 2657 002a C0F20002 		movt	r2, #:upper16:.LANCHOR16
 2658 002e 1268     		ldr	r2, [r2]
 2659 0030 9342     		cmp	r3, r2
 2660 0032 82BF     		ittt	hi
 2661 0034 40F20002 		movwhi	r2, #:lower16:.LANCHOR16
 2662 0038 C0F20002 		movthi	r2, #:upper16:.LANCHOR16
 2663 003c 1360     		strhi	r3, [r2]
 2664 003e 40F20000 		movw	r0, #:lower16:.LANCHOR0
 2665 0042 C0F20000 		movt	r0, #:upper16:.LANCHOR0
 2666 0046 03EB8303 		add	r3, r3, r3, lsl #2
 2667 004a 00EB8300 		add	r0, r0, r3, lsl #2
 2668 004e 2946     		mov	r1, r5
 2669 0050 FFF7FEFF 		bl	vListInsertEnd
 2670              	.LVL255:
 2671 0054 06E0     		b	.L165
 2672              	.L163:
1830:FreeRTOS/Source/tasks.c **** 	}
 2673              		.loc 1 1830 0
 2674 0056 40F20000 		movw	r0, #:lower16:.LANCHOR3
 2675 005a C0F20000 		movt	r0, #:upper16:.LANCHOR3
 2676 005e 2946     		mov	r1, r5
 2677 0060 FFF7FEFF 		bl	vListInsertEnd
 2678              	.LVL256:
 2679              	.L165:
1833:FreeRTOS/Source/tasks.c **** 	{
 2680              		.loc 1 1833 0
 2681 0064 E06A     		ldr	r0, [r4, #44]
 2682 0066 40F20003 		movw	r3, #:lower16:.LANCHOR8
 2683 006a C0F20003 		movt	r3, #:upper16:.LANCHOR8
 2684 006e 1B68     		ldr	r3, [r3]
 2685 0070 DB6A     		ldr	r3, [r3, #44]
 2686              	.LVL257:
1847:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 2687              		.loc 1 1847 0
 2688 0072 9842     		cmp	r0, r3
 2689 0074 34BF     		ite	cc
 2690 0076 0020     		movcc	r0, #0
 2691              	.LVL258:
 2692 0078 0120     		movcs	r0, #1
 2693 007a 38BD     		pop	{r3, r4, r5, pc}
 2694              		.cfi_endproc
 2695              	.LFE135:
 2697              		.section	.text.vTaskSetTimeOutState,"ax",%progbits
 2698              		.align	2
 2699              		.global	vTaskSetTimeOutState
 2700              		.thumb
 2701              		.thumb_func
 2703              	vTaskSetTimeOutState:
 2704              	.LFB136:
1851:FreeRTOS/Source/tasks.c **** 	configASSERT( pxTimeOut );
 2705              		.loc 1 1851 0
 2706              		.cfi_startproc
 2707              		@ args = 0, pretend = 0, frame = 0
 2708              		@ frame_needed = 0, uses_anonymous_args = 0
 2709              		@ link register save eliminated.
 2710              	.LVL259:
1853:FreeRTOS/Source/tasks.c **** 	pxTimeOut->xTimeOnEntering = xTickCount;
 2711              		.loc 1 1853 0
 2712 0000 40F20003 		movw	r3, #:lower16:.LANCHOR20
 2713 0004 C0F20003 		movt	r3, #:upper16:.LANCHOR20
 2714 0008 1B68     		ldr	r3, [r3]
 2715 000a 0360     		str	r3, [r0]
1854:FreeRTOS/Source/tasks.c **** }
 2716              		.loc 1 1854 0
 2717 000c 40F20003 		movw	r3, #:lower16:.LANCHOR9
 2718 0010 C0F20003 		movt	r3, #:upper16:.LANCHOR9
 2719 0014 1B68     		ldr	r3, [r3]
 2720 0016 4360     		str	r3, [r0, #4]
 2721 0018 7047     		bx	lr
 2722              		.cfi_endproc
 2723              	.LFE136:
 2725 001a 00BF     		.section	.text.xTaskCheckForTimeOut,"ax",%progbits
 2726              		.align	2
 2727              		.global	xTaskCheckForTimeOut
 2728              		.thumb
 2729              		.thumb_func
 2731              	xTaskCheckForTimeOut:
 2732              	.LFB137:
1859:FreeRTOS/Source/tasks.c **** portBASE_TYPE xReturn;
 2733              		.loc 1 1859 0
 2734              		.cfi_startproc
 2735              		@ args = 0, pretend = 0, frame = 0
 2736              		@ frame_needed = 0, uses_anonymous_args = 0
 2737              	.LVL260:
 2738 0000 38B5     		push	{r3, r4, r5, lr}
 2739              	.LCFI32:
 2740              		.cfi_def_cfa_offset 16
 2741              		.cfi_offset 3, -16
 2742              		.cfi_offset 4, -12
 2743              		.cfi_offset 5, -8
 2744              		.cfi_offset 14, -4
 2745 0002 0446     		mov	r4, r0
 2746 0004 0D46     		mov	r5, r1
1865:FreeRTOS/Source/tasks.c **** 	{
 2747              		.loc 1 1865 0
 2748 0006 FFF7FEFF 		bl	vPortEnterCritical
 2749              	.LVL261:
1871:FreeRTOS/Source/tasks.c **** 			{
 2750              		.loc 1 1871 0
 2751 000a 2A68     		ldr	r2, [r5]
 2752 000c B2F1FF3F 		cmp	r2, #-1
1873:FreeRTOS/Source/tasks.c **** 			}
 2753              		.loc 1 1873 0
 2754 0010 08BF     		it	eq
 2755 0012 0024     		moveq	r4, #0
 2756              	.LVL262:
1871:FreeRTOS/Source/tasks.c **** 			{
 2757              		.loc 1 1871 0
 2758 0014 29D0     		beq	.L170
1878:FreeRTOS/Source/tasks.c **** 		{
 2759              		.loc 1 1878 0
 2760 0016 2168     		ldr	r1, [r4]
 2761 0018 40F20003 		movw	r3, #:lower16:.LANCHOR20
 2762 001c C0F20003 		movt	r3, #:upper16:.LANCHOR20
 2763 0020 1B68     		ldr	r3, [r3]
 2764 0022 9942     		cmp	r1, r3
 2765 0024 09D0     		beq	.L171
1878:FreeRTOS/Source/tasks.c **** 		{
 2766              		.loc 1 1878 0 is_stmt 0 discriminator 1
 2767 0026 6168     		ldr	r1, [r4, #4]
 2768 0028 40F20003 		movw	r3, #:lower16:.LANCHOR9
 2769 002c C0F20003 		movt	r3, #:upper16:.LANCHOR9
 2770 0030 1B68     		ldr	r3, [r3]
 2771 0032 9942     		cmp	r1, r3
1884:FreeRTOS/Source/tasks.c **** 		}
 2772              		.loc 1 1884 0 is_stmt 1 discriminator 1
 2773 0034 98BF     		it	ls
 2774 0036 0124     		movls	r4, #1
1878:FreeRTOS/Source/tasks.c **** 		{
 2775              		.loc 1 1878 0 discriminator 1
 2776 0038 17D9     		bls	.L170
 2777              	.L171:
1886:FreeRTOS/Source/tasks.c **** 		{
 2778              		.loc 1 1886 0
 2779 003a 40F20003 		movw	r3, #:lower16:.LANCHOR9
 2780 003e C0F20003 		movt	r3, #:upper16:.LANCHOR9
 2781 0042 1968     		ldr	r1, [r3]
 2782 0044 6368     		ldr	r3, [r4, #4]
 2783 0046 C91A     		subs	r1, r1, r3
 2784 0048 8A42     		cmp	r2, r1
1895:FreeRTOS/Source/tasks.c **** 		}
 2785              		.loc 1 1895 0
 2786 004a 98BF     		it	ls
 2787 004c 0124     		movls	r4, #1
1886:FreeRTOS/Source/tasks.c **** 		{
 2788              		.loc 1 1886 0
 2789 004e 0CD9     		bls	.L170
1889:FreeRTOS/Source/tasks.c **** 			vTaskSetTimeOutState( pxTimeOut );
 2790              		.loc 1 1889 0
 2791 0050 40F20001 		movw	r1, #:lower16:.LANCHOR9
 2792 0054 C0F20001 		movt	r1, #:upper16:.LANCHOR9
 2793 0058 0968     		ldr	r1, [r1]
 2794 005a 5B1A     		subs	r3, r3, r1
 2795 005c 1A44     		add	r2, r2, r3
 2796 005e 2A60     		str	r2, [r5]
1890:FreeRTOS/Source/tasks.c **** 			xReturn = pdFALSE;
 2797              		.loc 1 1890 0
 2798 0060 2046     		mov	r0, r4
 2799 0062 FFF7FEFF 		bl	vTaskSetTimeOutState
 2800              	.LVL263:
1891:FreeRTOS/Source/tasks.c **** 		}
 2801              		.loc 1 1891 0
 2802 0066 0024     		movs	r4, #0
 2803 0068 FFE7     		b	.L170
 2804              	.LVL264:
 2805              	.L170:
1898:FreeRTOS/Source/tasks.c **** 
 2806              		.loc 1 1898 0
 2807 006a FFF7FEFF 		bl	vPortExitCritical
 2808              	.LVL265:
1901:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
 2809              		.loc 1 1901 0
 2810 006e 2046     		mov	r0, r4
 2811 0070 38BD     		pop	{r3, r4, r5, pc}
 2812              		.cfi_endproc
 2813              	.LFE137:
 2815 0072 00BF     		.section	.text.vTaskMissedYield,"ax",%progbits
 2816              		.align	2
 2817              		.global	vTaskMissedYield
 2818              		.thumb
 2819              		.thumb_func
 2821              	vTaskMissedYield:
 2822              	.LFB138:
1905:FreeRTOS/Source/tasks.c **** 	xMissedYield = pdTRUE;
 2823              		.loc 1 1905 0
 2824              		.cfi_startproc
 2825              		@ args = 0, pretend = 0, frame = 0
 2826              		@ frame_needed = 0, uses_anonymous_args = 0
 2827              		@ link register save eliminated.
1906:FreeRTOS/Source/tasks.c **** }
 2828              		.loc 1 1906 0
 2829 0000 40F20003 		movw	r3, #:lower16:.LANCHOR22
 2830 0004 C0F20003 		movt	r3, #:upper16:.LANCHOR22
 2831 0008 0122     		movs	r2, #1
 2832 000a 1A60     		str	r2, [r3]
 2833 000c 7047     		bx	lr
 2834              		.cfi_endproc
 2835              	.LFE138:
 2837 000e 00BF     		.section	.text.uxTaskGetStackHighWaterMark,"ax",%progbits
 2838              		.align	2
 2839              		.global	uxTaskGetStackHighWaterMark
 2840              		.thumb
 2841              		.thumb_func
 2843              	uxTaskGetStackHighWaterMark:
 2844              	.LFB147:
2321:FreeRTOS/Source/tasks.c **** 	tskTCB *pxTCB;
 2845              		.loc 1 2321 0
 2846              		.cfi_startproc
 2847              		@ args = 0, pretend = 0, frame = 0
 2848              		@ frame_needed = 0, uses_anonymous_args = 0
 2849              	.LVL266:
 2850 0000 08B5     		push	{r3, lr}
 2851              	.LCFI33:
 2852              		.cfi_def_cfa_offset 8
 2853              		.cfi_offset 3, -8
 2854              		.cfi_offset 14, -4
2326:FreeRTOS/Source/tasks.c **** 
 2855              		.loc 1 2326 0
 2856 0002 0346     		mov	r3, r0
 2857 0004 20B9     		cbnz	r0, .L177
2326:FreeRTOS/Source/tasks.c **** 
 2858              		.loc 1 2326 0 is_stmt 0 discriminator 1
 2859 0006 40F20003 		movw	r3, #:lower16:.LANCHOR8
 2860 000a C0F20003 		movt	r3, #:upper16:.LANCHOR8
 2861 000e 1B68     		ldr	r3, [r3]
 2862              	.LVL267:
 2863              	.L177:
2338:FreeRTOS/Source/tasks.c **** 
 2864              		.loc 1 2338 0 is_stmt 1 discriminator 3
 2865 0010 186B     		ldr	r0, [r3, #48]
 2866 0012 FFF7FEFF 		bl	usTaskCheckFreeStackSpace
 2867              	.LVL268:
2341:FreeRTOS/Source/tasks.c **** 
 2868              		.loc 1 2341 0 discriminator 3
 2869 0016 08BD     		pop	{r3, pc}
 2870              		.cfi_endproc
 2871              	.LFE147:
 2873              		.section	.text.xTaskGetCurrentTaskHandle,"ax",%progbits
 2874              		.align	2
 2875              		.global	xTaskGetCurrentTaskHandle
 2876              		.thumb
 2877              		.thumb_func
 2879              	xTaskGetCurrentTaskHandle:
 2880              	.LFB149:
2354:FreeRTOS/Source/tasks.c **** 	}
2355:FreeRTOS/Source/tasks.c **** 
2356:FreeRTOS/Source/tasks.c **** #endif
2357:FreeRTOS/Source/tasks.c **** 
2358:FreeRTOS/Source/tasks.c **** 
2359:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2360:FreeRTOS/Source/tasks.c **** 
2361:FreeRTOS/Source/tasks.c **** #if ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) )
2362:FreeRTOS/Source/tasks.c **** 
2363:FreeRTOS/Source/tasks.c **** 	xTaskHandle xTaskGetCurrentTaskHandle( void )
2364:FreeRTOS/Source/tasks.c **** 	{
 2881              		.loc 1 2364 0
 2882              		.cfi_startproc
 2883              		@ args = 0, pretend = 0, frame = 0
 2884              		@ frame_needed = 0, uses_anonymous_args = 0
 2885              		@ link register save eliminated.
2365:FreeRTOS/Source/tasks.c **** 	xTaskHandle xReturn;
2366:FreeRTOS/Source/tasks.c **** 
2367:FreeRTOS/Source/tasks.c **** 		/* A critical section is not required as this is not called from
2368:FreeRTOS/Source/tasks.c **** 		an interrupt and the current TCB will always be the same for any
2369:FreeRTOS/Source/tasks.c **** 		individual execution thread. */
2370:FreeRTOS/Source/tasks.c **** 		xReturn = pxCurrentTCB;
 2886              		.loc 1 2370 0
 2887 0000 40F20003 		movw	r3, #:lower16:.LANCHOR8
 2888 0004 C0F20003 		movt	r3, #:upper16:.LANCHOR8
 2889 0008 1868     		ldr	r0, [r3]
 2890              	.LVL269:
2371:FreeRTOS/Source/tasks.c **** 
2372:FreeRTOS/Source/tasks.c **** 		return xReturn;
2373:FreeRTOS/Source/tasks.c **** 	}
 2891              		.loc 1 2373 0
 2892 000a 7047     		bx	lr
 2893              		.cfi_endproc
 2894              	.LFE149:
 2896              		.section	.text.vTaskPriorityInherit,"ax",%progbits
 2897              		.align	2
 2898              		.global	vTaskPriorityInherit
 2899              		.thumb
 2900              		.thumb_func
 2902              	vTaskPriorityInherit:
 2903              	.LFB150:
2374:FreeRTOS/Source/tasks.c **** 
2375:FreeRTOS/Source/tasks.c **** #endif
2376:FreeRTOS/Source/tasks.c **** 
2377:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2378:FreeRTOS/Source/tasks.c **** 
2379:FreeRTOS/Source/tasks.c **** #if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
2380:FreeRTOS/Source/tasks.c **** 
2381:FreeRTOS/Source/tasks.c **** 	portBASE_TYPE xTaskGetSchedulerState( void )
2382:FreeRTOS/Source/tasks.c **** 	{
2383:FreeRTOS/Source/tasks.c **** 	portBASE_TYPE xReturn;
2384:FreeRTOS/Source/tasks.c **** 
2385:FreeRTOS/Source/tasks.c **** 		if( xSchedulerRunning == pdFALSE )
2386:FreeRTOS/Source/tasks.c **** 		{
2387:FreeRTOS/Source/tasks.c **** 			xReturn = taskSCHEDULER_NOT_STARTED;
2388:FreeRTOS/Source/tasks.c **** 		}
2389:FreeRTOS/Source/tasks.c **** 		else
2390:FreeRTOS/Source/tasks.c **** 		{
2391:FreeRTOS/Source/tasks.c **** 			if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
2392:FreeRTOS/Source/tasks.c **** 			{
2393:FreeRTOS/Source/tasks.c **** 				xReturn = taskSCHEDULER_RUNNING;
2394:FreeRTOS/Source/tasks.c **** 			}
2395:FreeRTOS/Source/tasks.c **** 			else
2396:FreeRTOS/Source/tasks.c **** 			{
2397:FreeRTOS/Source/tasks.c **** 				xReturn = taskSCHEDULER_SUSPENDED;
2398:FreeRTOS/Source/tasks.c **** 			}
2399:FreeRTOS/Source/tasks.c **** 		}
2400:FreeRTOS/Source/tasks.c **** 
2401:FreeRTOS/Source/tasks.c **** 		return xReturn;
2402:FreeRTOS/Source/tasks.c **** 	}
2403:FreeRTOS/Source/tasks.c **** 
2404:FreeRTOS/Source/tasks.c **** #endif
2405:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2406:FreeRTOS/Source/tasks.c **** 
2407:FreeRTOS/Source/tasks.c **** #if ( configUSE_MUTEXES == 1 )
2408:FreeRTOS/Source/tasks.c **** 
2409:FreeRTOS/Source/tasks.c **** 	void vTaskPriorityInherit( xTaskHandle * const pxMutexHolder )
2410:FreeRTOS/Source/tasks.c **** 	{
 2904              		.loc 1 2410 0
 2905              		.cfi_startproc
 2906              		@ args = 0, pretend = 0, frame = 0
 2907              		@ frame_needed = 0, uses_anonymous_args = 0
 2908              	.LVL270:
 2909 0000 38B5     		push	{r3, r4, r5, lr}
 2910              	.LCFI34:
 2911              		.cfi_def_cfa_offset 16
 2912              		.cfi_offset 3, -16
 2913              		.cfi_offset 4, -12
 2914              		.cfi_offset 5, -8
 2915              		.cfi_offset 14, -4
 2916 0002 0446     		mov	r4, r0
 2917              	.LVL271:
2411:FreeRTOS/Source/tasks.c **** 	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;
2412:FreeRTOS/Source/tasks.c **** 
2413:FreeRTOS/Source/tasks.c **** 		configASSERT( pxMutexHolder );
2414:FreeRTOS/Source/tasks.c **** 
2415:FreeRTOS/Source/tasks.c **** 		if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
 2918              		.loc 1 2415 0
 2919 0004 C26A     		ldr	r2, [r0, #44]
 2920 0006 40F20003 		movw	r3, #:lower16:.LANCHOR8
 2921 000a C0F20003 		movt	r3, #:upper16:.LANCHOR8
 2922 000e 1B68     		ldr	r3, [r3]
 2923 0010 DB6A     		ldr	r3, [r3, #44]
 2924 0012 9A42     		cmp	r2, r3
 2925 0014 3DD2     		bcs	.L179
2416:FreeRTOS/Source/tasks.c **** 		{
2417:FreeRTOS/Source/tasks.c **** 			/* Adjust the mutex holder state to account for its new priority. */
2418:FreeRTOS/Source/tasks.c **** 			listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxC
 2926              		.loc 1 2418 0
 2927 0016 40F20003 		movw	r3, #:lower16:.LANCHOR8
 2928 001a C0F20003 		movt	r3, #:upper16:.LANCHOR8
 2929 001e 1B68     		ldr	r3, [r3]
 2930 0020 DB6A     		ldr	r3, [r3, #44]
 2931 0022 C3F10503 		rsb	r3, r3, #5
 2932 0026 8361     		str	r3, [r0, #24]
2419:FreeRTOS/Source/tasks.c **** 
2420:FreeRTOS/Source/tasks.c **** 			/* If the task being modified is in the ready state it will need to
2421:FreeRTOS/Source/tasks.c **** 			be moved in to a new list. */
2422:FreeRTOS/Source/tasks.c **** 			if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericList
 2933              		.loc 1 2422 0
 2934 0028 4169     		ldr	r1, [r0, #20]
 2935 002a 40F20003 		movw	r3, #:lower16:.LANCHOR0
 2936 002e C0F20003 		movt	r3, #:upper16:.LANCHOR0
 2937 0032 02EB8202 		add	r2, r2, r2, lsl #2
 2938 0036 03EB8203 		add	r3, r3, r2, lsl #2
 2939 003a 9942     		cmp	r1, r3
 2940 003c 22D1     		bne	.L181
2423:FreeRTOS/Source/tasks.c **** 			{
2424:FreeRTOS/Source/tasks.c **** 				vListRemove( &( pxTCB->xGenericListItem ) );
 2941              		.loc 1 2424 0
 2942 003e 051D     		adds	r5, r0, #4
 2943 0040 2846     		mov	r0, r5
 2944              	.LVL272:
 2945 0042 FFF7FEFF 		bl	vListRemove
 2946              	.LVL273:
2425:FreeRTOS/Source/tasks.c **** 
2426:FreeRTOS/Source/tasks.c **** 				/* Inherit the priority before being moved into the new list. */
2427:FreeRTOS/Source/tasks.c **** 				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
 2947              		.loc 1 2427 0
 2948 0046 40F20003 		movw	r3, #:lower16:.LANCHOR8
 2949 004a C0F20003 		movt	r3, #:upper16:.LANCHOR8
 2950 004e 1B68     		ldr	r3, [r3]
 2951 0050 DB6A     		ldr	r3, [r3, #44]
 2952 0052 E362     		str	r3, [r4, #44]
2428:FreeRTOS/Source/tasks.c **** 				prvAddTaskToReadyQueue( pxTCB );
 2953              		.loc 1 2428 0
 2954 0054 40F20002 		movw	r2, #:lower16:.LANCHOR16
 2955 0058 C0F20002 		movt	r2, #:upper16:.LANCHOR16
 2956 005c 1268     		ldr	r2, [r2]
 2957 005e 9342     		cmp	r3, r2
 2958 0060 82BF     		ittt	hi
 2959 0062 40F20002 		movwhi	r2, #:lower16:.LANCHOR16
 2960 0066 C0F20002 		movthi	r2, #:upper16:.LANCHOR16
 2961 006a 1360     		strhi	r3, [r2]
 2962 006c 40F20000 		movw	r0, #:lower16:.LANCHOR0
 2963 0070 C0F20000 		movt	r0, #:upper16:.LANCHOR0
 2964 0074 03EB8303 		add	r3, r3, r3, lsl #2
 2965 0078 00EB8300 		add	r0, r0, r3, lsl #2
 2966 007c 2946     		mov	r1, r5
 2967 007e FFF7FEFF 		bl	vListInsertEnd
 2968              	.LVL274:
 2969 0082 38BD     		pop	{r3, r4, r5, pc}
 2970              	.LVL275:
 2971              	.L181:
2429:FreeRTOS/Source/tasks.c **** 			}
2430:FreeRTOS/Source/tasks.c **** 			else
2431:FreeRTOS/Source/tasks.c **** 			{
2432:FreeRTOS/Source/tasks.c **** 				/* Just inherit the priority. */
2433:FreeRTOS/Source/tasks.c **** 				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
 2972              		.loc 1 2433 0
 2973 0084 40F20003 		movw	r3, #:lower16:.LANCHOR8
 2974 0088 C0F20003 		movt	r3, #:upper16:.LANCHOR8
 2975 008c 1B68     		ldr	r3, [r3]
 2976 008e DB6A     		ldr	r3, [r3, #44]
 2977 0090 C362     		str	r3, [r0, #44]
 2978              	.L179:
 2979 0092 38BD     		pop	{r3, r4, r5, pc}
 2980              		.cfi_endproc
 2981              	.LFE150:
 2983              		.section	.text.vTaskPriorityDisinherit,"ax",%progbits
 2984              		.align	2
 2985              		.global	vTaskPriorityDisinherit
 2986              		.thumb
 2987              		.thumb_func
 2989              	vTaskPriorityDisinherit:
 2990              	.LFB151:
2434:FreeRTOS/Source/tasks.c **** 			}
2435:FreeRTOS/Source/tasks.c **** 		}
2436:FreeRTOS/Source/tasks.c **** 	}
2437:FreeRTOS/Source/tasks.c **** 
2438:FreeRTOS/Source/tasks.c **** #endif
2439:FreeRTOS/Source/tasks.c **** /*-----------------------------------------------------------*/
2440:FreeRTOS/Source/tasks.c **** 
2441:FreeRTOS/Source/tasks.c **** #if ( configUSE_MUTEXES == 1 )
2442:FreeRTOS/Source/tasks.c **** 
2443:FreeRTOS/Source/tasks.c **** 	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
2444:FreeRTOS/Source/tasks.c **** 	{
 2991              		.loc 1 2444 0
 2992              		.cfi_startproc
 2993              		@ args = 0, pretend = 0, frame = 0
 2994              		@ frame_needed = 0, uses_anonymous_args = 0
 2995              	.LVL276:
 2996 0000 38B5     		push	{r3, r4, r5, lr}
 2997              	.LCFI35:
 2998              		.cfi_def_cfa_offset 16
 2999              		.cfi_offset 3, -16
 3000              		.cfi_offset 4, -12
 3001              		.cfi_offset 5, -8
 3002              		.cfi_offset 14, -4
 3003              	.LVL277:
2445:FreeRTOS/Source/tasks.c **** 	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;
2446:FreeRTOS/Source/tasks.c **** 
2447:FreeRTOS/Source/tasks.c **** 		if( pxMutexHolder != NULL )
 3004              		.loc 1 2447 0
 3005 0002 0446     		mov	r4, r0
 3006 0004 18B3     		cbz	r0, .L183
2448:FreeRTOS/Source/tasks.c **** 		{
2449:FreeRTOS/Source/tasks.c **** 			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
 3007              		.loc 1 2449 0
 3008 0006 C26A     		ldr	r2, [r0, #44]
 3009 0008 436C     		ldr	r3, [r0, #68]
 3010 000a 9A42     		cmp	r2, r3
 3011 000c 1FD0     		beq	.L183
2450:FreeRTOS/Source/tasks.c **** 			{
2451:FreeRTOS/Source/tasks.c **** 				/* We must be the running task to be able to give the mutex back.
2452:FreeRTOS/Source/tasks.c **** 				Remove ourselves from the ready list we currently appear in. */
2453:FreeRTOS/Source/tasks.c **** 				vListRemove( &( pxTCB->xGenericListItem ) );
 3012              		.loc 1 2453 0
 3013 000e 051D     		adds	r5, r0, #4
 3014 0010 2846     		mov	r0, r5
 3015              	.LVL278:
 3016 0012 FFF7FEFF 		bl	vListRemove
 3017              	.LVL279:
2454:FreeRTOS/Source/tasks.c **** 
2455:FreeRTOS/Source/tasks.c **** 				/* Disinherit the priority before adding ourselves into the new
2456:FreeRTOS/Source/tasks.c **** 				ready list. */
2457:FreeRTOS/Source/tasks.c **** 				pxTCB->uxPriority = pxTCB->uxBasePriority;
 3018              		.loc 1 2457 0
 3019 0016 636C     		ldr	r3, [r4, #68]
 3020 0018 E362     		str	r3, [r4, #44]
2458:FreeRTOS/Source/tasks.c **** 				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) px
 3021              		.loc 1 2458 0
 3022 001a C3F10502 		rsb	r2, r3, #5
 3023 001e A261     		str	r2, [r4, #24]
2459:FreeRTOS/Source/tasks.c **** 				prvAddTaskToReadyQueue( pxTCB );
 3024              		.loc 1 2459 0
 3025 0020 40F20002 		movw	r2, #:lower16:.LANCHOR16
 3026 0024 C0F20002 		movt	r2, #:upper16:.LANCHOR16
 3027 0028 1268     		ldr	r2, [r2]
 3028 002a 9342     		cmp	r3, r2
 3029 002c 82BF     		ittt	hi
 3030 002e 40F20002 		movwhi	r2, #:lower16:.LANCHOR16
 3031 0032 C0F20002 		movthi	r2, #:upper16:.LANCHOR16
 3032 0036 1360     		strhi	r3, [r2]
 3033 0038 40F20000 		movw	r0, #:lower16:.LANCHOR0
 3034 003c C0F20000 		movt	r0, #:upper16:.LANCHOR0
 3035 0040 03EB8303 		add	r3, r3, r3, lsl #2
 3036 0044 00EB8300 		add	r0, r0, r3, lsl #2
 3037 0048 2946     		mov	r1, r5
 3038 004a FFF7FEFF 		bl	vListInsertEnd
 3039              	.LVL280:
 3040              	.L183:
 3041 004e 38BD     		pop	{r3, r4, r5, pc}
 3042              		.cfi_endproc
 3043              	.LFE151:
 3045              		.global	pxCurrentTCB
 3046              		.section	.bss.uxTopReadyPriority,"aw",%nobits
 3047              		.align	2
 3048              		.set	.LANCHOR16,. + 0
 3051              	uxTopReadyPriority:
 3052 0000 00000000 		.space	4
 3053              		.section	.bss.uxTasksDeleted,"aw",%nobits
 3054              		.align	2
 3055              		.set	.LANCHOR17,. + 0
 3058              	uxTasksDeleted:
 3059 0000 00000000 		.space	4
 3060              		.section	.bss.uxCurrentNumberOfTasks,"aw",%nobits
 3061              		.align	2
 3062              		.set	.LANCHOR12,. + 0
 3065              	uxCurrentNumberOfTasks:
 3066 0000 00000000 		.space	4
 3067              		.section	.bss.pxReadyTasksLists,"aw",%nobits
 3068              		.align	2
 3069              		.set	.LANCHOR0,. + 0
 3072              	pxReadyTasksLists:
 3073 0000 00000000 		.space	100
 3073      00000000 
 3073      00000000 
 3073      00000000 
 3073      00000000 
 3074              		.section	.bss.pxOverflowDelayedTaskList,"aw",%nobits
 3075              		.align	2
 3076              		.set	.LANCHOR7,. + 0
 3079              	pxOverflowDelayedTaskList:
 3080 0000 00000000 		.space	4
 3081              		.section	.bss.xTasksWaitingTermination,"aw",%nobits
 3082              		.align	2
 3083              		.set	.LANCHOR4,. + 0
 3086              	xTasksWaitingTermination:
 3087 0000 00000000 		.space	20
 3087      00000000 
 3087      00000000 
 3087      00000000 
 3087      00000000 
 3088              		.section	.bss.pxDelayedTaskList,"aw",%nobits
 3089              		.align	2
 3090              		.set	.LANCHOR6,. + 0
 3093              	pxDelayedTaskList:
 3094 0000 00000000 		.space	4
 3095              		.section	.bss.xPendingReadyList,"aw",%nobits
 3096              		.align	2
 3097              		.set	.LANCHOR3,. + 0
 3100              	xPendingReadyList:
 3101 0000 00000000 		.space	20
 3101      00000000 
 3101      00000000 
 3101      00000000 
 3101      00000000 
 3102              		.section	.bss.xSchedulerRunning,"aw",%nobits
 3103              		.align	2
 3104              		.set	.LANCHOR13,. + 0
 3107              	xSchedulerRunning:
 3108 0000 00000000 		.space	4
 3109              		.section	.bss.ulTaskSwitchedInTime,"aw",%nobits
 3110              		.align	2
 3111              		.set	.LANCHOR23,. + 0
 3114              	ulTaskSwitchedInTime:
 3115 0000 00000000 		.space	4
 3116              		.section	.bss.xMissedYield,"aw",%nobits
 3117              		.align	2
 3118              		.set	.LANCHOR22,. + 0
 3121              	xMissedYield:
 3122 0000 00000000 		.space	4
 3123              		.section	.data.xNextTaskUnblockTime,"aw",%progbits
 3124              		.align	2
 3125              		.set	.LANCHOR10,. + 0
 3128              	xNextTaskUnblockTime:
 3129 0000 FFFFFFFF 		.word	-1
 3130              		.section	.rodata.str1.4,"aMS",%progbits,1
 3131              		.align	2
 3132              	.LC0:
 3133 0000 25752020 		.ascii	"%u  %c  %-16s          0   0%%  %5u\015\012\000"
 3133      25632020 
 3133      252D3136 
 3133      73202020 
 3133      20202020 
 3134 0026 0000     		.space	2
 3135              	.LC1:
 3136 0028 25752020 		.ascii	"%u  %c  %-16s %10u %3u%%  %5u\015\012\000"
 3136      25632020 
 3136      252D3136 
 3136      73202531 
 3136      30752025 
 3137              	.LC2:
 3138 0048 25752020 		.ascii	"%u  %c  %-16s %10u  <1%%  %5u\015\012\000"
 3138      25632020 
 3138      252D3136 
 3138      73202531 
 3138      30752020 
 3139              	.LC3:
 3140 0068 49444C45 		.ascii	"IDLE\000"
 3140      00
 3141 006d 000000   		.space	3
 3142              	.LC4:
 3143 0070 0D0A00   		.ascii	"\015\012\000"
 3144 0073 00       		.section	.bss.pxCurrentTCB,"aw",%nobits
 3145              		.align	2
 3146              		.set	.LANCHOR8,. + 0
 3149              	pxCurrentTCB:
 3150 0000 00000000 		.space	4
 3151              		.section	.bss.pcStatsString,"aw",%nobits
 3152              		.align	2
 3153              		.set	.LANCHOR11,. + 0
 3156              	pcStatsString:
 3157 0000 00000000 		.space	50
 3157      00000000 
 3157      00000000 
 3157      00000000 
 3157      00000000 
 3158 0032 0000     		.section	.bss.xSuspendedTaskList,"aw",%nobits
 3159              		.align	2
 3160              		.set	.LANCHOR5,. + 0
 3163              	xSuspendedTaskList:
 3164 0000 00000000 		.space	20
 3164      00000000 
 3164      00000000 
 3164      00000000 
 3164      00000000 
 3165              		.section	.bss.xDelayedTaskList1,"aw",%nobits
 3166              		.align	2
 3167              		.set	.LANCHOR1,. + 0
 3170              	xDelayedTaskList1:
 3171 0000 00000000 		.space	20
 3171      00000000 
 3171      00000000 
 3171      00000000 
 3171      00000000 
 3172              		.section	.bss.xDelayedTaskList2,"aw",%nobits
 3173              		.align	2
 3174              		.set	.LANCHOR2,. + 0
 3177              	xDelayedTaskList2:
 3178 0000 00000000 		.space	20
 3178      00000000 
 3178      00000000 
 3178      00000000 
 3178      00000000 
 3179              		.section	.bss.uxTaskNumber,"aw",%nobits
 3180              		.align	2
 3181              		.set	.LANCHOR15,. + 0
 3184              	uxTaskNumber:
 3185 0000 00000000 		.space	4
 3186              		.section	.bss.xIdleTaskHandle,"aw",%nobits
 3187              		.align	2
 3188              		.set	.LANCHOR19,. + 0
 3191              	xIdleTaskHandle:
 3192 0000 00000000 		.space	4
 3193              		.section	.bss.uxSchedulerSuspended,"aw",%nobits
 3194              		.align	2
 3195              		.set	.LANCHOR18,. + 0
 3198              	uxSchedulerSuspended:
 3199 0000 00000000 		.space	4
 3200              		.section	.bss.uxMissedTicks,"aw",%nobits
 3201              		.align	2
 3202              		.set	.LANCHOR21,. + 0
 3205              	uxMissedTicks:
 3206 0000 00000000 		.space	4
 3207              		.section	.bss.xNumOfOverflows,"aw",%nobits
 3208              		.align	2
 3209              		.set	.LANCHOR20,. + 0
 3212              	xNumOfOverflows:
 3213 0000 00000000 		.space	4
 3214              		.section	.bss.xTickCount,"aw",%nobits
 3215              		.align	2
 3216              		.set	.LANCHOR9,. + 0
 3219              	xTickCount:
 3220 0000 00000000 		.space	4
 3221              		.section	.bss.uxTopUsedPriority,"aw",%nobits
 3222              		.align	2
 3223              		.set	.LANCHOR14,. + 0
 3226              	uxTopUsedPriority:
 3227 0000 00000000 		.space	4
 3228              		.text
 3229              	.Letext0:
 3230              		.file 2 "/usr/lib/gcc/arm-none-eabi/4.8.2/include/stddef.h"
 3231              		.file 3 "/usr/include/newlib/machine/_default_types.h"
 3232              		.file 4 "FreeRTOS/Source/include/projdefs.h"
 3233              		.file 5 "/usr/include/newlib/stdint.h"
 3234              		.file 6 "libs/Device/STM32F4xx/Include/stm32f4xx.h"
 3235              		.file 7 "FreeRTOS/Source/include/../../Source/portable/GCC/ARM_CM4F/portmacro.h"
 3236              		.file 8 "FreeRTOS/Source/include/FreeRTOS.h"
 3237              		.file 9 "FreeRTOS/Source/include/list.h"
 3238              		.file 10 "FreeRTOS/Source/include/task.h"
 3239              		.file 11 "libs/CMSIS/Include/core_cm4.h"
 3240              		.file 12 "/usr/include/newlib/stdlib.h"
 3241              		.file 13 "/usr/include/newlib/string.h"
 3242              		.file 14 "/usr/include/newlib/stdio.h"
 3243              		.file 15 "FreeRTOS/Source/include/portable.h"
 3244              		.file 16 "src/ustime.h"
 3245              		.file 17 "<built-in>"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 tasks.c
     /tmp/ccVw3cVZ.s:20     .text.usTaskCheckFreeStackSpace:0000000000000000 $t
     /tmp/ccVw3cVZ.s:24     .text.usTaskCheckFreeStackSpace:0000000000000000 usTaskCheckFreeStackSpace
     /tmp/ccVw3cVZ.s:61     .text.prvDeleteTCB:0000000000000000 $t
     /tmp/ccVw3cVZ.s:65     .text.prvDeleteTCB:0000000000000000 prvDeleteTCB
     /tmp/ccVw3cVZ.s:92     .text.prvAllocateTCBAndStack:0000000000000000 $t
     /tmp/ccVw3cVZ.s:96     .text.prvAllocateTCBAndStack:0000000000000000 prvAllocateTCBAndStack
     /tmp/ccVw3cVZ.s:156    .text.prvInitialiseTCBVariables:0000000000000000 $t
     /tmp/ccVw3cVZ.s:160    .text.prvInitialiseTCBVariables:0000000000000000 prvInitialiseTCBVariables
     /tmp/ccVw3cVZ.s:221    .text.prvInitialiseTaskLists:0000000000000000 $t
     /tmp/ccVw3cVZ.s:225    .text.prvInitialiseTaskLists:0000000000000000 prvInitialiseTaskLists
     /tmp/ccVw3cVZ.s:3069   .bss.pxReadyTasksLists:0000000000000000 .LANCHOR0
     /tmp/ccVw3cVZ.s:3167   .bss.xDelayedTaskList1:0000000000000000 .LANCHOR1
     /tmp/ccVw3cVZ.s:3174   .bss.xDelayedTaskList2:0000000000000000 .LANCHOR2
     /tmp/ccVw3cVZ.s:3097   .bss.xPendingReadyList:0000000000000000 .LANCHOR3
     /tmp/ccVw3cVZ.s:3083   .bss.xTasksWaitingTermination:0000000000000000 .LANCHOR4
     /tmp/ccVw3cVZ.s:3160   .bss.xSuspendedTaskList:0000000000000000 .LANCHOR5
     /tmp/ccVw3cVZ.s:3090   .bss.pxDelayedTaskList:0000000000000000 .LANCHOR6
     /tmp/ccVw3cVZ.s:3076   .bss.pxOverflowDelayedTaskList:0000000000000000 .LANCHOR7
     /tmp/ccVw3cVZ.s:301    .text.prvAddCurrentTaskToDelayedList:0000000000000000 $t
     /tmp/ccVw3cVZ.s:305    .text.prvAddCurrentTaskToDelayedList:0000000000000000 prvAddCurrentTaskToDelayedList
     /tmp/ccVw3cVZ.s:3146   .bss.pxCurrentTCB:0000000000000000 .LANCHOR8
     /tmp/ccVw3cVZ.s:3216   .bss.xTickCount:0000000000000000 .LANCHOR9
     /tmp/ccVw3cVZ.s:3125   .data.xNextTaskUnblockTime:0000000000000000 .LANCHOR10
     /tmp/ccVw3cVZ.s:369    .text.prvGenerateRunTimeStatsForTasksInList:0000000000000000 $t
     /tmp/ccVw3cVZ.s:373    .text.prvGenerateRunTimeStatsForTasksInList:0000000000000000 prvGenerateRunTimeStatsForTasksInList
     /tmp/ccVw3cVZ.s:3153   .bss.pcStatsString:0000000000000000 .LANCHOR11
     /tmp/ccVw3cVZ.s:3137   .rodata.str1.4:0000000000000048 .LC2
     /tmp/ccVw3cVZ.s:3135   .rodata.str1.4:0000000000000028 .LC1
     /tmp/ccVw3cVZ.s:3132   .rodata.str1.4:0000000000000000 .LC0
     /tmp/ccVw3cVZ.s:534    .text.xTaskGenericCreate:0000000000000000 $t
     /tmp/ccVw3cVZ.s:539    .text.xTaskGenericCreate:0000000000000000 xTaskGenericCreate
     /tmp/ccVw3cVZ.s:3062   .bss.uxCurrentNumberOfTasks:0000000000000000 .LANCHOR12
     /tmp/ccVw3cVZ.s:3104   .bss.xSchedulerRunning:0000000000000000 .LANCHOR13
     /tmp/ccVw3cVZ.s:3223   .bss.uxTopUsedPriority:0000000000000000 .LANCHOR14
     /tmp/ccVw3cVZ.s:3181   .bss.uxTaskNumber:0000000000000000 .LANCHOR15
     /tmp/ccVw3cVZ.s:3048   .bss.uxTopReadyPriority:0000000000000000 .LANCHOR16
     /tmp/ccVw3cVZ.s:729    .text.vTaskDelete:0000000000000000 $t
     /tmp/ccVw3cVZ.s:734    .text.vTaskDelete:0000000000000000 vTaskDelete
     /tmp/ccVw3cVZ.s:3055   .bss.uxTasksDeleted:0000000000000000 .LANCHOR17
     /tmp/ccVw3cVZ.s:822    .text.uxTaskPriorityGet:0000000000000000 $t
     /tmp/ccVw3cVZ.s:827    .text.uxTaskPriorityGet:0000000000000000 uxTaskPriorityGet
     /tmp/ccVw3cVZ.s:864    .text.vTaskPrioritySet:0000000000000000 $t
     /tmp/ccVw3cVZ.s:869    .text.vTaskPrioritySet:0000000000000000 vTaskPrioritySet
     /tmp/ccVw3cVZ.s:992    .text.xTaskIsTaskSuspended:0000000000000000 $t
     /tmp/ccVw3cVZ.s:997    .text.xTaskIsTaskSuspended:0000000000000000 xTaskIsTaskSuspended
     /tmp/ccVw3cVZ.s:1037   .text.vTaskResume:0000000000000000 $t
     /tmp/ccVw3cVZ.s:1042   .text.vTaskResume:0000000000000000 vTaskResume
     /tmp/ccVw3cVZ.s:1119   .text.xTaskResumeFromISR:0000000000000000 $t
     /tmp/ccVw3cVZ.s:1124   .text.xTaskResumeFromISR:0000000000000000 xTaskResumeFromISR
     /tmp/ccVw3cVZ.s:3195   .bss.uxSchedulerSuspended:0000000000000000 .LANCHOR18
     /tmp/ccVw3cVZ.s:1208   .text.vTaskStartScheduler:0000000000000000 $t
     /tmp/ccVw3cVZ.s:1213   .text.vTaskStartScheduler:0000000000000000 vTaskStartScheduler
     /tmp/ccVw3cVZ.s:3188   .bss.xIdleTaskHandle:0000000000000000 .LANCHOR19
     /tmp/ccVw3cVZ.s:2040   .text.prvIdleTask:0000000000000000 prvIdleTask
     /tmp/ccVw3cVZ.s:3139   .rodata.str1.4:0000000000000068 .LC3
     /tmp/ccVw3cVZ.s:1277   .text.vTaskEndScheduler:0000000000000000 $t
     /tmp/ccVw3cVZ.s:1282   .text.vTaskEndScheduler:0000000000000000 vTaskEndScheduler
     /tmp/ccVw3cVZ.s:1313   .text.vTaskSuspendAll:0000000000000000 $t
     /tmp/ccVw3cVZ.s:1318   .text.vTaskSuspendAll:0000000000000000 vTaskSuspendAll
     /tmp/ccVw3cVZ.s:1336   .text.xTaskGetTickCount:0000000000000000 $t
     /tmp/ccVw3cVZ.s:1341   .text.xTaskGetTickCount:0000000000000000 xTaskGetTickCount
     /tmp/ccVw3cVZ.s:1370   .text.xTaskGetTickCountFromISR:0000000000000000 $t
     /tmp/ccVw3cVZ.s:1375   .text.xTaskGetTickCountFromISR:0000000000000000 xTaskGetTickCountFromISR
     /tmp/ccVw3cVZ.s:1409   .text.uxTaskGetNumberOfTasks:0000000000000000 $t
     /tmp/ccVw3cVZ.s:1414   .text.uxTaskGetNumberOfTasks:0000000000000000 uxTaskGetNumberOfTasks
     /tmp/ccVw3cVZ.s:1431   .text.xTaskGetIdleTaskHandle:0000000000000000 $t
     /tmp/ccVw3cVZ.s:1436   .text.xTaskGetIdleTaskHandle:0000000000000000 xTaskGetIdleTaskHandle
     /tmp/ccVw3cVZ.s:1453   .text.vTaskIncrementTick:0000000000000000 $t
     /tmp/ccVw3cVZ.s:1458   .text.vTaskIncrementTick:0000000000000000 vTaskIncrementTick
     /tmp/ccVw3cVZ.s:3209   .bss.xNumOfOverflows:0000000000000000 .LANCHOR20
     /tmp/ccVw3cVZ.s:3202   .bss.uxMissedTicks:0000000000000000 .LANCHOR21
     /tmp/ccVw3cVZ.s:1622   .text.xTaskResumeAll:0000000000000000 $t
     /tmp/ccVw3cVZ.s:1627   .text.xTaskResumeAll:0000000000000000 xTaskResumeAll
     /tmp/ccVw3cVZ.s:3118   .bss.xMissedYield:0000000000000000 .LANCHOR22
     /tmp/ccVw3cVZ.s:1796   .text.vTaskDelayUntil:0000000000000000 $t
     /tmp/ccVw3cVZ.s:1801   .text.vTaskDelayUntil:0000000000000000 vTaskDelayUntil
     /tmp/ccVw3cVZ.s:1899   .text.vTaskDelay:0000000000000000 $t
     /tmp/ccVw3cVZ.s:1904   .text.vTaskDelay:0000000000000000 vTaskDelay
     /tmp/ccVw3cVZ.s:1961   .text.prvCheckTasksWaitingTermination:0000000000000000 $t
     /tmp/ccVw3cVZ.s:1965   .text.prvCheckTasksWaitingTermination:0000000000000000 prvCheckTasksWaitingTermination
     /tmp/ccVw3cVZ.s:2036   .text.prvIdleTask:0000000000000000 $t
     /tmp/ccVw3cVZ.s:2073   .text.vTaskGetRunTimeStats:0000000000000000 $t
     /tmp/ccVw3cVZ.s:2078   .text.vTaskGetRunTimeStats:0000000000000000 vTaskGetRunTimeStats
     /tmp/ccVw3cVZ.s:3142   .rodata.str1.4:0000000000000070 .LC4
     /tmp/ccVw3cVZ.s:2220   .text.vTaskSetApplicationTaskTag:0000000000000000 $t
     /tmp/ccVw3cVZ.s:2225   .text.vTaskSetApplicationTaskTag:0000000000000000 vTaskSetApplicationTaskTag
     /tmp/ccVw3cVZ.s:2262   .text.xTaskGetApplicationTaskTag:0000000000000000 $t
     /tmp/ccVw3cVZ.s:2267   .text.xTaskGetApplicationTaskTag:0000000000000000 xTaskGetApplicationTaskTag
     /tmp/ccVw3cVZ.s:2304   .text.xTaskCallApplicationTaskHook:0000000000000000 $t
     /tmp/ccVw3cVZ.s:2309   .text.xTaskCallApplicationTaskHook:0000000000000000 xTaskCallApplicationTaskHook
     /tmp/ccVw3cVZ.s:2350   .text.vTaskSwitchContext:0000000000000000 $t
     /tmp/ccVw3cVZ.s:2355   .text.vTaskSwitchContext:0000000000000000 vTaskSwitchContext
     /tmp/ccVw3cVZ.s:3111   .bss.ulTaskSwitchedInTime:0000000000000000 .LANCHOR23
     /tmp/ccVw3cVZ.s:2450   .text.vTaskSuspend:0000000000000000 $t
     /tmp/ccVw3cVZ.s:2455   .text.vTaskSuspend:0000000000000000 vTaskSuspend
     /tmp/ccVw3cVZ.s:2554   .text.vTaskPlaceOnEventList:0000000000000000 $t
     /tmp/ccVw3cVZ.s:2559   .text.vTaskPlaceOnEventList:0000000000000000 vTaskPlaceOnEventList
     /tmp/ccVw3cVZ.s:2615   .text.xTaskRemoveFromEventList:0000000000000000 $t
     /tmp/ccVw3cVZ.s:2620   .text.xTaskRemoveFromEventList:0000000000000000 xTaskRemoveFromEventList
     /tmp/ccVw3cVZ.s:2698   .text.vTaskSetTimeOutState:0000000000000000 $t
     /tmp/ccVw3cVZ.s:2703   .text.vTaskSetTimeOutState:0000000000000000 vTaskSetTimeOutState
     /tmp/ccVw3cVZ.s:2726   .text.xTaskCheckForTimeOut:0000000000000000 $t
     /tmp/ccVw3cVZ.s:2731   .text.xTaskCheckForTimeOut:0000000000000000 xTaskCheckForTimeOut
     /tmp/ccVw3cVZ.s:2816   .text.vTaskMissedYield:0000000000000000 $t
     /tmp/ccVw3cVZ.s:2821   .text.vTaskMissedYield:0000000000000000 vTaskMissedYield
     /tmp/ccVw3cVZ.s:2838   .text.uxTaskGetStackHighWaterMark:0000000000000000 $t
     /tmp/ccVw3cVZ.s:2843   .text.uxTaskGetStackHighWaterMark:0000000000000000 uxTaskGetStackHighWaterMark
     /tmp/ccVw3cVZ.s:2874   .text.xTaskGetCurrentTaskHandle:0000000000000000 $t
     /tmp/ccVw3cVZ.s:2879   .text.xTaskGetCurrentTaskHandle:0000000000000000 xTaskGetCurrentTaskHandle
     /tmp/ccVw3cVZ.s:2897   .text.vTaskPriorityInherit:0000000000000000 $t
     /tmp/ccVw3cVZ.s:2902   .text.vTaskPriorityInherit:0000000000000000 vTaskPriorityInherit
     /tmp/ccVw3cVZ.s:2984   .text.vTaskPriorityDisinherit:0000000000000000 $t
     /tmp/ccVw3cVZ.s:2989   .text.vTaskPriorityDisinherit:0000000000000000 vTaskPriorityDisinherit
     /tmp/ccVw3cVZ.s:3149   .bss.pxCurrentTCB:0000000000000000 pxCurrentTCB
     /tmp/ccVw3cVZ.s:3047   .bss.uxTopReadyPriority:0000000000000000 $d
     /tmp/ccVw3cVZ.s:3051   .bss.uxTopReadyPriority:0000000000000000 uxTopReadyPriority
     /tmp/ccVw3cVZ.s:3054   .bss.uxTasksDeleted:0000000000000000 $d
     /tmp/ccVw3cVZ.s:3058   .bss.uxTasksDeleted:0000000000000000 uxTasksDeleted
     /tmp/ccVw3cVZ.s:3061   .bss.uxCurrentNumberOfTasks:0000000000000000 $d
     /tmp/ccVw3cVZ.s:3065   .bss.uxCurrentNumberOfTasks:0000000000000000 uxCurrentNumberOfTasks
     /tmp/ccVw3cVZ.s:3068   .bss.pxReadyTasksLists:0000000000000000 $d
     /tmp/ccVw3cVZ.s:3072   .bss.pxReadyTasksLists:0000000000000000 pxReadyTasksLists
     /tmp/ccVw3cVZ.s:3075   .bss.pxOverflowDelayedTaskList:0000000000000000 $d
     /tmp/ccVw3cVZ.s:3079   .bss.pxOverflowDelayedTaskList:0000000000000000 pxOverflowDelayedTaskList
     /tmp/ccVw3cVZ.s:3082   .bss.xTasksWaitingTermination:0000000000000000 $d
     /tmp/ccVw3cVZ.s:3086   .bss.xTasksWaitingTermination:0000000000000000 xTasksWaitingTermination
     /tmp/ccVw3cVZ.s:3089   .bss.pxDelayedTaskList:0000000000000000 $d
     /tmp/ccVw3cVZ.s:3093   .bss.pxDelayedTaskList:0000000000000000 pxDelayedTaskList
     /tmp/ccVw3cVZ.s:3096   .bss.xPendingReadyList:0000000000000000 $d
     /tmp/ccVw3cVZ.s:3100   .bss.xPendingReadyList:0000000000000000 xPendingReadyList
     /tmp/ccVw3cVZ.s:3103   .bss.xSchedulerRunning:0000000000000000 $d
     /tmp/ccVw3cVZ.s:3107   .bss.xSchedulerRunning:0000000000000000 xSchedulerRunning
     /tmp/ccVw3cVZ.s:3110   .bss.ulTaskSwitchedInTime:0000000000000000 $d
     /tmp/ccVw3cVZ.s:3114   .bss.ulTaskSwitchedInTime:0000000000000000 ulTaskSwitchedInTime
     /tmp/ccVw3cVZ.s:3117   .bss.xMissedYield:0000000000000000 $d
     /tmp/ccVw3cVZ.s:3121   .bss.xMissedYield:0000000000000000 xMissedYield
     /tmp/ccVw3cVZ.s:3124   .data.xNextTaskUnblockTime:0000000000000000 $d
     /tmp/ccVw3cVZ.s:3128   .data.xNextTaskUnblockTime:0000000000000000 xNextTaskUnblockTime
     /tmp/ccVw3cVZ.s:3131   .rodata.str1.4:0000000000000000 $d
     /tmp/ccVw3cVZ.s:3145   .bss.pxCurrentTCB:0000000000000000 $d
     /tmp/ccVw3cVZ.s:3152   .bss.pcStatsString:0000000000000000 $d
     /tmp/ccVw3cVZ.s:3156   .bss.pcStatsString:0000000000000000 pcStatsString
     /tmp/ccVw3cVZ.s:3159   .bss.xSuspendedTaskList:0000000000000000 $d
     /tmp/ccVw3cVZ.s:3163   .bss.xSuspendedTaskList:0000000000000000 xSuspendedTaskList
     /tmp/ccVw3cVZ.s:3166   .bss.xDelayedTaskList1:0000000000000000 $d
     /tmp/ccVw3cVZ.s:3170   .bss.xDelayedTaskList1:0000000000000000 xDelayedTaskList1
     /tmp/ccVw3cVZ.s:3173   .bss.xDelayedTaskList2:0000000000000000 $d
     /tmp/ccVw3cVZ.s:3177   .bss.xDelayedTaskList2:0000000000000000 xDelayedTaskList2
     /tmp/ccVw3cVZ.s:3180   .bss.uxTaskNumber:0000000000000000 $d
     /tmp/ccVw3cVZ.s:3184   .bss.uxTaskNumber:0000000000000000 uxTaskNumber
     /tmp/ccVw3cVZ.s:3187   .bss.xIdleTaskHandle:0000000000000000 $d
     /tmp/ccVw3cVZ.s:3191   .bss.xIdleTaskHandle:0000000000000000 xIdleTaskHandle
     /tmp/ccVw3cVZ.s:3194   .bss.uxSchedulerSuspended:0000000000000000 $d
     /tmp/ccVw3cVZ.s:3198   .bss.uxSchedulerSuspended:0000000000000000 uxSchedulerSuspended
     /tmp/ccVw3cVZ.s:3201   .bss.uxMissedTicks:0000000000000000 $d
     /tmp/ccVw3cVZ.s:3205   .bss.uxMissedTicks:0000000000000000 uxMissedTicks
     /tmp/ccVw3cVZ.s:3208   .bss.xNumOfOverflows:0000000000000000 $d
     /tmp/ccVw3cVZ.s:3212   .bss.xNumOfOverflows:0000000000000000 xNumOfOverflows
     /tmp/ccVw3cVZ.s:3215   .bss.xTickCount:0000000000000000 $d
     /tmp/ccVw3cVZ.s:3219   .bss.xTickCount:0000000000000000 xTickCount
     /tmp/ccVw3cVZ.s:3222   .bss.uxTopUsedPriority:0000000000000000 $d
     /tmp/ccVw3cVZ.s:3226   .bss.uxTopUsedPriority:0000000000000000 uxTopUsedPriority
                     .debug_frame:0000000000000010 $d
                           .group:0000000000000000 wm4.1.7402b5479d3fa4780665141f585fc0ee
                           .group:0000000000000000 wm4.newlib.h.8.fec018e441fee7bfa1923812ad010f97
                           .group:0000000000000000 wm4.features.h.22.6a4ca7cd053637cc1d0db6c16f39b2d7
                           .group:0000000000000000 wm4.config.h.212.4163ef2871a828c674038d036b081cfd
                           .group:0000000000000000 wm4._ansi.h.23.2147fde150631f5584b9dc29b914d1b8
                           .group:0000000000000000 wm4.stdio.h.31.7c0e28c411445f3f9c5b11accf882760
                           .group:0000000000000000 wm4.stddef.h.184.159df79b4ca79c76561572a55985524c
                           .group:0000000000000000 wm4.stdarg.h.34.3a23a216c0c293b3d2ea2e89281481e6
                           .group:0000000000000000 wm4.stddef.h.39.7e3d906ac58942e0b374c527445f5de5
                           .group:0000000000000000 wm4._default_types.h.6.9e4229723f5523536bc8f574589d6a99
                           .group:0000000000000000 wm4.lock.h.2.9bc98482741e5e2a9450b12934a684ea
                           .group:0000000000000000 wm4._types.h.54.d3d34a3b7f3cc230cd159baf022b4b08
                           .group:0000000000000000 wm4.stddef.h.158.61317cdbfb4026324507d123a50b0fd6
                           .group:0000000000000000 wm4.reent.h.17.8bd9e4098e0428508c282cad794fae43
                           .group:0000000000000000 wm4.types.h.23.0d949686bbcadd1621462d4fa1f884f9
                           .group:0000000000000000 wm4.types.h.2.e9cec8c90ab35f77d9f499e06ae02400
                           .group:0000000000000000 wm4.types.h.80.56707660962b21991903f1fee7c13bb3
                           .group:0000000000000000 wm4.stdio.h.2.4aa87247282eca6c8f36f9de33d8df1a
                           .group:0000000000000000 wm4.stdio.h.64.0f05fa42cfe2db7fc44729a52d3ba948
                           .group:0000000000000000 wm4.stdlib.h.13.4ed386f5c1a80d71e72172885d946ef2
                           .group:0000000000000000 wm4.stddef.h.158.a7efb00f6cbc6f43213b50e183c9830c
                           .group:0000000000000000 wm4.alloca.h.8.dfc0c703c47ec3e69746825b17d9e66d
                           .group:0000000000000000 wm4.stdlib.h.53.1a82a3cc35cb0a04319c41bcf41d2a02
                           .group:0000000000000000 wm4.cdefs.h.47.62f534e9f325912d9007cf852ba0bf0d
                           .group:0000000000000000 wm4.string.h.15.dab3980bf35408a4c507182805e2de3a
                           .group:0000000000000000 wm4.string.h.126.6ff3aa59129e7f66b2c273baf353e066
                           .group:0000000000000000 wm4.projdefs.h.55.cdae9ead80b5a2ac004f41bb277aad45
                           .group:0000000000000000 wm4.FreeRTOSConfig.h.55.a343614a17c4367a6359a1f530d6d32b
                           .group:0000000000000000 wm4.stm32f4xx.h.48.a3308e16720c7afc3eb28e585e628ce6
                           .group:0000000000000000 wm4.core_cm4.h.32.5f62939b60122629d60d85d0c4a14709
                           .group:0000000000000000 wm4.stdint.h.10.d0f8e374834fcfc2e296d5d5fe82f02a
                           .group:0000000000000000 wm4.core_cmInstr.h.25.f50f886f2edf670cf199b35fd96f5c91
                           .group:0000000000000000 wm4.core_cm4_simd.h.29.b4a3fdfb606cb3b26119424324d4b963
                           .group:0000000000000000 wm4.core_cm4.h.153.5393ef7e6cebf34dd51ca528f9218ab3
                           .group:0000000000000000 wm4.stm32f4xx.h.282.95bae448a91bccfbf24a6f9d95904bb8
                           .group:0000000000000000 wm4.stm32f4xx_adc.h.102.2061aa73008746f3c2cc6ce8f635cad3
                           .group:0000000000000000 wm4.stm32f4xx_can.h.25.87f18ca48b2692d39f76e87b1f07c953
                           .group:0000000000000000 wm4.stm32f4xx_cryp.h.25.db1951c06ee684df97ea3a11aba6cb51
                           .group:0000000000000000 wm4.stm32f4xx_dac.h.25.c43557a6416ea4dfa986c1209c2558d6
                           .group:0000000000000000 wm4.stm32f4xx_dbgmcu.h.24.7aedfdcf091890b5cb96019bd29a2bfc
                           .group:0000000000000000 wm4.stm32f4xx_dcmi.h.24.64883d9be802a535b1d7770d14da73e0
                           .group:0000000000000000 wm4.stm32f4xx_dma.h.25.c1fa1d44ae0bc9c2b3a0d1d355d8c1e6
                           .group:0000000000000000 wm4.stm32f4xx_exti.h.25.620998268d5d3d9042a8297fbe07d507
                           .group:0000000000000000 wm4.stm32f4xx_flash.h.25.65d4f351b72ee41355279f70305f361a
                           .group:0000000000000000 wm4.stm32f4xx_fsmc.h.25.b907ac7bd9bec46e02d06b137d53cfd8
                           .group:0000000000000000 wm4.stm32f4xx_hash.h.25.633fb84f031cf2ab1bd834e536716dfa
                           .group:0000000000000000 wm4.stm32f4xx_gpio.h.25.5bd1d790d742a307b55aea5fa8fcdae8
                           .group:0000000000000000 wm4.stm32f4xx_i2c.h.25.8fcdb817a00a67d4624d79bab0d9275f
                           .group:0000000000000000 wm4.stm32f4xx_iwdg.h.25.3013e8d2058415cb9d51af77f748a146
                           .group:0000000000000000 wm4.stm32f4xx_pwr.h.25.48b68c1f3a894ab012f9c2a2c222f159
                           .group:0000000000000000 wm4.stm32f4xx_rcc.h.24.c15e7c8dc065bb29146f29591b195c87
                           .group:0000000000000000 wm4.stm32f4xx_rng.h.25.cdb5c5c07de6a48aedfde608da3f447e
                           .group:0000000000000000 wm4.stm32f4xx_rtc.h.25.4809a79ad46ad97b4a01e735a96738eb
                           .group:0000000000000000 wm4.stm32f4xx_sdio.h.25.406302aabae34eada94e5f2cde635a3e
                           .group:0000000000000000 wm4.stm32f4xx_spi.h.25.46c61b79ff8408da93e2e90cf9b717d6
                           .group:0000000000000000 wm4.stm32f4xx_syscfg.h.25.9d5caab5677661b69e959531364e23d7
                           .group:0000000000000000 wm4.stm32f4xx_tim.h.25.948f7fc943f34bd206e29758e77ee0a2
                           .group:0000000000000000 wm4.stm32f4xx_usart.h.25.b64697dad017ba547dd272c2cdb5846a
                           .group:0000000000000000 wm4.stm32f4xx_wwdg.h.25.09d70b7849c6894ddf1e83c8e86b70e1
                           .group:0000000000000000 wm4.misc.h.25.a0cb758c1f091b46f201b19cec9e63a1
                           .group:0000000000000000 wm4.stm32f4xx.h.6913.da011404ccb203790556c86f10c46b18
                           .group:0000000000000000 wm4.FreeRTOSConfig.h.74.fc794e36cd6c91c3b4695c74d78d9ccd
                           .group:0000000000000000 wm4.portmacro.h.69.a7e264ae32accd81a6ffb6f75a8356fe
                           .group:0000000000000000 wm4.portable.h.315.489c085dbd13c768c8594a7d23ef5545
                           .group:0000000000000000 wm4.mpu_wrappers.h.55.46a4a008a193040c38098e9a5f07ff9d
                           .group:0000000000000000 wm4.FreeRTOS.h.136.a1d4f27d190f434afd0502fdd510d30a
                           .group:0000000000000000 wm4.list.h.84.e713c47e239b06424d7c93968625e34d
                           .group:0000000000000000 wm4.task.h.73.ea72fb74b80a9cae261e97c6a9e3f3a7
                           .group:0000000000000000 wm4.timers.h.73.f641518c14256243ae6ff0fd4bba5bbe
                           .group:0000000000000000 wm4.StackMacros.h.55.6d32da70bba937a3f8476e3b9d518421

UNDEFINED SYMBOLS
free
malloc
memset
strncpy
vListInitialiseItem
vListInitialise
vListInsert
sprintf
strcat
pxPortInitialiseStack
vPortEnterCritical
vListInsertEnd
vPortExitCritical
vPortYieldFromISR
vListRemove
init_us_timer
xPortStartScheduler
vPortEndScheduler
get_us_time
strlen
