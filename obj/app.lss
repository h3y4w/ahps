
obj/app.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   00000188  08000000  08000000  00008000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         000041d0  08000188  08000188  00008188  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .init_array   00000008  08004358  08004358  0000c358  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  3 .fini_array   00000004  08004360  08004360  0000c360  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  4 .data         00000884  20000000  08004364  00010000  2**3
                  CONTENTS, ALLOC, LOAD, DATA
  5 .bss          00000594  20000888  08004be8  00010888  2**3
                  ALLOC
  6 ._user_heap_stack 00000400  20000e1c  08004be8  00010e1c  2**0
                  ALLOC
  7 .ARM.attributes 0000002e  00000000  00000000  00010884  2**0
                  CONTENTS, READONLY
  8 .comment      0000001f  00000000  00000000  000108b2  2**0
                  CONTENTS, READONLY
  9 .debug_info   000101be  00000000  00000000  000108d1  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_abbrev 00002b92  00000000  00000000  00020a8f  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00005ddc  00000000  00000000  00023621  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_aranges 00000cb0  00000000  00000000  00029400  2**3
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00000b50  00000000  00000000  0002a0b0  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_line   00004683  00000000  00000000  0002ac00  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_str    0005e3ff  00000000  00000000  0002f283  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_frame  0000263c  00000000  00000000  0008d684  2**2
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_macro  0000dfb2  00000000  00000000  0008fcc0  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

08000188 <deregister_tm_clones>:
 8000188:	b508      	push	{r3, lr}
 800018a:	f640 0084 	movw	r0, #2180	; 0x884
 800018e:	4b07      	ldr	r3, [pc, #28]	; (80001ac <deregister_tm_clones+0x24>)
 8000190:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8000194:	1a1b      	subs	r3, r3, r0
 8000196:	2b06      	cmp	r3, #6
 8000198:	d800      	bhi.n	800019c <deregister_tm_clones+0x14>
 800019a:	bd08      	pop	{r3, pc}
 800019c:	f240 0300 	movw	r3, #0
 80001a0:	f2c0 0300 	movt	r3, #0
 80001a4:	2b00      	cmp	r3, #0
 80001a6:	d0f8      	beq.n	800019a <deregister_tm_clones+0x12>
 80001a8:	4798      	blx	r3
 80001aa:	e7f6      	b.n	800019a <deregister_tm_clones+0x12>
 80001ac:	20000887 	.word	0x20000887

080001b0 <register_tm_clones>:
 80001b0:	b508      	push	{r3, lr}
 80001b2:	f640 0084 	movw	r0, #2180	; 0x884
 80001b6:	f640 0384 	movw	r3, #2180	; 0x884
 80001ba:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80001be:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80001c2:	1a1b      	subs	r3, r3, r0
 80001c4:	109b      	asrs	r3, r3, #2
 80001c6:	eb03 73d3 	add.w	r3, r3, r3, lsr #31
 80001ca:	1059      	asrs	r1, r3, #1
 80001cc:	d100      	bne.n	80001d0 <register_tm_clones+0x20>
 80001ce:	bd08      	pop	{r3, pc}
 80001d0:	f240 0200 	movw	r2, #0
 80001d4:	f2c0 0200 	movt	r2, #0
 80001d8:	2a00      	cmp	r2, #0
 80001da:	d0f8      	beq.n	80001ce <register_tm_clones+0x1e>
 80001dc:	4790      	blx	r2
 80001de:	e7f6      	b.n	80001ce <register_tm_clones+0x1e>

080001e0 <__do_global_dtors_aux>:
 80001e0:	b510      	push	{r4, lr}
 80001e2:	f640 0488 	movw	r4, #2184	; 0x888
 80001e6:	f2c2 0400 	movt	r4, #8192	; 0x2000
 80001ea:	7823      	ldrb	r3, [r4, #0]
 80001ec:	b973      	cbnz	r3, 800020c <__do_global_dtors_aux+0x2c>
 80001ee:	f7ff ffcb 	bl	8000188 <deregister_tm_clones>
 80001f2:	f240 0300 	movw	r3, #0
 80001f6:	f2c0 0300 	movt	r3, #0
 80001fa:	b12b      	cbz	r3, 8000208 <__do_global_dtors_aux+0x28>
 80001fc:	f244 3040 	movw	r0, #17216	; 0x4340
 8000200:	f6c0 0000 	movt	r0, #2048	; 0x800
 8000204:	f3af 8000 	nop.w
 8000208:	2301      	movs	r3, #1
 800020a:	7023      	strb	r3, [r4, #0]
 800020c:	bd10      	pop	{r4, pc}
 800020e:	bf00      	nop

08000210 <frame_dummy>:
 8000210:	b508      	push	{r3, lr}
 8000212:	f240 0300 	movw	r3, #0
 8000216:	f2c0 0300 	movt	r3, #0
 800021a:	b14b      	cbz	r3, 8000230 <frame_dummy+0x20>
 800021c:	f244 3040 	movw	r0, #17216	; 0x4340
 8000220:	f640 018c 	movw	r1, #2188	; 0x88c
 8000224:	f6c0 0000 	movt	r0, #2048	; 0x800
 8000228:	f2c2 0100 	movt	r1, #8192	; 0x2000
 800022c:	f3af 8000 	nop.w
 8000230:	f640 0084 	movw	r0, #2180	; 0x884
 8000234:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8000238:	6803      	ldr	r3, [r0, #0]
 800023a:	b12b      	cbz	r3, 8000248 <frame_dummy+0x38>
 800023c:	f240 0300 	movw	r3, #0
 8000240:	f2c0 0300 	movt	r3, #0
 8000244:	b103      	cbz	r3, 8000248 <frame_dummy+0x38>
 8000246:	4798      	blx	r3
 8000248:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
 800024c:	e7b0      	b.n	80001b0 <register_tm_clones>
 800024e:	bf00      	nop

08000250 <memcpy>:
 8000250:	4684      	mov	ip, r0
 8000252:	ea41 0300 	orr.w	r3, r1, r0
 8000256:	f013 0303 	ands.w	r3, r3, #3
 800025a:	d16d      	bne.n	8000338 <memcpy+0xe8>
 800025c:	3a40      	subs	r2, #64	; 0x40
 800025e:	d341      	bcc.n	80002e4 <memcpy+0x94>
 8000260:	f851 3b04 	ldr.w	r3, [r1], #4
 8000264:	f840 3b04 	str.w	r3, [r0], #4
 8000268:	f851 3b04 	ldr.w	r3, [r1], #4
 800026c:	f840 3b04 	str.w	r3, [r0], #4
 8000270:	f851 3b04 	ldr.w	r3, [r1], #4
 8000274:	f840 3b04 	str.w	r3, [r0], #4
 8000278:	f851 3b04 	ldr.w	r3, [r1], #4
 800027c:	f840 3b04 	str.w	r3, [r0], #4
 8000280:	f851 3b04 	ldr.w	r3, [r1], #4
 8000284:	f840 3b04 	str.w	r3, [r0], #4
 8000288:	f851 3b04 	ldr.w	r3, [r1], #4
 800028c:	f840 3b04 	str.w	r3, [r0], #4
 8000290:	f851 3b04 	ldr.w	r3, [r1], #4
 8000294:	f840 3b04 	str.w	r3, [r0], #4
 8000298:	f851 3b04 	ldr.w	r3, [r1], #4
 800029c:	f840 3b04 	str.w	r3, [r0], #4
 80002a0:	f851 3b04 	ldr.w	r3, [r1], #4
 80002a4:	f840 3b04 	str.w	r3, [r0], #4
 80002a8:	f851 3b04 	ldr.w	r3, [r1], #4
 80002ac:	f840 3b04 	str.w	r3, [r0], #4
 80002b0:	f851 3b04 	ldr.w	r3, [r1], #4
 80002b4:	f840 3b04 	str.w	r3, [r0], #4
 80002b8:	f851 3b04 	ldr.w	r3, [r1], #4
 80002bc:	f840 3b04 	str.w	r3, [r0], #4
 80002c0:	f851 3b04 	ldr.w	r3, [r1], #4
 80002c4:	f840 3b04 	str.w	r3, [r0], #4
 80002c8:	f851 3b04 	ldr.w	r3, [r1], #4
 80002cc:	f840 3b04 	str.w	r3, [r0], #4
 80002d0:	f851 3b04 	ldr.w	r3, [r1], #4
 80002d4:	f840 3b04 	str.w	r3, [r0], #4
 80002d8:	f851 3b04 	ldr.w	r3, [r1], #4
 80002dc:	f840 3b04 	str.w	r3, [r0], #4
 80002e0:	3a40      	subs	r2, #64	; 0x40
 80002e2:	d2bd      	bcs.n	8000260 <memcpy+0x10>
 80002e4:	3230      	adds	r2, #48	; 0x30
 80002e6:	d311      	bcc.n	800030c <memcpy+0xbc>
 80002e8:	f851 3b04 	ldr.w	r3, [r1], #4
 80002ec:	f840 3b04 	str.w	r3, [r0], #4
 80002f0:	f851 3b04 	ldr.w	r3, [r1], #4
 80002f4:	f840 3b04 	str.w	r3, [r0], #4
 80002f8:	f851 3b04 	ldr.w	r3, [r1], #4
 80002fc:	f840 3b04 	str.w	r3, [r0], #4
 8000300:	f851 3b04 	ldr.w	r3, [r1], #4
 8000304:	f840 3b04 	str.w	r3, [r0], #4
 8000308:	3a10      	subs	r2, #16
 800030a:	d2ed      	bcs.n	80002e8 <memcpy+0x98>
 800030c:	320c      	adds	r2, #12
 800030e:	d305      	bcc.n	800031c <memcpy+0xcc>
 8000310:	f851 3b04 	ldr.w	r3, [r1], #4
 8000314:	f840 3b04 	str.w	r3, [r0], #4
 8000318:	3a04      	subs	r2, #4
 800031a:	d2f9      	bcs.n	8000310 <memcpy+0xc0>
 800031c:	3204      	adds	r2, #4
 800031e:	d008      	beq.n	8000332 <memcpy+0xe2>
 8000320:	07d2      	lsls	r2, r2, #31
 8000322:	bf1c      	itt	ne
 8000324:	f811 3b01 	ldrbne.w	r3, [r1], #1
 8000328:	f800 3b01 	strbne.w	r3, [r0], #1
 800032c:	d301      	bcc.n	8000332 <memcpy+0xe2>
 800032e:	880b      	ldrh	r3, [r1, #0]
 8000330:	8003      	strh	r3, [r0, #0]
 8000332:	4660      	mov	r0, ip
 8000334:	4770      	bx	lr
 8000336:	bf00      	nop
 8000338:	2a08      	cmp	r2, #8
 800033a:	d313      	bcc.n	8000364 <memcpy+0x114>
 800033c:	078b      	lsls	r3, r1, #30
 800033e:	d08d      	beq.n	800025c <memcpy+0xc>
 8000340:	f010 0303 	ands.w	r3, r0, #3
 8000344:	d08a      	beq.n	800025c <memcpy+0xc>
 8000346:	f1c3 0304 	rsb	r3, r3, #4
 800034a:	1ad2      	subs	r2, r2, r3
 800034c:	07db      	lsls	r3, r3, #31
 800034e:	bf1c      	itt	ne
 8000350:	f811 3b01 	ldrbne.w	r3, [r1], #1
 8000354:	f800 3b01 	strbne.w	r3, [r0], #1
 8000358:	d380      	bcc.n	800025c <memcpy+0xc>
 800035a:	f831 3b02 	ldrh.w	r3, [r1], #2
 800035e:	f820 3b02 	strh.w	r3, [r0], #2
 8000362:	e77b      	b.n	800025c <memcpy+0xc>
 8000364:	3a04      	subs	r2, #4
 8000366:	d3d9      	bcc.n	800031c <memcpy+0xcc>
 8000368:	3a01      	subs	r2, #1
 800036a:	f811 3b01 	ldrb.w	r3, [r1], #1
 800036e:	f800 3b01 	strb.w	r3, [r0], #1
 8000372:	d2f9      	bcs.n	8000368 <memcpy+0x118>
 8000374:	780b      	ldrb	r3, [r1, #0]
 8000376:	7003      	strb	r3, [r0, #0]
 8000378:	784b      	ldrb	r3, [r1, #1]
 800037a:	7043      	strb	r3, [r0, #1]
 800037c:	788b      	ldrb	r3, [r1, #2]
 800037e:	7083      	strb	r3, [r0, #2]
 8000380:	4660      	mov	r0, ip
 8000382:	4770      	bx	lr

08000384 <rb_getc>:
 * \param   rb    pointer to ringbuffer struct
 * \param   data  pointer to data byte
 * \return  number of bytes read (0 if buffer was empty)
 */
static inline int rb_getc(struct ringbuf *rb, char *data)
{
 8000384:	b580      	push	{r7, lr}
 8000386:	b082      	sub	sp, #8
 8000388:	af00      	add	r7, sp, #0
 800038a:	6078      	str	r0, [r7, #4]
 800038c:	6039      	str	r1, [r7, #0]
    if (!rb->len)
 800038e:	687b      	ldr	r3, [r7, #4]
 8000390:	68db      	ldr	r3, [r3, #12]
 8000392:	2b00      	cmp	r3, #0
 8000394:	d101      	bne.n	800039a <rb_getc+0x16>
        return 0;
 8000396:	2300      	movs	r3, #0
 8000398:	e021      	b.n	80003de <rb_getc+0x5a>

    vPortEnterCritical();
 800039a:	f002 fadd 	bl	8002958 <vPortEnterCritical>

    *data = rb->buf[rb->pos++];
 800039e:	687b      	ldr	r3, [r7, #4]
 80003a0:	681a      	ldr	r2, [r3, #0]
 80003a2:	687b      	ldr	r3, [r7, #4]
 80003a4:	689b      	ldr	r3, [r3, #8]
 80003a6:	1c58      	adds	r0, r3, #1
 80003a8:	6879      	ldr	r1, [r7, #4]
 80003aa:	6088      	str	r0, [r1, #8]
 80003ac:	4413      	add	r3, r2
 80003ae:	781a      	ldrb	r2, [r3, #0]
 80003b0:	683b      	ldr	r3, [r7, #0]
 80003b2:	701a      	strb	r2, [r3, #0]
	if (rb->pos >= rb->bufsize)
 80003b4:	687b      	ldr	r3, [r7, #4]
 80003b6:	689a      	ldr	r2, [r3, #8]
 80003b8:	687b      	ldr	r3, [r7, #4]
 80003ba:	685b      	ldr	r3, [r3, #4]
 80003bc:	429a      	cmp	r2, r3
 80003be:	db06      	blt.n	80003ce <rb_getc+0x4a>
		rb->pos -= rb->bufsize;
 80003c0:	687b      	ldr	r3, [r7, #4]
 80003c2:	689a      	ldr	r2, [r3, #8]
 80003c4:	687b      	ldr	r3, [r7, #4]
 80003c6:	685b      	ldr	r3, [r3, #4]
 80003c8:	1ad2      	subs	r2, r2, r3
 80003ca:	687b      	ldr	r3, [r7, #4]
 80003cc:	609a      	str	r2, [r3, #8]
	rb->len--;
 80003ce:	687b      	ldr	r3, [r7, #4]
 80003d0:	68db      	ldr	r3, [r3, #12]
 80003d2:	1e5a      	subs	r2, r3, #1
 80003d4:	687b      	ldr	r3, [r7, #4]
 80003d6:	60da      	str	r2, [r3, #12]

    vPortExitCritical();
 80003d8:	f002 fad4 	bl	8002984 <vPortExitCritical>
    return 1;
 80003dc:	2301      	movs	r3, #1
}
 80003de:	4618      	mov	r0, r3
 80003e0:	3708      	adds	r7, #8
 80003e2:	46bd      	mov	sp, r7
 80003e4:	bd80      	pop	{r7, pc}
 80003e6:	bf00      	nop

080003e8 <rb_putc>:
 * \param   rb    pointer to ringbuffer struct
 * \param   data  pointer to data byte
 * \return  number of bytes written (0 if buffer was full)
 */
static inline int rb_putc(struct ringbuf *rb, const char data)
{
 80003e8:	b580      	push	{r7, lr}
 80003ea:	b084      	sub	sp, #16
 80003ec:	af00      	add	r7, sp, #0
 80003ee:	6078      	str	r0, [r7, #4]
 80003f0:	460b      	mov	r3, r1
 80003f2:	70fb      	strb	r3, [r7, #3]
    if (rb->len >= rb->bufsize)
 80003f4:	687b      	ldr	r3, [r7, #4]
 80003f6:	68da      	ldr	r2, [r3, #12]
 80003f8:	687b      	ldr	r3, [r7, #4]
 80003fa:	685b      	ldr	r3, [r3, #4]
 80003fc:	429a      	cmp	r2, r3
 80003fe:	db01      	blt.n	8000404 <rb_putc+0x1c>
        return 0;
 8000400:	2300      	movs	r3, #0
 8000402:	e01f      	b.n	8000444 <rb_putc+0x5c>

    vPortEnterCritical();
 8000404:	f002 faa8 	bl	8002958 <vPortEnterCritical>

	int i = rb->pos + rb->len;
 8000408:	687b      	ldr	r3, [r7, #4]
 800040a:	689a      	ldr	r2, [r3, #8]
 800040c:	687b      	ldr	r3, [r7, #4]
 800040e:	68db      	ldr	r3, [r3, #12]
 8000410:	4413      	add	r3, r2
 8000412:	60fb      	str	r3, [r7, #12]
	if (i >= rb->bufsize)
 8000414:	687b      	ldr	r3, [r7, #4]
 8000416:	685a      	ldr	r2, [r3, #4]
 8000418:	68fb      	ldr	r3, [r7, #12]
 800041a:	429a      	cmp	r2, r3
 800041c:	dc04      	bgt.n	8000428 <rb_putc+0x40>
		i -= rb->bufsize;
 800041e:	687b      	ldr	r3, [r7, #4]
 8000420:	685b      	ldr	r3, [r3, #4]
 8000422:	68fa      	ldr	r2, [r7, #12]
 8000424:	1ad3      	subs	r3, r2, r3
 8000426:	60fb      	str	r3, [r7, #12]

	rb->buf[i] = data;
 8000428:	687b      	ldr	r3, [r7, #4]
 800042a:	681a      	ldr	r2, [r3, #0]
 800042c:	68fb      	ldr	r3, [r7, #12]
 800042e:	4413      	add	r3, r2
 8000430:	78fa      	ldrb	r2, [r7, #3]
 8000432:	701a      	strb	r2, [r3, #0]
	rb->len++;
 8000434:	687b      	ldr	r3, [r7, #4]
 8000436:	68db      	ldr	r3, [r3, #12]
 8000438:	1c5a      	adds	r2, r3, #1
 800043a:	687b      	ldr	r3, [r7, #4]
 800043c:	60da      	str	r2, [r3, #12]

    vPortExitCritical();
 800043e:	f002 faa1 	bl	8002984 <vPortExitCritical>
    return 1;
 8000442:	2301      	movs	r3, #1
}
 8000444:	4618      	mov	r0, r3
 8000446:	3710      	adds	r7, #16
 8000448:	46bd      	mov	sp, r7
 800044a:	bd80      	pop	{r7, pc}

0800044c <USART1_IRQHandler>:
    uint32_t    tx_bytes;
} uart_stats;


void USART1_IRQHandler(void)
{
 800044c:	b580      	push	{r7, lr}
 800044e:	b082      	sub	sp, #8
 8000450:	af00      	add	r7, sp, #0
    if (USART1->SR & USART_SR_RXNE) {
 8000452:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 8000456:	f2c4 0301 	movt	r3, #16385	; 0x4001
 800045a:	881b      	ldrh	r3, [r3, #0]
 800045c:	b29b      	uxth	r3, r3
 800045e:	f003 0320 	and.w	r3, r3, #32
 8000462:	2b00      	cmp	r3, #0
 8000464:	d027      	beq.n	80004b6 <USART1_IRQHandler+0x6a>
        if (!rb_putc(&rx_buf, USART1->DR))
 8000466:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 800046a:	f2c4 0301 	movt	r3, #16385	; 0x4001
 800046e:	889b      	ldrh	r3, [r3, #4]
 8000470:	b29b      	uxth	r3, r3
 8000472:	b2db      	uxtb	r3, r3
 8000474:	f240 0000 	movw	r0, #0
 8000478:	f2c2 0000 	movt	r0, #8192	; 0x2000
 800047c:	4619      	mov	r1, r3
 800047e:	f7ff ffb3 	bl	80003e8 <rb_putc>
 8000482:	4603      	mov	r3, r0
 8000484:	2b00      	cmp	r3, #0
 8000486:	d10b      	bne.n	80004a0 <USART1_IRQHandler+0x54>
            uart_stats.rx_overrun++;
 8000488:	f640 13a4 	movw	r3, #2468	; 0x9a4
 800048c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8000490:	681b      	ldr	r3, [r3, #0]
 8000492:	1c5a      	adds	r2, r3, #1
 8000494:	f640 13a4 	movw	r3, #2468	; 0x9a4
 8000498:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800049c:	601a      	str	r2, [r3, #0]
 800049e:	e00a      	b.n	80004b6 <USART1_IRQHandler+0x6a>
        else
            uart_stats.rx_bytes++;
 80004a0:	f640 13a4 	movw	r3, #2468	; 0x9a4
 80004a4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80004a8:	685b      	ldr	r3, [r3, #4]
 80004aa:	1c5a      	adds	r2, r3, #1
 80004ac:	f640 13a4 	movw	r3, #2468	; 0x9a4
 80004b0:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80004b4:	605a      	str	r2, [r3, #4]
    }

    if (USART1->SR & USART_SR_TXE) {
 80004b6:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 80004ba:	f2c4 0301 	movt	r3, #16385	; 0x4001
 80004be:	881b      	ldrh	r3, [r3, #0]
 80004c0:	b29b      	uxth	r3, r3
 80004c2:	f003 0380 	and.w	r3, r3, #128	; 0x80
 80004c6:	2b00      	cmp	r3, #0
 80004c8:	d02a      	beq.n	8000520 <USART1_IRQHandler+0xd4>
        char c;
        if (rb_getc(&tx_buf, &c)) {
 80004ca:	1dfb      	adds	r3, r7, #7
 80004cc:	f240 0010 	movw	r0, #16
 80004d0:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80004d4:	4619      	mov	r1, r3
 80004d6:	f7ff ff55 	bl	8000384 <rb_getc>
 80004da:	4603      	mov	r3, r0
 80004dc:	2b00      	cmp	r3, #0
 80004de:	d006      	beq.n	80004ee <USART1_IRQHandler+0xa2>
            // send a queued byte
            //
            USART1->DR = c;
 80004e0:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 80004e4:	f2c4 0301 	movt	r3, #16385	; 0x4001
 80004e8:	79fa      	ldrb	r2, [r7, #7]
 80004ea:	809a      	strh	r2, [r3, #4]
 80004ec:	e00d      	b.n	800050a <USART1_IRQHandler+0xbe>
        }
        else {
            // nothing to send, disable interrupt
            //
            USART1->CR1 &= ~USART_CR1_TXEIE;
 80004ee:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 80004f2:	f2c4 0301 	movt	r3, #16385	; 0x4001
 80004f6:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 80004fa:	f2c4 0201 	movt	r2, #16385	; 0x4001
 80004fe:	8992      	ldrh	r2, [r2, #12]
 8000500:	b292      	uxth	r2, r2
 8000502:	f022 0280 	bic.w	r2, r2, #128	; 0x80
 8000506:	b292      	uxth	r2, r2
 8000508:	819a      	strh	r2, [r3, #12]
        }
        uart_stats.tx_bytes++;
 800050a:	f640 13a4 	movw	r3, #2468	; 0x9a4
 800050e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8000512:	689b      	ldr	r3, [r3, #8]
 8000514:	1c5a      	adds	r2, r3, #1
 8000516:	f640 13a4 	movw	r3, #2468	; 0x9a4
 800051a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800051e:	609a      	str	r2, [r3, #8]
    }
}
 8000520:	3708      	adds	r7, #8
 8000522:	46bd      	mov	sp, r7
 8000524:	bd80      	pop	{r7, pc}
 8000526:	bf00      	nop

08000528 <get_us_time>:
 *   this function must be called at least
 *   once every 65ms to work correctly.
 *
 */
uint64_t get_us_time()
{
 8000528:	b580      	push	{r7, lr}
 800052a:	b082      	sub	sp, #8
 800052c:	af00      	add	r7, sp, #0
    static uint16_t t0;
    static uint64_t tickcount;

    vPortEnterCritical();
 800052e:	f002 fa13 	bl	8002958 <vPortEnterCritical>

    int t = TIM7->CNT;
 8000532:	f44f 53a0 	mov.w	r3, #5120	; 0x1400
 8000536:	f2c4 0300 	movt	r3, #16384	; 0x4000
 800053a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800053c:	607b      	str	r3, [r7, #4]
    if (t < t0)
 800053e:	f640 13b0 	movw	r3, #2480	; 0x9b0
 8000542:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8000546:	881b      	ldrh	r3, [r3, #0]
 8000548:	461a      	mov	r2, r3
 800054a:	687b      	ldr	r3, [r7, #4]
 800054c:	429a      	cmp	r2, r3
 800054e:	dd03      	ble.n	8000558 <get_us_time+0x30>
        t += 0x10000;
 8000550:	687b      	ldr	r3, [r7, #4]
 8000552:	f503 3380 	add.w	r3, r3, #65536	; 0x10000
 8000556:	607b      	str	r3, [r7, #4]

    tickcount += t - t0;
 8000558:	f640 13b0 	movw	r3, #2480	; 0x9b0
 800055c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8000560:	881b      	ldrh	r3, [r3, #0]
 8000562:	687a      	ldr	r2, [r7, #4]
 8000564:	1ad3      	subs	r3, r2, r3
 8000566:	4618      	mov	r0, r3
 8000568:	ea4f 71e0 	mov.w	r1, r0, asr #31
 800056c:	f640 13b8 	movw	r3, #2488	; 0x9b8
 8000570:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8000574:	e9d3 2300 	ldrd	r2, r3, [r3]
 8000578:	1880      	adds	r0, r0, r2
 800057a:	eb41 0103 	adc.w	r1, r1, r3
 800057e:	f640 13b8 	movw	r3, #2488	; 0x9b8
 8000582:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8000586:	e9c3 0100 	strd	r0, r1, [r3]
    t0 = t;
 800058a:	687b      	ldr	r3, [r7, #4]
 800058c:	b29a      	uxth	r2, r3
 800058e:	f640 13b0 	movw	r3, #2480	; 0x9b0
 8000592:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8000596:	801a      	strh	r2, [r3, #0]

    vPortExitCritical();
 8000598:	f002 f9f4 	bl	8002984 <vPortExitCritical>

    return tickcount;
 800059c:	f640 13b8 	movw	r3, #2488	; 0x9b8
 80005a0:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80005a4:	e9d3 2300 	ldrd	r2, r3, [r3]
}
 80005a8:	4610      	mov	r0, r2
 80005aa:	4619      	mov	r1, r3
 80005ac:	3708      	adds	r7, #8
 80005ae:	46bd      	mov	sp, r7
 80005b0:	bd80      	pop	{r7, pc}
 80005b2:	bf00      	nop

080005b4 <delay_us>:
 * \param  us  number of microseconds to wait.
 * \note   The actual delay will last between us and (us-1) microseconds.
 *         To wait _at_least_ 1 us, you should use delay_us(2).
 */
void delay_us(unsigned long us)
{
 80005b4:	b480      	push	{r7}
 80005b6:	b085      	sub	sp, #20
 80005b8:	af00      	add	r7, sp, #0
 80005ba:	6078      	str	r0, [r7, #4]
    uint16_t  t0 = TIM7->CNT;
 80005bc:	f44f 53a0 	mov.w	r3, #5120	; 0x1400
 80005c0:	f2c4 0300 	movt	r3, #16384	; 0x4000
 80005c4:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80005c6:	81fb      	strh	r3, [r7, #14]
    for (;;) {
        int  t = TIM7->CNT;
 80005c8:	f44f 53a0 	mov.w	r3, #5120	; 0x1400
 80005cc:	f2c4 0300 	movt	r3, #16384	; 0x4000
 80005d0:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80005d2:	60bb      	str	r3, [r7, #8]
        if (t < t0)
 80005d4:	89fa      	ldrh	r2, [r7, #14]
 80005d6:	68bb      	ldr	r3, [r7, #8]
 80005d8:	429a      	cmp	r2, r3
 80005da:	dd03      	ble.n	80005e4 <delay_us+0x30>
            t += 0x10000;
 80005dc:	68bb      	ldr	r3, [r7, #8]
 80005de:	f503 3380 	add.w	r3, r3, #65536	; 0x10000
 80005e2:	60bb      	str	r3, [r7, #8]

        if (us < t - t0)
 80005e4:	89fb      	ldrh	r3, [r7, #14]
 80005e6:	68ba      	ldr	r2, [r7, #8]
 80005e8:	1ad3      	subs	r3, r2, r3
 80005ea:	461a      	mov	r2, r3
 80005ec:	687b      	ldr	r3, [r7, #4]
 80005ee:	429a      	cmp	r2, r3
 80005f0:	d900      	bls.n	80005f4 <delay_us+0x40>
            return;
 80005f2:	e008      	b.n	8000606 <delay_us+0x52>

        us -= t - t0;
 80005f4:	89fa      	ldrh	r2, [r7, #14]
 80005f6:	68bb      	ldr	r3, [r7, #8]
 80005f8:	1ad3      	subs	r3, r2, r3
 80005fa:	687a      	ldr	r2, [r7, #4]
 80005fc:	4413      	add	r3, r2
 80005fe:	607b      	str	r3, [r7, #4]
        t0  = t;
 8000600:	68bb      	ldr	r3, [r7, #8]
 8000602:	81fb      	strh	r3, [r7, #14]
    }
 8000604:	e7e0      	b.n	80005c8 <delay_us+0x14>
}
 8000606:	3714      	adds	r7, #20
 8000608:	46bd      	mov	sp, r7
 800060a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800060e:	4770      	bx	lr

08000610 <delay_ms>:
 * Perform a millisecond delay
 *
 * \param  ms  number of milliseconds to wait.
 */
void delay_ms(unsigned long ms)
{
 8000610:	b580      	push	{r7, lr}
 8000612:	b082      	sub	sp, #8
 8000614:	af00      	add	r7, sp, #0
 8000616:	6078      	str	r0, [r7, #4]
    delay_us(ms * 1000);
 8000618:	687b      	ldr	r3, [r7, #4]
 800061a:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 800061e:	fb02 f303 	mul.w	r3, r2, r3
 8000622:	4618      	mov	r0, r3
 8000624:	f7ff ffc6 	bl	80005b4 <delay_us>
}
 8000628:	3708      	adds	r7, #8
 800062a:	46bd      	mov	sp, r7
 800062c:	bd80      	pop	{r7, pc}
 800062e:	bf00      	nop

08000630 <init_us_timer>:
/**
 * Set up TIM7 as a 16bit, microsecond-timer.
 *
 */
void init_us_timer()
{
 8000630:	b580      	push	{r7, lr}
 8000632:	b084      	sub	sp, #16
 8000634:	af00      	add	r7, sp, #0
    RCC_ClocksTypeDef RCC_Clocks;
    RCC_GetClocksFreq(&RCC_Clocks);
 8000636:	463b      	mov	r3, r7
 8000638:	4618      	mov	r0, r3
 800063a:	f002 fb7f 	bl	8002d3c <RCC_GetClocksFreq>

    RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM7, ENABLE);
 800063e:	2020      	movs	r0, #32
 8000640:	2101      	movs	r1, #1
 8000642:	f002 fc77 	bl	8002f34 <RCC_APB1PeriphClockCmd>

    RCC->APB1ENR |= RCC_APB1Periph_TIM7;
 8000646:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 800064a:	f2c4 0302 	movt	r3, #16386	; 0x4002
 800064e:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 8000652:	f2c4 0202 	movt	r2, #16386	; 0x4002
 8000656:	6c12      	ldr	r2, [r2, #64]	; 0x40
 8000658:	f042 0220 	orr.w	r2, r2, #32
 800065c:	641a      	str	r2, [r3, #64]	; 0x40
    TIM7->PSC = (RCC_Clocks.PCLK2_Frequency / 1000000) - 1;
 800065e:	f44f 53a0 	mov.w	r3, #5120	; 0x1400
 8000662:	f2c4 0300 	movt	r3, #16384	; 0x4000
 8000666:	68f9      	ldr	r1, [r7, #12]
 8000668:	f64d 6283 	movw	r2, #56963	; 0xde83
 800066c:	f2c4 321b 	movt	r2, #17179	; 0x431b
 8000670:	fba2 0201 	umull	r0, r2, r2, r1
 8000674:	0c92      	lsrs	r2, r2, #18
 8000676:	b292      	uxth	r2, r2
 8000678:	3a01      	subs	r2, #1
 800067a:	b292      	uxth	r2, r2
 800067c:	851a      	strh	r2, [r3, #40]	; 0x28
    TIM7->ARR = 0xFFFF;
 800067e:	f44f 53a0 	mov.w	r3, #5120	; 0x1400
 8000682:	f2c4 0300 	movt	r3, #16384	; 0x4000
 8000686:	f64f 72ff 	movw	r2, #65535	; 0xffff
 800068a:	62da      	str	r2, [r3, #44]	; 0x2c
    TIM7->CR1 = TIM_CR1_CEN;
 800068c:	f44f 53a0 	mov.w	r3, #5120	; 0x1400
 8000690:	f2c4 0300 	movt	r3, #16384	; 0x4000
 8000694:	2201      	movs	r2, #1
 8000696:	801a      	strh	r2, [r3, #0]

    TIM_Cmd(TIM7, ENABLE);
 8000698:	f44f 50a0 	mov.w	r0, #5120	; 0x1400
 800069c:	f2c4 0000 	movt	r0, #16384	; 0x4000
 80006a0:	2101      	movs	r1, #1
 80006a2:	f002 fd05 	bl	80030b0 <TIM_Cmd>
}
 80006a6:	3710      	adds	r7, #16
 80006a8:	46bd      	mov	sp, r7
 80006aa:	bd80      	pop	{r7, pc}

080006ac <idle_blinky>:

    USART_puts(USART2, "\r\n");
    vTaskDelete(NULL);
}

void idle_blinky (void *pvParameters) {
 80006ac:	b580      	push	{r7, lr}
    while(1) {
        GPIO_SetBits(GPIOD, GPIO_Pin_12);
 80006ae:	f44f 6440 	mov.w	r4, #3072	; 0xc00
 80006b2:	f2c4 0402 	movt	r4, #16386	; 0x4002
 80006b6:	f44f 5980 	mov.w	r9, #4096	; 0x1000
        delay_ms(500);
 80006ba:	f44f 75fa 	mov.w	r5, #500	; 0x1f4

        GPIO_SetBits(GPIOD, GPIO_Pin_13);
 80006be:	f44f 5800 	mov.w	r8, #8192	; 0x2000
        delay_ms(500);

        GPIO_SetBits(GPIOD, GPIO_Pin_14);
 80006c2:	f44f 4780 	mov.w	r7, #16384	; 0x4000
        delay_ms(500);

        GPIO_SetBits(GPIOD, GPIO_Pin_15);
 80006c6:	f44f 4600 	mov.w	r6, #32768	; 0x8000
    vTaskDelete(NULL);
}

void idle_blinky (void *pvParameters) {
    while(1) {
        GPIO_SetBits(GPIOD, GPIO_Pin_12);
 80006ca:	4620      	mov	r0, r4
 80006cc:	4649      	mov	r1, r9
 80006ce:	f002 fad3 	bl	8002c78 <GPIO_SetBits>
        delay_ms(500);
 80006d2:	4628      	mov	r0, r5
 80006d4:	f7ff ff9c 	bl	8000610 <delay_ms>

        GPIO_SetBits(GPIOD, GPIO_Pin_13);
 80006d8:	4620      	mov	r0, r4
 80006da:	4641      	mov	r1, r8
 80006dc:	f002 facc 	bl	8002c78 <GPIO_SetBits>
        delay_ms(500);
 80006e0:	4628      	mov	r0, r5
 80006e2:	f7ff ff95 	bl	8000610 <delay_ms>

        GPIO_SetBits(GPIOD, GPIO_Pin_14);
 80006e6:	4620      	mov	r0, r4
 80006e8:	4639      	mov	r1, r7
 80006ea:	f002 fac5 	bl	8002c78 <GPIO_SetBits>
        delay_ms(500);
 80006ee:	4628      	mov	r0, r5
 80006f0:	f7ff ff8e 	bl	8000610 <delay_ms>

        GPIO_SetBits(GPIOD, GPIO_Pin_15);
 80006f4:	4620      	mov	r0, r4
 80006f6:	4631      	mov	r1, r6
 80006f8:	f002 fabe 	bl	8002c78 <GPIO_SetBits>
        delay_ms(500);
 80006fc:	4628      	mov	r0, r5
 80006fe:	f7ff ff87 	bl	8000610 <delay_ms>

        GPIO_ResetBits(GPIOD, GPIO_Pin_12|GPIO_Pin_13 | GPIO_Pin_14 | GPIO_Pin_15);
 8000702:	4620      	mov	r0, r4
 8000704:	f44f 4170 	mov.w	r1, #61440	; 0xf000
 8000708:	f002 fac4 	bl	8002c94 <GPIO_ResetBits>
        delay_ms(500);
 800070c:	4628      	mov	r0, r5
 800070e:	f7ff ff7f 	bl	8000610 <delay_ms>
 8000712:	e7da      	b.n	80006ca <idle_blinky+0x1e>

08000714 <USART_put>:
    if (SysTick_Config(SystemCoreClock / 1000)) {
        while (1){};
    }
}

void USART_put(USART_TypeDef* USARTx, volatile char c) {
 8000714:	b500      	push	{lr}
 8000716:	b083      	sub	sp, #12
 8000718:	f88d 1007 	strb.w	r1, [sp, #7]
    // wait until data register is empty
    while(!(USARTx->SR & 0x00000040) );
 800071c:	8803      	ldrh	r3, [r0, #0]
 800071e:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8000722:	b29b      	uxth	r3, r3
 8000724:	2b00      	cmp	r3, #0
 8000726:	d0f9      	beq.n	800071c <USART_put+0x8>
    USART_SendData(USARTx, c);
 8000728:	f89d 1007 	ldrb.w	r1, [sp, #7]
 800072c:	f002 ff00 	bl	8003530 <USART_SendData>
}
 8000730:	b003      	add	sp, #12
 8000732:	f85d fb04 	ldr.w	pc, [sp], #4
 8000736:	bf00      	nop

08000738 <USART_puts>:

void USART_puts(USART_TypeDef* USARTx, volatile char *s){
 8000738:	b570      	push	{r4, r5, r6, lr}
 800073a:	4606      	mov	r6, r0
 800073c:	460c      	mov	r4, r1
	while(*s){
 800073e:	e007      	b.n	8000750 <USART_puts+0x18>
        USART_put(USARTx, *s);
 8000740:	4625      	mov	r5, r4
 8000742:	f815 1b01 	ldrb.w	r1, [r5], #1
 8000746:	4630      	mov	r0, r6
 8000748:	f7ff ffe4 	bl	8000714 <USART_put>
		*s++;
 800074c:	7823      	ldrb	r3, [r4, #0]
 800074e:	462c      	mov	r4, r5
    while(!(USARTx->SR & 0x00000040) );
    USART_SendData(USARTx, c);
}

void USART_puts(USART_TypeDef* USARTx, volatile char *s){
	while(*s){
 8000750:	7823      	ldrb	r3, [r4, #0]
 8000752:	f013 0fff 	tst.w	r3, #255	; 0xff
 8000756:	d1f3      	bne.n	8000740 <USART_puts+0x8>
        USART_put(USARTx, *s);
		*s++;
	}
}
 8000758:	bd70      	pop	{r4, r5, r6, pc}
 800075a:	bf00      	nop

0800075c <handle_uart_command>:
    }

    return 1;
}
*/
void handle_uart_command(char *command) {
 800075c:	b510      	push	{r4, lr}

    USART_puts(USART2, "Command: ");
 800075e:	f44f 4488 	mov.w	r4, #17408	; 0x4400
 8000762:	f2c4 0400 	movt	r4, #16384	; 0x4000
 8000766:	4620      	mov	r0, r4
 8000768:	f244 1128 	movw	r1, #16680	; 0x4128
 800076c:	f6c0 0100 	movt	r1, #2048	; 0x800
 8000770:	f7ff ffe2 	bl	8000738 <USART_puts>
        USART_put(USART2, *command);
        command++;
    }
    */

    USART_puts(USART2, "\r\n");
 8000774:	4620      	mov	r0, r4
 8000776:	f244 11f0 	movw	r1, #16880	; 0x41f0
 800077a:	f6c0 0100 	movt	r1, #2048	; 0x800
 800077e:	f7ff ffdb 	bl	8000738 <USART_puts>
    vTaskDelete(NULL);
 8000782:	2000      	movs	r0, #0
 8000784:	f000 ff5c 	bl	8001640 <vTaskDelete>
 8000788:	bd10      	pop	{r4, pc}
 800078a:	bf00      	nop

0800078c <vPH_read_value>:
} 

int TEST_PH_VALUE = 50;


void vPH_read_value(PHMeter_Module *meter) {
 800078c:	b510      	push	{r4, lr}
 800078e:	4604      	mov	r4, r0
    meter->state = MODULE_RUNNING;
 8000790:	2300      	movs	r3, #0
 8000792:	7203      	strb	r3, [r0, #8]
    if (xSemaphoreTake(meter->mutex, (portTickType) 100) == pdTRUE) {
 8000794:	6840      	ldr	r0, [r0, #4]
 8000796:	4619      	mov	r1, r3
 8000798:	2264      	movs	r2, #100	; 0x64
 800079a:	f001 fdeb 	bl	8002374 <xQueueGenericReceive>
 800079e:	2801      	cmp	r0, #1
 80007a0:	d118      	bne.n	80007d4 <vPH_read_value+0x48>
        USART_puts(USART2, "Read pH Meter...\r\n");
 80007a2:	f44f 4088 	mov.w	r0, #17408	; 0x4400
 80007a6:	f2c4 0000 	movt	r0, #16384	; 0x4000
 80007aa:	f244 1134 	movw	r1, #16692	; 0x4134
 80007ae:	f6c0 0100 	movt	r1, #2048	; 0x800
 80007b2:	f7ff ffc1 	bl	8000738 <USART_puts>
        meter->value = TEST_PH_VALUE;
 80007b6:	f240 0320 	movw	r3, #32
 80007ba:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80007be:	681b      	ldr	r3, [r3, #0]
 80007c0:	6023      	str	r3, [r4, #0]
        meter->state = MODULE_EXECUTED;
 80007c2:	2302      	movs	r3, #2
 80007c4:	7223      	strb	r3, [r4, #8]
        xSemaphoreGive(meter->mutex);
 80007c6:	6860      	ldr	r0, [r4, #4]
 80007c8:	2100      	movs	r1, #0
 80007ca:	460a      	mov	r2, r1
 80007cc:	460b      	mov	r3, r1
 80007ce:	f001 fd4b 	bl	8002268 <xQueueGenericSend>
 80007d2:	e009      	b.n	80007e8 <vPH_read_value+0x5c>

    }

    else {
        USART_puts(USART2, "COULDNT TAKE SEMAPHORE");
 80007d4:	f44f 4088 	mov.w	r0, #17408	; 0x4400
 80007d8:	f2c4 0000 	movt	r0, #16384	; 0x4000
 80007dc:	f244 1148 	movw	r1, #16712	; 0x4148
 80007e0:	f6c0 0100 	movt	r1, #2048	; 0x800
 80007e4:	f7ff ffa8 	bl	8000738 <USART_puts>

    }

    vTaskDelete(NULL);
 80007e8:	2000      	movs	r0, #0
 80007ea:	f000 ff29 	bl	8001640 <vTaskDelete>
 80007ee:	bd10      	pop	{r4, pc}

080007f0 <vPPump_dispense>:

}

void vPPump_dispense(vPPump_parameters *params) {
 80007f0:	b510      	push	{r4, lr}
 80007f2:	4604      	mov	r4, r0
    params->ppump->state = MODULE_RUNNING; 
 80007f4:	6802      	ldr	r2, [r0, #0]
 80007f6:	2300      	movs	r3, #0
 80007f8:	f882 302e 	strb.w	r3, [r2, #46]	; 0x2e
    if (xSemaphoreTake(PHMeter_Resvoir.mutex, (portTickType) 100) == pdTRUE) {
 80007fc:	f640 32c8 	movw	r2, #3016	; 0xbc8
 8000800:	f2c2 0200 	movt	r2, #8192	; 0x2000
 8000804:	6850      	ldr	r0, [r2, #4]
 8000806:	4619      	mov	r1, r3
 8000808:	2264      	movs	r2, #100	; 0x64
 800080a:	f001 fdb3 	bl	8002374 <xQueueGenericReceive>
 800080e:	2801      	cmp	r0, #1
 8000810:	d143      	bne.n	800089a <vPPump_dispense+0xaa>
        const int ppump_speed = 1;
        //GPIO_WriteBit(params->port, params->pin, Bit_SET);
        USART_puts(USART2, "Starting to dispense...\r\n");
 8000812:	f44f 4088 	mov.w	r0, #17408	; 0x4400
 8000816:	f2c4 0000 	movt	r0, #16384	; 0x4000
 800081a:	f244 1160 	movw	r1, #16736	; 0x4160
 800081e:	f6c0 0100 	movt	r1, #2048	; 0x800
 8000822:	f7ff ff89 	bl	8000738 <USART_puts>
        if (params->ppump == &PPump_PHUP) TEST_PH_VALUE+=5;
 8000826:	6822      	ldr	r2, [r4, #0]
 8000828:	f640 33d4 	movw	r3, #3028	; 0xbd4
 800082c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8000830:	429a      	cmp	r2, r3
 8000832:	d107      	bne.n	8000844 <vPPump_dispense+0x54>
 8000834:	f240 0320 	movw	r3, #32
 8000838:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800083c:	681a      	ldr	r2, [r3, #0]
 800083e:	3205      	adds	r2, #5
 8000840:	601a      	str	r2, [r3, #0]
 8000842:	e00d      	b.n	8000860 <vPPump_dispense+0x70>
        else if(params->ppump == &PPump_PHDOWN) TEST_PH_VALUE-=5; 
 8000844:	f640 43a8 	movw	r3, #3240	; 0xca8
 8000848:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800084c:	429a      	cmp	r2, r3
 800084e:	bf01      	itttt	eq
 8000850:	f240 0320 	movweq	r3, #32
 8000854:	f2c2 0300 	movteq	r3, #8192	; 0x2000
 8000858:	681a      	ldreq	r2, [r3, #0]
 800085a:	3a05      	subeq	r2, #5
 800085c:	bf08      	it	eq
 800085e:	601a      	streq	r2, [r3, #0]

        portTickType xDelay = (1000 * ppump_speed) / portTICK_RATE_MS;
        vTaskDelay(xDelay);
 8000860:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8000864:	f000 ff46 	bl	80016f4 <vTaskDelay>
        USART_puts(USART2, "Finished dispensing\r\n");
 8000868:	f44f 4088 	mov.w	r0, #17408	; 0x4400
 800086c:	f2c4 0000 	movt	r0, #16384	; 0x4000
 8000870:	f244 117c 	movw	r1, #16764	; 0x417c
 8000874:	f6c0 0100 	movt	r1, #2048	; 0x800
 8000878:	f7ff ff5e 	bl	8000738 <USART_puts>
        xSemaphoreGive(PHMeter_Resvoir.mutex);
 800087c:	f640 33c8 	movw	r3, #3016	; 0xbc8
 8000880:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8000884:	6858      	ldr	r0, [r3, #4]
 8000886:	2100      	movs	r1, #0
 8000888:	460a      	mov	r2, r1
 800088a:	460b      	mov	r3, r1
 800088c:	f001 fcec 	bl	8002268 <xQueueGenericSend>
        params->ppump->state = MODULE_EXECUTED; 
 8000890:	6823      	ldr	r3, [r4, #0]
 8000892:	2202      	movs	r2, #2
 8000894:	f883 202e 	strb.w	r2, [r3, #46]	; 0x2e
 8000898:	e009      	b.n	80008ae <vPPump_dispense+0xbe>

    }

    else {
        USART_puts(USART2, "PPUMP_DISPENSE COULDNT GET MUTEX\r\n");
 800089a:	f44f 4088 	mov.w	r0, #17408	; 0x4400
 800089e:	f2c4 0000 	movt	r0, #16384	; 0x4000
 80008a2:	f244 1194 	movw	r1, #16788	; 0x4194
 80008a6:	f6c0 0100 	movt	r1, #2048	; 0x800
 80008aa:	f7ff ff45 	bl	8000738 <USART_puts>
    }
    vTaskDelete(NULL);
 80008ae:	2000      	movs	r0, #0
 80008b0:	f000 fec6 	bl	8001640 <vTaskDelete>
 80008b4:	bd10      	pop	{r4, pc}
 80008b6:	bf00      	nop

080008b8 <USART_put_int>:
        USART_put(USARTx, *s);
		*s++;
	}
}

void USART_put_int(USART_TypeDef* USARTx, int number) {
 80008b8:	b5f0      	push	{r4, r5, r6, r7, lr}
 80008ba:	b085      	sub	sp, #20
 80008bc:	4606      	mov	r6, r0
    uint8_t neg = 0;

    if (number < 0) {
 80008be:	2900      	cmp	r1, #0
        number*=-1;
 80008c0:	bfba      	itte	lt
 80008c2:	4249      	neglt	r1, r1
        neg = 1;
 80008c4:	2701      	movlt	r7, #1
		*s++;
	}
}

void USART_put_int(USART_TypeDef* USARTx, int number) {
    uint8_t neg = 0;
 80008c6:	2700      	movge	r7, #0
    if (number < 0) {
        number*=-1;
        neg = 1;
    }
    char value[10];
    int i=0;
 80008c8:	2200      	movs	r2, #0
    do {
        value[i++] = (char)(number % 10) + '0';
 80008ca:	f246 6067 	movw	r0, #26215	; 0x6667
 80008ce:	f2c6 6066 	movt	r0, #26214	; 0x6666
 80008d2:	1c54      	adds	r4, r2, #1
 80008d4:	fb80 3501 	smull	r3, r5, r0, r1
 80008d8:	17cb      	asrs	r3, r1, #31
 80008da:	ebc3 03a5 	rsb	r3, r3, r5, asr #2
 80008de:	461d      	mov	r5, r3
 80008e0:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 80008e4:	eba1 0343 	sub.w	r3, r1, r3, lsl #1
 80008e8:	b2db      	uxtb	r3, r3
 80008ea:	a904      	add	r1, sp, #16
 80008ec:	440a      	add	r2, r1
 80008ee:	3330      	adds	r3, #48	; 0x30
 80008f0:	f802 3c0c 	strb.w	r3, [r2, #-12]
        number /= 10;
 80008f4:	4629      	mov	r1, r5
        neg = 1;
    }
    char value[10];
    int i=0;
    do {
        value[i++] = (char)(number % 10) + '0';
 80008f6:	4622      	mov	r2, r4
        number /= 10;
    } while (number);
 80008f8:	2d00      	cmp	r5, #0
 80008fa:	d1ea      	bne.n	80008d2 <USART_put_int+0x1a>

    if (neg) USART_put(USARTx, '-');    
 80008fc:	b167      	cbz	r7, 8000918 <USART_put_int+0x60>
 80008fe:	4630      	mov	r0, r6
 8000900:	212d      	movs	r1, #45	; 0x2d
 8000902:	f7ff ff07 	bl	8000714 <USART_put>
 8000906:	e007      	b.n	8000918 <USART_put_int+0x60>
    while(i) {
        USART_put(USARTx, value[--i]);
 8000908:	3c01      	subs	r4, #1
 800090a:	ab04      	add	r3, sp, #16
 800090c:	4423      	add	r3, r4
 800090e:	4630      	mov	r0, r6
 8000910:	f813 1c0c 	ldrb.w	r1, [r3, #-12]
 8000914:	f7ff fefe 	bl	8000714 <USART_put>
        value[i++] = (char)(number % 10) + '0';
        number /= 10;
    } while (number);

    if (neg) USART_put(USARTx, '-');    
    while(i) {
 8000918:	2c00      	cmp	r4, #0
 800091a:	d1f5      	bne.n	8000908 <USART_put_int+0x50>
        USART_put(USARTx, value[--i]);
    }
}
 800091c:	b005      	add	sp, #20
 800091e:	bdf0      	pop	{r4, r5, r6, r7, pc}

08000920 <vPH_task>:
    }
    vTaskDelete(NULL);
}


void vPH_task(vPH_parameters *params) {
 8000920:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8000924:	b089      	sub	sp, #36	; 0x24
 8000926:	4681      	mov	r9, r0
    USART_puts(USART2, "-----------------\r\n(1)target ph: ");
 8000928:	f44f 4488 	mov.w	r4, #17408	; 0x4400
 800092c:	f2c4 0400 	movt	r4, #16384	; 0x4000
 8000930:	4620      	mov	r0, r4
 8000932:	f244 11b8 	movw	r1, #16824	; 0x41b8
 8000936:	f6c0 0100 	movt	r1, #2048	; 0x800
 800093a:	f7ff fefd 	bl	8000738 <USART_puts>
    USART_put_int(USART2, params->target_ph);
 800093e:	4620      	mov	r0, r4
 8000940:	f8d9 1004 	ldr.w	r1, [r9, #4]
 8000944:	f7ff ffb8 	bl	80008b8 <USART_put_int>
    USART_puts(USART2, "\r\n");
 8000948:	4620      	mov	r0, r4
 800094a:	f244 11f0 	movw	r1, #16880	; 0x41f0
 800094e:	f6c0 0100 	movt	r1, #2048	; 0x800
 8000952:	f7ff fef1 	bl	8000738 <USART_puts>

    USART_puts(USART2, "Executing PH_task...\r\n");
 8000956:	4620      	mov	r0, r4
 8000958:	f244 11dc 	movw	r1, #16860	; 0x41dc
 800095c:	f6c0 0100 	movt	r1, #2048	; 0x800
 8000960:	f7ff feea 	bl	8000738 <USART_puts>

    PHMeter_Resvoir.mutex = xSemaphoreCreateMutex();
 8000964:	f001 fc42 	bl	80021ec <xQueueCreateMutex>
 8000968:	f640 34c8 	movw	r4, #3016	; 0xbc8
 800096c:	f2c2 0400 	movt	r4, #8192	; 0x2000
 8000970:	6060      	str	r0, [r4, #4]
    xSemaphoreGive(PHMeter_Resvoir.mutex);
 8000972:	2100      	movs	r1, #0
 8000974:	460a      	mov	r2, r1
 8000976:	460b      	mov	r3, r1
 8000978:	f001 fc76 	bl	8002268 <xQueueGenericSend>


    if (PHMeter_Resvoir.mutex == NULL) USART_puts(USART2, "PH_METER->mutex == NULL\r\n");
 800097c:	6863      	ldr	r3, [r4, #4]
 800097e:	b94b      	cbnz	r3, 8000994 <vPH_task+0x74>
 8000980:	f44f 4088 	mov.w	r0, #17408	; 0x4400
 8000984:	f2c4 0000 	movt	r0, #16384	; 0x4000
 8000988:	f244 11f4 	movw	r1, #16884	; 0x41f4
 800098c:	f6c0 0100 	movt	r1, #2048	; 0x800
 8000990:	f7ff fed2 	bl	8000738 <USART_puts>
     *
     *
     * MAKE SUB TASKS CREATED INCREMENT ITS PRIORITY BY ONE RELATIVE TO PARENT TASK
     */
//    params->target_ph = 100;
    USART_puts(USART2, "-----------------\r\ntarget ph: ");
 8000994:	f44f 4488 	mov.w	r4, #17408	; 0x4400
 8000998:	f2c4 0400 	movt	r4, #16384	; 0x4000
 800099c:	4620      	mov	r0, r4
 800099e:	f244 2110 	movw	r1, #16912	; 0x4210
 80009a2:	f6c0 0100 	movt	r1, #2048	; 0x800
 80009a6:	f7ff fec7 	bl	8000738 <USART_puts>
    USART_put_int(USART2, params->target_ph);
 80009aa:	4620      	mov	r0, r4
 80009ac:	f8d9 1004 	ldr.w	r1, [r9, #4]
 80009b0:	f7ff ff82 	bl	80008b8 <USART_put_int>
    USART_puts(USART2, "\r\n");
 80009b4:	4620      	mov	r0, r4
 80009b6:	f244 11f0 	movw	r1, #16880	; 0x41f0
 80009ba:	f6c0 0100 	movt	r1, #2048	; 0x800
 80009be:	f7ff febb 	bl	8000738 <USART_puts>

    if (PHMeter_Resvoir.mutex == NULL) USART_puts(USART2, "PH_METER->mutex == NULL\r\n");

    //PH_CHANGING = 1; use this so the web console knows when changes are happening
   //add if sepamphore is not null error check
    int read_ph=1; 
 80009c2:	2501      	movs	r5, #1

    while (!TARGET_PH_REACHED) {

        if (read_ph){ 
            read_ph=0;
            xTaskCreate(vPH_read_value, (signed char*)"PH Read", 128, &PHMeter_Resvoir, tskIDLE_PRIORITY+4, NULL);
 80009c4:	f240 778d 	movw	r7, #1933	; 0x78d
 80009c8:	f6c0 0700 	movt	r7, #2048	; 0x800
 80009cc:	f244 2630 	movw	r6, #16944	; 0x4230
 80009d0:	f6c0 0600 	movt	r6, #2048	; 0x800
 80009d4:	f640 34c8 	movw	r4, #3016	; 0xbc8
 80009d8:	f2c2 0400 	movt	r4, #8192	; 0x2000

                }

            }
            else {
                USART_puts(USART2, "COULDNT ACCESS SAFELY IN PH_TASK\r\n");
 80009dc:	f244 2aa4 	movw	sl, #17060	; 0x42a4
 80009e0:	f6c0 0a00 	movt	sl, #2048	; 0x800

        if (PHMeter_Resvoir.state == MODULE_EXECUTED) { 
            if (xSemaphoreTake(PHMeter_Resvoir.mutex, (portTickType) 10) == pdTRUE) {
                int value = PHMeter_Resvoir.value; 

                USART_puts(USART2, "METER READ SUCCESSFULLY. PH=");
 80009e4:	f244 2b38 	movw	fp, #16952	; 0x4238
 80009e8:	f6c0 0b00 	movt	fp, #2048	; 0x800
                USART_put_int(USART2, value);
                USART_puts(USART2, "\ttarget_PH=");
 80009ec:	f244 2358 	movw	r3, #16984	; 0x4258
 80009f0:	f6c0 0300 	movt	r3, #2048	; 0x800
 80009f4:	9305      	str	r3, [sp, #20]
//    params->target_ph = 100;
    USART_puts(USART2, "-----------------\r\ntarget ph: ");
    USART_put_int(USART2, params->target_ph);
    USART_puts(USART2, "\r\n");

    while (!TARGET_PH_REACHED) {
 80009f6:	e0c2      	b.n	8000b7e <vPH_task+0x25e>

        if (read_ph){ 
            read_ph=0;
            xTaskCreate(vPH_read_value, (signed char*)"PH Read", 128, &PHMeter_Resvoir, tskIDLE_PRIORITY+4, NULL);
 80009f8:	2304      	movs	r3, #4
 80009fa:	9300      	str	r3, [sp, #0]
 80009fc:	2500      	movs	r5, #0
 80009fe:	9501      	str	r5, [sp, #4]
 8000a00:	9502      	str	r5, [sp, #8]
 8000a02:	9503      	str	r5, [sp, #12]
 8000a04:	4638      	mov	r0, r7
 8000a06:	4631      	mov	r1, r6
 8000a08:	2280      	movs	r2, #128	; 0x80
 8000a0a:	4623      	mov	r3, r4
 8000a0c:	f000 fd4a 	bl	80014a4 <xTaskGenericCreate>
        }

        vTaskDelay((portTickType) 500 / portTICK_RATE_MS);
 8000a10:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
 8000a14:	f000 fe6e 	bl	80016f4 <vTaskDelay>

        if (PHMeter_Resvoir.state == MODULE_EXECUTED) { 
 8000a18:	7a23      	ldrb	r3, [r4, #8]
 8000a1a:	2b02      	cmp	r3, #2
 8000a1c:	f040 80af 	bne.w	8000b7e <vPH_task+0x25e>
            if (xSemaphoreTake(PHMeter_Resvoir.mutex, (portTickType) 10) == pdTRUE) {
 8000a20:	6860      	ldr	r0, [r4, #4]
 8000a22:	2100      	movs	r1, #0
 8000a24:	220a      	movs	r2, #10
 8000a26:	460b      	mov	r3, r1
 8000a28:	f001 fca4 	bl	8002374 <xQueueGenericReceive>
 8000a2c:	2801      	cmp	r0, #1
 8000a2e:	f040 809d 	bne.w	8000b6c <vPH_task+0x24c>
                int value = PHMeter_Resvoir.value; 
 8000a32:	f8d4 8000 	ldr.w	r8, [r4]

                USART_puts(USART2, "METER READ SUCCESSFULLY. PH=");
 8000a36:	f44f 4588 	mov.w	r5, #17408	; 0x4400
 8000a3a:	f2c4 0500 	movt	r5, #16384	; 0x4000
 8000a3e:	4628      	mov	r0, r5
 8000a40:	4659      	mov	r1, fp
 8000a42:	f7ff fe79 	bl	8000738 <USART_puts>
                USART_put_int(USART2, value);
 8000a46:	4628      	mov	r0, r5
 8000a48:	4641      	mov	r1, r8
 8000a4a:	f7ff ff35 	bl	80008b8 <USART_put_int>
                USART_puts(USART2, "\ttarget_PH=");
 8000a4e:	4628      	mov	r0, r5
 8000a50:	9905      	ldr	r1, [sp, #20]
 8000a52:	f7ff fe71 	bl	8000738 <USART_puts>
                USART_put_int(USART2, params->target_ph);
 8000a56:	4628      	mov	r0, r5
 8000a58:	f8d9 1004 	ldr.w	r1, [r9, #4]
 8000a5c:	f7ff ff2c 	bl	80008b8 <USART_put_int>
                USART_puts(USART2, "\r\n");
 8000a60:	4628      	mov	r0, r5
 8000a62:	f244 11f0 	movw	r1, #16880	; 0x41f0
 8000a66:	f6c0 0100 	movt	r1, #2048	; 0x800
 8000a6a:	f7ff fe65 	bl	8000738 <USART_puts>
                vPPump_parameters ppump_params;

                xSemaphoreGive(PHMeter_Resvoir.mutex);
 8000a6e:	6860      	ldr	r0, [r4, #4]
 8000a70:	2100      	movs	r1, #0
 8000a72:	460a      	mov	r2, r1
 8000a74:	460b      	mov	r3, r1
 8000a76:	f001 fbf7 	bl	8002268 <xQueueGenericSend>
  
                if (value < params->target_ph){
 8000a7a:	f8d9 3004 	ldr.w	r3, [r9, #4]
 8000a7e:	4543      	cmp	r3, r8
 8000a80:	dd27      	ble.n	8000ad2 <vPH_task+0x1b2>
                    USART_puts(USART2, "ADDING PH UP\r\n");
 8000a82:	f44f 4088 	mov.w	r0, #17408	; 0x4400
 8000a86:	f2c4 0000 	movt	r0, #16384	; 0x4000
 8000a8a:	f244 2164 	movw	r1, #16996	; 0x4264
 8000a8e:	f6c0 0100 	movt	r1, #2048	; 0x800
 8000a92:	f7ff fe51 	bl	8000738 <USART_puts>
                    ppump_params.amount = params->target_ph - value;
 8000a96:	f8d9 3004 	ldr.w	r3, [r9, #4]
 8000a9a:	ebc8 0303 	rsb	r3, r8, r3
 8000a9e:	9307      	str	r3, [sp, #28]
                    ppump_params.ppump = &PPump_PHUP;
 8000aa0:	f640 32d4 	movw	r2, #3028	; 0xbd4
 8000aa4:	f2c2 0200 	movt	r2, #8192	; 0x2000
 8000aa8:	ab08      	add	r3, sp, #32
 8000aaa:	f843 2d08 	str.w	r2, [r3, #-8]!
                    
                    xTaskCreate(vPPump_dispense, (signed char*)"PP", 128, &ppump_params, tskIDLE_PRIORITY+3, NULL); 
 8000aae:	2203      	movs	r2, #3
 8000ab0:	9200      	str	r2, [sp, #0]
 8000ab2:	2200      	movs	r2, #0
 8000ab4:	9201      	str	r2, [sp, #4]
 8000ab6:	9202      	str	r2, [sp, #8]
 8000ab8:	9203      	str	r2, [sp, #12]
 8000aba:	f240 70f1 	movw	r0, #2033	; 0x7f1
 8000abe:	f6c0 0000 	movt	r0, #2048	; 0x800
 8000ac2:	f244 2174 	movw	r1, #17012	; 0x4274
 8000ac6:	f6c0 0100 	movt	r1, #2048	; 0x800
 8000aca:	2280      	movs	r2, #128	; 0x80
 8000acc:	f000 fcea 	bl	80014a4 <xTaskGenericCreate>
 8000ad0:	e045      	b.n	8000b5e <vPH_task+0x23e>

                }
                else if (value > params->target_ph) {
 8000ad2:	4598      	cmp	r8, r3
 8000ad4:	dd27      	ble.n	8000b26 <vPH_task+0x206>
                    USART_puts(USART2, "ADDING PH DOWN\r\n");
 8000ad6:	f44f 4088 	mov.w	r0, #17408	; 0x4400
 8000ada:	f2c4 0000 	movt	r0, #16384	; 0x4000
 8000ade:	f244 2178 	movw	r1, #17016	; 0x4278
 8000ae2:	f6c0 0100 	movt	r1, #2048	; 0x800
 8000ae6:	f7ff fe27 	bl	8000738 <USART_puts>
                    ppump_params.amount = value - params->target_ph;
 8000aea:	f8d9 3004 	ldr.w	r3, [r9, #4]
 8000aee:	ebc3 0308 	rsb	r3, r3, r8
 8000af2:	9307      	str	r3, [sp, #28]
                    ppump_params.ppump = &PPump_PHDOWN;
 8000af4:	f640 42a8 	movw	r2, #3240	; 0xca8
 8000af8:	f2c2 0200 	movt	r2, #8192	; 0x2000
 8000afc:	ab08      	add	r3, sp, #32
 8000afe:	f843 2d08 	str.w	r2, [r3, #-8]!

                    xTaskCreate(vPPump_dispense, (signed char*)"PP", 128, &ppump_params, tskIDLE_PRIORITY+3, NULL); 
 8000b02:	2203      	movs	r2, #3
 8000b04:	9200      	str	r2, [sp, #0]
 8000b06:	2200      	movs	r2, #0
 8000b08:	9201      	str	r2, [sp, #4]
 8000b0a:	9202      	str	r2, [sp, #8]
 8000b0c:	9203      	str	r2, [sp, #12]
 8000b0e:	f240 70f1 	movw	r0, #2033	; 0x7f1
 8000b12:	f6c0 0000 	movt	r0, #2048	; 0x800
 8000b16:	f244 2174 	movw	r1, #17012	; 0x4274
 8000b1a:	f6c0 0100 	movt	r1, #2048	; 0x800
 8000b1e:	2280      	movs	r2, #128	; 0x80
 8000b20:	f000 fcc0 	bl	80014a4 <xTaskGenericCreate>
 8000b24:	e01b      	b.n	8000b5e <vPH_task+0x23e>

                }
                else {
                    USART_puts(USART2, "STABILIZED PH LEVELS @");
 8000b26:	f44f 4488 	mov.w	r4, #17408	; 0x4400
 8000b2a:	f2c4 0400 	movt	r4, #16384	; 0x4000
 8000b2e:	4620      	mov	r0, r4
 8000b30:	f244 218c 	movw	r1, #17036	; 0x428c
 8000b34:	f6c0 0100 	movt	r1, #2048	; 0x800
 8000b38:	f7ff fdfe 	bl	8000738 <USART_puts>
                    USART_put_int(USART2, value);
 8000b3c:	4620      	mov	r0, r4
 8000b3e:	4641      	mov	r1, r8
 8000b40:	f7ff feba 	bl	80008b8 <USART_put_int>
                    USART_puts(USART2, "\r\n");
 8000b44:	4620      	mov	r0, r4
 8000b46:	f244 11f0 	movw	r1, #16880	; 0x41f0
 8000b4a:	f6c0 0100 	movt	r1, #2048	; 0x800
 8000b4e:	f7ff fdf3 	bl	8000738 <USART_puts>
            }
            PHMeter_Resvoir.state = MODULE_STANDBY;
        }
    }
    //PH_CHANGING = 0;  
    vTaskDelete(NULL);
 8000b52:	2000      	movs	r0, #0
 8000b54:	f000 fd74 	bl	8001640 <vTaskDelete>
 8000b58:	e015      	b.n	8000b86 <vPH_task+0x266>
                    break;
                };

                read_ph=1;
                while(ppump_params.ppump->state == MODULE_RUNNING) {
                    taskYIELD();
 8000b5a:	f001 feef 	bl	800293c <vPortYieldFromISR>
                    USART_puts(USART2, "\r\n");
                    break;
                };

                read_ph=1;
                while(ppump_params.ppump->state == MODULE_RUNNING) {
 8000b5e:	9b06      	ldr	r3, [sp, #24]
 8000b60:	f893 302e 	ldrb.w	r3, [r3, #46]	; 0x2e
 8000b64:	2b00      	cmp	r3, #0
 8000b66:	d0f8      	beq.n	8000b5a <vPH_task+0x23a>
                    USART_put_int(USART2, value);
                    USART_puts(USART2, "\r\n");
                    break;
                };

                read_ph=1;
 8000b68:	2501      	movs	r5, #1
 8000b6a:	e006      	b.n	8000b7a <vPH_task+0x25a>

                }

            }
            else {
                USART_puts(USART2, "COULDNT ACCESS SAFELY IN PH_TASK\r\n");
 8000b6c:	f44f 4088 	mov.w	r0, #17408	; 0x4400
 8000b70:	f2c4 0000 	movt	r0, #16384	; 0x4000
 8000b74:	4651      	mov	r1, sl
 8000b76:	f7ff fddf 	bl	8000738 <USART_puts>
            }
            PHMeter_Resvoir.state = MODULE_STANDBY;
 8000b7a:	2301      	movs	r3, #1
 8000b7c:	7223      	strb	r3, [r4, #8]
    USART_put_int(USART2, params->target_ph);
    USART_puts(USART2, "\r\n");

    while (!TARGET_PH_REACHED) {

        if (read_ph){ 
 8000b7e:	2d00      	cmp	r5, #0
 8000b80:	f43f af46 	beq.w	8000a10 <vPH_task+0xf0>
 8000b84:	e738      	b.n	80009f8 <vPH_task+0xd8>
            PHMeter_Resvoir.state = MODULE_STANDBY;
        }
    }
    //PH_CHANGING = 0;  
    vTaskDelete(NULL);
}
 8000b86:	b009      	add	sp, #36	; 0x24
 8000b88:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

08000b8c <USART2_IRQHandler>:
        *(num) *= -1;
    }

}

void USART2_IRQHandler(void){
 8000b8c:	b570      	push	{r4, r5, r6, lr}
 8000b8e:	b084      	sub	sp, #16
	// check if the USART2 receive interrupt flag was set
	if( USART_GetITStatus(USART2, USART_IT_RXNE)){
 8000b90:	f44f 4088 	mov.w	r0, #17408	; 0x4400
 8000b94:	f2c4 0000 	movt	r0, #16384	; 0x4000
 8000b98:	f240 5125 	movw	r1, #1317	; 0x525
 8000b9c:	f002 fd22 	bl	80035e4 <USART_GetITStatus>
 8000ba0:	2800      	cmp	r0, #0
 8000ba2:	f000 808f 	beq.w	8000cc4 <USART2_IRQHandler+0x138>
        static uint8_t count=0;

		
		//static uint8_t cnt = 0; // this counter is used to determine the string length
		char t = USART2->DR; // the character from the USART2 data register is saved in t
 8000ba6:	f44f 4388 	mov.w	r3, #17408	; 0x4400
 8000baa:	f2c4 0300 	movt	r3, #16384	; 0x4000
 8000bae:	8899      	ldrh	r1, [r3, #4]
 8000bb0:	b2c9      	uxtb	r1, r1

        if (write_pos == MAX_STRLEN-1) write_pos=0;

        if (t == 8 || t== 127) {
 8000bb2:	297f      	cmp	r1, #127	; 0x7f
 8000bb4:	bf18      	it	ne
 8000bb6:	2908      	cmpne	r1, #8
 8000bb8:	d11e      	bne.n	8000bf8 <USART2_IRQHandler+0x6c>
            write_pos--;
 8000bba:	f640 13c2 	movw	r3, #2498	; 0x9c2
 8000bbe:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8000bc2:	781a      	ldrb	r2, [r3, #0]
 8000bc4:	3a01      	subs	r2, #1
 8000bc6:	b2d2      	uxtb	r2, r2
 8000bc8:	701a      	strb	r2, [r3, #0]
            received_string[write_pos] = '\r';
 8000bca:	f640 43e8 	movw	r3, #3304	; 0xce8
 8000bce:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8000bd2:	210d      	movs	r1, #13
 8000bd4:	5499      	strb	r1, [r3, r2]
            USART_put(USART2, '\b');
 8000bd6:	f44f 4488 	mov.w	r4, #17408	; 0x4400
 8000bda:	f2c4 0400 	movt	r4, #16384	; 0x4000
 8000bde:	4620      	mov	r0, r4
 8000be0:	2108      	movs	r1, #8
 8000be2:	f7ff fd97 	bl	8000714 <USART_put>
            USART_put(USART2, ' ');
 8000be6:	4620      	mov	r0, r4
 8000be8:	2120      	movs	r1, #32
 8000bea:	f7ff fd93 	bl	8000714 <USART_put>
            USART_put(USART2, '\b');
 8000bee:	4620      	mov	r0, r4
 8000bf0:	2108      	movs	r1, #8
 8000bf2:	f7ff fd8f 	bl	8000714 <USART_put>
            return;
 8000bf6:	e065      	b.n	8000cc4 <USART2_IRQHandler+0x138>

        }

		// check if the received character is not the LF character (used to determine end of string) 
		// or the if the maximum string length has been been reached 
		else if/*(*/ (t != '\r')/* && (cnt< MAX_STRLEN-1) )*/{ 
 8000bf8:	290d      	cmp	r1, #13
 8000bfa:	d017      	beq.n	8000c2c <USART2_IRQHandler+0xa0>
            count++;
 8000bfc:	f640 13c1 	movw	r3, #2497	; 0x9c1
 8000c00:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8000c04:	781a      	ldrb	r2, [r3, #0]
 8000c06:	3201      	adds	r2, #1
 8000c08:	701a      	strb	r2, [r3, #0]
			received_string[/*cnt*/write_pos] = t;
 8000c0a:	f640 13c2 	movw	r3, #2498	; 0x9c2
 8000c0e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8000c12:	781a      	ldrb	r2, [r3, #0]
 8000c14:	f640 43e8 	movw	r3, #3304	; 0xce8
 8000c18:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8000c1c:	5499      	strb	r1, [r3, r2]
            USART_put(USART2, t);
 8000c1e:	f44f 4088 	mov.w	r0, #17408	; 0x4400
 8000c22:	f2c4 0000 	movt	r0, #16384	; 0x4000
 8000c26:	f7ff fd75 	bl	8000714 <USART_put>
 8000c2a:	e044      	b.n	8000cb6 <USART2_IRQHandler+0x12a>

		}

		else{ // otherwise reset the character counter and print newline 
            if (count != 0) {
 8000c2c:	f640 13c1 	movw	r3, #2497	; 0x9c1
 8000c30:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8000c34:	781b      	ldrb	r3, [r3, #0]
 8000c36:	b3a3      	cbz	r3, 8000ca2 <USART2_IRQHandler+0x116>
                
                received_string[/*cnt*/write_pos] = '\r';
 8000c38:	f640 14c2 	movw	r4, #2498	; 0x9c2
 8000c3c:	f2c2 0400 	movt	r4, #8192	; 0x2000
 8000c40:	7823      	ldrb	r3, [r4, #0]
 8000c42:	f640 46e8 	movw	r6, #3304	; 0xce8
 8000c46:	f2c2 0600 	movt	r6, #8192	; 0x2000
 8000c4a:	220d      	movs	r2, #13
 8000c4c:	54f2      	strb	r2, [r6, r3]
                USART_puts(USART2, "\r\n");
 8000c4e:	f44f 4088 	mov.w	r0, #17408	; 0x4400
 8000c52:	f2c4 0000 	movt	r0, #16384	; 0x4000
 8000c56:	f244 11f0 	movw	r1, #16880	; 0x41f0
 8000c5a:	f6c0 0100 	movt	r1, #2048	; 0x800
 8000c5e:	f7ff fd6b 	bl	8000738 <USART_puts>

                char *command = &received_string[write_pos-count];
 8000c62:	7822      	ldrb	r2, [r4, #0]
 8000c64:	f640 15c1 	movw	r5, #2497	; 0x9c1
 8000c68:	f2c2 0500 	movt	r5, #8192	; 0x2000
 8000c6c:	782b      	ldrb	r3, [r5, #0]
 8000c6e:	1ad3      	subs	r3, r2, r3

                xTaskCreate(handle_uart_command, (signed char*)"handle_uart_command", 128, command, tskIDLE_PRIORITY+1, NULL);
 8000c70:	2201      	movs	r2, #1
 8000c72:	9200      	str	r2, [sp, #0]
 8000c74:	2400      	movs	r4, #0
 8000c76:	9401      	str	r4, [sp, #4]
 8000c78:	9402      	str	r4, [sp, #8]
 8000c7a:	9403      	str	r4, [sp, #12]
 8000c7c:	f240 705d 	movw	r0, #1885	; 0x75d
 8000c80:	f6c0 0000 	movt	r0, #2048	; 0x800
 8000c84:	f244 21c8 	movw	r1, #17096	; 0x42c8
 8000c88:	f6c0 0100 	movt	r1, #2048	; 0x800
 8000c8c:	2280      	movs	r2, #128	; 0x80
 8000c8e:	4433      	add	r3, r6
 8000c90:	f000 fc08 	bl	80014a4 <xTaskGenericCreate>
//                xTaskCreate(idle_blinky, (signed char*)"idle_blinky", 128, NULL, tskIDLE_PRIORITY, NULL);


                input_lock = 0;
 8000c94:	f640 13c0 	movw	r3, #2496	; 0x9c0
 8000c98:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8000c9c:	701c      	strb	r4, [r3, #0]
                count = 0;
 8000c9e:	702c      	strb	r4, [r5, #0]
 8000ca0:	e009      	b.n	8000cb6 <USART2_IRQHandler+0x12a>
            }
            else USART_puts(USART2, "\r\n");
 8000ca2:	f44f 4088 	mov.w	r0, #17408	; 0x4400
 8000ca6:	f2c4 0000 	movt	r0, #16384	; 0x4000
 8000caa:	f244 11f0 	movw	r1, #16880	; 0x41f0
 8000cae:	f6c0 0100 	movt	r1, #2048	; 0x800
 8000cb2:	f7ff fd41 	bl	8000738 <USART_puts>
		}
        write_pos++;
 8000cb6:	f640 13c2 	movw	r3, #2498	; 0x9c2
 8000cba:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8000cbe:	781a      	ldrb	r2, [r3, #0]
 8000cc0:	3201      	adds	r2, #1
 8000cc2:	701a      	strb	r2, [r3, #0]
	}
}
 8000cc4:	b004      	add	sp, #16
 8000cc6:	bd70      	pop	{r4, r5, r6, pc}

08000cc8 <initx>:



//Initialize GPIO and USART2
void initx(void){
 8000cc8:	b5f0      	push	{r4, r5, r6, r7, lr}
 8000cca:	b089      	sub	sp, #36	; 0x24
	//Enable GPIO Clocks For USART2
        RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOA, ENABLE);
 8000ccc:	2001      	movs	r0, #1
 8000cce:	4601      	mov	r1, r0
 8000cd0:	f002 f908 	bl	8002ee4 <RCC_AHB1PeriphClockCmd>

	//Enable Clocks for USART2
        RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART2, ENABLE);	
 8000cd4:	f44f 3000 	mov.w	r0, #131072	; 0x20000
 8000cd8:	2101      	movs	r1, #1
 8000cda:	f002 f92b 	bl	8002f34 <RCC_APB1PeriphClockCmd>
	USART_InitTypeDef USART_InitStructure;

    NVIC_InitTypeDef NVIC_InitStructure;

	//GPIO Configuration
  	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2 | GPIO_Pin_3;
 8000cde:	270c      	movs	r7, #12
 8000ce0:	9706      	str	r7, [sp, #24]
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
 8000ce2:	2602      	movs	r6, #2
 8000ce4:	f88d 601c 	strb.w	r6, [sp, #28]
	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
 8000ce8:	2400      	movs	r4, #0
 8000cea:	f88d 401e 	strb.w	r4, [sp, #30]
	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
 8000cee:	f88d 401f 	strb.w	r4, [sp, #31]
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 8000cf2:	f88d 601d 	strb.w	r6, [sp, #29]
	GPIO_Init(GPIOA, &GPIO_InitStructure);
 8000cf6:	4625      	mov	r5, r4
 8000cf8:	f2c4 0502 	movt	r5, #16386	; 0x4002
 8000cfc:	4628      	mov	r0, r5
 8000cfe:	a906      	add	r1, sp, #24
 8000d00:	f001 ff2c 	bl	8002b5c <GPIO_Init>


	//Connect USART pins to AF
	GPIO_PinAFConfig(GPIOA, GPIO_PinSource2, GPIO_AF_USART2);
 8000d04:	4628      	mov	r0, r5
 8000d06:	4631      	mov	r1, r6
 8000d08:	2207      	movs	r2, #7
 8000d0a:	f001 ffd1 	bl	8002cb0 <GPIO_PinAFConfig>
	GPIO_PinAFConfig(GPIOA, GPIO_PinSource3, GPIO_AF_USART2);
 8000d0e:	4628      	mov	r0, r5
 8000d10:	2103      	movs	r1, #3
 8000d12:	2207      	movs	r2, #7
 8000d14:	f001 ffcc 	bl	8002cb0 <GPIO_PinAFConfig>

	//Initialize LED
	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOD, ENABLE);
 8000d18:	2008      	movs	r0, #8
 8000d1a:	2101      	movs	r1, #1
 8000d1c:	f002 f8e2 	bl	8002ee4 <RCC_AHB1PeriphClockCmd>
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_12 | GPIO_Pin_13| GPIO_Pin_14| GPIO_Pin_15;
 8000d20:	f44f 4370 	mov.w	r3, #61440	; 0xf000
 8000d24:	9306      	str	r3, [sp, #24]
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
 8000d26:	2501      	movs	r5, #1
 8000d28:	f88d 501c 	strb.w	r5, [sp, #28]
	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
 8000d2c:	f88d 401e 	strb.w	r4, [sp, #30]
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
 8000d30:	2303      	movs	r3, #3
 8000d32:	f88d 301d 	strb.w	r3, [sp, #29]
	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
 8000d36:	f88d 401f 	strb.w	r4, [sp, #31]
	GPIO_Init(GPIOD, &GPIO_InitStructure);
 8000d3a:	f44f 6040 	mov.w	r0, #3072	; 0xc00
 8000d3e:	f2c4 0002 	movt	r0, #16386	; 0x4002
 8000d42:	a906      	add	r1, sp, #24
 8000d44:	f001 ff0a 	bl	8002b5c <GPIO_Init>

	//USART Parameters
	USART_InitStructure.USART_BaudRate = 38400;
 8000d48:	f44f 4316 	mov.w	r3, #38400	; 0x9600
 8000d4c:	9302      	str	r3, [sp, #8]
	USART_InitStructure.USART_WordLength = USART_WordLength_8b;
 8000d4e:	f8ad 400c 	strh.w	r4, [sp, #12]
	USART_InitStructure.USART_StopBits = USART_StopBits_1;
 8000d52:	f8ad 400e 	strh.w	r4, [sp, #14]
	USART_InitStructure.USART_Parity = USART_Parity_No ;
 8000d56:	f8ad 4010 	strh.w	r4, [sp, #16]
	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;  
 8000d5a:	f8ad 4014 	strh.w	r4, [sp, #20]
    USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx ;
 8000d5e:	f8ad 7012 	strh.w	r7, [sp, #18]

	//Configuring And Enabling USART2
	USART_Init(USART2, &USART_InitStructure);
 8000d62:	f44f 4688 	mov.w	r6, #17408	; 0x4400
 8000d66:	f2c4 0600 	movt	r6, #16384	; 0x4000
 8000d6a:	4630      	mov	r0, r6
 8000d6c:	a902      	add	r1, sp, #8
 8000d6e:	f002 fafb 	bl	8003368 <USART_Init>


    USART_ITConfig(USART2, USART_IT_RXNE, ENABLE);
 8000d72:	4630      	mov	r0, r6
 8000d74:	f240 5125 	movw	r1, #1317	; 0x525
 8000d78:	462a      	mov	r2, r5
 8000d7a:	f002 fbeb 	bl	8003554 <USART_ITConfig>

    NVIC_InitStructure.NVIC_IRQChannel = USART2_IRQn;
 8000d7e:	2326      	movs	r3, #38	; 0x26
 8000d80:	f88d 3004 	strb.w	r3, [sp, #4]
    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
 8000d84:	f88d 4005 	strb.w	r4, [sp, #5]
    NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
 8000d88:	f88d 4006 	strb.w	r4, [sp, #6]
    NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
 8000d8c:	f88d 5007 	strb.w	r5, [sp, #7]

    NVIC_Init(&NVIC_InitStructure);
 8000d90:	a801      	add	r0, sp, #4
 8000d92:	f001 fe7d 	bl	8002a90 <NVIC_Init>

	USART_Cmd(USART2, ENABLE);
 8000d96:	4630      	mov	r0, r6
 8000d98:	4629      	mov	r1, r5
 8000d9a:	f002 fba9 	bl	80034f0 <USART_Cmd>

}
 8000d9e:	b009      	add	sp, #36	; 0x24
 8000da0:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8000da2:	bf00      	nop

08000da4 <TIM_PWM_init>:

void TIM_PWM_init() {
 8000da4:	b570      	push	{r4, r5, r6, lr}
 8000da6:	b088      	sub	sp, #32
    //TIMER SETUP
    RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM4, ENABLE);
 8000da8:	2004      	movs	r0, #4
 8000daa:	2101      	movs	r1, #1
 8000dac:	f002 f8c2 	bl	8002f34 <RCC_APB1PeriphClockCmd>

    TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStruct;

    TIM_TimeBaseInitStruct.TIM_Period = 19999;
 8000db0:	f644 631f 	movw	r3, #19999	; 0x4e1f
 8000db4:	9306      	str	r3, [sp, #24]
    TIM_TimeBaseInitStruct.TIM_Prescaler = 84;
 8000db6:	2354      	movs	r3, #84	; 0x54
 8000db8:	f8ad 3014 	strh.w	r3, [sp, #20]
    TIM_TimeBaseInitStruct.TIM_ClockDivision = 0;//TIM_CKD_DIV1;
 8000dbc:	2500      	movs	r5, #0
 8000dbe:	f8ad 501c 	strh.w	r5, [sp, #28]
    TIM_TimeBaseInitStruct.TIM_CounterMode = TIM_CounterMode_Up;
 8000dc2:	f8ad 5016 	strh.w	r5, [sp, #22]

    TIM_TimeBaseInit(TIM4, &TIM_TimeBaseInitStruct);
 8000dc6:	f44f 6400 	mov.w	r4, #2048	; 0x800
 8000dca:	f2c4 0400 	movt	r4, #16384	; 0x4000
 8000dce:	4620      	mov	r0, r4
 8000dd0:	a905      	add	r1, sp, #20
 8000dd2:	f002 f8d7 	bl	8002f84 <TIM_TimeBaseInit>

    //pwm setup
    
    TIM_OCInitTypeDef TIM_OCInitStruct;
    
    TIM_OCInitStruct.TIM_OCMode = TIM_OCMode_PWM1;
 8000dd6:	2360      	movs	r3, #96	; 0x60
 8000dd8:	f8ad 3000 	strh.w	r3, [sp]
    TIM_OCInitStruct.TIM_OutputState = TIM_OutputState_Enable;
 8000ddc:	2601      	movs	r6, #1
 8000dde:	f8ad 6002 	strh.w	r6, [sp, #2]
    TIM_OCInitStruct.TIM_Pulse = 0;
 8000de2:	9502      	str	r5, [sp, #8]
    TIM_OCInitStruct.TIM_OCPolarity = TIM_OCPolarity_High;
 8000de4:	f8ad 500c 	strh.w	r5, [sp, #12]
    


    TIM_OC1Init(TIM4, &TIM_OCInitStruct); //channel 1
 8000de8:	4620      	mov	r0, r4
 8000dea:	4669      	mov	r1, sp
 8000dec:	f002 f980 	bl	80030f0 <TIM_OC1Init>
    TIM_OC1PreloadConfig(TIM4, TIM_OCPreload_Enable);
 8000df0:	4620      	mov	r0, r4
 8000df2:	2108      	movs	r1, #8
 8000df4:	f002 fa7e 	bl	80032f4 <TIM_OC1PreloadConfig>

    TIM_OC2Init(TIM4, &TIM_OCInitStruct); // channel 2
 8000df8:	4620      	mov	r0, r4
 8000dfa:	4669      	mov	r1, sp
 8000dfc:	f002 f9f2 	bl	80031e4 <TIM_OC2Init>
    TIM_OC2PreloadConfig(TIM4, TIM_OCPreload_Enable);
 8000e00:	4620      	mov	r0, r4
 8000e02:	2108      	movs	r1, #8
 8000e04:	f002 fa92 	bl	800332c <TIM_OC2PreloadConfig>


    TIM_ARRPreloadConfig(TIM4, ENABLE);
 8000e08:	4620      	mov	r0, r4
 8000e0a:	4631      	mov	r1, r6
 8000e0c:	f002 f930 	bl	8003070 <TIM_ARRPreloadConfig>
    TIM_Cmd(TIM4, ENABLE);
 8000e10:	4620      	mov	r0, r4
 8000e12:	4631      	mov	r1, r6
 8000e14:	f002 f94c 	bl	80030b0 <TIM_Cmd>
}
 8000e18:	b008      	add	sp, #32
 8000e1a:	bd70      	pop	{r4, r5, r6, pc}

08000e1c <PPump_Init>:
        module->state = MODULE_STANDBY;
    }
}

void PPump_Init(PPump_Module *module, UDS_Module *sensor) {
    if (module) {
 8000e1c:	4603      	mov	r3, r0
 8000e1e:	b198      	cbz	r0, 8000e48 <PPump_Init+0x2c>
        //use sensor to calculate distance Make this a task.  One parent task for getting tank size and one for ultrasonic distance finding
        sensor->value = 8;
 8000e20:	2208      	movs	r2, #8
 8000e22:	660a      	str	r2, [r1, #96]	; 0x60
        sensor->state = MODULE_EXECUTED;
 8000e24:	2002      	movs	r0, #2
 8000e26:	f881 005c 	strb.w	r0, [r1, #92]	; 0x5c
        module->tank = 100*(sensor->value/module->tank_height);
 8000e2a:	6b59      	ldr	r1, [r3, #52]	; 0x34
 8000e2c:	fb92 f2f1 	sdiv	r2, r2, r1
 8000e30:	2164      	movs	r1, #100	; 0x64
 8000e32:	fb01 f202 	mul.w	r2, r1, r2
 8000e36:	ee07 2a10 	vmov	s14, r2
 8000e3a:	eef8 7ac7 	vcvt.f32.s32	s15, s14
 8000e3e:	edc3 7a00 	vstr	s15, [r3]
        module->state = MODULE_STANDBY;
 8000e42:	2201      	movs	r2, #1
 8000e44:	f883 202e 	strb.w	r2, [r3, #46]	; 0x2e
 8000e48:	4770      	bx	lr
 8000e4a:	bf00      	nop

08000e4c <main>:
}

    vPH_parameters ph_p;

//Main Function
int main(void){
 8000e4c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8000e50:	b092      	sub	sp, #72	; 0x48
	//Call initx(); To Initialize USART & GPIO

	initx();
 8000e52:	f7ff ff39 	bl	8000cc8 <initx>
    init_us_timer();
 8000e56:	f7ff fbeb 	bl	8000630 <init_us_timer>
    //setSysTick();


    int i;

    USART_puts(USART2, "Booting up...\r\n");
 8000e5a:	f44f 4088 	mov.w	r0, #17408	; 0x4400
 8000e5e:	f2c4 0000 	movt	r0, #16384	; 0x4000
 8000e62:	f244 21f4 	movw	r1, #17140	; 0x42f4
 8000e66:	f6c0 0100 	movt	r1, #2048	; 0x800
 8000e6a:	f7ff fc65 	bl	8000738 <USART_puts>
    for(i=0; i<2; i++) { 
 8000e6e:	2500      	movs	r5, #0
        GPIO_SetBits(GPIOD, GPIO_Pin_12);
 8000e70:	f44f 6440 	mov.w	r4, #3072	; 0xc00
 8000e74:	f2c4 0402 	movt	r4, #16386	; 0x4002
 8000e78:	f44f 5a80 	mov.w	sl, #4096	; 0x1000
        GPIO_SetBits(GPIOD, GPIO_Pin_13);
 8000e7c:	f44f 5900 	mov.w	r9, #8192	; 0x2000
        GPIO_SetBits(GPIOD, GPIO_Pin_14);
 8000e80:	f44f 4880 	mov.w	r8, #16384	; 0x4000
        GPIO_SetBits(GPIOD, GPIO_Pin_15);
 8000e84:	f44f 4700 	mov.w	r7, #32768	; 0x8000
        delay_ms(500);
 8000e88:	f44f 76fa 	mov.w	r6, #500	; 0x1f4


    int i;

    USART_puts(USART2, "Booting up...\r\n");
    for(i=0; i<2; i++) { 
 8000e8c:	e01b      	b.n	8000ec6 <main+0x7a>
        GPIO_SetBits(GPIOD, GPIO_Pin_12);
 8000e8e:	4620      	mov	r0, r4
 8000e90:	4651      	mov	r1, sl
 8000e92:	f001 fef1 	bl	8002c78 <GPIO_SetBits>
        GPIO_SetBits(GPIOD, GPIO_Pin_13);
 8000e96:	4620      	mov	r0, r4
 8000e98:	4649      	mov	r1, r9
 8000e9a:	f001 feed 	bl	8002c78 <GPIO_SetBits>
        GPIO_SetBits(GPIOD, GPIO_Pin_14);
 8000e9e:	4620      	mov	r0, r4
 8000ea0:	4641      	mov	r1, r8
 8000ea2:	f001 fee9 	bl	8002c78 <GPIO_SetBits>
        GPIO_SetBits(GPIOD, GPIO_Pin_15);
 8000ea6:	4620      	mov	r0, r4
 8000ea8:	4639      	mov	r1, r7
 8000eaa:	f001 fee5 	bl	8002c78 <GPIO_SetBits>
        delay_ms(500);
 8000eae:	4630      	mov	r0, r6
 8000eb0:	f7ff fbae 	bl	8000610 <delay_ms>

        GPIO_ResetBits(GPIOD, GPIO_Pin_12|GPIO_Pin_13 | GPIO_Pin_14 | GPIO_Pin_15);
 8000eb4:	4620      	mov	r0, r4
 8000eb6:	f44f 4170 	mov.w	r1, #61440	; 0xf000
 8000eba:	f001 feeb 	bl	8002c94 <GPIO_ResetBits>
        delay_ms(500);
 8000ebe:	4630      	mov	r0, r6
 8000ec0:	f7ff fba6 	bl	8000610 <delay_ms>


    int i;

    USART_puts(USART2, "Booting up...\r\n");
    for(i=0; i<2; i++) { 
 8000ec4:	3501      	adds	r5, #1
 8000ec6:	2d01      	cmp	r5, #1
 8000ec8:	dde1      	ble.n	8000e8e <main+0x42>
        delay_ms(500);

    }


	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOE, ENABLE);
 8000eca:	2010      	movs	r0, #16
 8000ecc:	2101      	movs	r1, #1
 8000ece:	f002 f809 	bl	8002ee4 <RCC_AHB1PeriphClockCmd>

    GPIO_InitTypeDef gpio_ultrasonic;

    gpio_ultrasonic.GPIO_Pin = GPIO_Pin_0;
 8000ed2:	2601      	movs	r6, #1
 8000ed4:	9610      	str	r6, [sp, #64]	; 0x40
    gpio_ultrasonic.GPIO_OType = GPIO_OType_PP; //PP
 8000ed6:	2400      	movs	r4, #0
 8000ed8:	f88d 4046 	strb.w	r4, [sp, #70]	; 0x46
    gpio_ultrasonic.GPIO_Mode = GPIO_Mode_OUT;
 8000edc:	f88d 6044 	strb.w	r6, [sp, #68]	; 0x44
    //gpio_ultrasonic.GPIO_PuPd = GPIO_PuPd_NOPULL;

    gpio_ultrasonic.GPIO_Speed = GPIO_Speed_50MHz;
 8000ee0:	2502      	movs	r5, #2
 8000ee2:	f88d 5045 	strb.w	r5, [sp, #69]	; 0x45
    GPIO_Init(GPIOE, &gpio_ultrasonic);
 8000ee6:	f44f 5780 	mov.w	r7, #4096	; 0x1000
 8000eea:	f2c4 0702 	movt	r7, #16386	; 0x4002
 8000eee:	4638      	mov	r0, r7
 8000ef0:	a910      	add	r1, sp, #64	; 0x40
 8000ef2:	f001 fe33 	bl	8002b5c <GPIO_Init>


    gpio_ultrasonic.GPIO_Pin = GPIO_Pin_1;
 8000ef6:	9510      	str	r5, [sp, #64]	; 0x40
    gpio_ultrasonic.GPIO_OType = GPIO_OType_PP;
 8000ef8:	f88d 4046 	strb.w	r4, [sp, #70]	; 0x46
    //gpio_ultrasonic.GPIO_PuPd = GPIO_PuPd_DOWN;
    gpio_ultrasonic.GPIO_Mode = GPIO_Mode_IN;
 8000efc:	f88d 4044 	strb.w	r4, [sp, #68]	; 0x44
    GPIO_Init(GPIOE, &gpio_ultrasonic);
 8000f00:	4638      	mov	r0, r7
 8000f02:	a910      	add	r1, sp, #64	; 0x40
 8000f04:	f001 fe2a 	bl	8002b5c <GPIO_Init>

    Ultrasonic_Typedef sensor;
    ultrasonic_init(&sensor, GPIOE, GPIOE, GPIO_Pin_1, GPIO_Pin_0, 300); 
 8000f08:	9600      	str	r6, [sp, #0]
 8000f0a:	f44f 7396 	mov.w	r3, #300	; 0x12c
 8000f0e:	9301      	str	r3, [sp, #4]
 8000f10:	a80c      	add	r0, sp, #48	; 0x30
 8000f12:	4639      	mov	r1, r7
 8000f14:	463a      	mov	r2, r7
 8000f16:	462b      	mov	r3, r5
 8000f18:	f000 fa54 	bl	80013c4 <ultrasonic_init>
        USART_put_int(USART2, d);
        USART_puts(USART2, "\r\n");
    }
    */
    //SERVO SETUP
    TIM_PWM_init();
 8000f1c:	f7ff ff42 	bl	8000da4 <TIM_PWM_init>

	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOB, ENABLE);
 8000f20:	4628      	mov	r0, r5
 8000f22:	4631      	mov	r1, r6
 8000f24:	f001 ffde 	bl	8002ee4 <RCC_AHB1PeriphClockCmd>
    GPIO_PinAFConfig(GPIOB, GPIO_PinSource7, GPIO_AF_TIM4);
 8000f28:	f44f 6780 	mov.w	r7, #1024	; 0x400
 8000f2c:	f2c4 0702 	movt	r7, #16386	; 0x4002
 8000f30:	4638      	mov	r0, r7
 8000f32:	2107      	movs	r1, #7
 8000f34:	462a      	mov	r2, r5
 8000f36:	f001 febb 	bl	8002cb0 <GPIO_PinAFConfig>
    GPIO_PinAFConfig(GPIOB, GPIO_PinSource6, GPIO_AF_TIM4);
 8000f3a:	4638      	mov	r0, r7
 8000f3c:	2106      	movs	r1, #6
 8000f3e:	462a      	mov	r2, r5
 8000f40:	f001 feb6 	bl	8002cb0 <GPIO_PinAFConfig>



    GPIO_InitTypeDef GPIO_InitStructServo;

    GPIO_InitStructServo.GPIO_Pin = GPIO_Pin_6 | GPIO_Pin_7;
 8000f44:	23c0      	movs	r3, #192	; 0xc0
 8000f46:	930a      	str	r3, [sp, #40]	; 0x28
    GPIO_InitStructServo.GPIO_OType = GPIO_OType_PP;
 8000f48:	f88d 402e 	strb.w	r4, [sp, #46]	; 0x2e
    GPIO_InitStructServo.GPIO_PuPd = GPIO_PuPd_UP;
 8000f4c:	f88d 602f 	strb.w	r6, [sp, #47]	; 0x2f
    GPIO_InitStructServo.GPIO_Mode = GPIO_Mode_AF;
 8000f50:	f88d 502c 	strb.w	r5, [sp, #44]	; 0x2c
    GPIO_InitStructServo.GPIO_Speed = GPIO_Speed_100MHz;
 8000f54:	2303      	movs	r3, #3
 8000f56:	f88d 302d 	strb.w	r3, [sp, #45]	; 0x2d
    GPIO_Init(GPIOB, &GPIO_InitStructServo);
 8000f5a:	4638      	mov	r0, r7
 8000f5c:	a90a      	add	r1, sp, #40	; 0x28
 8000f5e:	f001 fdfd 	bl	8002b5c <GPIO_Init>


    Servo_Typedef servo1, servo2;
    servo_init(&servo1, &(TIM4->CCR1), 500, 1850/*61*/); //up and down servo
 8000f62:	a807      	add	r0, sp, #28
 8000f64:	f640 0134 	movw	r1, #2100	; 0x834
 8000f68:	f2c4 0100 	movt	r1, #16384	; 0x4000
 8000f6c:	f44f 72fa 	mov.w	r2, #500	; 0x1f4
 8000f70:	f240 733a 	movw	r3, #1850	; 0x73a
 8000f74:	f000 fa42 	bl	80013fc <servo_init>
    servo_init(&servo2, &(TIM4->CCR2), 500, 1000);
 8000f78:	a804      	add	r0, sp, #16
 8000f7a:	f640 0138 	movw	r1, #2104	; 0x838
 8000f7e:	f2c4 0100 	movt	r1, #16384	; 0x4000
 8000f82:	f44f 72fa 	mov.w	r2, #500	; 0x1f4
 8000f86:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 8000f8a:	f000 fa37 	bl	80013fc <servo_init>
    servo_set_degrees(&servo1, 90);
 8000f8e:	a807      	add	r0, sp, #28
 8000f90:	215a      	movs	r1, #90	; 0x5a
 8000f92:	f000 fa5d 	bl	8001450 <servo_set_degrees>

    char hello[] = "hello";

    xTaskCreate(idle_blinky, (signed char*)"idle_blinky", 128, NULL, tskIDLE_PRIORITY, NULL);
 8000f96:	9400      	str	r4, [sp, #0]
 8000f98:	9401      	str	r4, [sp, #4]
 8000f9a:	9402      	str	r4, [sp, #8]
 8000f9c:	9403      	str	r4, [sp, #12]
 8000f9e:	f240 60ad 	movw	r0, #1709	; 0x6ad
 8000fa2:	f6c0 0000 	movt	r0, #2048	; 0x800
 8000fa6:	f244 3104 	movw	r1, #17156	; 0x4304
 8000faa:	f6c0 0100 	movt	r1, #2048	; 0x800
 8000fae:	2280      	movs	r2, #128	; 0x80
 8000fb0:	4623      	mov	r3, r4
 8000fb2:	f000 fa77 	bl	80014a4 <xTaskGenericCreate>


    PPump_PHUP.tank_height = 10;
 8000fb6:	f640 36d4 	movw	r6, #3028	; 0xbd4
 8000fba:	f2c2 0600 	movt	r6, #8192	; 0x2000
 8000fbe:	220a      	movs	r2, #10
 8000fc0:	6372      	str	r2, [r6, #52]	; 0x34
    PPump_PHDOWN.tank_height = 10;
 8000fc2:	f640 43a8 	movw	r3, #3240	; 0xca8
 8000fc6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8000fca:	635a      	str	r2, [r3, #52]	; 0x34

    PPump_Init(&PPump_PHUP, &UDS_PHUP);
 8000fcc:	4630      	mov	r0, r6
 8000fce:	f640 3164 	movw	r1, #2916	; 0xb64
 8000fd2:	f2c2 0100 	movt	r1, #8192	; 0x2000
 8000fd6:	f7ff ff21 	bl	8000e1c <PPump_Init>
    PPump_Init(&PPump_PHUP, &UDS_PHDOWN);
 8000fda:	4630      	mov	r0, r6
 8000fdc:	f640 3100 	movw	r1, #2816	; 0xb00
 8000fe0:	f2c2 0100 	movt	r1, #8192	; 0x2000
 8000fe4:	f7ff ff1a 	bl	8000e1c <PPump_Init>

    ph_p.target_ph = 20;
 8000fe8:	f640 46e0 	movw	r6, #3296	; 0xce0
 8000fec:	f2c2 0600 	movt	r6, #8192	; 0x2000
 8000ff0:	2314      	movs	r3, #20
 8000ff2:	6073      	str	r3, [r6, #4]


    //xTaskCreate(vLight_task, (signed char*)"vLight", 128, &light_p, tskIDLE_PRIORITY+1, NULL);


    xTaskCreate(vPH_task, (signed char*)"vPH", 128, &ph_p, tskIDLE_PRIORITY+2, NULL);
 8000ff4:	9500      	str	r5, [sp, #0]
 8000ff6:	9401      	str	r4, [sp, #4]
 8000ff8:	9402      	str	r4, [sp, #8]
 8000ffa:	9403      	str	r4, [sp, #12]
 8000ffc:	f640 1021 	movw	r0, #2337	; 0x921
 8001000:	f6c0 0000 	movt	r0, #2048	; 0x800
 8001004:	f244 3110 	movw	r1, #17168	; 0x4310
 8001008:	f6c0 0100 	movt	r1, #2048	; 0x800
 800100c:	2280      	movs	r2, #128	; 0x80
 800100e:	4633      	mov	r3, r6
 8001010:	f000 fa48 	bl	80014a4 <xTaskGenericCreate>

    //ph_p.target_ph = 100;

    USART_puts(USART2, "-----------------\r\n(2)target ph: ");
 8001014:	f44f 4588 	mov.w	r5, #17408	; 0x4400
 8001018:	f2c4 0500 	movt	r5, #16384	; 0x4000
 800101c:	4628      	mov	r0, r5
 800101e:	f244 3114 	movw	r1, #17172	; 0x4314
 8001022:	f6c0 0100 	movt	r1, #2048	; 0x800
 8001026:	f7ff fb87 	bl	8000738 <USART_puts>
    USART_put_int(USART2, ph_p.target_ph);
 800102a:	4628      	mov	r0, r5
 800102c:	6871      	ldr	r1, [r6, #4]
 800102e:	f7ff fc43 	bl	80008b8 <USART_put_int>
    USART_puts(USART2, "\r\n");
 8001032:	4628      	mov	r0, r5
 8001034:	f244 11f0 	movw	r1, #16880	; 0x41f0
 8001038:	f6c0 0100 	movt	r1, #2048	; 0x800
 800103c:	f7ff fb7c 	bl	8000738 <USART_puts>


	//xTaskCreate(UsartTask, (signed char*)"UsartTask", 128, NULL, tskIDLE_PRIORITY+1, NULL);

	//Call Scheduler
	vTaskStartScheduler();
 8001040:	f000 fb82 	bl	8001748 <vTaskStartScheduler>
    //
    
   

}
 8001044:	4620      	mov	r0, r4
 8001046:	b012      	add	sp, #72	; 0x48
 8001048:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

0800104c <Reset_Handler>:
 800104c:	2100      	movs	r1, #0
 800104e:	e003      	b.n	8001058 <LoopCopyDataInit>

08001050 <CopyDataInit>:
 8001050:	4b0e      	ldr	r3, [pc, #56]	; (800108c <LoopFillZerobss+0x20>)
 8001052:	585b      	ldr	r3, [r3, r1]
 8001054:	5043      	str	r3, [r0, r1]
 8001056:	3104      	adds	r1, #4

08001058 <LoopCopyDataInit>:
 8001058:	480d      	ldr	r0, [pc, #52]	; (8001090 <LoopFillZerobss+0x24>)
 800105a:	4b0e      	ldr	r3, [pc, #56]	; (8001094 <LoopFillZerobss+0x28>)
 800105c:	1842      	adds	r2, r0, r1
 800105e:	429a      	cmp	r2, r3
 8001060:	d3f6      	bcc.n	8001050 <CopyDataInit>
 8001062:	4a0d      	ldr	r2, [pc, #52]	; (8001098 <LoopFillZerobss+0x2c>)
 8001064:	e002      	b.n	800106c <LoopFillZerobss>

08001066 <FillZerobss>:
 8001066:	2300      	movs	r3, #0
 8001068:	f842 3b04 	str.w	r3, [r2], #4

0800106c <LoopFillZerobss>:
 800106c:	4b0b      	ldr	r3, [pc, #44]	; (800109c <LoopFillZerobss+0x30>)
 800106e:	429a      	cmp	r2, r3
 8001070:	d3f9      	bcc.n	8001066 <FillZerobss>
 8001072:	480b      	ldr	r0, [pc, #44]	; (80010a0 <LoopFillZerobss+0x34>)
 8001074:	6801      	ldr	r1, [r0, #0]
 8001076:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
 800107a:	6001      	str	r1, [r0, #0]
 800107c:	f000 f814 	bl	80010a8 <SystemInit>
 8001080:	f002 fb28 	bl	80036d4 <__libc_init_array>
 8001084:	f7ff fee2 	bl	8000e4c <main>
 8001088:	4770      	bx	lr
 800108a:	0000      	.short	0x0000
 800108c:	08004364 	.word	0x08004364
 8001090:	20000000 	.word	0x20000000
 8001094:	20000884 	.word	0x20000884
 8001098:	20000888 	.word	0x20000888
 800109c:	20000e1c 	.word	0x20000e1c
 80010a0:	e000ed88 	.word	0xe000ed88

080010a4 <ADC_IRQHandler>:
 80010a4:	e7fe      	b.n	80010a4 <ADC_IRQHandler>
 80010a6:	0000      	movs	r0, r0

080010a8 <SystemInit>:
  *         SystemFrequency variable.
  * @param  None
  * @retval None
  */
void SystemInit(void)
{
 80010a8:	b580      	push	{r7, lr}
 80010aa:	af00      	add	r7, sp, #0
  /* Reset the RCC clock configuration to the default reset state ------------*/
  /* Set HSION bit */
  RCC->CR |= (uint32_t)0x00000001;
 80010ac:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 80010b0:	f2c4 0302 	movt	r3, #16386	; 0x4002
 80010b4:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 80010b8:	f2c4 0202 	movt	r2, #16386	; 0x4002
 80010bc:	6812      	ldr	r2, [r2, #0]
 80010be:	f042 0201 	orr.w	r2, r2, #1
 80010c2:	601a      	str	r2, [r3, #0]

  /* Reset CFGR register */
  RCC->CFGR = 0x00000000;
 80010c4:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 80010c8:	f2c4 0302 	movt	r3, #16386	; 0x4002
 80010cc:	2200      	movs	r2, #0
 80010ce:	609a      	str	r2, [r3, #8]

  /* Reset HSEON, CSSON and PLLON bits */
  RCC->CR &= (uint32_t)0xFEF6FFFF;
 80010d0:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 80010d4:	f2c4 0302 	movt	r3, #16386	; 0x4002
 80010d8:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 80010dc:	f2c4 0202 	movt	r2, #16386	; 0x4002
 80010e0:	6812      	ldr	r2, [r2, #0]
 80010e2:	f022 7284 	bic.w	r2, r2, #17301504	; 0x1080000
 80010e6:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 80010ea:	601a      	str	r2, [r3, #0]

  /* Reset PLLCFGR register */
  RCC->PLLCFGR = 0x24003010;
 80010ec:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 80010f0:	f2c4 0302 	movt	r3, #16386	; 0x4002
 80010f4:	f243 0210 	movw	r2, #12304	; 0x3010
 80010f8:	f2c2 4200 	movt	r2, #9216	; 0x2400
 80010fc:	605a      	str	r2, [r3, #4]

  /* Reset HSEBYP bit */
  RCC->CR &= (uint32_t)0xFFFBFFFF;
 80010fe:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8001102:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8001106:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 800110a:	f2c4 0202 	movt	r2, #16386	; 0x4002
 800110e:	6812      	ldr	r2, [r2, #0]
 8001110:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 8001114:	601a      	str	r2, [r3, #0]

  /* Disable all interrupts */
  RCC->CIR = 0x00000000;
 8001116:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 800111a:	f2c4 0302 	movt	r3, #16386	; 0x4002
 800111e:	2200      	movs	r2, #0
 8001120:	60da      	str	r2, [r3, #12]
  SystemInit_ExtMemCtl(); 
#endif /* DATA_IN_ExtSRAM */
         
  /* Configure the System clock source, PLL Multiplier and Divider factors, 
     AHB/APBx prescalers and Flash settings ----------------------------------*/
  SetSysClock();
 8001122:	f000 f809 	bl	8001138 <SetSysClock>

  /* Configure the Vector Table location add offset address ------------------*/
#ifdef VECT_TAB_SRAM
  SCB->VTOR = SRAM_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM */
#else
  SCB->VTOR = FLASH_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal FLASH */
 8001126:	f44f 436d 	mov.w	r3, #60672	; 0xed00
 800112a:	f2ce 0300 	movt	r3, #57344	; 0xe000
 800112e:	f04f 6200 	mov.w	r2, #134217728	; 0x8000000
 8001132:	609a      	str	r2, [r3, #8]
#endif
}
 8001134:	bd80      	pop	{r7, pc}
 8001136:	bf00      	nop

08001138 <SetSysClock>:
  *         is reset to the default reset state (done in SystemInit() function).   
  * @param  None
  * @retval None
  */
static void SetSysClock(void)
{
 8001138:	b480      	push	{r7}
 800113a:	b083      	sub	sp, #12
 800113c:	af00      	add	r7, sp, #0
/******************************************************************************/
/*            PLL (clocked by HSE) used as System clock source                */
/******************************************************************************/
  __IO uint32_t StartUpCounter = 0, HSEStatus = 0;
 800113e:	2300      	movs	r3, #0
 8001140:	607b      	str	r3, [r7, #4]
 8001142:	2300      	movs	r3, #0
 8001144:	603b      	str	r3, [r7, #0]
  
  /* Enable HSE */
  RCC->CR |= ((uint32_t)RCC_CR_HSEON);
 8001146:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 800114a:	f2c4 0302 	movt	r3, #16386	; 0x4002
 800114e:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 8001152:	f2c4 0202 	movt	r2, #16386	; 0x4002
 8001156:	6812      	ldr	r2, [r2, #0]
 8001158:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
 800115c:	601a      	str	r2, [r3, #0]
 
  /* Wait till HSE is ready and if Time out is reached exit */
  do
  {
    HSEStatus = RCC->CR & RCC_CR_HSERDY;
 800115e:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8001162:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8001166:	681b      	ldr	r3, [r3, #0]
 8001168:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 800116c:	603b      	str	r3, [r7, #0]
    StartUpCounter++;
 800116e:	687b      	ldr	r3, [r7, #4]
 8001170:	3301      	adds	r3, #1
 8001172:	607b      	str	r3, [r7, #4]
  } while((HSEStatus == 0) && (StartUpCounter != HSE_STARTUP_TIMEOUT));
 8001174:	683b      	ldr	r3, [r7, #0]
 8001176:	2b00      	cmp	r3, #0
 8001178:	d103      	bne.n	8001182 <SetSysClock+0x4a>
 800117a:	687b      	ldr	r3, [r7, #4]
 800117c:	f5b3 6fa0 	cmp.w	r3, #1280	; 0x500
 8001180:	d1ed      	bne.n	800115e <SetSysClock+0x26>

  if ((RCC->CR & RCC_CR_HSERDY) != RESET)
 8001182:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8001186:	f2c4 0302 	movt	r3, #16386	; 0x4002
 800118a:	681b      	ldr	r3, [r3, #0]
 800118c:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 8001190:	2b00      	cmp	r3, #0
 8001192:	d002      	beq.n	800119a <SetSysClock+0x62>
  {
    HSEStatus = (uint32_t)0x01;
 8001194:	2301      	movs	r3, #1
 8001196:	603b      	str	r3, [r7, #0]
 8001198:	e001      	b.n	800119e <SetSysClock+0x66>
  }
  else
  {
    HSEStatus = (uint32_t)0x00;
 800119a:	2300      	movs	r3, #0
 800119c:	603b      	str	r3, [r7, #0]
  }

  if (HSEStatus == (uint32_t)0x01)
 800119e:	683b      	ldr	r3, [r7, #0]
 80011a0:	2b01      	cmp	r3, #1
 80011a2:	f040 8082 	bne.w	80012aa <SetSysClock+0x172>
  {
    /* Enable high performance mode, System frequency up to 168 MHz */
    RCC->APB1ENR |= RCC_APB1ENR_PWREN;
 80011a6:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 80011aa:	f2c4 0302 	movt	r3, #16386	; 0x4002
 80011ae:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 80011b2:	f2c4 0202 	movt	r2, #16386	; 0x4002
 80011b6:	6c12      	ldr	r2, [r2, #64]	; 0x40
 80011b8:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 80011bc:	641a      	str	r2, [r3, #64]	; 0x40
    PWR->CR |= PWR_CR_PMODE;  
 80011be:	f44f 43e0 	mov.w	r3, #28672	; 0x7000
 80011c2:	f2c4 0300 	movt	r3, #16384	; 0x4000
 80011c6:	f44f 42e0 	mov.w	r2, #28672	; 0x7000
 80011ca:	f2c4 0200 	movt	r2, #16384	; 0x4000
 80011ce:	6812      	ldr	r2, [r2, #0]
 80011d0:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
 80011d4:	601a      	str	r2, [r3, #0]

    /* HCLK = SYSCLK / 1*/
    RCC->CFGR |= RCC_CFGR_HPRE_DIV1;
 80011d6:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 80011da:	f2c4 0302 	movt	r3, #16386	; 0x4002
 80011de:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 80011e2:	f2c4 0202 	movt	r2, #16386	; 0x4002
 80011e6:	6892      	ldr	r2, [r2, #8]
 80011e8:	609a      	str	r2, [r3, #8]
      
    /* PCLK2 = HCLK / 2*/
    RCC->CFGR |= RCC_CFGR_PPRE2_DIV2;
 80011ea:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 80011ee:	f2c4 0302 	movt	r3, #16386	; 0x4002
 80011f2:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 80011f6:	f2c4 0202 	movt	r2, #16386	; 0x4002
 80011fa:	6892      	ldr	r2, [r2, #8]
 80011fc:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
 8001200:	609a      	str	r2, [r3, #8]
    
    /* PCLK1 = HCLK / 4*/
    RCC->CFGR |= RCC_CFGR_PPRE1_DIV4;
 8001202:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8001206:	f2c4 0302 	movt	r3, #16386	; 0x4002
 800120a:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 800120e:	f2c4 0202 	movt	r2, #16386	; 0x4002
 8001212:	6892      	ldr	r2, [r2, #8]
 8001214:	f442 52a0 	orr.w	r2, r2, #5120	; 0x1400
 8001218:	609a      	str	r2, [r3, #8]

    /* Configure the main PLL */
    RCC->PLLCFGR = PLL_M | (PLL_N << 6) | (((PLL_P >> 1) -1) << 16) |
 800121a:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 800121e:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8001222:	f245 4208 	movw	r2, #21512	; 0x5408
 8001226:	f2c0 7240 	movt	r2, #1856	; 0x740
 800122a:	605a      	str	r2, [r3, #4]
                   (RCC_PLLCFGR_PLLSRC_HSE) | (PLL_Q << 24);

    /* Enable the main PLL */
    RCC->CR |= RCC_CR_PLLON;
 800122c:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8001230:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8001234:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 8001238:	f2c4 0202 	movt	r2, #16386	; 0x4002
 800123c:	6812      	ldr	r2, [r2, #0]
 800123e:	f042 7280 	orr.w	r2, r2, #16777216	; 0x1000000
 8001242:	601a      	str	r2, [r3, #0]

    /* Wait till the main PLL is ready */
    while((RCC->CR & RCC_CR_PLLRDY) == 0)
 8001244:	bf00      	nop
 8001246:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 800124a:	f2c4 0302 	movt	r3, #16386	; 0x4002
 800124e:	681b      	ldr	r3, [r3, #0]
 8001250:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
 8001254:	2b00      	cmp	r3, #0
 8001256:	d0f6      	beq.n	8001246 <SetSysClock+0x10e>
    {
    }
   
    /* Configure Flash prefetch, Instruction cache, Data cache and wait state */
    FLASH->ACR = FLASH_ACR_ICEN |FLASH_ACR_DCEN |FLASH_ACR_LATENCY_5WS;
 8001258:	f44f 5370 	mov.w	r3, #15360	; 0x3c00
 800125c:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8001260:	f240 6205 	movw	r2, #1541	; 0x605
 8001264:	601a      	str	r2, [r3, #0]

    /* Select the main PLL as system clock source */
    RCC->CFGR &= (uint32_t)((uint32_t)~(RCC_CFGR_SW));
 8001266:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 800126a:	f2c4 0302 	movt	r3, #16386	; 0x4002
 800126e:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 8001272:	f2c4 0202 	movt	r2, #16386	; 0x4002
 8001276:	6892      	ldr	r2, [r2, #8]
 8001278:	f022 0203 	bic.w	r2, r2, #3
 800127c:	609a      	str	r2, [r3, #8]
    RCC->CFGR |= RCC_CFGR_SW_PLL;
 800127e:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8001282:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8001286:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 800128a:	f2c4 0202 	movt	r2, #16386	; 0x4002
 800128e:	6892      	ldr	r2, [r2, #8]
 8001290:	f042 0202 	orr.w	r2, r2, #2
 8001294:	609a      	str	r2, [r3, #8]

    /* Wait till the main PLL is used as system clock source */
    while ((RCC->CFGR & (uint32_t)RCC_CFGR_SWS ) != RCC_CFGR_SWS_PLL);
 8001296:	bf00      	nop
 8001298:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 800129c:	f2c4 0302 	movt	r3, #16386	; 0x4002
 80012a0:	689b      	ldr	r3, [r3, #8]
 80012a2:	f003 030c 	and.w	r3, r3, #12
 80012a6:	2b08      	cmp	r3, #8
 80012a8:	d1f6      	bne.n	8001298 <SetSysClock+0x160>

/******************************************************************************/
/*                        I2S clock configuration                             */
/******************************************************************************/
  /* PLLI2S clock used as I2S clock source */
  RCC->CFGR &= ~RCC_CFGR_I2SSRC;
 80012aa:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 80012ae:	f2c4 0302 	movt	r3, #16386	; 0x4002
 80012b2:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 80012b6:	f2c4 0202 	movt	r2, #16386	; 0x4002
 80012ba:	6892      	ldr	r2, [r2, #8]
 80012bc:	f422 0200 	bic.w	r2, r2, #8388608	; 0x800000
 80012c0:	609a      	str	r2, [r3, #8]

  /* Configure PLLI2S */
  RCC->PLLI2SCFGR = (PLLI2S_N << 6) | (PLLI2S_R << 28);
 80012c2:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 80012c6:	f2c4 0302 	movt	r3, #16386	; 0x4002
 80012ca:	f44f 5240 	mov.w	r2, #12288	; 0x3000
 80012ce:	f2c5 0200 	movt	r2, #20480	; 0x5000
 80012d2:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84

  /* Enable PLLI2S */
  RCC->CR |= ((uint32_t)RCC_CR_PLLI2SON);
 80012d6:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 80012da:	f2c4 0302 	movt	r3, #16386	; 0x4002
 80012de:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 80012e2:	f2c4 0202 	movt	r2, #16386	; 0x4002
 80012e6:	6812      	ldr	r2, [r2, #0]
 80012e8:	f042 6280 	orr.w	r2, r2, #67108864	; 0x4000000
 80012ec:	601a      	str	r2, [r3, #0]

  /* Wait till PLLI2S is ready */
  while((RCC->CR & RCC_CR_PLLI2SRDY) == 0)
 80012ee:	bf00      	nop
 80012f0:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 80012f4:	f2c4 0302 	movt	r3, #16386	; 0x4002
 80012f8:	681b      	ldr	r3, [r3, #0]
 80012fa:	f003 6300 	and.w	r3, r3, #134217728	; 0x8000000
 80012fe:	2b00      	cmp	r3, #0
 8001300:	d0f6      	beq.n	80012f0 <SetSysClock+0x1b8>
  {
  }
}
 8001302:	370c      	adds	r7, #12
 8001304:	46bd      	mov	sp, r7
 8001306:	f85d 7b04 	ldr.w	r7, [sp], #4
 800130a:	4770      	bx	lr

0800130c <_sbrk_r>:
    return 1;
}


void *_sbrk_r(struct _reent *r, ptrdiff_t incr)
{
 800130c:	b490      	push	{r4, r7}
 800130e:	b084      	sub	sp, #16
 8001310:	af00      	add	r7, sp, #0
 8001312:	6078      	str	r0, [r7, #4]
 8001314:	6039      	str	r1, [r7, #0]
    extern char end;   // provided by the linker script

    if (__brkval == 0)
 8001316:	f640 6318 	movw	r3, #3608	; 0xe18
 800131a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800131e:	681b      	ldr	r3, [r3, #0]
 8001320:	2b00      	cmp	r3, #0
 8001322:	d108      	bne.n	8001336 <_sbrk_r+0x2a>
        __brkval = &end;
 8001324:	f640 6318 	movw	r3, #3608	; 0xe18
 8001328:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800132c:	f640 621c 	movw	r2, #3612	; 0xe1c
 8001330:	f2c2 0200 	movt	r2, #8192	; 0x2000
 8001334:	601a      	str	r2, [r3, #0]

    if (__brkval + incr > (char*)__get_MSP() - __malloc_margin) {
 8001336:	f640 6318 	movw	r3, #3608	; 0xe18
 800133a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800133e:	681a      	ldr	r2, [r3, #0]
 8001340:	683b      	ldr	r3, [r7, #0]
 8001342:	441a      	add	r2, r3
 */
__attribute__( ( always_inline ) ) static __INLINE uint32_t __get_MSP(void)
{
  register uint32_t result;

  __ASM volatile ("MRS %0, msp\n" : "=r" (result) );
 8001344:	f3ef 8308 	mrs	r3, MSP
 8001348:	461c      	mov	r4, r3
  return(result);
 800134a:	4623      	mov	r3, r4
 800134c:	4619      	mov	r1, r3
 800134e:	f240 0328 	movw	r3, #40	; 0x28
 8001352:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001356:	681b      	ldr	r3, [r3, #0]
 8001358:	1acb      	subs	r3, r1, r3
 800135a:	429a      	cmp	r2, r3
 800135c:	d905      	bls.n	800136a <_sbrk_r+0x5e>
        r->_errno = ENOMEM;
 800135e:	687b      	ldr	r3, [r7, #4]
 8001360:	220c      	movs	r2, #12
 8001362:	601a      	str	r2, [r3, #0]
        return (void*)-1;
 8001364:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 8001368:	e012      	b.n	8001390 <_sbrk_r+0x84>
    }

    void *ret = __brkval;
 800136a:	f640 6318 	movw	r3, #3608	; 0xe18
 800136e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001372:	681b      	ldr	r3, [r3, #0]
 8001374:	60fb      	str	r3, [r7, #12]
    __brkval += incr;
 8001376:	f640 6318 	movw	r3, #3608	; 0xe18
 800137a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800137e:	681a      	ldr	r2, [r3, #0]
 8001380:	683b      	ldr	r3, [r7, #0]
 8001382:	441a      	add	r2, r3
 8001384:	f640 6318 	movw	r3, #3608	; 0xe18
 8001388:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800138c:	601a      	str	r2, [r3, #0]

    return ret;
 800138e:	68fb      	ldr	r3, [r7, #12]
}
 8001390:	4618      	mov	r0, r3
 8001392:	3710      	adds	r7, #16
 8001394:	46bd      	mov	sp, r7
 8001396:	bc90      	pop	{r4, r7}
 8001398:	4770      	bx	lr
 800139a:	bf00      	nop

0800139c <__malloc_lock>:
    return -1;
}


void __malloc_lock(struct _reent *r)
{
 800139c:	b580      	push	{r7, lr}
 800139e:	b082      	sub	sp, #8
 80013a0:	af00      	add	r7, sp, #0
 80013a2:	6078      	str	r0, [r7, #4]
    vPortEnterCritical();
 80013a4:	f001 fad8 	bl	8002958 <vPortEnterCritical>
}
 80013a8:	3708      	adds	r7, #8
 80013aa:	46bd      	mov	sp, r7
 80013ac:	bd80      	pop	{r7, pc}
 80013ae:	bf00      	nop

080013b0 <__malloc_unlock>:


void __malloc_unlock(struct _reent *r)
{
 80013b0:	b580      	push	{r7, lr}
 80013b2:	b082      	sub	sp, #8
 80013b4:	af00      	add	r7, sp, #0
 80013b6:	6078      	str	r0, [r7, #4]
    vPortExitCritical();
 80013b8:	f001 fae4 	bl	8002984 <vPortExitCritical>
}
 80013bc:	3708      	adds	r7, #8
 80013be:	46bd      	mov	sp, r7
 80013c0:	bd80      	pop	{r7, pc}
 80013c2:	bf00      	nop

080013c4 <ultrasonic_init>:
                      GPIO_TypeDef *port_in,
                      GPIO_TypeDef *port_out,
                      uint16_t pin_in,
                      uint16_t pin_out,
                      uint16_t timeout)
{
 80013c4:	b480      	push	{r7}
 80013c6:	b085      	sub	sp, #20
 80013c8:	af00      	add	r7, sp, #0
 80013ca:	60f8      	str	r0, [r7, #12]
 80013cc:	60b9      	str	r1, [r7, #8]
 80013ce:	607a      	str	r2, [r7, #4]
 80013d0:	807b      	strh	r3, [r7, #2]
    sensor->port_in = port_in;
 80013d2:	68fb      	ldr	r3, [r7, #12]
 80013d4:	68ba      	ldr	r2, [r7, #8]
 80013d6:	601a      	str	r2, [r3, #0]
    sensor->pin_in = pin_in;
 80013d8:	68fb      	ldr	r3, [r7, #12]
 80013da:	887a      	ldrh	r2, [r7, #2]
 80013dc:	809a      	strh	r2, [r3, #4]
    sensor->port_out = port_out;
 80013de:	68fb      	ldr	r3, [r7, #12]
 80013e0:	687a      	ldr	r2, [r7, #4]
 80013e2:	609a      	str	r2, [r3, #8]
    sensor->pin_out = pin_out;
 80013e4:	68fb      	ldr	r3, [r7, #12]
 80013e6:	8b3a      	ldrh	r2, [r7, #24]
 80013e8:	819a      	strh	r2, [r3, #12]

    sensor->timeout = timeout;
 80013ea:	68fb      	ldr	r3, [r7, #12]
 80013ec:	8bba      	ldrh	r2, [r7, #28]
 80013ee:	81da      	strh	r2, [r3, #14]
}
 80013f0:	3714      	adds	r7, #20
 80013f2:	46bd      	mov	sp, r7
 80013f4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80013f8:	4770      	bx	lr
 80013fa:	bf00      	nop

080013fc <servo_init>:

  }
    return disTime/58*2; //converts to centimeters
}

void servo_init(Servo_Typedef *servo, volatile uint32_t *CCR, uint16_t offset, uint16_t range) {
 80013fc:	b480      	push	{r7}
 80013fe:	b085      	sub	sp, #20
 8001400:	af00      	add	r7, sp, #0
 8001402:	60f8      	str	r0, [r7, #12]
 8001404:	60b9      	str	r1, [r7, #8]
 8001406:	80fa      	strh	r2, [r7, #6]
 8001408:	80bb      	strh	r3, [r7, #4]
    servo->CCR = CCR;
 800140a:	68fb      	ldr	r3, [r7, #12]
 800140c:	68ba      	ldr	r2, [r7, #8]
 800140e:	601a      	str	r2, [r3, #0]
    servo->offset = offset;
 8001410:	68fb      	ldr	r3, [r7, #12]
 8001412:	88fa      	ldrh	r2, [r7, #6]
 8001414:	809a      	strh	r2, [r3, #4]
    servo->ratio = range/180;
 8001416:	88bb      	ldrh	r3, [r7, #4]
 8001418:	089a      	lsrs	r2, r3, #2
 800141a:	f646 4317 	movw	r3, #27671	; 0x6c17
 800141e:	f2c1 63c1 	movt	r3, #5825	; 0x16c1
 8001422:	fba3 1302 	umull	r1, r3, r3, r2
 8001426:	089b      	lsrs	r3, r3, #2
 8001428:	b29b      	uxth	r3, r3
 800142a:	b2da      	uxtb	r2, r3
 800142c:	68fb      	ldr	r3, [r7, #12]
 800142e:	719a      	strb	r2, [r3, #6]
    servo->last_pos = 0;
 8001430:	68fb      	ldr	r3, [r7, #12]
 8001432:	2200      	movs	r2, #0
 8001434:	71da      	strb	r2, [r3, #7]
    servo->current_pos = 0;
 8001436:	68fb      	ldr	r3, [r7, #12]
 8001438:	2200      	movs	r2, #0
 800143a:	721a      	strb	r2, [r3, #8]

    *(servo->CCR) = 0;
 800143c:	68fb      	ldr	r3, [r7, #12]
 800143e:	681b      	ldr	r3, [r3, #0]
 8001440:	2200      	movs	r2, #0
 8001442:	801a      	strh	r2, [r3, #0]
}
 8001444:	3714      	adds	r7, #20
 8001446:	46bd      	mov	sp, r7
 8001448:	f85d 7b04 	ldr.w	r7, [sp], #4
 800144c:	4770      	bx	lr
 800144e:	bf00      	nop

08001450 <servo_set_degrees>:

int servo_set_degrees(Servo_Typedef *servo, uint8_t degrees) {
 8001450:	b480      	push	{r7}
 8001452:	b083      	sub	sp, #12
 8001454:	af00      	add	r7, sp, #0
 8001456:	6078      	str	r0, [r7, #4]
 8001458:	460b      	mov	r3, r1
 800145a:	70fb      	strb	r3, [r7, #3]
    if (degrees==-1) *(servo->CCR) = -1;
    else {
        *(servo->CCR) = servo->offset+degrees*servo->ratio;
 800145c:	687b      	ldr	r3, [r7, #4]
 800145e:	681b      	ldr	r3, [r3, #0]
 8001460:	687a      	ldr	r2, [r7, #4]
 8001462:	8891      	ldrh	r1, [r2, #4]
 8001464:	78fa      	ldrb	r2, [r7, #3]
 8001466:	b292      	uxth	r2, r2
 8001468:	6878      	ldr	r0, [r7, #4]
 800146a:	7980      	ldrb	r0, [r0, #6]
 800146c:	fb00 f202 	mul.w	r2, r0, r2
 8001470:	b292      	uxth	r2, r2
 8001472:	440a      	add	r2, r1
 8001474:	b292      	uxth	r2, r2
 8001476:	801a      	strh	r2, [r3, #0]
        //int8_t offset = (10*(degrees - servo->current_pos));
        //if (offset<0) offset*-1;

        //*(servo->CCR) = 0;

        servo->last_pos = servo->current_pos;
 8001478:	687b      	ldr	r3, [r7, #4]
 800147a:	7a1a      	ldrb	r2, [r3, #8]
 800147c:	687b      	ldr	r3, [r7, #4]
 800147e:	71da      	strb	r2, [r3, #7]
        servo->current_pos = degrees;
 8001480:	687b      	ldr	r3, [r7, #4]
 8001482:	78fa      	ldrb	r2, [r7, #3]
 8001484:	721a      	strb	r2, [r3, #8]
        return servo->offset+degrees*servo->ratio;
 8001486:	687b      	ldr	r3, [r7, #4]
 8001488:	889b      	ldrh	r3, [r3, #4]
 800148a:	461a      	mov	r2, r3
 800148c:	78fb      	ldrb	r3, [r7, #3]
 800148e:	6879      	ldr	r1, [r7, #4]
 8001490:	7989      	ldrb	r1, [r1, #6]
 8001492:	fb01 f303 	mul.w	r3, r1, r3
 8001496:	4413      	add	r3, r2


    }
}
 8001498:	4618      	mov	r0, r3
 800149a:	370c      	adds	r7, #12
 800149c:	46bd      	mov	sp, r7
 800149e:	f85d 7b04 	ldr.w	r7, [sp], #4
 80014a2:	4770      	bx	lr

080014a4 <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
 80014a4:	b580      	push	{r7, lr}
 80014a6:	b08a      	sub	sp, #40	; 0x28
 80014a8:	af02      	add	r7, sp, #8
 80014aa:	60f8      	str	r0, [r7, #12]
 80014ac:	60b9      	str	r1, [r7, #8]
 80014ae:	603b      	str	r3, [r7, #0]
 80014b0:	4613      	mov	r3, r2
 80014b2:	80fb      	strh	r3, [r7, #6]
	configASSERT( pxTaskCode );
	configASSERT( ( uxPriority < configMAX_PRIORITIES ) );

	/* Allocate the memory required by the TCB and stack for the new task,
	checking that the allocation was successful. */
	pxNewTCB = prvAllocateTCBAndStack( usStackDepth, puxStackBuffer );
 80014b4:	88fb      	ldrh	r3, [r7, #6]
 80014b6:	4618      	mov	r0, r3
 80014b8:	6b39      	ldr	r1, [r7, #48]	; 0x30
 80014ba:	f000 fd9d 	bl	8001ff8 <prvAllocateTCBAndStack>
 80014be:	61b8      	str	r0, [r7, #24]

	if( pxNewTCB != NULL )
 80014c0:	69bb      	ldr	r3, [r7, #24]
 80014c2:	2b00      	cmp	r3, #0
 80014c4:	f000 809e 	beq.w	8001604 <xTaskGenericCreate+0x160>
		stack grows from high memory to low (as per the 80x86) or visa versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
 80014c8:	69bb      	ldr	r3, [r7, #24]
 80014ca:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 80014cc:	88fb      	ldrh	r3, [r7, #6]
 80014ce:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 80014d2:	3b01      	subs	r3, #1
 80014d4:	009b      	lsls	r3, r3, #2
 80014d6:	4413      	add	r3, r2
 80014d8:	617b      	str	r3, [r7, #20]
			pxTopOfStack = ( portSTACK_TYPE * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ( portPOINTER_SIZE_TYPE ) ~portBYTE_ALIGNMENT_MASK  ) );
 80014da:	697b      	ldr	r3, [r7, #20]
 80014dc:	f023 0307 	bic.w	r3, r3, #7
 80014e0:	617b      	str	r3, [r7, #20]
			pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
		}
		#endif

		/* Setup the newly allocated TCB with the initial state of the task. */
		prvInitialiseTCBVariables( pxNewTCB, pcName, uxPriority, xRegions, usStackDepth );
 80014e2:	88fb      	ldrh	r3, [r7, #6]
 80014e4:	9300      	str	r3, [sp, #0]
 80014e6:	69b8      	ldr	r0, [r7, #24]
 80014e8:	68b9      	ldr	r1, [r7, #8]
 80014ea:	6aba      	ldr	r2, [r7, #40]	; 0x28
 80014ec:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80014ee:	f000 fc6f 	bl	8001dd0 <prvInitialiseTCBVariables>
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 80014f2:	6978      	ldr	r0, [r7, #20]
 80014f4:	68f9      	ldr	r1, [r7, #12]
 80014f6:	683a      	ldr	r2, [r7, #0]
 80014f8:	f001 f9a2 	bl	8002840 <pxPortInitialiseStack>
 80014fc:	4602      	mov	r2, r0
 80014fe:	69bb      	ldr	r3, [r7, #24]
 8001500:	601a      	str	r2, [r3, #0]
		#endif

		/* Check the alignment of the initialised stack. */
		configASSERT( ( ( ( unsigned long ) pxNewTCB->pxTopOfStack & ( unsigned long ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );

		if( ( void * ) pxCreatedTask != NULL )
 8001502:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8001504:	2b00      	cmp	r3, #0
 8001506:	d002      	beq.n	800150e <xTaskGenericCreate+0x6a>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
 8001508:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800150a:	69ba      	ldr	r2, [r7, #24]
 800150c:	601a      	str	r2, [r3, #0]
		}
		
		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		taskENTER_CRITICAL();
 800150e:	f001 fa23 	bl	8002958 <vPortEnterCritical>
		{
			uxCurrentNumberOfTasks++;
 8001512:	f640 23a0 	movw	r3, #2720	; 0xaa0
 8001516:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800151a:	681b      	ldr	r3, [r3, #0]
 800151c:	1c5a      	adds	r2, r3, #1
 800151e:	f640 23a0 	movw	r3, #2720	; 0xaa0
 8001522:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001526:	601a      	str	r2, [r3, #0]
			if( pxCurrentTCB == NULL )
 8001528:	f640 13c4 	movw	r3, #2500	; 0x9c4
 800152c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001530:	681b      	ldr	r3, [r3, #0]
 8001532:	2b00      	cmp	r3, #0
 8001534:	d10f      	bne.n	8001556 <xTaskGenericCreate+0xb2>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
 8001536:	f640 13c4 	movw	r3, #2500	; 0x9c4
 800153a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800153e:	69ba      	ldr	r2, [r7, #24]
 8001540:	601a      	str	r2, [r3, #0]

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
 8001542:	f640 23a0 	movw	r3, #2720	; 0xaa0
 8001546:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800154a:	681b      	ldr	r3, [r3, #0]
 800154c:	2b01      	cmp	r3, #1
 800154e:	d118      	bne.n	8001582 <xTaskGenericCreate+0xde>
				{
					/* This is the first task to be created so do the preliminary
					initialisation required.  We will not recover if this call
					fails, but we will report the failure. */
					prvInitialiseTaskLists();
 8001550:	f000 fc7a 	bl	8001e48 <prvInitialiseTaskLists>
 8001554:	e015      	b.n	8001582 <xTaskGenericCreate+0xde>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
 8001556:	f640 23b0 	movw	r3, #2736	; 0xab0
 800155a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800155e:	681b      	ldr	r3, [r3, #0]
 8001560:	2b00      	cmp	r3, #0
 8001562:	d10e      	bne.n	8001582 <xTaskGenericCreate+0xde>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
 8001564:	f640 13c4 	movw	r3, #2500	; 0x9c4
 8001568:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800156c:	681b      	ldr	r3, [r3, #0]
 800156e:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8001570:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8001572:	429a      	cmp	r2, r3
 8001574:	d805      	bhi.n	8001582 <xTaskGenericCreate+0xde>
					{
						pxCurrentTCB = pxNewTCB;
 8001576:	f640 13c4 	movw	r3, #2500	; 0x9c4
 800157a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800157e:	69ba      	ldr	r2, [r7, #24]
 8001580:	601a      	str	r2, [r3, #0]
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
 8001582:	69bb      	ldr	r3, [r7, #24]
 8001584:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8001586:	f640 23a8 	movw	r3, #2728	; 0xaa8
 800158a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800158e:	681b      	ldr	r3, [r3, #0]
 8001590:	429a      	cmp	r2, r3
 8001592:	d906      	bls.n	80015a2 <xTaskGenericCreate+0xfe>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
 8001594:	69bb      	ldr	r3, [r7, #24]
 8001596:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8001598:	f640 23a8 	movw	r3, #2728	; 0xaa8
 800159c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80015a0:	601a      	str	r2, [r3, #0]
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
 80015a2:	f640 23c4 	movw	r3, #2756	; 0xac4
 80015a6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80015aa:	681b      	ldr	r3, [r3, #0]
 80015ac:	1c5a      	adds	r2, r3, #1
 80015ae:	f640 23c4 	movw	r3, #2756	; 0xac4
 80015b2:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80015b6:	601a      	str	r2, [r3, #0]

			prvAddTaskToReadyQueue( pxNewTCB );
 80015b8:	69bb      	ldr	r3, [r7, #24]
 80015ba:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 80015bc:	f640 23ac 	movw	r3, #2732	; 0xaac
 80015c0:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80015c4:	681b      	ldr	r3, [r3, #0]
 80015c6:	429a      	cmp	r2, r3
 80015c8:	d906      	bls.n	80015d8 <xTaskGenericCreate+0x134>
 80015ca:	69bb      	ldr	r3, [r7, #24]
 80015cc:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 80015ce:	f640 23ac 	movw	r3, #2732	; 0xaac
 80015d2:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80015d6:	601a      	str	r2, [r3, #0]
 80015d8:	69bb      	ldr	r3, [r7, #24]
 80015da:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 80015dc:	4613      	mov	r3, r2
 80015de:	009b      	lsls	r3, r3, #2
 80015e0:	4413      	add	r3, r2
 80015e2:	009b      	lsls	r3, r3, #2
 80015e4:	f640 12c8 	movw	r2, #2504	; 0x9c8
 80015e8:	f2c2 0200 	movt	r2, #8192	; 0x2000
 80015ec:	441a      	add	r2, r3
 80015ee:	69bb      	ldr	r3, [r7, #24]
 80015f0:	3304      	adds	r3, #4
 80015f2:	4610      	mov	r0, r2
 80015f4:	4619      	mov	r1, r3
 80015f6:	f001 f89b 	bl	8002730 <vListInsertEnd>

			xReturn = pdPASS;
 80015fa:	2301      	movs	r3, #1
 80015fc:	61fb      	str	r3, [r7, #28]
			traceTASK_CREATE( pxNewTCB );
		}
		taskEXIT_CRITICAL();
 80015fe:	f001 f9c1 	bl	8002984 <vPortExitCritical>
 8001602:	e002      	b.n	800160a <xTaskGenericCreate+0x166>
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
 8001604:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 8001608:	61fb      	str	r3, [r7, #28]
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
 800160a:	69fb      	ldr	r3, [r7, #28]
 800160c:	2b01      	cmp	r3, #1
 800160e:	d111      	bne.n	8001634 <xTaskGenericCreate+0x190>
	{
		if( xSchedulerRunning != pdFALSE )
 8001610:	f640 23b0 	movw	r3, #2736	; 0xab0
 8001614:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001618:	681b      	ldr	r3, [r3, #0]
 800161a:	2b00      	cmp	r3, #0
 800161c:	d00a      	beq.n	8001634 <xTaskGenericCreate+0x190>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
 800161e:	f640 13c4 	movw	r3, #2500	; 0x9c4
 8001622:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001626:	681b      	ldr	r3, [r3, #0]
 8001628:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800162a:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800162c:	429a      	cmp	r2, r3
 800162e:	d201      	bcs.n	8001634 <xTaskGenericCreate+0x190>
			{
				portYIELD_WITHIN_API();
 8001630:	f001 f984 	bl	800293c <vPortYieldFromISR>
			}
		}
	}

	return xReturn;
 8001634:	69fb      	ldr	r3, [r7, #28]
}
 8001636:	4618      	mov	r0, r3
 8001638:	3720      	adds	r7, #32
 800163a:	46bd      	mov	sp, r7
 800163c:	bd80      	pop	{r7, pc}
 800163e:	bf00      	nop

08001640 <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	void vTaskDelete( xTaskHandle pxTaskToDelete )
	{
 8001640:	b580      	push	{r7, lr}
 8001642:	b084      	sub	sp, #16
 8001644:	af00      	add	r7, sp, #0
 8001646:	6078      	str	r0, [r7, #4]
	tskTCB *pxTCB;

		taskENTER_CRITICAL();
 8001648:	f001 f986 	bl	8002958 <vPortEnterCritical>
		{
			/* Ensure a yield is performed if the current task is being
			deleted. */
			if( pxTaskToDelete == pxCurrentTCB )
 800164c:	f640 13c4 	movw	r3, #2500	; 0x9c4
 8001650:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001654:	681b      	ldr	r3, [r3, #0]
 8001656:	687a      	ldr	r2, [r7, #4]
 8001658:	429a      	cmp	r2, r3
 800165a:	d101      	bne.n	8001660 <vTaskDelete+0x20>
			{
				pxTaskToDelete = NULL;
 800165c:	2300      	movs	r3, #0
 800165e:	607b      	str	r3, [r7, #4]
			}

			/* If null is passed in here then we are deleting ourselves. */
			pxTCB = prvGetTCBFromHandle( pxTaskToDelete );
 8001660:	687b      	ldr	r3, [r7, #4]
 8001662:	2b00      	cmp	r3, #0
 8001664:	d105      	bne.n	8001672 <vTaskDelete+0x32>
 8001666:	f640 13c4 	movw	r3, #2500	; 0x9c4
 800166a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800166e:	681b      	ldr	r3, [r3, #0]
 8001670:	e000      	b.n	8001674 <vTaskDelete+0x34>
 8001672:	687b      	ldr	r3, [r7, #4]
 8001674:	60fb      	str	r3, [r7, #12]

			/* Remove task from the ready list and place in the	termination list.
			This will stop the task from be scheduled.  The idle task will check
			the termination list and free up any memory allocated by the
			scheduler for the TCB and stack. */
			vListRemove( &( pxTCB->xGenericListItem ) );
 8001676:	68fb      	ldr	r3, [r7, #12]
 8001678:	3304      	adds	r3, #4
 800167a:	4618      	mov	r0, r3
 800167c:	f001 f8b8 	bl	80027f0 <vListRemove>

			/* Is the task waiting on an event also? */
			if( pxTCB->xEventListItem.pvContainer != NULL )
 8001680:	68fb      	ldr	r3, [r7, #12]
 8001682:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8001684:	2b00      	cmp	r3, #0
 8001686:	d004      	beq.n	8001692 <vTaskDelete+0x52>
			{
				vListRemove( &( pxTCB->xEventListItem ) );
 8001688:	68fb      	ldr	r3, [r7, #12]
 800168a:	3318      	adds	r3, #24
 800168c:	4618      	mov	r0, r3
 800168e:	f001 f8af 	bl	80027f0 <vListRemove>
			}

			vListInsertEnd( ( xList * ) &xTasksWaitingTermination, &( pxTCB->xGenericListItem ) );
 8001692:	68fb      	ldr	r3, [r7, #12]
 8001694:	3304      	adds	r3, #4
 8001696:	f640 2070 	movw	r0, #2672	; 0xa70
 800169a:	f2c2 0000 	movt	r0, #8192	; 0x2000
 800169e:	4619      	mov	r1, r3
 80016a0:	f001 f846 	bl	8002730 <vListInsertEnd>

			/* Increment the ucTasksDeleted variable so the idle task knows
			there is a task that has been deleted and that it should therefore
			check the xTasksWaitingTermination list. */
			++uxTasksDeleted;
 80016a4:	f640 2384 	movw	r3, #2692	; 0xa84
 80016a8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80016ac:	681b      	ldr	r3, [r3, #0]
 80016ae:	1c5a      	adds	r2, r3, #1
 80016b0:	f640 2384 	movw	r3, #2692	; 0xa84
 80016b4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80016b8:	601a      	str	r2, [r3, #0]

			/* Increment the uxTaskNumberVariable also so kernel aware debuggers
			can detect that the task lists need re-generating. */
			uxTaskNumber++;
 80016ba:	f640 23c4 	movw	r3, #2756	; 0xac4
 80016be:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80016c2:	681b      	ldr	r3, [r3, #0]
 80016c4:	1c5a      	adds	r2, r3, #1
 80016c6:	f640 23c4 	movw	r3, #2756	; 0xac4
 80016ca:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80016ce:	601a      	str	r2, [r3, #0]

			traceTASK_DELETE( pxTCB );
		}
		taskEXIT_CRITICAL();
 80016d0:	f001 f958 	bl	8002984 <vPortExitCritical>

		/* Force a reschedule if we have just deleted the current task. */
		if( xSchedulerRunning != pdFALSE )
 80016d4:	f640 23b0 	movw	r3, #2736	; 0xab0
 80016d8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80016dc:	681b      	ldr	r3, [r3, #0]
 80016de:	2b00      	cmp	r3, #0
 80016e0:	d004      	beq.n	80016ec <vTaskDelete+0xac>
		{
			if( ( void * ) pxTaskToDelete == NULL )
 80016e2:	687b      	ldr	r3, [r7, #4]
 80016e4:	2b00      	cmp	r3, #0
 80016e6:	d101      	bne.n	80016ec <vTaskDelete+0xac>
			{
				portYIELD_WITHIN_API();
 80016e8:	f001 f928 	bl	800293c <vPortYieldFromISR>
			}
		}
	}
 80016ec:	3710      	adds	r7, #16
 80016ee:	46bd      	mov	sp, r7
 80016f0:	bd80      	pop	{r7, pc}
 80016f2:	bf00      	nop

080016f4 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
 80016f4:	b580      	push	{r7, lr}
 80016f6:	b084      	sub	sp, #16
 80016f8:	af00      	add	r7, sp, #0
 80016fa:	6078      	str	r0, [r7, #4]
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;
 80016fc:	2300      	movs	r3, #0
 80016fe:	60fb      	str	r3, [r7, #12]

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0U )
 8001700:	687b      	ldr	r3, [r7, #4]
 8001702:	2b00      	cmp	r3, #0
 8001704:	d018      	beq.n	8001738 <vTaskDelay+0x44>
		{
			vTaskSuspendAll();
 8001706:	f000 f855 	bl	80017b4 <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
 800170a:	f640 23a4 	movw	r3, #2724	; 0xaa4
 800170e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001712:	681a      	ldr	r2, [r3, #0]
 8001714:	687b      	ldr	r3, [r7, #4]
 8001716:	4413      	add	r3, r2
 8001718:	60bb      	str	r3, [r7, #8]

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
 800171a:	f640 13c4 	movw	r3, #2500	; 0x9c4
 800171e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001722:	681b      	ldr	r3, [r3, #0]
 8001724:	3304      	adds	r3, #4
 8001726:	4618      	mov	r0, r3
 8001728:	f001 f862 	bl	80027f0 <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
 800172c:	68b8      	ldr	r0, [r7, #8]
 800172e:	f000 fc1f 	bl	8001f70 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
 8001732:	f000 f851 	bl	80017d8 <xTaskResumeAll>
 8001736:	60f8      	str	r0, [r7, #12]
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
 8001738:	68fb      	ldr	r3, [r7, #12]
 800173a:	2b00      	cmp	r3, #0
 800173c:	d101      	bne.n	8001742 <vTaskDelay+0x4e>
		{
			portYIELD_WITHIN_API();
 800173e:	f001 f8fd 	bl	800293c <vPortYieldFromISR>
		}
	}
 8001742:	3710      	adds	r7, #16
 8001744:	46bd      	mov	sp, r7
 8001746:	bd80      	pop	{r7, pc}

08001748 <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
 8001748:	b580      	push	{r7, lr}
 800174a:	b086      	sub	sp, #24
 800174c:	af04      	add	r7, sp, #16
	/* Add the idle task at the lowest priority. */
	#if ( INCLUDE_xTaskGetIdleTaskHandle == 1 )
	{
		/* Create the idle task, storing its handle in xIdleTaskHandle so it can
		be returned by the xTaskGetIdleTaskHandle() function. */
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), &xIdleTaskHandle );
 800174e:	2300      	movs	r3, #0
 8001750:	9300      	str	r3, [sp, #0]
 8001752:	f640 239c 	movw	r3, #2716	; 0xa9c
 8001756:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800175a:	9301      	str	r3, [sp, #4]
 800175c:	2300      	movs	r3, #0
 800175e:	9302      	str	r3, [sp, #8]
 8001760:	2300      	movs	r3, #0
 8001762:	9303      	str	r3, [sp, #12]
 8001764:	f641 50ad 	movw	r0, #7597	; 0x1dad
 8001768:	f6c0 0000 	movt	r0, #2048	; 0x800
 800176c:	f244 01b4 	movw	r1, #16564	; 0x40b4
 8001770:	f6c0 0100 	movt	r1, #2048	; 0x800
 8001774:	f44f 7280 	mov.w	r2, #256	; 0x100
 8001778:	2300      	movs	r3, #0
 800177a:	f7ff fe93 	bl	80014a4 <xTaskGenericCreate>
 800177e:	6078      	str	r0, [r7, #4]
			xReturn = xTimerCreateTimerTask();
		}
	}
	#endif

	if( xReturn == pdPASS )
 8001780:	687b      	ldr	r3, [r7, #4]
 8001782:	2b01      	cmp	r3, #1
 8001784:	d113      	bne.n	80017ae <vTaskStartScheduler+0x66>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
 8001786:	f04f 00bf 	mov.w	r0, #191	; 0xbf
 800178a:	f380 8811 	msr	BASEPRI, r0

		xSchedulerRunning = pdTRUE;
 800178e:	f640 23b0 	movw	r3, #2736	; 0xab0
 8001792:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001796:	2201      	movs	r2, #1
 8001798:	601a      	str	r2, [r3, #0]
		xTickCount = ( portTickType ) 0U;
 800179a:	f640 23a4 	movw	r3, #2724	; 0xaa4
 800179e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80017a2:	2200      	movs	r2, #0
 80017a4:	601a      	str	r2, [r3, #0]

		/* If configGENERATE_RUN_TIME_STATS is defined then the following
		macro must be defined to configure the timer/counter used to generate
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();
 80017a6:	f7fe ff43 	bl	8000630 <init_us_timer>
		
		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
 80017aa:	f001 f891 	bl	80028d0 <xPortStartScheduler>
		}
	}

	/* This line will only be reached if the kernel could not be started. */
	configASSERT( xReturn );
}
 80017ae:	3708      	adds	r7, #8
 80017b0:	46bd      	mov	sp, r7
 80017b2:	bd80      	pop	{r7, pc}

080017b4 <vTaskSuspendAll>:
	vPortEndScheduler();
}
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
 80017b4:	b480      	push	{r7}
 80017b6:	af00      	add	r7, sp, #0
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
 80017b8:	f640 23b4 	movw	r3, #2740	; 0xab4
 80017bc:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80017c0:	681b      	ldr	r3, [r3, #0]
 80017c2:	1c5a      	adds	r2, r3, #1
 80017c4:	f640 23b4 	movw	r3, #2740	; 0xab4
 80017c8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80017cc:	601a      	str	r2, [r3, #0]
}
 80017ce:	46bd      	mov	sp, r7
 80017d0:	f85d 7b04 	ldr.w	r7, [sp], #4
 80017d4:	4770      	bx	lr
 80017d6:	bf00      	nop

080017d8 <xTaskResumeAll>:
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
 80017d8:	b590      	push	{r4, r7, lr}
 80017da:	b083      	sub	sp, #12
 80017dc:	af00      	add	r7, sp, #0
register tskTCB *pxTCB;
signed portBASE_TYPE xAlreadyYielded = pdFALSE;
 80017de:	2300      	movs	r3, #0
 80017e0:	607b      	str	r3, [r7, #4]
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
 80017e2:	f001 f8b9 	bl	8002958 <vPortEnterCritical>
	{
		--uxSchedulerSuspended;
 80017e6:	f640 23b4 	movw	r3, #2740	; 0xab4
 80017ea:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80017ee:	681b      	ldr	r3, [r3, #0]
 80017f0:	1e5a      	subs	r2, r3, #1
 80017f2:	f640 23b4 	movw	r3, #2740	; 0xab4
 80017f6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80017fa:	601a      	str	r2, [r3, #0]

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
 80017fc:	f640 23b4 	movw	r3, #2740	; 0xab4
 8001800:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001804:	681b      	ldr	r3, [r3, #0]
 8001806:	2b00      	cmp	r3, #0
 8001808:	d179      	bne.n	80018fe <xTaskResumeAll+0x126>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
 800180a:	f640 23a0 	movw	r3, #2720	; 0xaa0
 800180e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001812:	681b      	ldr	r3, [r3, #0]
 8001814:	2b00      	cmp	r3, #0
 8001816:	d072      	beq.n	80018fe <xTaskResumeAll+0x126>
			{
				portBASE_TYPE xYieldRequired = pdFALSE;
 8001818:	2300      	movs	r3, #0
 800181a:	603b      	str	r3, [r7, #0]

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
 800181c:	e036      	b.n	800188c <xTaskResumeAll+0xb4>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
 800181e:	f640 235c 	movw	r3, #2652	; 0xa5c
 8001822:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001826:	68db      	ldr	r3, [r3, #12]
 8001828:	68dc      	ldr	r4, [r3, #12]
					vListRemove( &( pxTCB->xEventListItem ) );
 800182a:	f104 0318 	add.w	r3, r4, #24
 800182e:	4618      	mov	r0, r3
 8001830:	f000 ffde 	bl	80027f0 <vListRemove>
					vListRemove( &( pxTCB->xGenericListItem ) );
 8001834:	1d23      	adds	r3, r4, #4
 8001836:	4618      	mov	r0, r3
 8001838:	f000 ffda 	bl	80027f0 <vListRemove>
					prvAddTaskToReadyQueue( pxTCB );
 800183c:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 800183e:	f640 23ac 	movw	r3, #2732	; 0xaac
 8001842:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001846:	681b      	ldr	r3, [r3, #0]
 8001848:	429a      	cmp	r2, r3
 800184a:	d905      	bls.n	8001858 <xTaskResumeAll+0x80>
 800184c:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 800184e:	f640 23ac 	movw	r3, #2732	; 0xaac
 8001852:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001856:	601a      	str	r2, [r3, #0]
 8001858:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 800185a:	4613      	mov	r3, r2
 800185c:	009b      	lsls	r3, r3, #2
 800185e:	4413      	add	r3, r2
 8001860:	009b      	lsls	r3, r3, #2
 8001862:	f640 12c8 	movw	r2, #2504	; 0x9c8
 8001866:	f2c2 0200 	movt	r2, #8192	; 0x2000
 800186a:	441a      	add	r2, r3
 800186c:	1d23      	adds	r3, r4, #4
 800186e:	4610      	mov	r0, r2
 8001870:	4619      	mov	r1, r3
 8001872:	f000 ff5d 	bl	8002730 <vListInsertEnd>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 8001876:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 8001878:	f640 13c4 	movw	r3, #2500	; 0x9c4
 800187c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001880:	681b      	ldr	r3, [r3, #0]
 8001882:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8001884:	429a      	cmp	r2, r3
 8001886:	d301      	bcc.n	800188c <xTaskResumeAll+0xb4>
					{
						xYieldRequired = pdTRUE;
 8001888:	2301      	movs	r3, #1
 800188a:	603b      	str	r3, [r7, #0]
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
 800188c:	f640 235c 	movw	r3, #2652	; 0xa5c
 8001890:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001894:	681b      	ldr	r3, [r3, #0]
 8001896:	2b00      	cmp	r3, #0
 8001898:	d1c1      	bne.n	800181e <xTaskResumeAll+0x46>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
 800189a:	f640 23b8 	movw	r3, #2744	; 0xab8
 800189e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80018a2:	681b      	ldr	r3, [r3, #0]
 80018a4:	2b00      	cmp	r3, #0
 80018a6:	d016      	beq.n	80018d6 <xTaskResumeAll+0xfe>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
 80018a8:	e00c      	b.n	80018c4 <xTaskResumeAll+0xec>
					{
						vTaskIncrementTick();
 80018aa:	f000 f82f 	bl	800190c <vTaskIncrementTick>
						--uxMissedTicks;
 80018ae:	f640 23b8 	movw	r3, #2744	; 0xab8
 80018b2:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80018b6:	681b      	ldr	r3, [r3, #0]
 80018b8:	1e5a      	subs	r2, r3, #1
 80018ba:	f640 23b8 	movw	r3, #2744	; 0xab8
 80018be:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80018c2:	601a      	str	r2, [r3, #0]
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
 80018c4:	f640 23b8 	movw	r3, #2744	; 0xab8
 80018c8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80018cc:	681b      	ldr	r3, [r3, #0]
 80018ce:	2b00      	cmp	r3, #0
 80018d0:	d1eb      	bne.n	80018aa <xTaskResumeAll+0xd2>
					/* As we have processed some ticks it is appropriate to yield
					to ensure the highest priority task that is ready to run is
					the task actually running. */
					#if configUSE_PREEMPTION == 1
					{
						xYieldRequired = pdTRUE;
 80018d2:	2301      	movs	r3, #1
 80018d4:	603b      	str	r3, [r7, #0]
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
 80018d6:	683b      	ldr	r3, [r7, #0]
 80018d8:	2b01      	cmp	r3, #1
 80018da:	d006      	beq.n	80018ea <xTaskResumeAll+0x112>
 80018dc:	f640 23bc 	movw	r3, #2748	; 0xabc
 80018e0:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80018e4:	681b      	ldr	r3, [r3, #0]
 80018e6:	2b01      	cmp	r3, #1
 80018e8:	d109      	bne.n	80018fe <xTaskResumeAll+0x126>
				{
					xAlreadyYielded = pdTRUE;
 80018ea:	2301      	movs	r3, #1
 80018ec:	607b      	str	r3, [r7, #4]
					xMissedYield = pdFALSE;
 80018ee:	f640 23bc 	movw	r3, #2748	; 0xabc
 80018f2:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80018f6:	2200      	movs	r2, #0
 80018f8:	601a      	str	r2, [r3, #0]
					portYIELD_WITHIN_API();
 80018fa:	f001 f81f 	bl	800293c <vPortYieldFromISR>
				}
			}
		}
	}
	taskEXIT_CRITICAL();
 80018fe:	f001 f841 	bl	8002984 <vPortExitCritical>

	return xAlreadyYielded;
 8001902:	687b      	ldr	r3, [r7, #4]
}
 8001904:	4618      	mov	r0, r3
 8001906:	370c      	adds	r7, #12
 8001908:	46bd      	mov	sp, r7
 800190a:	bd90      	pop	{r4, r7, pc}

0800190c <vTaskIncrementTick>:
 * SCHEDULER INTERNALS AVAILABLE FOR PORTING PURPOSES
 * documented in task.h
 *----------------------------------------------------------*/

void vTaskIncrementTick( void )
{
 800190c:	b580      	push	{r7, lr}
 800190e:	b084      	sub	sp, #16
 8001910:	af00      	add	r7, sp, #0
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
 8001912:	f640 23b4 	movw	r3, #2740	; 0xab4
 8001916:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800191a:	681b      	ldr	r3, [r3, #0]
 800191c:	2b00      	cmp	r3, #0
 800191e:	f040 80b9 	bne.w	8001a94 <vTaskIncrementTick+0x188>
	{
		++xTickCount;
 8001922:	f640 23a4 	movw	r3, #2724	; 0xaa4
 8001926:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800192a:	681b      	ldr	r3, [r3, #0]
 800192c:	1c5a      	adds	r2, r3, #1
 800192e:	f640 23a4 	movw	r3, #2724	; 0xaa4
 8001932:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001936:	601a      	str	r2, [r3, #0]
		if( xTickCount == ( portTickType ) 0U )
 8001938:	f640 23a4 	movw	r3, #2724	; 0xaa4
 800193c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001940:	681b      	ldr	r3, [r3, #0]
 8001942:	2b00      	cmp	r3, #0
 8001944:	d13f      	bne.n	80019c6 <vTaskIncrementTick+0xba>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );
			
			pxTemp = pxDelayedTaskList;
 8001946:	f640 2354 	movw	r3, #2644	; 0xa54
 800194a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800194e:	681b      	ldr	r3, [r3, #0]
 8001950:	60fb      	str	r3, [r7, #12]
			pxDelayedTaskList = pxOverflowDelayedTaskList;
 8001952:	f640 2358 	movw	r3, #2648	; 0xa58
 8001956:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800195a:	681a      	ldr	r2, [r3, #0]
 800195c:	f640 2354 	movw	r3, #2644	; 0xa54
 8001960:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001964:	601a      	str	r2, [r3, #0]
			pxOverflowDelayedTaskList = pxTemp;
 8001966:	f640 2358 	movw	r3, #2648	; 0xa58
 800196a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800196e:	68fa      	ldr	r2, [r7, #12]
 8001970:	601a      	str	r2, [r3, #0]
			xNumOfOverflows++;
 8001972:	f640 23c0 	movw	r3, #2752	; 0xac0
 8001976:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800197a:	681b      	ldr	r3, [r3, #0]
 800197c:	1c5a      	adds	r2, r3, #1
 800197e:	f640 23c0 	movw	r3, #2752	; 0xac0
 8001982:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001986:	601a      	str	r2, [r3, #0]
	
			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 8001988:	f640 2354 	movw	r3, #2644	; 0xa54
 800198c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001990:	681b      	ldr	r3, [r3, #0]
 8001992:	681b      	ldr	r3, [r3, #0]
 8001994:	2b00      	cmp	r3, #0
 8001996:	d107      	bne.n	80019a8 <vTaskIncrementTick+0x9c>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the	
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
 8001998:	f240 032c 	movw	r3, #44	; 0x2c
 800199c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80019a0:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 80019a4:	601a      	str	r2, [r3, #0]
 80019a6:	e00e      	b.n	80019c6 <vTaskIncrementTick+0xba>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
 80019a8:	f640 2354 	movw	r3, #2644	; 0xa54
 80019ac:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80019b0:	681b      	ldr	r3, [r3, #0]
 80019b2:	68db      	ldr	r3, [r3, #12]
 80019b4:	68db      	ldr	r3, [r3, #12]
 80019b6:	60bb      	str	r3, [r7, #8]
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
 80019b8:	68bb      	ldr	r3, [r7, #8]
 80019ba:	685a      	ldr	r2, [r3, #4]
 80019bc:	f240 032c 	movw	r3, #44	; 0x2c
 80019c0:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80019c4:	601a      	str	r2, [r3, #0]
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
 80019c6:	f640 23a4 	movw	r3, #2724	; 0xaa4
 80019ca:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80019ce:	681a      	ldr	r2, [r3, #0]
 80019d0:	f240 032c 	movw	r3, #44	; 0x2c
 80019d4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80019d8:	681b      	ldr	r3, [r3, #0]
 80019da:	429a      	cmp	r2, r3
 80019dc:	d359      	bcc.n	8001a92 <vTaskIncrementTick+0x186>
 80019de:	f640 2354 	movw	r3, #2644	; 0xa54
 80019e2:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80019e6:	681b      	ldr	r3, [r3, #0]
 80019e8:	681b      	ldr	r3, [r3, #0]
 80019ea:	2b00      	cmp	r3, #0
 80019ec:	d107      	bne.n	80019fe <vTaskIncrementTick+0xf2>
 80019ee:	f240 032c 	movw	r3, #44	; 0x2c
 80019f2:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80019f6:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 80019fa:	601a      	str	r2, [r3, #0]
 80019fc:	e049      	b.n	8001a92 <vTaskIncrementTick+0x186>
 80019fe:	f640 2354 	movw	r3, #2644	; 0xa54
 8001a02:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001a06:	681b      	ldr	r3, [r3, #0]
 8001a08:	68db      	ldr	r3, [r3, #12]
 8001a0a:	68db      	ldr	r3, [r3, #12]
 8001a0c:	60bb      	str	r3, [r7, #8]
 8001a0e:	68bb      	ldr	r3, [r7, #8]
 8001a10:	685b      	ldr	r3, [r3, #4]
 8001a12:	607b      	str	r3, [r7, #4]
 8001a14:	f640 23a4 	movw	r3, #2724	; 0xaa4
 8001a18:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001a1c:	681a      	ldr	r2, [r3, #0]
 8001a1e:	687b      	ldr	r3, [r7, #4]
 8001a20:	429a      	cmp	r2, r3
 8001a22:	d206      	bcs.n	8001a32 <vTaskIncrementTick+0x126>
 8001a24:	f240 032c 	movw	r3, #44	; 0x2c
 8001a28:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001a2c:	687a      	ldr	r2, [r7, #4]
 8001a2e:	601a      	str	r2, [r3, #0]
 8001a30:	e02f      	b.n	8001a92 <vTaskIncrementTick+0x186>
 8001a32:	68bb      	ldr	r3, [r7, #8]
 8001a34:	3304      	adds	r3, #4
 8001a36:	4618      	mov	r0, r3
 8001a38:	f000 feda 	bl	80027f0 <vListRemove>
 8001a3c:	68bb      	ldr	r3, [r7, #8]
 8001a3e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8001a40:	2b00      	cmp	r3, #0
 8001a42:	d004      	beq.n	8001a4e <vTaskIncrementTick+0x142>
 8001a44:	68bb      	ldr	r3, [r7, #8]
 8001a46:	3318      	adds	r3, #24
 8001a48:	4618      	mov	r0, r3
 8001a4a:	f000 fed1 	bl	80027f0 <vListRemove>
 8001a4e:	68bb      	ldr	r3, [r7, #8]
 8001a50:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8001a52:	f640 23ac 	movw	r3, #2732	; 0xaac
 8001a56:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001a5a:	681b      	ldr	r3, [r3, #0]
 8001a5c:	429a      	cmp	r2, r3
 8001a5e:	d906      	bls.n	8001a6e <vTaskIncrementTick+0x162>
 8001a60:	68bb      	ldr	r3, [r7, #8]
 8001a62:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8001a64:	f640 23ac 	movw	r3, #2732	; 0xaac
 8001a68:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001a6c:	601a      	str	r2, [r3, #0]
 8001a6e:	68bb      	ldr	r3, [r7, #8]
 8001a70:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8001a72:	4613      	mov	r3, r2
 8001a74:	009b      	lsls	r3, r3, #2
 8001a76:	4413      	add	r3, r2
 8001a78:	009b      	lsls	r3, r3, #2
 8001a7a:	f640 12c8 	movw	r2, #2504	; 0x9c8
 8001a7e:	f2c2 0200 	movt	r2, #8192	; 0x2000
 8001a82:	441a      	add	r2, r3
 8001a84:	68bb      	ldr	r3, [r7, #8]
 8001a86:	3304      	adds	r3, #4
 8001a88:	4610      	mov	r0, r2
 8001a8a:	4619      	mov	r1, r3
 8001a8c:	f000 fe50 	bl	8002730 <vListInsertEnd>
 8001a90:	e7a5      	b.n	80019de <vTaskIncrementTick+0xd2>
 8001a92:	e00a      	b.n	8001aaa <vTaskIncrementTick+0x19e>
	}
	else
	{
		++uxMissedTicks;
 8001a94:	f640 23b8 	movw	r3, #2744	; 0xab8
 8001a98:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001a9c:	681b      	ldr	r3, [r3, #0]
 8001a9e:	1c5a      	adds	r2, r3, #1
 8001aa0:	f640 23b8 	movw	r3, #2744	; 0xab8
 8001aa4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001aa8:	601a      	str	r2, [r3, #0]
		}
	}
	#endif

	traceTASK_INCREMENT_TICK( xTickCount );
}
 8001aaa:	3710      	adds	r7, #16
 8001aac:	46bd      	mov	sp, r7
 8001aae:	bd80      	pop	{r7, pc}

08001ab0 <vTaskSwitchContext>:

#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
 8001ab0:	b580      	push	{r7, lr}
 8001ab2:	b082      	sub	sp, #8
 8001ab4:	af00      	add	r7, sp, #0
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
 8001ab6:	f640 23b4 	movw	r3, #2740	; 0xab4
 8001aba:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001abe:	681b      	ldr	r3, [r3, #0]
 8001ac0:	2b00      	cmp	r3, #0
 8001ac2:	d006      	beq.n	8001ad2 <vTaskSwitchContext+0x22>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
 8001ac4:	f640 23bc 	movw	r3, #2748	; 0xabc
 8001ac8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001acc:	2201      	movs	r2, #1
 8001ace:	601a      	str	r2, [r3, #0]
 8001ad0:	e069      	b.n	8001ba6 <vTaskSwitchContext+0xf6>
			unsigned long ulTempCounter;
			
				#ifdef portALT_GET_RUN_TIME_COUNTER_VALUE
					portALT_GET_RUN_TIME_COUNTER_VALUE( ulTempCounter );
				#else
					ulTempCounter = portGET_RUN_TIME_COUNTER_VALUE();
 8001ad2:	f7fe fd29 	bl	8000528 <get_us_time>
 8001ad6:	4602      	mov	r2, r0
 8001ad8:	460b      	mov	r3, r1
 8001ada:	4613      	mov	r3, r2
 8001adc:	607b      	str	r3, [r7, #4]
				/* Add the amount of time the task has been running to the accumulated
				time so far.  The time the task started running was stored in
				ulTaskSwitchedInTime.  Note that there is no overflow protection here
				so count values are only valid until the timer overflows.  Generally
				this will be about 1 hour assuming a 1uS timer increment. */
				pxCurrentTCB->ulRunTimeCounter += ( ulTempCounter - ulTaskSwitchedInTime );
 8001ade:	f640 13c4 	movw	r3, #2500	; 0x9c4
 8001ae2:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001ae6:	681a      	ldr	r2, [r3, #0]
 8001ae8:	6cd1      	ldr	r1, [r2, #76]	; 0x4c
 8001aea:	f640 23c8 	movw	r3, #2760	; 0xac8
 8001aee:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001af2:	681b      	ldr	r3, [r3, #0]
 8001af4:	6878      	ldr	r0, [r7, #4]
 8001af6:	1ac3      	subs	r3, r0, r3
 8001af8:	440b      	add	r3, r1
 8001afa:	64d3      	str	r3, [r2, #76]	; 0x4c
				ulTaskSwitchedInTime = ulTempCounter;
 8001afc:	f640 23c8 	movw	r3, #2760	; 0xac8
 8001b00:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001b04:	687a      	ldr	r2, [r7, #4]
 8001b06:	601a      	str	r2, [r3, #0]
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
 8001b08:	e00a      	b.n	8001b20 <vTaskSwitchContext+0x70>
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
 8001b0a:	f640 23ac 	movw	r3, #2732	; 0xaac
 8001b0e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001b12:	681b      	ldr	r3, [r3, #0]
 8001b14:	1e5a      	subs	r2, r3, #1
 8001b16:	f640 23ac 	movw	r3, #2732	; 0xaac
 8001b1a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001b1e:	601a      	str	r2, [r3, #0]
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
 8001b20:	f640 23ac 	movw	r3, #2732	; 0xaac
 8001b24:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001b28:	6819      	ldr	r1, [r3, #0]
 8001b2a:	f640 12c8 	movw	r2, #2504	; 0x9c8
 8001b2e:	f2c2 0200 	movt	r2, #8192	; 0x2000
 8001b32:	460b      	mov	r3, r1
 8001b34:	009b      	lsls	r3, r3, #2
 8001b36:	440b      	add	r3, r1
 8001b38:	009b      	lsls	r3, r3, #2
 8001b3a:	4413      	add	r3, r2
 8001b3c:	681b      	ldr	r3, [r3, #0]
 8001b3e:	2b00      	cmp	r3, #0
 8001b40:	d0e3      	beq.n	8001b0a <vTaskSwitchContext+0x5a>
			--uxTopReadyPriority;
		}
	
		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
 8001b42:	f640 23ac 	movw	r3, #2732	; 0xaac
 8001b46:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001b4a:	681a      	ldr	r2, [r3, #0]
 8001b4c:	4613      	mov	r3, r2
 8001b4e:	009b      	lsls	r3, r3, #2
 8001b50:	4413      	add	r3, r2
 8001b52:	009b      	lsls	r3, r3, #2
 8001b54:	f640 12c8 	movw	r2, #2504	; 0x9c8
 8001b58:	f2c2 0200 	movt	r2, #8192	; 0x2000
 8001b5c:	4413      	add	r3, r2
 8001b5e:	603b      	str	r3, [r7, #0]
 8001b60:	683b      	ldr	r3, [r7, #0]
 8001b62:	685b      	ldr	r3, [r3, #4]
 8001b64:	685a      	ldr	r2, [r3, #4]
 8001b66:	683b      	ldr	r3, [r7, #0]
 8001b68:	605a      	str	r2, [r3, #4]
 8001b6a:	683b      	ldr	r3, [r7, #0]
 8001b6c:	685a      	ldr	r2, [r3, #4]
 8001b6e:	683b      	ldr	r3, [r7, #0]
 8001b70:	3308      	adds	r3, #8
 8001b72:	429a      	cmp	r2, r3
 8001b74:	d104      	bne.n	8001b80 <vTaskSwitchContext+0xd0>
 8001b76:	683b      	ldr	r3, [r7, #0]
 8001b78:	685b      	ldr	r3, [r3, #4]
 8001b7a:	685a      	ldr	r2, [r3, #4]
 8001b7c:	683b      	ldr	r3, [r7, #0]
 8001b7e:	605a      	str	r2, [r3, #4]
 8001b80:	683b      	ldr	r3, [r7, #0]
 8001b82:	685b      	ldr	r3, [r3, #4]
 8001b84:	68da      	ldr	r2, [r3, #12]
 8001b86:	f640 13c4 	movw	r3, #2500	; 0x9c4
 8001b8a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001b8e:	601a      	str	r2, [r3, #0]
	
		traceTASK_SWITCHED_IN();
 8001b90:	f44f 43e8 	mov.w	r3, #29696	; 0x7400
 8001b94:	f2c4 0300 	movt	r3, #16384	; 0x4000
 8001b98:	f640 12c4 	movw	r2, #2500	; 0x9c4
 8001b9c:	f2c2 0200 	movt	r2, #8192	; 0x2000
 8001ba0:	6812      	ldr	r2, [r2, #0]
 8001ba2:	6c92      	ldr	r2, [r2, #72]	; 0x48
 8001ba4:	60da      	str	r2, [r3, #12]
		vWriteTraceToBuffer();
	}
}
 8001ba6:	3708      	adds	r7, #8
 8001ba8:	46bd      	mov	sp, r7
 8001baa:	bd80      	pop	{r7, pc}

08001bac <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
 8001bac:	b580      	push	{r7, lr}
 8001bae:	b084      	sub	sp, #16
 8001bb0:	af00      	add	r7, sp, #0
 8001bb2:	6078      	str	r0, [r7, #4]
 8001bb4:	6039      	str	r1, [r7, #0]
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
 8001bb6:	f640 13c4 	movw	r3, #2500	; 0x9c4
 8001bba:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001bbe:	681b      	ldr	r3, [r3, #0]
 8001bc0:	3318      	adds	r3, #24
 8001bc2:	6878      	ldr	r0, [r7, #4]
 8001bc4:	4619      	mov	r1, r3
 8001bc6:	f000 fddb 	bl	8002780 <vListInsert>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
 8001bca:	f640 13c4 	movw	r3, #2500	; 0x9c4
 8001bce:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001bd2:	681b      	ldr	r3, [r3, #0]
 8001bd4:	3304      	adds	r3, #4
 8001bd6:	4618      	mov	r0, r3
 8001bd8:	f000 fe0a 	bl	80027f0 <vListRemove>


	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( xTicksToWait == portMAX_DELAY )
 8001bdc:	683b      	ldr	r3, [r7, #0]
 8001bde:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 8001be2:	d10d      	bne.n	8001c00 <vTaskPlaceOnEventList+0x54>
		{
			/* Add ourselves to the suspended task list instead of a delayed task
			list to ensure we are not woken by a timing event.  We will block
			indefinitely. */
			vListInsertEnd( ( xList * ) &xSuspendedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
 8001be4:	f640 13c4 	movw	r3, #2500	; 0x9c4
 8001be8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001bec:	681b      	ldr	r3, [r3, #0]
 8001bee:	3304      	adds	r3, #4
 8001bf0:	f640 2088 	movw	r0, #2696	; 0xa88
 8001bf4:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8001bf8:	4619      	mov	r1, r3
 8001bfa:	f000 fd99 	bl	8002730 <vListInsertEnd>
 8001bfe:	e00a      	b.n	8001c16 <vTaskPlaceOnEventList+0x6a>
		}
		else
		{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
 8001c00:	f640 23a4 	movw	r3, #2724	; 0xaa4
 8001c04:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001c08:	681a      	ldr	r2, [r3, #0]
 8001c0a:	683b      	ldr	r3, [r7, #0]
 8001c0c:	4413      	add	r3, r2
 8001c0e:	60fb      	str	r3, [r7, #12]
			prvAddCurrentTaskToDelayedList( xTimeToWake );
 8001c10:	68f8      	ldr	r0, [r7, #12]
 8001c12:	f000 f9ad 	bl	8001f70 <prvAddCurrentTaskToDelayedList>
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
			prvAddCurrentTaskToDelayedList( xTimeToWake );
	}
	#endif
}
 8001c16:	3710      	adds	r7, #16
 8001c18:	46bd      	mov	sp, r7
 8001c1a:	bd80      	pop	{r7, pc}

08001c1c <xTaskRemoveFromEventList>:
	
#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
 8001c1c:	b580      	push	{r7, lr}
 8001c1e:	b084      	sub	sp, #16
 8001c20:	af00      	add	r7, sp, #0
 8001c22:	6078      	str	r0, [r7, #4]
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.
	
	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
 8001c24:	687b      	ldr	r3, [r7, #4]
 8001c26:	68db      	ldr	r3, [r3, #12]
 8001c28:	68db      	ldr	r3, [r3, #12]
 8001c2a:	60bb      	str	r3, [r7, #8]
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
 8001c2c:	68bb      	ldr	r3, [r7, #8]
 8001c2e:	3318      	adds	r3, #24
 8001c30:	4618      	mov	r0, r3
 8001c32:	f000 fddd 	bl	80027f0 <vListRemove>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
 8001c36:	f640 23b4 	movw	r3, #2740	; 0xab4
 8001c3a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001c3e:	681b      	ldr	r3, [r3, #0]
 8001c40:	2b00      	cmp	r3, #0
 8001c42:	d126      	bne.n	8001c92 <xTaskRemoveFromEventList+0x76>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
 8001c44:	68bb      	ldr	r3, [r7, #8]
 8001c46:	3304      	adds	r3, #4
 8001c48:	4618      	mov	r0, r3
 8001c4a:	f000 fdd1 	bl	80027f0 <vListRemove>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
 8001c4e:	68bb      	ldr	r3, [r7, #8]
 8001c50:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8001c52:	f640 23ac 	movw	r3, #2732	; 0xaac
 8001c56:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001c5a:	681b      	ldr	r3, [r3, #0]
 8001c5c:	429a      	cmp	r2, r3
 8001c5e:	d906      	bls.n	8001c6e <xTaskRemoveFromEventList+0x52>
 8001c60:	68bb      	ldr	r3, [r7, #8]
 8001c62:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8001c64:	f640 23ac 	movw	r3, #2732	; 0xaac
 8001c68:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001c6c:	601a      	str	r2, [r3, #0]
 8001c6e:	68bb      	ldr	r3, [r7, #8]
 8001c70:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8001c72:	4613      	mov	r3, r2
 8001c74:	009b      	lsls	r3, r3, #2
 8001c76:	4413      	add	r3, r2
 8001c78:	009b      	lsls	r3, r3, #2
 8001c7a:	f640 12c8 	movw	r2, #2504	; 0x9c8
 8001c7e:	f2c2 0200 	movt	r2, #8192	; 0x2000
 8001c82:	441a      	add	r2, r3
 8001c84:	68bb      	ldr	r3, [r7, #8]
 8001c86:	3304      	adds	r3, #4
 8001c88:	4610      	mov	r0, r2
 8001c8a:	4619      	mov	r1, r3
 8001c8c:	f000 fd50 	bl	8002730 <vListInsertEnd>
 8001c90:	e008      	b.n	8001ca4 <xTaskRemoveFromEventList+0x88>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
 8001c92:	68bb      	ldr	r3, [r7, #8]
 8001c94:	3318      	adds	r3, #24
 8001c96:	f640 205c 	movw	r0, #2652	; 0xa5c
 8001c9a:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8001c9e:	4619      	mov	r1, r3
 8001ca0:	f000 fd46 	bl	8002730 <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
 8001ca4:	68bb      	ldr	r3, [r7, #8]
 8001ca6:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8001ca8:	f640 13c4 	movw	r3, #2500	; 0x9c4
 8001cac:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001cb0:	681b      	ldr	r3, [r3, #0]
 8001cb2:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8001cb4:	429a      	cmp	r2, r3
 8001cb6:	d302      	bcc.n	8001cbe <xTaskRemoveFromEventList+0xa2>
	{
		/* Return true if the task removed from the event list has
		a higher priority than the calling task.  This allows
		the calling task to know if it should force a context
		switch now. */
		xReturn = pdTRUE;
 8001cb8:	2301      	movs	r3, #1
 8001cba:	60fb      	str	r3, [r7, #12]
 8001cbc:	e001      	b.n	8001cc2 <xTaskRemoveFromEventList+0xa6>
	}
	else
	{
		xReturn = pdFALSE;
 8001cbe:	2300      	movs	r3, #0
 8001cc0:	60fb      	str	r3, [r7, #12]
	}

	return xReturn;
 8001cc2:	68fb      	ldr	r3, [r7, #12]
}
 8001cc4:	4618      	mov	r0, r3
 8001cc6:	3710      	adds	r7, #16
 8001cc8:	46bd      	mov	sp, r7
 8001cca:	bd80      	pop	{r7, pc}

08001ccc <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
 8001ccc:	b480      	push	{r7}
 8001cce:	b083      	sub	sp, #12
 8001cd0:	af00      	add	r7, sp, #0
 8001cd2:	6078      	str	r0, [r7, #4]
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
 8001cd4:	f640 23c0 	movw	r3, #2752	; 0xac0
 8001cd8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001cdc:	681a      	ldr	r2, [r3, #0]
 8001cde:	687b      	ldr	r3, [r7, #4]
 8001ce0:	601a      	str	r2, [r3, #0]
	pxTimeOut->xTimeOnEntering = xTickCount;
 8001ce2:	f640 23a4 	movw	r3, #2724	; 0xaa4
 8001ce6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001cea:	681a      	ldr	r2, [r3, #0]
 8001cec:	687b      	ldr	r3, [r7, #4]
 8001cee:	605a      	str	r2, [r3, #4]
}
 8001cf0:	370c      	adds	r7, #12
 8001cf2:	46bd      	mov	sp, r7
 8001cf4:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001cf8:	4770      	bx	lr
 8001cfa:	bf00      	nop

08001cfc <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
 8001cfc:	b580      	push	{r7, lr}
 8001cfe:	b084      	sub	sp, #16
 8001d00:	af00      	add	r7, sp, #0
 8001d02:	6078      	str	r0, [r7, #4]
 8001d04:	6039      	str	r1, [r7, #0]
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
 8001d06:	f000 fe27 	bl	8002958 <vPortEnterCritical>
	{
		#if ( INCLUDE_vTaskSuspend == 1 )
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
 8001d0a:	683b      	ldr	r3, [r7, #0]
 8001d0c:	681b      	ldr	r3, [r3, #0]
 8001d0e:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 8001d12:	d102      	bne.n	8001d1a <xTaskCheckForTimeOut+0x1e>
			{
				xReturn = pdFALSE;
 8001d14:	2300      	movs	r3, #0
 8001d16:	60fb      	str	r3, [r7, #12]
 8001d18:	e035      	b.n	8001d86 <xTaskCheckForTimeOut+0x8a>
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
 8001d1a:	687b      	ldr	r3, [r7, #4]
 8001d1c:	681a      	ldr	r2, [r3, #0]
 8001d1e:	f640 23c0 	movw	r3, #2752	; 0xac0
 8001d22:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001d26:	681b      	ldr	r3, [r3, #0]
 8001d28:	429a      	cmp	r2, r3
 8001d2a:	d00b      	beq.n	8001d44 <xTaskCheckForTimeOut+0x48>
 8001d2c:	687b      	ldr	r3, [r7, #4]
 8001d2e:	685a      	ldr	r2, [r3, #4]
 8001d30:	f640 23a4 	movw	r3, #2724	; 0xaa4
 8001d34:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001d38:	681b      	ldr	r3, [r3, #0]
 8001d3a:	429a      	cmp	r2, r3
 8001d3c:	d802      	bhi.n	8001d44 <xTaskCheckForTimeOut+0x48>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
 8001d3e:	2301      	movs	r3, #1
 8001d40:	60fb      	str	r3, [r7, #12]
 8001d42:	e020      	b.n	8001d86 <xTaskCheckForTimeOut+0x8a>
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
 8001d44:	f640 23a4 	movw	r3, #2724	; 0xaa4
 8001d48:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001d4c:	681a      	ldr	r2, [r3, #0]
 8001d4e:	687b      	ldr	r3, [r7, #4]
 8001d50:	685b      	ldr	r3, [r3, #4]
 8001d52:	1ad2      	subs	r2, r2, r3
 8001d54:	683b      	ldr	r3, [r7, #0]
 8001d56:	681b      	ldr	r3, [r3, #0]
 8001d58:	429a      	cmp	r2, r3
 8001d5a:	d212      	bcs.n	8001d82 <xTaskCheckForTimeOut+0x86>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
 8001d5c:	683b      	ldr	r3, [r7, #0]
 8001d5e:	681a      	ldr	r2, [r3, #0]
 8001d60:	687b      	ldr	r3, [r7, #4]
 8001d62:	6859      	ldr	r1, [r3, #4]
 8001d64:	f640 23a4 	movw	r3, #2724	; 0xaa4
 8001d68:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001d6c:	681b      	ldr	r3, [r3, #0]
 8001d6e:	1acb      	subs	r3, r1, r3
 8001d70:	441a      	add	r2, r3
 8001d72:	683b      	ldr	r3, [r7, #0]
 8001d74:	601a      	str	r2, [r3, #0]
			vTaskSetTimeOutState( pxTimeOut );
 8001d76:	6878      	ldr	r0, [r7, #4]
 8001d78:	f7ff ffa8 	bl	8001ccc <vTaskSetTimeOutState>
			xReturn = pdFALSE;
 8001d7c:	2300      	movs	r3, #0
 8001d7e:	60fb      	str	r3, [r7, #12]
 8001d80:	e001      	b.n	8001d86 <xTaskCheckForTimeOut+0x8a>
		}
		else
		{
			xReturn = pdTRUE;
 8001d82:	2301      	movs	r3, #1
 8001d84:	60fb      	str	r3, [r7, #12]
		}
	}
	taskEXIT_CRITICAL();
 8001d86:	f000 fdfd 	bl	8002984 <vPortExitCritical>

	return xReturn;
 8001d8a:	68fb      	ldr	r3, [r7, #12]
}
 8001d8c:	4618      	mov	r0, r3
 8001d8e:	3710      	adds	r7, #16
 8001d90:	46bd      	mov	sp, r7
 8001d92:	bd80      	pop	{r7, pc}

08001d94 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
 8001d94:	b480      	push	{r7}
 8001d96:	af00      	add	r7, sp, #0
	xMissedYield = pdTRUE;
 8001d98:	f640 23bc 	movw	r3, #2748	; 0xabc
 8001d9c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001da0:	2201      	movs	r2, #1
 8001da2:	601a      	str	r2, [r3, #0]
}
 8001da4:	46bd      	mov	sp, r7
 8001da6:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001daa:	4770      	bx	lr

08001dac <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
 8001dac:	b580      	push	{r7, lr}
 8001dae:	b082      	sub	sp, #8
 8001db0:	af00      	add	r7, sp, #0
 8001db2:	6078      	str	r0, [r7, #4]
	( void ) pvParameters;

	for( ;; )
	{
		/* See if any tasks have been deleted. */
		prvCheckTasksWaitingTermination();
 8001db4:	f000 f894 	bl	8001ee0 <prvCheckTasksWaitingTermination>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
 8001db8:	f640 13c8 	movw	r3, #2504	; 0x9c8
 8001dbc:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001dc0:	681b      	ldr	r3, [r3, #0]
 8001dc2:	2b01      	cmp	r3, #1
 8001dc4:	d902      	bls.n	8001dcc <prvIdleTask+0x20>
			{
				taskYIELD();
 8001dc6:	f000 fdb9 	bl	800293c <vPortYieldFromISR>
			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
			CALL A FUNCTION THAT MIGHT BLOCK. */
			vApplicationIdleHook();
		}
		#endif
	}
 8001dca:	e7f3      	b.n	8001db4 <prvIdleTask+0x8>
 8001dcc:	e7f2      	b.n	8001db4 <prvIdleTask+0x8>
 8001dce:	bf00      	nop

08001dd0 <prvInitialiseTCBVariables>:
 *----------------------------------------------------------*/



static void prvInitialiseTCBVariables( tskTCB *pxTCB, const signed char * const pcName, unsigned portBASE_TYPE uxPriority, const xMemoryRegion * const xRegions, unsigned short usStackDepth )
{
 8001dd0:	b580      	push	{r7, lr}
 8001dd2:	b084      	sub	sp, #16
 8001dd4:	af00      	add	r7, sp, #0
 8001dd6:	60f8      	str	r0, [r7, #12]
 8001dd8:	60b9      	str	r1, [r7, #8]
 8001dda:	607a      	str	r2, [r7, #4]
 8001ddc:	603b      	str	r3, [r7, #0]
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
 8001dde:	68fb      	ldr	r3, [r7, #12]
 8001de0:	3334      	adds	r3, #52	; 0x34
 8001de2:	4618      	mov	r0, r3
 8001de4:	68b9      	ldr	r1, [r7, #8]
 8001de6:	2210      	movs	r2, #16
 8001de8:	f001 ffae 	bl	8003d48 <strncpy>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
 8001dec:	68fb      	ldr	r3, [r7, #12]
 8001dee:	2200      	movs	r2, #0
 8001df0:	f883 2043 	strb.w	r2, [r3, #67]	; 0x43

	/* This is used as an array index so must ensure it's not too large.  First
	remove the privilege bit if one is present. */
	if( uxPriority >= configMAX_PRIORITIES )
 8001df4:	687b      	ldr	r3, [r7, #4]
 8001df6:	2b04      	cmp	r3, #4
 8001df8:	d901      	bls.n	8001dfe <prvInitialiseTCBVariables+0x2e>
	{
		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
 8001dfa:	2304      	movs	r3, #4
 8001dfc:	607b      	str	r3, [r7, #4]
	}

	pxTCB->uxPriority = uxPriority;
 8001dfe:	68fb      	ldr	r3, [r7, #12]
 8001e00:	687a      	ldr	r2, [r7, #4]
 8001e02:	62da      	str	r2, [r3, #44]	; 0x2c
	#if ( configUSE_MUTEXES == 1 )
	{
		pxTCB->uxBasePriority = uxPriority;
 8001e04:	68fb      	ldr	r3, [r7, #12]
 8001e06:	687a      	ldr	r2, [r7, #4]
 8001e08:	645a      	str	r2, [r3, #68]	; 0x44
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
 8001e0a:	68fb      	ldr	r3, [r7, #12]
 8001e0c:	3304      	adds	r3, #4
 8001e0e:	4618      	mov	r0, r3
 8001e10:	f000 fc82 	bl	8002718 <vListInitialiseItem>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
 8001e14:	68fb      	ldr	r3, [r7, #12]
 8001e16:	3318      	adds	r3, #24
 8001e18:	4618      	mov	r0, r3
 8001e1a:	f000 fc7d 	bl	8002718 <vListInitialiseItem>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
 8001e1e:	68fb      	ldr	r3, [r7, #12]
 8001e20:	68fa      	ldr	r2, [r7, #12]
 8001e22:	611a      	str	r2, [r3, #16]

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
 8001e24:	687b      	ldr	r3, [r7, #4]
 8001e26:	f1c3 0205 	rsb	r2, r3, #5
 8001e2a:	68fb      	ldr	r3, [r7, #12]
 8001e2c:	619a      	str	r2, [r3, #24]
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
 8001e2e:	68fb      	ldr	r3, [r7, #12]
 8001e30:	68fa      	ldr	r2, [r7, #12]
 8001e32:	625a      	str	r2, [r3, #36]	; 0x24
	}
	#endif

	#if ( configUSE_APPLICATION_TASK_TAG == 1 )
	{
		pxTCB->pxTaskTag = NULL;
 8001e34:	68fb      	ldr	r3, [r7, #12]
 8001e36:	2200      	movs	r2, #0
 8001e38:	649a      	str	r2, [r3, #72]	; 0x48
	}
	#endif

	#if ( configGENERATE_RUN_TIME_STATS == 1 )
	{
		pxTCB->ulRunTimeCounter = 0UL;
 8001e3a:	68fb      	ldr	r3, [r7, #12]
 8001e3c:	2200      	movs	r2, #0
 8001e3e:	64da      	str	r2, [r3, #76]	; 0x4c
	{
		( void ) xRegions;
		( void ) usStackDepth;
	}
	#endif
}
 8001e40:	3710      	adds	r7, #16
 8001e42:	46bd      	mov	sp, r7
 8001e44:	bd80      	pop	{r7, pc}
 8001e46:	bf00      	nop

08001e48 <prvInitialiseTaskLists>:
	}
	/*-----------------------------------------------------------*/
#endif

static void prvInitialiseTaskLists( void )
{
 8001e48:	b580      	push	{r7, lr}
 8001e4a:	b082      	sub	sp, #8
 8001e4c:	af00      	add	r7, sp, #0
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
 8001e4e:	2300      	movs	r3, #0
 8001e50:	607b      	str	r3, [r7, #4]
 8001e52:	e00f      	b.n	8001e74 <prvInitialiseTaskLists+0x2c>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
 8001e54:	687a      	ldr	r2, [r7, #4]
 8001e56:	4613      	mov	r3, r2
 8001e58:	009b      	lsls	r3, r3, #2
 8001e5a:	4413      	add	r3, r2
 8001e5c:	009b      	lsls	r3, r3, #2
 8001e5e:	f640 12c8 	movw	r2, #2504	; 0x9c8
 8001e62:	f2c2 0200 	movt	r2, #8192	; 0x2000
 8001e66:	4413      	add	r3, r2
 8001e68:	4618      	mov	r0, r3
 8001e6a:	f000 fc35 	bl	80026d8 <vListInitialise>

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
 8001e6e:	687b      	ldr	r3, [r7, #4]
 8001e70:	3301      	adds	r3, #1
 8001e72:	607b      	str	r3, [r7, #4]
 8001e74:	687b      	ldr	r3, [r7, #4]
 8001e76:	2b04      	cmp	r3, #4
 8001e78:	d9ec      	bls.n	8001e54 <prvInitialiseTaskLists+0xc>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
 8001e7a:	f640 202c 	movw	r0, #2604	; 0xa2c
 8001e7e:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8001e82:	f000 fc29 	bl	80026d8 <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
 8001e86:	f640 2040 	movw	r0, #2624	; 0xa40
 8001e8a:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8001e8e:	f000 fc23 	bl	80026d8 <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyList );
 8001e92:	f640 205c 	movw	r0, #2652	; 0xa5c
 8001e96:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8001e9a:	f000 fc1d 	bl	80026d8 <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( ( xList * ) &xTasksWaitingTermination );
 8001e9e:	f640 2070 	movw	r0, #2672	; 0xa70
 8001ea2:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8001ea6:	f000 fc17 	bl	80026d8 <vListInitialise>
	}
	#endif

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( ( xList * ) &xSuspendedTaskList );
 8001eaa:	f640 2088 	movw	r0, #2696	; 0xa88
 8001eae:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8001eb2:	f000 fc11 	bl	80026d8 <vListInitialise>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
 8001eb6:	f640 2354 	movw	r3, #2644	; 0xa54
 8001eba:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001ebe:	f640 222c 	movw	r2, #2604	; 0xa2c
 8001ec2:	f2c2 0200 	movt	r2, #8192	; 0x2000
 8001ec6:	601a      	str	r2, [r3, #0]
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
 8001ec8:	f640 2358 	movw	r3, #2648	; 0xa58
 8001ecc:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001ed0:	f640 2240 	movw	r2, #2624	; 0xa40
 8001ed4:	f2c2 0200 	movt	r2, #8192	; 0x2000
 8001ed8:	601a      	str	r2, [r3, #0]
}
 8001eda:	3708      	adds	r7, #8
 8001edc:	46bd      	mov	sp, r7
 8001ede:	bd80      	pop	{r7, pc}

08001ee0 <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
 8001ee0:	b580      	push	{r7, lr}
 8001ee2:	b082      	sub	sp, #8
 8001ee4:	af00      	add	r7, sp, #0
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0U )
 8001ee6:	f640 2384 	movw	r3, #2692	; 0xa84
 8001eea:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001eee:	681b      	ldr	r3, [r3, #0]
 8001ef0:	2b00      	cmp	r3, #0
 8001ef2:	d03a      	beq.n	8001f6a <prvCheckTasksWaitingTermination+0x8a>
		{
			vTaskSuspendAll();
 8001ef4:	f7ff fc5e 	bl	80017b4 <vTaskSuspendAll>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
 8001ef8:	f640 2370 	movw	r3, #2672	; 0xa70
 8001efc:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001f00:	681b      	ldr	r3, [r3, #0]
 8001f02:	2b00      	cmp	r3, #0
 8001f04:	bf14      	ite	ne
 8001f06:	2300      	movne	r3, #0
 8001f08:	2301      	moveq	r3, #1
 8001f0a:	b2db      	uxtb	r3, r3
 8001f0c:	607b      	str	r3, [r7, #4]
			xTaskResumeAll();
 8001f0e:	f7ff fc63 	bl	80017d8 <xTaskResumeAll>

			if( xListIsEmpty == pdFALSE )
 8001f12:	687b      	ldr	r3, [r7, #4]
 8001f14:	2b00      	cmp	r3, #0
 8001f16:	d128      	bne.n	8001f6a <prvCheckTasksWaitingTermination+0x8a>
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
 8001f18:	f000 fd1e 	bl	8002958 <vPortEnterCritical>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
 8001f1c:	f640 2370 	movw	r3, #2672	; 0xa70
 8001f20:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001f24:	68db      	ldr	r3, [r3, #12]
 8001f26:	68db      	ldr	r3, [r3, #12]
 8001f28:	603b      	str	r3, [r7, #0]
					vListRemove( &( pxTCB->xGenericListItem ) );
 8001f2a:	683b      	ldr	r3, [r7, #0]
 8001f2c:	3304      	adds	r3, #4
 8001f2e:	4618      	mov	r0, r3
 8001f30:	f000 fc5e 	bl	80027f0 <vListRemove>
					--uxCurrentNumberOfTasks;
 8001f34:	f640 23a0 	movw	r3, #2720	; 0xaa0
 8001f38:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001f3c:	681b      	ldr	r3, [r3, #0]
 8001f3e:	1e5a      	subs	r2, r3, #1
 8001f40:	f640 23a0 	movw	r3, #2720	; 0xaa0
 8001f44:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001f48:	601a      	str	r2, [r3, #0]
					--uxTasksDeleted;
 8001f4a:	f640 2384 	movw	r3, #2692	; 0xa84
 8001f4e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001f52:	681b      	ldr	r3, [r3, #0]
 8001f54:	1e5a      	subs	r2, r3, #1
 8001f56:	f640 2384 	movw	r3, #2692	; 0xa84
 8001f5a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001f5e:	601a      	str	r2, [r3, #0]
				}
				taskEXIT_CRITICAL();
 8001f60:	f000 fd10 	bl	8002984 <vPortExitCritical>

				prvDeleteTCB( pxTCB );
 8001f64:	6838      	ldr	r0, [r7, #0]
 8001f66:	f000 f87b 	bl	8002060 <prvDeleteTCB>
			}
		}
	}
	#endif
}
 8001f6a:	3708      	adds	r7, #8
 8001f6c:	46bd      	mov	sp, r7
 8001f6e:	bd80      	pop	{r7, pc}

08001f70 <prvAddCurrentTaskToDelayedList>:
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
 8001f70:	b580      	push	{r7, lr}
 8001f72:	b082      	sub	sp, #8
 8001f74:	af00      	add	r7, sp, #0
 8001f76:	6078      	str	r0, [r7, #4]
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
 8001f78:	f640 13c4 	movw	r3, #2500	; 0x9c4
 8001f7c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001f80:	681b      	ldr	r3, [r3, #0]
 8001f82:	687a      	ldr	r2, [r7, #4]
 8001f84:	605a      	str	r2, [r3, #4]

	if( xTimeToWake < xTickCount )
 8001f86:	f640 23a4 	movw	r3, #2724	; 0xaa4
 8001f8a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001f8e:	681b      	ldr	r3, [r3, #0]
 8001f90:	687a      	ldr	r2, [r7, #4]
 8001f92:	429a      	cmp	r2, r3
 8001f94:	d20f      	bcs.n	8001fb6 <prvAddCurrentTaskToDelayedList+0x46>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
 8001f96:	f640 2358 	movw	r3, #2648	; 0xa58
 8001f9a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001f9e:	681a      	ldr	r2, [r3, #0]
 8001fa0:	f640 13c4 	movw	r3, #2500	; 0x9c4
 8001fa4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001fa8:	681b      	ldr	r3, [r3, #0]
 8001faa:	3304      	adds	r3, #4
 8001fac:	4610      	mov	r0, r2
 8001fae:	4619      	mov	r1, r3
 8001fb0:	f000 fbe6 	bl	8002780 <vListInsert>
 8001fb4:	e01c      	b.n	8001ff0 <prvAddCurrentTaskToDelayedList+0x80>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
 8001fb6:	f640 2354 	movw	r3, #2644	; 0xa54
 8001fba:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001fbe:	681a      	ldr	r2, [r3, #0]
 8001fc0:	f640 13c4 	movw	r3, #2500	; 0x9c4
 8001fc4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001fc8:	681b      	ldr	r3, [r3, #0]
 8001fca:	3304      	adds	r3, #4
 8001fcc:	4610      	mov	r0, r2
 8001fce:	4619      	mov	r1, r3
 8001fd0:	f000 fbd6 	bl	8002780 <vListInsert>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
 8001fd4:	f240 032c 	movw	r3, #44	; 0x2c
 8001fd8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001fdc:	681b      	ldr	r3, [r3, #0]
 8001fde:	687a      	ldr	r2, [r7, #4]
 8001fe0:	429a      	cmp	r2, r3
 8001fe2:	d205      	bcs.n	8001ff0 <prvAddCurrentTaskToDelayedList+0x80>
		{
			xNextTaskUnblockTime = xTimeToWake;
 8001fe4:	f240 032c 	movw	r3, #44	; 0x2c
 8001fe8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001fec:	687a      	ldr	r2, [r7, #4]
 8001fee:	601a      	str	r2, [r3, #0]
		}
	}
}
 8001ff0:	3708      	adds	r7, #8
 8001ff2:	46bd      	mov	sp, r7
 8001ff4:	bd80      	pop	{r7, pc}
 8001ff6:	bf00      	nop

08001ff8 <prvAllocateTCBAndStack>:
/*-----------------------------------------------------------*/

static tskTCB *prvAllocateTCBAndStack( unsigned short usStackDepth, portSTACK_TYPE *puxStackBuffer )
{
 8001ff8:	b580      	push	{r7, lr}
 8001ffa:	b084      	sub	sp, #16
 8001ffc:	af00      	add	r7, sp, #0
 8001ffe:	4603      	mov	r3, r0
 8002000:	6039      	str	r1, [r7, #0]
 8002002:	80fb      	strh	r3, [r7, #6]
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
 8002004:	2050      	movs	r0, #80	; 0x50
 8002006:	f001 fb93 	bl	8003730 <malloc>
 800200a:	4603      	mov	r3, r0
 800200c:	60fb      	str	r3, [r7, #12]

	if( pxNewTCB != NULL )
 800200e:	68fb      	ldr	r3, [r7, #12]
 8002010:	2b00      	cmp	r3, #0
 8002012:	d01f      	beq.n	8002054 <prvAllocateTCBAndStack+0x5c>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
 8002014:	683b      	ldr	r3, [r7, #0]
 8002016:	2b00      	cmp	r3, #0
 8002018:	d106      	bne.n	8002028 <prvAllocateTCBAndStack+0x30>
 800201a:	88fb      	ldrh	r3, [r7, #6]
 800201c:	009b      	lsls	r3, r3, #2
 800201e:	4618      	mov	r0, r3
 8002020:	f001 fb86 	bl	8003730 <malloc>
 8002024:	4603      	mov	r3, r0
 8002026:	e000      	b.n	800202a <prvAllocateTCBAndStack+0x32>
 8002028:	683b      	ldr	r3, [r7, #0]
 800202a:	68fa      	ldr	r2, [r7, #12]
 800202c:	6313      	str	r3, [r2, #48]	; 0x30

		if( pxNewTCB->pxStack == NULL )
 800202e:	68fb      	ldr	r3, [r7, #12]
 8002030:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8002032:	2b00      	cmp	r3, #0
 8002034:	d105      	bne.n	8002042 <prvAllocateTCBAndStack+0x4a>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
 8002036:	68f8      	ldr	r0, [r7, #12]
 8002038:	f001 fb82 	bl	8003740 <free>
			pxNewTCB = NULL;
 800203c:	2300      	movs	r3, #0
 800203e:	60fb      	str	r3, [r7, #12]
 8002040:	e008      	b.n	8002054 <prvAllocateTCBAndStack+0x5c>
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) usStackDepth * sizeof( portSTACK_TYPE ) );
 8002042:	68fb      	ldr	r3, [r7, #12]
 8002044:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8002046:	88fb      	ldrh	r3, [r7, #6]
 8002048:	009b      	lsls	r3, r3, #2
 800204a:	4610      	mov	r0, r2
 800204c:	21a5      	movs	r1, #165	; 0xa5
 800204e:	461a      	mov	r2, r3
 8002050:	f001 fe30 	bl	8003cb4 <memset>
		}
	}

	return pxNewTCB;
 8002054:	68fb      	ldr	r3, [r7, #12]
}
 8002056:	4618      	mov	r0, r3
 8002058:	3710      	adds	r7, #16
 800205a:	46bd      	mov	sp, r7
 800205c:	bd80      	pop	{r7, pc}
 800205e:	bf00      	nop

08002060 <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
 8002060:	b580      	push	{r7, lr}
 8002062:	b082      	sub	sp, #8
 8002064:	af00      	add	r7, sp, #0
 8002066:	6078      	str	r0, [r7, #4]
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
 8002068:	687b      	ldr	r3, [r7, #4]
 800206a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800206c:	4618      	mov	r0, r3
 800206e:	f001 fb67 	bl	8003740 <free>
		vPortFree( pxTCB );
 8002072:	6878      	ldr	r0, [r7, #4]
 8002074:	f001 fb64 	bl	8003740 <free>
	}
 8002078:	3708      	adds	r7, #8
 800207a:	46bd      	mov	sp, r7
 800207c:	bd80      	pop	{r7, pc}
 800207e:	bf00      	nop

08002080 <xTaskGetCurrentTaskHandle>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) )

	xTaskHandle xTaskGetCurrentTaskHandle( void )
	{
 8002080:	b480      	push	{r7}
 8002082:	b083      	sub	sp, #12
 8002084:	af00      	add	r7, sp, #0
	xTaskHandle xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
 8002086:	f640 13c4 	movw	r3, #2500	; 0x9c4
 800208a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800208e:	681b      	ldr	r3, [r3, #0]
 8002090:	607b      	str	r3, [r7, #4]

		return xReturn;
 8002092:	687b      	ldr	r3, [r7, #4]
	}
 8002094:	4618      	mov	r0, r3
 8002096:	370c      	adds	r7, #12
 8002098:	46bd      	mov	sp, r7
 800209a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800209e:	4770      	bx	lr

080020a0 <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( xTaskHandle * const pxMutexHolder )
	{
 80020a0:	b580      	push	{r7, lr}
 80020a2:	b084      	sub	sp, #16
 80020a4:	af00      	add	r7, sp, #0
 80020a6:	6078      	str	r0, [r7, #4]
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;
 80020a8:	687b      	ldr	r3, [r7, #4]
 80020aa:	60fb      	str	r3, [r7, #12]

		configASSERT( pxMutexHolder );

		if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
 80020ac:	68fb      	ldr	r3, [r7, #12]
 80020ae:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 80020b0:	f640 13c4 	movw	r3, #2500	; 0x9c4
 80020b4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80020b8:	681b      	ldr	r3, [r3, #0]
 80020ba:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80020bc:	429a      	cmp	r2, r3
 80020be:	d24f      	bcs.n	8002160 <vTaskPriorityInherit+0xc0>
		{
			/* Adjust the mutex holder state to account for its new priority. */
			listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxCurrentTCB->uxPriority );
 80020c0:	f640 13c4 	movw	r3, #2500	; 0x9c4
 80020c4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80020c8:	681b      	ldr	r3, [r3, #0]
 80020ca:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80020cc:	f1c3 0205 	rsb	r2, r3, #5
 80020d0:	68fb      	ldr	r3, [r7, #12]
 80020d2:	619a      	str	r2, [r3, #24]

			/* If the task being modified is in the ready state it will need to
			be moved in to a new list. */
			if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) != pdFALSE )
 80020d4:	68fb      	ldr	r3, [r7, #12]
 80020d6:	6959      	ldr	r1, [r3, #20]
 80020d8:	68fb      	ldr	r3, [r7, #12]
 80020da:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 80020dc:	4613      	mov	r3, r2
 80020de:	009b      	lsls	r3, r3, #2
 80020e0:	4413      	add	r3, r2
 80020e2:	009b      	lsls	r3, r3, #2
 80020e4:	f640 12c8 	movw	r2, #2504	; 0x9c8
 80020e8:	f2c2 0200 	movt	r2, #8192	; 0x2000
 80020ec:	4413      	add	r3, r2
 80020ee:	4299      	cmp	r1, r3
 80020f0:	d12e      	bne.n	8002150 <vTaskPriorityInherit+0xb0>
			{
				vListRemove( &( pxTCB->xGenericListItem ) );
 80020f2:	68fb      	ldr	r3, [r7, #12]
 80020f4:	3304      	adds	r3, #4
 80020f6:	4618      	mov	r0, r3
 80020f8:	f000 fb7a 	bl	80027f0 <vListRemove>

				/* Inherit the priority before being moved into the new list. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
 80020fc:	f640 13c4 	movw	r3, #2500	; 0x9c4
 8002100:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8002104:	681b      	ldr	r3, [r3, #0]
 8002106:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8002108:	68fb      	ldr	r3, [r7, #12]
 800210a:	62da      	str	r2, [r3, #44]	; 0x2c
				prvAddTaskToReadyQueue( pxTCB );
 800210c:	68fb      	ldr	r3, [r7, #12]
 800210e:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8002110:	f640 23ac 	movw	r3, #2732	; 0xaac
 8002114:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8002118:	681b      	ldr	r3, [r3, #0]
 800211a:	429a      	cmp	r2, r3
 800211c:	d906      	bls.n	800212c <vTaskPriorityInherit+0x8c>
 800211e:	68fb      	ldr	r3, [r7, #12]
 8002120:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8002122:	f640 23ac 	movw	r3, #2732	; 0xaac
 8002126:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800212a:	601a      	str	r2, [r3, #0]
 800212c:	68fb      	ldr	r3, [r7, #12]
 800212e:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8002130:	4613      	mov	r3, r2
 8002132:	009b      	lsls	r3, r3, #2
 8002134:	4413      	add	r3, r2
 8002136:	009b      	lsls	r3, r3, #2
 8002138:	f640 12c8 	movw	r2, #2504	; 0x9c8
 800213c:	f2c2 0200 	movt	r2, #8192	; 0x2000
 8002140:	441a      	add	r2, r3
 8002142:	68fb      	ldr	r3, [r7, #12]
 8002144:	3304      	adds	r3, #4
 8002146:	4610      	mov	r0, r2
 8002148:	4619      	mov	r1, r3
 800214a:	f000 faf1 	bl	8002730 <vListInsertEnd>
 800214e:	e007      	b.n	8002160 <vTaskPriorityInherit+0xc0>
			}
			else
			{
				/* Just inherit the priority. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
 8002150:	f640 13c4 	movw	r3, #2500	; 0x9c4
 8002154:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8002158:	681b      	ldr	r3, [r3, #0]
 800215a:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800215c:	68fb      	ldr	r3, [r7, #12]
 800215e:	62da      	str	r2, [r3, #44]	; 0x2c
			}
		}
	}
 8002160:	3710      	adds	r7, #16
 8002162:	46bd      	mov	sp, r7
 8002164:	bd80      	pop	{r7, pc}
 8002166:	bf00      	nop

08002168 <vTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
 8002168:	b580      	push	{r7, lr}
 800216a:	b084      	sub	sp, #16
 800216c:	af00      	add	r7, sp, #0
 800216e:	6078      	str	r0, [r7, #4]
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;
 8002170:	687b      	ldr	r3, [r7, #4]
 8002172:	60fb      	str	r3, [r7, #12]

		if( pxMutexHolder != NULL )
 8002174:	687b      	ldr	r3, [r7, #4]
 8002176:	2b00      	cmp	r3, #0
 8002178:	d035      	beq.n	80021e6 <vTaskPriorityDisinherit+0x7e>
		{
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
 800217a:	68fb      	ldr	r3, [r7, #12]
 800217c:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800217e:	68fb      	ldr	r3, [r7, #12]
 8002180:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8002182:	429a      	cmp	r2, r3
 8002184:	d02f      	beq.n	80021e6 <vTaskPriorityDisinherit+0x7e>
			{
				/* We must be the running task to be able to give the mutex back.
				Remove ourselves from the ready list we currently appear in. */
				vListRemove( &( pxTCB->xGenericListItem ) );
 8002186:	68fb      	ldr	r3, [r7, #12]
 8002188:	3304      	adds	r3, #4
 800218a:	4618      	mov	r0, r3
 800218c:	f000 fb30 	bl	80027f0 <vListRemove>

				/* Disinherit the priority before adding ourselves into the new
				ready list. */
				pxTCB->uxPriority = pxTCB->uxBasePriority;
 8002190:	68fb      	ldr	r3, [r7, #12]
 8002192:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 8002194:	68fb      	ldr	r3, [r7, #12]
 8002196:	62da      	str	r2, [r3, #44]	; 0x2c
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
 8002198:	68fb      	ldr	r3, [r7, #12]
 800219a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800219c:	f1c3 0205 	rsb	r2, r3, #5
 80021a0:	68fb      	ldr	r3, [r7, #12]
 80021a2:	619a      	str	r2, [r3, #24]
				prvAddTaskToReadyQueue( pxTCB );
 80021a4:	68fb      	ldr	r3, [r7, #12]
 80021a6:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 80021a8:	f640 23ac 	movw	r3, #2732	; 0xaac
 80021ac:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80021b0:	681b      	ldr	r3, [r3, #0]
 80021b2:	429a      	cmp	r2, r3
 80021b4:	d906      	bls.n	80021c4 <vTaskPriorityDisinherit+0x5c>
 80021b6:	68fb      	ldr	r3, [r7, #12]
 80021b8:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 80021ba:	f640 23ac 	movw	r3, #2732	; 0xaac
 80021be:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80021c2:	601a      	str	r2, [r3, #0]
 80021c4:	68fb      	ldr	r3, [r7, #12]
 80021c6:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 80021c8:	4613      	mov	r3, r2
 80021ca:	009b      	lsls	r3, r3, #2
 80021cc:	4413      	add	r3, r2
 80021ce:	009b      	lsls	r3, r3, #2
 80021d0:	f640 12c8 	movw	r2, #2504	; 0x9c8
 80021d4:	f2c2 0200 	movt	r2, #8192	; 0x2000
 80021d8:	441a      	add	r2, r3
 80021da:	68fb      	ldr	r3, [r7, #12]
 80021dc:	3304      	adds	r3, #4
 80021de:	4610      	mov	r0, r2
 80021e0:	4619      	mov	r1, r3
 80021e2:	f000 faa5 	bl	8002730 <vListInsertEnd>
			}
		}
	}
 80021e6:	3710      	adds	r7, #16
 80021e8:	46bd      	mov	sp, r7
 80021ea:	bd80      	pop	{r7, pc}

080021ec <xQueueCreateMutex>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	xQueueHandle xQueueCreateMutex( void )
	{
 80021ec:	b580      	push	{r7, lr}
 80021ee:	b082      	sub	sp, #8
 80021f0:	af00      	add	r7, sp, #0
	xQUEUE *pxNewQueue;

		/* Allocate the new queue structure. */
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
 80021f2:	204c      	movs	r0, #76	; 0x4c
 80021f4:	f001 fa9c 	bl	8003730 <malloc>
 80021f8:	4603      	mov	r3, r0
 80021fa:	607b      	str	r3, [r7, #4]
		if( pxNewQueue != NULL )
 80021fc:	687b      	ldr	r3, [r7, #4]
 80021fe:	2b00      	cmp	r3, #0
 8002200:	d02c      	beq.n	800225c <xQueueCreateMutex+0x70>
		{
			/* Information required for priority inheritance. */
			pxNewQueue->pxMutexHolder = NULL;
 8002202:	687b      	ldr	r3, [r7, #4]
 8002204:	2200      	movs	r2, #0
 8002206:	605a      	str	r2, [r3, #4]
			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
 8002208:	687b      	ldr	r3, [r7, #4]
 800220a:	2200      	movs	r2, #0
 800220c:	601a      	str	r2, [r3, #0]

			/* Queues used as a mutex no data is actually copied into or out
			of the queue. */
			pxNewQueue->pcWriteTo = NULL;
 800220e:	687b      	ldr	r3, [r7, #4]
 8002210:	2200      	movs	r2, #0
 8002212:	609a      	str	r2, [r3, #8]
			pxNewQueue->pcReadFrom = NULL;
 8002214:	687b      	ldr	r3, [r7, #4]
 8002216:	2200      	movs	r2, #0
 8002218:	60da      	str	r2, [r3, #12]

			/* Each mutex has a length of 1 (like a binary semaphore) and
			an item size of 0 as nothing is actually copied into or out
			of the mutex. */
			pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
 800221a:	687b      	ldr	r3, [r7, #4]
 800221c:	2200      	movs	r2, #0
 800221e:	639a      	str	r2, [r3, #56]	; 0x38
			pxNewQueue->uxLength = ( unsigned portBASE_TYPE ) 1U;
 8002220:	687b      	ldr	r3, [r7, #4]
 8002222:	2201      	movs	r2, #1
 8002224:	63da      	str	r2, [r3, #60]	; 0x3c
			pxNewQueue->uxItemSize = ( unsigned portBASE_TYPE ) 0U;
 8002226:	687b      	ldr	r3, [r7, #4]
 8002228:	2200      	movs	r2, #0
 800222a:	641a      	str	r2, [r3, #64]	; 0x40
			pxNewQueue->xRxLock = queueUNLOCKED;
 800222c:	687b      	ldr	r3, [r7, #4]
 800222e:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 8002232:	645a      	str	r2, [r3, #68]	; 0x44
			pxNewQueue->xTxLock = queueUNLOCKED;
 8002234:	687b      	ldr	r3, [r7, #4]
 8002236:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 800223a:	649a      	str	r2, [r3, #72]	; 0x48

			/* Ensure the event queues start with the correct state. */
			vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
 800223c:	687b      	ldr	r3, [r7, #4]
 800223e:	3310      	adds	r3, #16
 8002240:	4618      	mov	r0, r3
 8002242:	f000 fa49 	bl	80026d8 <vListInitialise>
			vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
 8002246:	687b      	ldr	r3, [r7, #4]
 8002248:	3324      	adds	r3, #36	; 0x24
 800224a:	4618      	mov	r0, r3
 800224c:	f000 fa44 	bl	80026d8 <vListInitialise>

			/* Start with the semaphore in the expected state. */
			xQueueGenericSend( pxNewQueue, NULL, ( portTickType ) 0U, queueSEND_TO_BACK );
 8002250:	6878      	ldr	r0, [r7, #4]
 8002252:	2100      	movs	r1, #0
 8002254:	2200      	movs	r2, #0
 8002256:	2300      	movs	r3, #0
 8002258:	f000 f806 	bl	8002268 <xQueueGenericSend>
		{
			traceCREATE_MUTEX_FAILED();
		}

		configASSERT( pxNewQueue );
		return pxNewQueue;
 800225c:	687b      	ldr	r3, [r7, #4]
	}
 800225e:	4618      	mov	r0, r3
 8002260:	3708      	adds	r7, #8
 8002262:	46bd      	mov	sp, r7
 8002264:	bd80      	pop	{r7, pc}
 8002266:	bf00      	nop

08002268 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
 8002268:	b580      	push	{r7, lr}
 800226a:	b088      	sub	sp, #32
 800226c:	af00      	add	r7, sp, #0
 800226e:	60f8      	str	r0, [r7, #12]
 8002270:	60b9      	str	r1, [r7, #8]
 8002272:	607a      	str	r2, [r7, #4]
 8002274:	603b      	str	r3, [r7, #0]
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
 8002276:	2300      	movs	r3, #0
 8002278:	61fb      	str	r3, [r7, #28]
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
 800227a:	f000 fb6d 	bl	8002958 <vPortEnterCritical>
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
 800227e:	68fb      	ldr	r3, [r7, #12]
 8002280:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 8002282:	68fb      	ldr	r3, [r7, #12]
 8002284:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8002286:	429a      	cmp	r2, r3
 8002288:	d216      	bcs.n	80022b8 <xQueueGenericSend+0x50>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 800228a:	68f8      	ldr	r0, [r7, #12]
 800228c:	68b9      	ldr	r1, [r7, #8]
 800228e:	683a      	ldr	r2, [r7, #0]
 8002290:	f000 f926 	bl	80024e0 <prvCopyDataToQueue>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 8002294:	68fb      	ldr	r3, [r7, #12]
 8002296:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8002298:	2b00      	cmp	r3, #0
 800229a:	d009      	beq.n	80022b0 <xQueueGenericSend+0x48>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
 800229c:	68fb      	ldr	r3, [r7, #12]
 800229e:	3324      	adds	r3, #36	; 0x24
 80022a0:	4618      	mov	r0, r3
 80022a2:	f7ff fcbb 	bl	8001c1c <xTaskRemoveFromEventList>
 80022a6:	4603      	mov	r3, r0
 80022a8:	2b01      	cmp	r3, #1
 80022aa:	d101      	bne.n	80022b0 <xQueueGenericSend+0x48>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
 80022ac:	f000 fb46 	bl	800293c <vPortYieldFromISR>
					}
				}

				taskEXIT_CRITICAL();
 80022b0:	f000 fb68 	bl	8002984 <vPortExitCritical>

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
 80022b4:	2301      	movs	r3, #1
 80022b6:	e059      	b.n	800236c <xQueueGenericSend+0x104>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
 80022b8:	687b      	ldr	r3, [r7, #4]
 80022ba:	2b00      	cmp	r3, #0
 80022bc:	d103      	bne.n	80022c6 <xQueueGenericSend+0x5e>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
 80022be:	f000 fb61 	bl	8002984 <vPortExitCritical>

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
 80022c2:	2300      	movs	r3, #0
 80022c4:	e052      	b.n	800236c <xQueueGenericSend+0x104>
				}
				else if( xEntryTimeSet == pdFALSE )
 80022c6:	69fb      	ldr	r3, [r7, #28]
 80022c8:	2b00      	cmp	r3, #0
 80022ca:	d106      	bne.n	80022da <xQueueGenericSend+0x72>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
 80022cc:	f107 0314 	add.w	r3, r7, #20
 80022d0:	4618      	mov	r0, r3
 80022d2:	f7ff fcfb 	bl	8001ccc <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
 80022d6:	2301      	movs	r3, #1
 80022d8:	61fb      	str	r3, [r7, #28]
				}
			}
		}
		taskEXIT_CRITICAL();
 80022da:	f000 fb53 	bl	8002984 <vPortExitCritical>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
 80022de:	f7ff fa69 	bl	80017b4 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
 80022e2:	f000 fb39 	bl	8002958 <vPortEnterCritical>
 80022e6:	68fb      	ldr	r3, [r7, #12]
 80022e8:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 80022ea:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 80022ee:	d102      	bne.n	80022f6 <xQueueGenericSend+0x8e>
 80022f0:	68fb      	ldr	r3, [r7, #12]
 80022f2:	2200      	movs	r2, #0
 80022f4:	645a      	str	r2, [r3, #68]	; 0x44
 80022f6:	68fb      	ldr	r3, [r7, #12]
 80022f8:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 80022fa:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 80022fe:	d102      	bne.n	8002306 <xQueueGenericSend+0x9e>
 8002300:	68fb      	ldr	r3, [r7, #12]
 8002302:	2200      	movs	r2, #0
 8002304:	649a      	str	r2, [r3, #72]	; 0x48
 8002306:	f000 fb3d 	bl	8002984 <vPortExitCritical>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 800230a:	f107 0214 	add.w	r2, r7, #20
 800230e:	1d3b      	adds	r3, r7, #4
 8002310:	4610      	mov	r0, r2
 8002312:	4619      	mov	r1, r3
 8002314:	f7ff fcf2 	bl	8001cfc <xTaskCheckForTimeOut>
 8002318:	4603      	mov	r3, r0
 800231a:	2b00      	cmp	r3, #0
 800231c:	d11e      	bne.n	800235c <xQueueGenericSend+0xf4>
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
 800231e:	68f8      	ldr	r0, [r7, #12]
 8002320:	f000 f9c2 	bl	80026a8 <prvIsQueueFull>
 8002324:	4603      	mov	r3, r0
 8002326:	2b00      	cmp	r3, #0
 8002328:	d012      	beq.n	8002350 <xQueueGenericSend+0xe8>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
 800232a:	68fb      	ldr	r3, [r7, #12]
 800232c:	f103 0210 	add.w	r2, r3, #16
 8002330:	687b      	ldr	r3, [r7, #4]
 8002332:	4610      	mov	r0, r2
 8002334:	4619      	mov	r1, r3
 8002336:	f7ff fc39 	bl	8001bac <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
 800233a:	68f8      	ldr	r0, [r7, #12]
 800233c:	f000 f952 	bl	80025e4 <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
 8002340:	f7ff fa4a 	bl	80017d8 <xTaskResumeAll>
 8002344:	4603      	mov	r3, r0
 8002346:	2b00      	cmp	r3, #0
 8002348:	d10f      	bne.n	800236a <xQueueGenericSend+0x102>
				{
					portYIELD_WITHIN_API();
 800234a:	f000 faf7 	bl	800293c <vPortYieldFromISR>
 800234e:	e00c      	b.n	800236a <xQueueGenericSend+0x102>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
 8002350:	68f8      	ldr	r0, [r7, #12]
 8002352:	f000 f947 	bl	80025e4 <prvUnlockQueue>
				( void ) xTaskResumeAll();
 8002356:	f7ff fa3f 	bl	80017d8 <xTaskResumeAll>
			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
 800235a:	e78e      	b.n	800227a <xQueueGenericSend+0x12>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
 800235c:	68f8      	ldr	r0, [r7, #12]
 800235e:	f000 f941 	bl	80025e4 <prvUnlockQueue>
			( void ) xTaskResumeAll();
 8002362:	f7ff fa39 	bl	80017d8 <xTaskResumeAll>

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
 8002366:	2300      	movs	r3, #0
 8002368:	e000      	b.n	800236c <xQueueGenericSend+0x104>
		}
	}
 800236a:	e786      	b.n	800227a <xQueueGenericSend+0x12>
}
 800236c:	4618      	mov	r0, r3
 800236e:	3720      	adds	r7, #32
 8002370:	46bd      	mov	sp, r7
 8002372:	bd80      	pop	{r7, pc}

08002374 <xQueueGenericReceive>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
 8002374:	b580      	push	{r7, lr}
 8002376:	b088      	sub	sp, #32
 8002378:	af00      	add	r7, sp, #0
 800237a:	60f8      	str	r0, [r7, #12]
 800237c:	60b9      	str	r1, [r7, #8]
 800237e:	607a      	str	r2, [r7, #4]
 8002380:	603b      	str	r3, [r7, #0]
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
 8002382:	2300      	movs	r3, #0
 8002384:	61fb      	str	r3, [r7, #28]
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
 8002386:	f000 fae7 	bl	8002958 <vPortEnterCritical>
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
 800238a:	68fb      	ldr	r3, [r7, #12]
 800238c:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800238e:	2b00      	cmp	r3, #0
 8002390:	d03b      	beq.n	800240a <xQueueGenericReceive+0x96>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
 8002392:	68fb      	ldr	r3, [r7, #12]
 8002394:	68db      	ldr	r3, [r3, #12]
 8002396:	61bb      	str	r3, [r7, #24]

				prvCopyDataFromQueue( pxQueue, pvBuffer );
 8002398:	68f8      	ldr	r0, [r7, #12]
 800239a:	68b9      	ldr	r1, [r7, #8]
 800239c:	f000 f8fc 	bl	8002598 <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
 80023a0:	683b      	ldr	r3, [r7, #0]
 80023a2:	2b00      	cmp	r3, #0
 80023a4:	d11c      	bne.n	80023e0 <xQueueGenericReceive+0x6c>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
 80023a6:	68fb      	ldr	r3, [r7, #12]
 80023a8:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 80023aa:	1e5a      	subs	r2, r3, #1
 80023ac:	68fb      	ldr	r3, [r7, #12]
 80023ae:	639a      	str	r2, [r3, #56]	; 0x38

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 80023b0:	68fb      	ldr	r3, [r7, #12]
 80023b2:	681b      	ldr	r3, [r3, #0]
 80023b4:	2b00      	cmp	r3, #0
 80023b6:	d104      	bne.n	80023c2 <xQueueGenericReceive+0x4e>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
 80023b8:	f7ff fe62 	bl	8002080 <xTaskGetCurrentTaskHandle>
 80023bc:	4602      	mov	r2, r0
 80023be:	68fb      	ldr	r3, [r7, #12]
 80023c0:	605a      	str	r2, [r3, #4]
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 80023c2:	68fb      	ldr	r3, [r7, #12]
 80023c4:	691b      	ldr	r3, [r3, #16]
 80023c6:	2b00      	cmp	r3, #0
 80023c8:	d01b      	beq.n	8002402 <xQueueGenericReceive+0x8e>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
 80023ca:	68fb      	ldr	r3, [r7, #12]
 80023cc:	3310      	adds	r3, #16
 80023ce:	4618      	mov	r0, r3
 80023d0:	f7ff fc24 	bl	8001c1c <xTaskRemoveFromEventList>
 80023d4:	4603      	mov	r3, r0
 80023d6:	2b01      	cmp	r3, #1
 80023d8:	d113      	bne.n	8002402 <xQueueGenericReceive+0x8e>
						{
							portYIELD_WITHIN_API();
 80023da:	f000 faaf 	bl	800293c <vPortYieldFromISR>
 80023de:	e010      	b.n	8002402 <xQueueGenericReceive+0x8e>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
 80023e0:	68fb      	ldr	r3, [r7, #12]
 80023e2:	69ba      	ldr	r2, [r7, #24]
 80023e4:	60da      	str	r2, [r3, #12]

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 80023e6:	68fb      	ldr	r3, [r7, #12]
 80023e8:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80023ea:	2b00      	cmp	r3, #0
 80023ec:	d009      	beq.n	8002402 <xQueueGenericReceive+0x8e>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 80023ee:	68fb      	ldr	r3, [r7, #12]
 80023f0:	3324      	adds	r3, #36	; 0x24
 80023f2:	4618      	mov	r0, r3
 80023f4:	f7ff fc12 	bl	8001c1c <xTaskRemoveFromEventList>
 80023f8:	4603      	mov	r3, r0
 80023fa:	2b00      	cmp	r3, #0
 80023fc:	d001      	beq.n	8002402 <xQueueGenericReceive+0x8e>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
 80023fe:	f000 fa9d 	bl	800293c <vPortYieldFromISR>
						}
					}

				}

				taskEXIT_CRITICAL();
 8002402:	f000 fabf 	bl	8002984 <vPortExitCritical>
				return pdPASS;
 8002406:	2301      	movs	r3, #1
 8002408:	e066      	b.n	80024d8 <xQueueGenericReceive+0x164>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
 800240a:	687b      	ldr	r3, [r7, #4]
 800240c:	2b00      	cmp	r3, #0
 800240e:	d103      	bne.n	8002418 <xQueueGenericReceive+0xa4>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
 8002410:	f000 fab8 	bl	8002984 <vPortExitCritical>
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
 8002414:	2300      	movs	r3, #0
 8002416:	e05f      	b.n	80024d8 <xQueueGenericReceive+0x164>
				}
				else if( xEntryTimeSet == pdFALSE )
 8002418:	69fb      	ldr	r3, [r7, #28]
 800241a:	2b00      	cmp	r3, #0
 800241c:	d106      	bne.n	800242c <xQueueGenericReceive+0xb8>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
 800241e:	f107 0310 	add.w	r3, r7, #16
 8002422:	4618      	mov	r0, r3
 8002424:	f7ff fc52 	bl	8001ccc <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
 8002428:	2301      	movs	r3, #1
 800242a:	61fb      	str	r3, [r7, #28]
				}
			}
		}
		taskEXIT_CRITICAL();
 800242c:	f000 faaa 	bl	8002984 <vPortExitCritical>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
 8002430:	f7ff f9c0 	bl	80017b4 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
 8002434:	f000 fa90 	bl	8002958 <vPortEnterCritical>
 8002438:	68fb      	ldr	r3, [r7, #12]
 800243a:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800243c:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 8002440:	d102      	bne.n	8002448 <xQueueGenericReceive+0xd4>
 8002442:	68fb      	ldr	r3, [r7, #12]
 8002444:	2200      	movs	r2, #0
 8002446:	645a      	str	r2, [r3, #68]	; 0x44
 8002448:	68fb      	ldr	r3, [r7, #12]
 800244a:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800244c:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 8002450:	d102      	bne.n	8002458 <xQueueGenericReceive+0xe4>
 8002452:	68fb      	ldr	r3, [r7, #12]
 8002454:	2200      	movs	r2, #0
 8002456:	649a      	str	r2, [r3, #72]	; 0x48
 8002458:	f000 fa94 	bl	8002984 <vPortExitCritical>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 800245c:	f107 0210 	add.w	r2, r7, #16
 8002460:	1d3b      	adds	r3, r7, #4
 8002462:	4610      	mov	r0, r2
 8002464:	4619      	mov	r1, r3
 8002466:	f7ff fc49 	bl	8001cfc <xTaskCheckForTimeOut>
 800246a:	4603      	mov	r3, r0
 800246c:	2b00      	cmp	r3, #0
 800246e:	d12b      	bne.n	80024c8 <xQueueGenericReceive+0x154>
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 8002470:	68f8      	ldr	r0, [r7, #12]
 8002472:	f000 f903 	bl	800267c <prvIsQueueEmpty>
 8002476:	4603      	mov	r3, r0
 8002478:	2b00      	cmp	r3, #0
 800247a:	d01f      	beq.n	80024bc <xQueueGenericReceive+0x148>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 800247c:	68fb      	ldr	r3, [r7, #12]
 800247e:	681b      	ldr	r3, [r3, #0]
 8002480:	2b00      	cmp	r3, #0
 8002482:	d108      	bne.n	8002496 <xQueueGenericReceive+0x122>
					{
						portENTER_CRITICAL();
 8002484:	f000 fa68 	bl	8002958 <vPortEnterCritical>
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
 8002488:	68fb      	ldr	r3, [r7, #12]
 800248a:	685b      	ldr	r3, [r3, #4]
 800248c:	4618      	mov	r0, r3
 800248e:	f7ff fe07 	bl	80020a0 <vTaskPriorityInherit>
						}
						portEXIT_CRITICAL();
 8002492:	f000 fa77 	bl	8002984 <vPortExitCritical>
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
 8002496:	68fb      	ldr	r3, [r7, #12]
 8002498:	f103 0224 	add.w	r2, r3, #36	; 0x24
 800249c:	687b      	ldr	r3, [r7, #4]
 800249e:	4610      	mov	r0, r2
 80024a0:	4619      	mov	r1, r3
 80024a2:	f7ff fb83 	bl	8001bac <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
 80024a6:	68f8      	ldr	r0, [r7, #12]
 80024a8:	f000 f89c 	bl	80025e4 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
 80024ac:	f7ff f994 	bl	80017d8 <xTaskResumeAll>
 80024b0:	4603      	mov	r3, r0
 80024b2:	2b00      	cmp	r3, #0
 80024b4:	d10f      	bne.n	80024d6 <xQueueGenericReceive+0x162>
				{
					portYIELD_WITHIN_API();
 80024b6:	f000 fa41 	bl	800293c <vPortYieldFromISR>
 80024ba:	e00c      	b.n	80024d6 <xQueueGenericReceive+0x162>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
 80024bc:	68f8      	ldr	r0, [r7, #12]
 80024be:	f000 f891 	bl	80025e4 <prvUnlockQueue>
				( void ) xTaskResumeAll();
 80024c2:	f7ff f989 	bl	80017d8 <xTaskResumeAll>
			prvUnlockQueue( pxQueue );
			( void ) xTaskResumeAll();
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
		}
	}
 80024c6:	e75e      	b.n	8002386 <xQueueGenericReceive+0x12>
				( void ) xTaskResumeAll();
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
 80024c8:	68f8      	ldr	r0, [r7, #12]
 80024ca:	f000 f88b 	bl	80025e4 <prvUnlockQueue>
			( void ) xTaskResumeAll();
 80024ce:	f7ff f983 	bl	80017d8 <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
 80024d2:	2300      	movs	r3, #0
 80024d4:	e000      	b.n	80024d8 <xQueueGenericReceive+0x164>
		}
	}
 80024d6:	e756      	b.n	8002386 <xQueueGenericReceive+0x12>
}
 80024d8:	4618      	mov	r0, r3
 80024da:	3720      	adds	r7, #32
 80024dc:	46bd      	mov	sp, r7
 80024de:	bd80      	pop	{r7, pc}

080024e0 <prvCopyDataToQueue>:
	vPortFree( pxQueue );
}
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
 80024e0:	b580      	push	{r7, lr}
 80024e2:	b084      	sub	sp, #16
 80024e4:	af00      	add	r7, sp, #0
 80024e6:	60f8      	str	r0, [r7, #12]
 80024e8:	60b9      	str	r1, [r7, #8]
 80024ea:	607a      	str	r2, [r7, #4]
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
 80024ec:	68fb      	ldr	r3, [r7, #12]
 80024ee:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 80024f0:	2b00      	cmp	r3, #0
 80024f2:	d10c      	bne.n	800250e <prvCopyDataToQueue+0x2e>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 80024f4:	68fb      	ldr	r3, [r7, #12]
 80024f6:	681b      	ldr	r3, [r3, #0]
 80024f8:	2b00      	cmp	r3, #0
 80024fa:	d145      	bne.n	8002588 <prvCopyDataToQueue+0xa8>
			{
				/* The mutex is no longer being held. */
				vTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
 80024fc:	68fb      	ldr	r3, [r7, #12]
 80024fe:	685b      	ldr	r3, [r3, #4]
 8002500:	4618      	mov	r0, r3
 8002502:	f7ff fe31 	bl	8002168 <vTaskPriorityDisinherit>
				pxQueue->pxMutexHolder = NULL;
 8002506:	68fb      	ldr	r3, [r7, #12]
 8002508:	2200      	movs	r2, #0
 800250a:	605a      	str	r2, [r3, #4]
 800250c:	e03c      	b.n	8002588 <prvCopyDataToQueue+0xa8>
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
 800250e:	687b      	ldr	r3, [r7, #4]
 8002510:	2b00      	cmp	r3, #0
 8002512:	d11a      	bne.n	800254a <prvCopyDataToQueue+0x6a>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
 8002514:	68fb      	ldr	r3, [r7, #12]
 8002516:	689a      	ldr	r2, [r3, #8]
 8002518:	68fb      	ldr	r3, [r7, #12]
 800251a:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800251c:	4610      	mov	r0, r2
 800251e:	68b9      	ldr	r1, [r7, #8]
 8002520:	461a      	mov	r2, r3
 8002522:	f7fd fe95 	bl	8000250 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
 8002526:	68fb      	ldr	r3, [r7, #12]
 8002528:	689a      	ldr	r2, [r3, #8]
 800252a:	68fb      	ldr	r3, [r7, #12]
 800252c:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800252e:	441a      	add	r2, r3
 8002530:	68fb      	ldr	r3, [r7, #12]
 8002532:	609a      	str	r2, [r3, #8]
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
 8002534:	68fb      	ldr	r3, [r7, #12]
 8002536:	689a      	ldr	r2, [r3, #8]
 8002538:	68fb      	ldr	r3, [r7, #12]
 800253a:	685b      	ldr	r3, [r3, #4]
 800253c:	429a      	cmp	r2, r3
 800253e:	d323      	bcc.n	8002588 <prvCopyDataToQueue+0xa8>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
 8002540:	68fb      	ldr	r3, [r7, #12]
 8002542:	681a      	ldr	r2, [r3, #0]
 8002544:	68fb      	ldr	r3, [r7, #12]
 8002546:	609a      	str	r2, [r3, #8]
 8002548:	e01e      	b.n	8002588 <prvCopyDataToQueue+0xa8>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
 800254a:	68fb      	ldr	r3, [r7, #12]
 800254c:	68da      	ldr	r2, [r3, #12]
 800254e:	68fb      	ldr	r3, [r7, #12]
 8002550:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8002552:	4610      	mov	r0, r2
 8002554:	68b9      	ldr	r1, [r7, #8]
 8002556:	461a      	mov	r2, r3
 8002558:	f7fd fe7a 	bl	8000250 <memcpy>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
 800255c:	68fb      	ldr	r3, [r7, #12]
 800255e:	68da      	ldr	r2, [r3, #12]
 8002560:	68fb      	ldr	r3, [r7, #12]
 8002562:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8002564:	425b      	negs	r3, r3
 8002566:	441a      	add	r2, r3
 8002568:	68fb      	ldr	r3, [r7, #12]
 800256a:	60da      	str	r2, [r3, #12]
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
 800256c:	68fb      	ldr	r3, [r7, #12]
 800256e:	68da      	ldr	r2, [r3, #12]
 8002570:	68fb      	ldr	r3, [r7, #12]
 8002572:	681b      	ldr	r3, [r3, #0]
 8002574:	429a      	cmp	r2, r3
 8002576:	d207      	bcs.n	8002588 <prvCopyDataToQueue+0xa8>
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
 8002578:	68fb      	ldr	r3, [r7, #12]
 800257a:	685a      	ldr	r2, [r3, #4]
 800257c:	68fb      	ldr	r3, [r7, #12]
 800257e:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8002580:	425b      	negs	r3, r3
 8002582:	441a      	add	r2, r3
 8002584:	68fb      	ldr	r3, [r7, #12]
 8002586:	60da      	str	r2, [r3, #12]
		}
	}

	++( pxQueue->uxMessagesWaiting );
 8002588:	68fb      	ldr	r3, [r7, #12]
 800258a:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800258c:	1c5a      	adds	r2, r3, #1
 800258e:	68fb      	ldr	r3, [r7, #12]
 8002590:	639a      	str	r2, [r3, #56]	; 0x38
}
 8002592:	3710      	adds	r7, #16
 8002594:	46bd      	mov	sp, r7
 8002596:	bd80      	pop	{r7, pc}

08002598 <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
 8002598:	b580      	push	{r7, lr}
 800259a:	b082      	sub	sp, #8
 800259c:	af00      	add	r7, sp, #0
 800259e:	6078      	str	r0, [r7, #4]
 80025a0:	6039      	str	r1, [r7, #0]
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
 80025a2:	687b      	ldr	r3, [r7, #4]
 80025a4:	681b      	ldr	r3, [r3, #0]
 80025a6:	2b00      	cmp	r3, #0
 80025a8:	d019      	beq.n	80025de <prvCopyDataFromQueue+0x46>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
 80025aa:	687b      	ldr	r3, [r7, #4]
 80025ac:	68da      	ldr	r2, [r3, #12]
 80025ae:	687b      	ldr	r3, [r7, #4]
 80025b0:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 80025b2:	441a      	add	r2, r3
 80025b4:	687b      	ldr	r3, [r7, #4]
 80025b6:	60da      	str	r2, [r3, #12]
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
 80025b8:	687b      	ldr	r3, [r7, #4]
 80025ba:	68da      	ldr	r2, [r3, #12]
 80025bc:	687b      	ldr	r3, [r7, #4]
 80025be:	685b      	ldr	r3, [r3, #4]
 80025c0:	429a      	cmp	r2, r3
 80025c2:	d303      	bcc.n	80025cc <prvCopyDataFromQueue+0x34>
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
 80025c4:	687b      	ldr	r3, [r7, #4]
 80025c6:	681a      	ldr	r2, [r3, #0]
 80025c8:	687b      	ldr	r3, [r7, #4]
 80025ca:	60da      	str	r2, [r3, #12]
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
 80025cc:	687b      	ldr	r3, [r7, #4]
 80025ce:	68da      	ldr	r2, [r3, #12]
 80025d0:	687b      	ldr	r3, [r7, #4]
 80025d2:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 80025d4:	6838      	ldr	r0, [r7, #0]
 80025d6:	4611      	mov	r1, r2
 80025d8:	461a      	mov	r2, r3
 80025da:	f7fd fe39 	bl	8000250 <memcpy>
	}
}
 80025de:	3708      	adds	r7, #8
 80025e0:	46bd      	mov	sp, r7
 80025e2:	bd80      	pop	{r7, pc}

080025e4 <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
 80025e4:	b580      	push	{r7, lr}
 80025e6:	b082      	sub	sp, #8
 80025e8:	af00      	add	r7, sp, #0
 80025ea:	6078      	str	r0, [r7, #4]

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
 80025ec:	f000 f9b4 	bl	8002958 <vPortEnterCritical>
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
 80025f0:	e014      	b.n	800261c <prvUnlockQueue+0x38>
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 80025f2:	687b      	ldr	r3, [r7, #4]
 80025f4:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80025f6:	2b00      	cmp	r3, #0
 80025f8:	d00f      	beq.n	800261a <prvUnlockQueue+0x36>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 80025fa:	687b      	ldr	r3, [r7, #4]
 80025fc:	3324      	adds	r3, #36	; 0x24
 80025fe:	4618      	mov	r0, r3
 8002600:	f7ff fb0c 	bl	8001c1c <xTaskRemoveFromEventList>
 8002604:	4603      	mov	r3, r0
 8002606:	2b00      	cmp	r3, #0
 8002608:	d001      	beq.n	800260e <prvUnlockQueue+0x2a>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
 800260a:	f7ff fbc3 	bl	8001d94 <vTaskMissedYield>
				}

				--( pxQueue->xTxLock );
 800260e:	687b      	ldr	r3, [r7, #4]
 8002610:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8002612:	1e5a      	subs	r2, r3, #1
 8002614:	687b      	ldr	r3, [r7, #4]
 8002616:	649a      	str	r2, [r3, #72]	; 0x48
 8002618:	e000      	b.n	800261c <prvUnlockQueue+0x38>
			}
			else
			{
				break;
 800261a:	e003      	b.n	8002624 <prvUnlockQueue+0x40>
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
 800261c:	687b      	ldr	r3, [r7, #4]
 800261e:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8002620:	2b00      	cmp	r3, #0
 8002622:	dce6      	bgt.n	80025f2 <prvUnlockQueue+0xe>
			{
				break;
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
 8002624:	687b      	ldr	r3, [r7, #4]
 8002626:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 800262a:	649a      	str	r2, [r3, #72]	; 0x48
	}
	taskEXIT_CRITICAL();
 800262c:	f000 f9aa 	bl	8002984 <vPortExitCritical>

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
 8002630:	f000 f992 	bl	8002958 <vPortEnterCritical>
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
 8002634:	e014      	b.n	8002660 <prvUnlockQueue+0x7c>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 8002636:	687b      	ldr	r3, [r7, #4]
 8002638:	691b      	ldr	r3, [r3, #16]
 800263a:	2b00      	cmp	r3, #0
 800263c:	d00f      	beq.n	800265e <prvUnlockQueue+0x7a>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 800263e:	687b      	ldr	r3, [r7, #4]
 8002640:	3310      	adds	r3, #16
 8002642:	4618      	mov	r0, r3
 8002644:	f7ff faea 	bl	8001c1c <xTaskRemoveFromEventList>
 8002648:	4603      	mov	r3, r0
 800264a:	2b00      	cmp	r3, #0
 800264c:	d001      	beq.n	8002652 <prvUnlockQueue+0x6e>
				{
					vTaskMissedYield();
 800264e:	f7ff fba1 	bl	8001d94 <vTaskMissedYield>
				}

				--( pxQueue->xRxLock );
 8002652:	687b      	ldr	r3, [r7, #4]
 8002654:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8002656:	1e5a      	subs	r2, r3, #1
 8002658:	687b      	ldr	r3, [r7, #4]
 800265a:	645a      	str	r2, [r3, #68]	; 0x44
 800265c:	e000      	b.n	8002660 <prvUnlockQueue+0x7c>
			}
			else
			{
				break;
 800265e:	e003      	b.n	8002668 <prvUnlockQueue+0x84>
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
 8002660:	687b      	ldr	r3, [r7, #4]
 8002662:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8002664:	2b00      	cmp	r3, #0
 8002666:	dce6      	bgt.n	8002636 <prvUnlockQueue+0x52>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
 8002668:	687b      	ldr	r3, [r7, #4]
 800266a:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 800266e:	645a      	str	r2, [r3, #68]	; 0x44
	}
	taskEXIT_CRITICAL();
 8002670:	f000 f988 	bl	8002984 <vPortExitCritical>
}
 8002674:	3708      	adds	r7, #8
 8002676:	46bd      	mov	sp, r7
 8002678:	bd80      	pop	{r7, pc}
 800267a:	bf00      	nop

0800267c <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
 800267c:	b580      	push	{r7, lr}
 800267e:	b084      	sub	sp, #16
 8002680:	af00      	add	r7, sp, #0
 8002682:	6078      	str	r0, [r7, #4]
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
 8002684:	f000 f968 	bl	8002958 <vPortEnterCritical>
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
 8002688:	687b      	ldr	r3, [r7, #4]
 800268a:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800268c:	2b00      	cmp	r3, #0
 800268e:	bf14      	ite	ne
 8002690:	2300      	movne	r3, #0
 8002692:	2301      	moveq	r3, #1
 8002694:	b2db      	uxtb	r3, r3
 8002696:	60fb      	str	r3, [r7, #12]
	taskEXIT_CRITICAL();
 8002698:	f000 f974 	bl	8002984 <vPortExitCritical>

	return xReturn;
 800269c:	68fb      	ldr	r3, [r7, #12]
}
 800269e:	4618      	mov	r0, r3
 80026a0:	3710      	adds	r7, #16
 80026a2:	46bd      	mov	sp, r7
 80026a4:	bd80      	pop	{r7, pc}
 80026a6:	bf00      	nop

080026a8 <prvIsQueueFull>:
	return xReturn;
}
/*-----------------------------------------------------------*/

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
 80026a8:	b580      	push	{r7, lr}
 80026aa:	b084      	sub	sp, #16
 80026ac:	af00      	add	r7, sp, #0
 80026ae:	6078      	str	r0, [r7, #4]
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
 80026b0:	f000 f952 	bl	8002958 <vPortEnterCritical>
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
 80026b4:	687b      	ldr	r3, [r7, #4]
 80026b6:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 80026b8:	687b      	ldr	r3, [r7, #4]
 80026ba:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 80026bc:	429a      	cmp	r2, r3
 80026be:	bf14      	ite	ne
 80026c0:	2300      	movne	r3, #0
 80026c2:	2301      	moveq	r3, #1
 80026c4:	b2db      	uxtb	r3, r3
 80026c6:	60fb      	str	r3, [r7, #12]
	taskEXIT_CRITICAL();
 80026c8:	f000 f95c 	bl	8002984 <vPortExitCritical>

	return xReturn;
 80026cc:	68fb      	ldr	r3, [r7, #12]
}
 80026ce:	4618      	mov	r0, r3
 80026d0:	3710      	adds	r7, #16
 80026d2:	46bd      	mov	sp, r7
 80026d4:	bd80      	pop	{r7, pc}
 80026d6:	bf00      	nop

080026d8 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
 80026d8:	b480      	push	{r7}
 80026da:	b083      	sub	sp, #12
 80026dc:	af00      	add	r7, sp, #0
 80026de:	6078      	str	r0, [r7, #4]
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
 80026e0:	687b      	ldr	r3, [r7, #4]
 80026e2:	f103 0208 	add.w	r2, r3, #8
 80026e6:	687b      	ldr	r3, [r7, #4]
 80026e8:	605a      	str	r2, [r3, #4]

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
 80026ea:	687b      	ldr	r3, [r7, #4]
 80026ec:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 80026f0:	609a      	str	r2, [r3, #8]

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
 80026f2:	687b      	ldr	r3, [r7, #4]
 80026f4:	f103 0208 	add.w	r2, r3, #8
 80026f8:	687b      	ldr	r3, [r7, #4]
 80026fa:	60da      	str	r2, [r3, #12]
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
 80026fc:	687b      	ldr	r3, [r7, #4]
 80026fe:	f103 0208 	add.w	r2, r3, #8
 8002702:	687b      	ldr	r3, [r7, #4]
 8002704:	611a      	str	r2, [r3, #16]

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
 8002706:	687b      	ldr	r3, [r7, #4]
 8002708:	2200      	movs	r2, #0
 800270a:	601a      	str	r2, [r3, #0]
}
 800270c:	370c      	adds	r7, #12
 800270e:	46bd      	mov	sp, r7
 8002710:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002714:	4770      	bx	lr
 8002716:	bf00      	nop

08002718 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
 8002718:	b480      	push	{r7}
 800271a:	b083      	sub	sp, #12
 800271c:	af00      	add	r7, sp, #0
 800271e:	6078      	str	r0, [r7, #4]
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
 8002720:	687b      	ldr	r3, [r7, #4]
 8002722:	2200      	movs	r2, #0
 8002724:	611a      	str	r2, [r3, #16]
}
 8002726:	370c      	adds	r7, #12
 8002728:	46bd      	mov	sp, r7
 800272a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800272e:	4770      	bx	lr

08002730 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
 8002730:	b480      	push	{r7}
 8002732:	b085      	sub	sp, #20
 8002734:	af00      	add	r7, sp, #0
 8002736:	6078      	str	r0, [r7, #4]
 8002738:	6039      	str	r1, [r7, #0]

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
 800273a:	687b      	ldr	r3, [r7, #4]
 800273c:	685b      	ldr	r3, [r3, #4]
 800273e:	60fb      	str	r3, [r7, #12]

	pxNewListItem->pxNext = pxIndex->pxNext;
 8002740:	68fb      	ldr	r3, [r7, #12]
 8002742:	685a      	ldr	r2, [r3, #4]
 8002744:	683b      	ldr	r3, [r7, #0]
 8002746:	605a      	str	r2, [r3, #4]
	pxNewListItem->pxPrevious = pxList->pxIndex;
 8002748:	687b      	ldr	r3, [r7, #4]
 800274a:	685a      	ldr	r2, [r3, #4]
 800274c:	683b      	ldr	r3, [r7, #0]
 800274e:	609a      	str	r2, [r3, #8]
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
 8002750:	68fb      	ldr	r3, [r7, #12]
 8002752:	685b      	ldr	r3, [r3, #4]
 8002754:	683a      	ldr	r2, [r7, #0]
 8002756:	609a      	str	r2, [r3, #8]
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
 8002758:	68fb      	ldr	r3, [r7, #12]
 800275a:	683a      	ldr	r2, [r7, #0]
 800275c:	605a      	str	r2, [r3, #4]
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
 800275e:	687b      	ldr	r3, [r7, #4]
 8002760:	683a      	ldr	r2, [r7, #0]
 8002762:	605a      	str	r2, [r3, #4]

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
 8002764:	683b      	ldr	r3, [r7, #0]
 8002766:	687a      	ldr	r2, [r7, #4]
 8002768:	611a      	str	r2, [r3, #16]

	( pxList->uxNumberOfItems )++;
 800276a:	687b      	ldr	r3, [r7, #4]
 800276c:	681b      	ldr	r3, [r3, #0]
 800276e:	1c5a      	adds	r2, r3, #1
 8002770:	687b      	ldr	r3, [r7, #4]
 8002772:	601a      	str	r2, [r3, #0]
}
 8002774:	3714      	adds	r7, #20
 8002776:	46bd      	mov	sp, r7
 8002778:	f85d 7b04 	ldr.w	r7, [sp], #4
 800277c:	4770      	bx	lr
 800277e:	bf00      	nop

08002780 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
 8002780:	b480      	push	{r7}
 8002782:	b085      	sub	sp, #20
 8002784:	af00      	add	r7, sp, #0
 8002786:	6078      	str	r0, [r7, #4]
 8002788:	6039      	str	r1, [r7, #0]
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
 800278a:	683b      	ldr	r3, [r7, #0]
 800278c:	681b      	ldr	r3, [r3, #0]
 800278e:	60bb      	str	r3, [r7, #8]
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
 8002790:	68bb      	ldr	r3, [r7, #8]
 8002792:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 8002796:	d103      	bne.n	80027a0 <vListInsert+0x20>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
 8002798:	687b      	ldr	r3, [r7, #4]
 800279a:	691b      	ldr	r3, [r3, #16]
 800279c:	60fb      	str	r3, [r7, #12]
 800279e:	e00c      	b.n	80027ba <vListInsert+0x3a>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/
		
		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
 80027a0:	687b      	ldr	r3, [r7, #4]
 80027a2:	3308      	adds	r3, #8
 80027a4:	60fb      	str	r3, [r7, #12]
 80027a6:	e002      	b.n	80027ae <vListInsert+0x2e>
 80027a8:	68fb      	ldr	r3, [r7, #12]
 80027aa:	685b      	ldr	r3, [r3, #4]
 80027ac:	60fb      	str	r3, [r7, #12]
 80027ae:	68fb      	ldr	r3, [r7, #12]
 80027b0:	685b      	ldr	r3, [r3, #4]
 80027b2:	681a      	ldr	r2, [r3, #0]
 80027b4:	68bb      	ldr	r3, [r7, #8]
 80027b6:	429a      	cmp	r2, r3
 80027b8:	d9f6      	bls.n	80027a8 <vListInsert+0x28>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
 80027ba:	68fb      	ldr	r3, [r7, #12]
 80027bc:	685a      	ldr	r2, [r3, #4]
 80027be:	683b      	ldr	r3, [r7, #0]
 80027c0:	605a      	str	r2, [r3, #4]
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
 80027c2:	683b      	ldr	r3, [r7, #0]
 80027c4:	685b      	ldr	r3, [r3, #4]
 80027c6:	683a      	ldr	r2, [r7, #0]
 80027c8:	609a      	str	r2, [r3, #8]
	pxNewListItem->pxPrevious = pxIterator;
 80027ca:	683b      	ldr	r3, [r7, #0]
 80027cc:	68fa      	ldr	r2, [r7, #12]
 80027ce:	609a      	str	r2, [r3, #8]
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
 80027d0:	68fb      	ldr	r3, [r7, #12]
 80027d2:	683a      	ldr	r2, [r7, #0]
 80027d4:	605a      	str	r2, [r3, #4]

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
 80027d6:	683b      	ldr	r3, [r7, #0]
 80027d8:	687a      	ldr	r2, [r7, #4]
 80027da:	611a      	str	r2, [r3, #16]

	( pxList->uxNumberOfItems )++;
 80027dc:	687b      	ldr	r3, [r7, #4]
 80027de:	681b      	ldr	r3, [r3, #0]
 80027e0:	1c5a      	adds	r2, r3, #1
 80027e2:	687b      	ldr	r3, [r7, #4]
 80027e4:	601a      	str	r2, [r3, #0]
}
 80027e6:	3714      	adds	r7, #20
 80027e8:	46bd      	mov	sp, r7
 80027ea:	f85d 7b04 	ldr.w	r7, [sp], #4
 80027ee:	4770      	bx	lr

080027f0 <vListRemove>:
/*-----------------------------------------------------------*/

void vListRemove( xListItem *pxItemToRemove )
{
 80027f0:	b480      	push	{r7}
 80027f2:	b085      	sub	sp, #20
 80027f4:	af00      	add	r7, sp, #0
 80027f6:	6078      	str	r0, [r7, #4]
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
 80027f8:	687b      	ldr	r3, [r7, #4]
 80027fa:	685b      	ldr	r3, [r3, #4]
 80027fc:	687a      	ldr	r2, [r7, #4]
 80027fe:	6892      	ldr	r2, [r2, #8]
 8002800:	609a      	str	r2, [r3, #8]
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
 8002802:	687b      	ldr	r3, [r7, #4]
 8002804:	689b      	ldr	r3, [r3, #8]
 8002806:	687a      	ldr	r2, [r7, #4]
 8002808:	6852      	ldr	r2, [r2, #4]
 800280a:	605a      	str	r2, [r3, #4]
	
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
 800280c:	687b      	ldr	r3, [r7, #4]
 800280e:	691b      	ldr	r3, [r3, #16]
 8002810:	60fb      	str	r3, [r7, #12]

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
 8002812:	68fb      	ldr	r3, [r7, #12]
 8002814:	685a      	ldr	r2, [r3, #4]
 8002816:	687b      	ldr	r3, [r7, #4]
 8002818:	429a      	cmp	r2, r3
 800281a:	d103      	bne.n	8002824 <vListRemove+0x34>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
 800281c:	687b      	ldr	r3, [r7, #4]
 800281e:	689a      	ldr	r2, [r3, #8]
 8002820:	68fb      	ldr	r3, [r7, #12]
 8002822:	605a      	str	r2, [r3, #4]
	}

	pxItemToRemove->pvContainer = NULL;
 8002824:	687b      	ldr	r3, [r7, #4]
 8002826:	2200      	movs	r2, #0
 8002828:	611a      	str	r2, [r3, #16]
	( pxList->uxNumberOfItems )--;
 800282a:	68fb      	ldr	r3, [r7, #12]
 800282c:	681b      	ldr	r3, [r3, #0]
 800282e:	1e5a      	subs	r2, r3, #1
 8002830:	68fb      	ldr	r3, [r7, #12]
 8002832:	601a      	str	r2, [r3, #0]
}
 8002834:	3714      	adds	r7, #20
 8002836:	46bd      	mov	sp, r7
 8002838:	f85d 7b04 	ldr.w	r7, [sp], #4
 800283c:	4770      	bx	lr
 800283e:	bf00      	nop

08002840 <pxPortInitialiseStack>:

/*
 * See header file for description.
 */
portSTACK_TYPE *pxPortInitialiseStack( portSTACK_TYPE *pxTopOfStack, pdTASK_CODE pxCode, void *pvParameters )
{
 8002840:	b480      	push	{r7}
 8002842:	b085      	sub	sp, #20
 8002844:	af00      	add	r7, sp, #0
 8002846:	60f8      	str	r0, [r7, #12]
 8002848:	60b9      	str	r1, [r7, #8]
 800284a:	607a      	str	r2, [r7, #4]
	/* Simulate the stack frame as it would be created by a context switch
	interrupt. */

	/* Offset added to account for the way the MCU uses the stack on entry/exit
	of interrupts, and to ensure alignment. */
	pxTopOfStack--;
 800284c:	68fb      	ldr	r3, [r7, #12]
 800284e:	3b04      	subs	r3, #4
 8002850:	60fb      	str	r3, [r7, #12]

	*pxTopOfStack = portINITIAL_XPSR;	/* xPSR */
 8002852:	68fb      	ldr	r3, [r7, #12]
 8002854:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
 8002858:	601a      	str	r2, [r3, #0]
	pxTopOfStack--;
 800285a:	68fb      	ldr	r3, [r7, #12]
 800285c:	3b04      	subs	r3, #4
 800285e:	60fb      	str	r3, [r7, #12]
	*pxTopOfStack = ( portSTACK_TYPE ) pxCode;	/* PC */
 8002860:	68ba      	ldr	r2, [r7, #8]
 8002862:	68fb      	ldr	r3, [r7, #12]
 8002864:	601a      	str	r2, [r3, #0]
	pxTopOfStack--;
 8002866:	68fb      	ldr	r3, [r7, #12]
 8002868:	3b04      	subs	r3, #4
 800286a:	60fb      	str	r3, [r7, #12]
	*pxTopOfStack = 0;	/* LR */
 800286c:	68fb      	ldr	r3, [r7, #12]
 800286e:	2200      	movs	r2, #0
 8002870:	601a      	str	r2, [r3, #0]

	/* Save code space by skipping register initialisation. */
	pxTopOfStack -= 5;	/* R12, R3, R2 and R1. */
 8002872:	68fb      	ldr	r3, [r7, #12]
 8002874:	3b14      	subs	r3, #20
 8002876:	60fb      	str	r3, [r7, #12]
	*pxTopOfStack = ( portSTACK_TYPE ) pvParameters;	/* R0 */
 8002878:	687a      	ldr	r2, [r7, #4]
 800287a:	68fb      	ldr	r3, [r7, #12]
 800287c:	601a      	str	r2, [r3, #0]

	/* A save method is being used that requires each task to maintain its
	own exec return value. */
	pxTopOfStack--;
 800287e:	68fb      	ldr	r3, [r7, #12]
 8002880:	3b04      	subs	r3, #4
 8002882:	60fb      	str	r3, [r7, #12]
	*pxTopOfStack = portINITIAL_EXEC_RETURN;
 8002884:	68fb      	ldr	r3, [r7, #12]
 8002886:	f06f 0202 	mvn.w	r2, #2
 800288a:	601a      	str	r2, [r3, #0]

	pxTopOfStack -= 8;	/* R11, R10, R9, R8, R7, R6, R5 and R4. */
 800288c:	68fb      	ldr	r3, [r7, #12]
 800288e:	3b20      	subs	r3, #32
 8002890:	60fb      	str	r3, [r7, #12]

	return pxTopOfStack;
 8002892:	68fb      	ldr	r3, [r7, #12]
}
 8002894:	4618      	mov	r0, r3
 8002896:	3714      	adds	r7, #20
 8002898:	46bd      	mov	sp, r7
 800289a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800289e:	4770      	bx	lr

080028a0 <SVC_Handler>:
/*-----------------------------------------------------------*/

void vPortSVCHandler( void )
{
	__asm volatile (
 80028a0:	4b05      	ldr	r3, [pc, #20]	; (80028b8 <pxCurrentTCBConst2>)
 80028a2:	6819      	ldr	r1, [r3, #0]
 80028a4:	6808      	ldr	r0, [r1, #0]
 80028a6:	e8b0 4ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80028aa:	f380 8809 	msr	PSP, r0
 80028ae:	f04f 0000 	mov.w	r0, #0
 80028b2:	f380 8811 	msr	BASEPRI, r0
 80028b6:	4770      	bx	lr

080028b8 <pxCurrentTCBConst2>:
 80028b8:	200009c4 	.word	0x200009c4

080028bc <vPortStartFirstTask>:
}
/*-----------------------------------------------------------*/

static void vPortStartFirstTask( void )
{
	__asm volatile(
 80028bc:	4803      	ldr	r0, [pc, #12]	; (80028cc <vPortStartFirstTask+0x10>)
 80028be:	6800      	ldr	r0, [r0, #0]
 80028c0:	6800      	ldr	r0, [r0, #0]
 80028c2:	f380 8808 	msr	MSP, r0
 80028c6:	b662      	cpsie	i
 80028c8:	df00      	svc	0
 80028ca:	bf00      	nop
 80028cc:	e000ed08 	.word	0xe000ed08

080028d0 <xPortStartScheduler>:

/*
 * See header file for description.
 */
portBASE_TYPE xPortStartScheduler( void )
{
 80028d0:	b580      	push	{r7, lr}
 80028d2:	af00      	add	r7, sp, #0
	/* Make PendSV and SysTick the lowest priority interrupts. */
	*(portNVIC_SYSPRI2) |= portNVIC_PENDSV_PRI;
 80028d4:	f64e 5320 	movw	r3, #60704	; 0xed20
 80028d8:	f2ce 0300 	movt	r3, #57344	; 0xe000
 80028dc:	f64e 5220 	movw	r2, #60704	; 0xed20
 80028e0:	f2ce 0200 	movt	r2, #57344	; 0xe000
 80028e4:	6812      	ldr	r2, [r2, #0]
 80028e6:	f442 027f 	orr.w	r2, r2, #16711680	; 0xff0000
 80028ea:	601a      	str	r2, [r3, #0]
	*(portNVIC_SYSPRI2) |= portNVIC_SYSTICK_PRI;
 80028ec:	f64e 5320 	movw	r3, #60704	; 0xed20
 80028f0:	f2ce 0300 	movt	r3, #57344	; 0xe000
 80028f4:	f64e 5220 	movw	r2, #60704	; 0xed20
 80028f8:	f2ce 0200 	movt	r2, #57344	; 0xe000
 80028fc:	6812      	ldr	r2, [r2, #0]
 80028fe:	f042 427f 	orr.w	r2, r2, #4278190080	; 0xff000000
 8002902:	601a      	str	r2, [r3, #0]

	/* Start the timer that generates the tick ISR.  Interrupts are disabled
	here already. */
	prvSetupTimerInterrupt();
 8002904:	f000 f89c 	bl	8002a40 <prvSetupTimerInterrupt>

	/* Initialise the critical nesting count ready for the first task. */
	uxCriticalNesting = 0;
 8002908:	f240 0330 	movw	r3, #48	; 0x30
 800290c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8002910:	2200      	movs	r2, #0
 8002912:	601a      	str	r2, [r3, #0]

	/* Ensure the VFP is enabled - it should be anyway. */
	vPortEnableVFP();
 8002914:	f000 f8b2 	bl	8002a7c <vPortEnableVFP>

	/* Lazy save always. */
	*( portFPCCR ) |= portASPEN_AND_LSPEN_BITS;
 8002918:	f64e 7334 	movw	r3, #61236	; 0xef34
 800291c:	f2ce 0300 	movt	r3, #57344	; 0xe000
 8002920:	f64e 7234 	movw	r2, #61236	; 0xef34
 8002924:	f2ce 0200 	movt	r2, #57344	; 0xe000
 8002928:	6812      	ldr	r2, [r2, #0]
 800292a:	f042 4240 	orr.w	r2, r2, #3221225472	; 0xc0000000
 800292e:	601a      	str	r2, [r3, #0]

	/* Start the first task. */
	vPortStartFirstTask();
 8002930:	f7ff ffc4 	bl	80028bc <vPortStartFirstTask>

	/* Should not get here! */
	return 0;
 8002934:	2300      	movs	r3, #0
}
 8002936:	4618      	mov	r0, r3
 8002938:	bd80      	pop	{r7, pc}
 800293a:	bf00      	nop

0800293c <vPortYieldFromISR>:
	is nothing to return to.  */
}
/*-----------------------------------------------------------*/

void vPortYieldFromISR( void )
{
 800293c:	b480      	push	{r7}
 800293e:	af00      	add	r7, sp, #0
	/* Set a PendSV to request a context switch. */
	*(portNVIC_INT_CTRL) = portNVIC_PENDSVSET;
 8002940:	f64e 5304 	movw	r3, #60676	; 0xed04
 8002944:	f2ce 0300 	movt	r3, #57344	; 0xe000
 8002948:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 800294c:	601a      	str	r2, [r3, #0]
}
 800294e:	46bd      	mov	sp, r7
 8002950:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002954:	4770      	bx	lr
 8002956:	bf00      	nop

08002958 <vPortEnterCritical>:
/*-----------------------------------------------------------*/

void vPortEnterCritical( void )
{
 8002958:	b480      	push	{r7}
 800295a:	af00      	add	r7, sp, #0
	portDISABLE_INTERRUPTS();
 800295c:	f04f 00bf 	mov.w	r0, #191	; 0xbf
 8002960:	f380 8811 	msr	BASEPRI, r0
	uxCriticalNesting++;
 8002964:	f240 0330 	movw	r3, #48	; 0x30
 8002968:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800296c:	681b      	ldr	r3, [r3, #0]
 800296e:	1c5a      	adds	r2, r3, #1
 8002970:	f240 0330 	movw	r3, #48	; 0x30
 8002974:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8002978:	601a      	str	r2, [r3, #0]
}
 800297a:	46bd      	mov	sp, r7
 800297c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002980:	4770      	bx	lr
 8002982:	bf00      	nop

08002984 <vPortExitCritical>:
/*-----------------------------------------------------------*/

void vPortExitCritical( void )
{
 8002984:	b480      	push	{r7}
 8002986:	af00      	add	r7, sp, #0
	uxCriticalNesting--;
 8002988:	f240 0330 	movw	r3, #48	; 0x30
 800298c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8002990:	681b      	ldr	r3, [r3, #0]
 8002992:	1e5a      	subs	r2, r3, #1
 8002994:	f240 0330 	movw	r3, #48	; 0x30
 8002998:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800299c:	601a      	str	r2, [r3, #0]
	if( uxCriticalNesting == 0 )
 800299e:	f240 0330 	movw	r3, #48	; 0x30
 80029a2:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80029a6:	681b      	ldr	r3, [r3, #0]
 80029a8:	2b00      	cmp	r3, #0
 80029aa:	d103      	bne.n	80029b4 <vPortExitCritical+0x30>
	{
		portENABLE_INTERRUPTS();
 80029ac:	f04f 0000 	mov.w	r0, #0
 80029b0:	f380 8811 	msr	BASEPRI, r0
	}
}
 80029b4:	46bd      	mov	sp, r7
 80029b6:	f85d 7b04 	ldr.w	r7, [sp], #4
 80029ba:	4770      	bx	lr

080029bc <PendSV_Handler>:

void xPortPendSVHandler( void )
{
	/* This is a naked function. */

	__asm volatile
 80029bc:	f3ef 8009 	mrs	r0, PSP
 80029c0:	4b11      	ldr	r3, [pc, #68]	; (8002a08 <pxCurrentTCBConst>)
 80029c2:	681a      	ldr	r2, [r3, #0]
 80029c4:	f01e 0f10 	tst.w	lr, #16
 80029c8:	bf08      	it	eq
 80029ca:	ed20 8a10 	vstmdbeq	r0!, {s16-s31}
 80029ce:	e920 4ff0 	stmdb	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80029d2:	6010      	str	r0, [r2, #0]
 80029d4:	e92d 4008 	stmdb	sp!, {r3, lr}
 80029d8:	f04f 00bf 	mov.w	r0, #191	; 0xbf
 80029dc:	f380 8811 	msr	BASEPRI, r0
 80029e0:	f7ff f866 	bl	8001ab0 <vTaskSwitchContext>
 80029e4:	f04f 0000 	mov.w	r0, #0
 80029e8:	f380 8811 	msr	BASEPRI, r0
 80029ec:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
 80029f0:	6819      	ldr	r1, [r3, #0]
 80029f2:	6808      	ldr	r0, [r1, #0]
 80029f4:	e8b0 4ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80029f8:	f01e 0f10 	tst.w	lr, #16
 80029fc:	bf08      	it	eq
 80029fe:	ecb0 8a10 	vldmiaeq	r0!, {s16-s31}
 8002a02:	f380 8809 	msr	PSP, r0
 8002a06:	4770      	bx	lr

08002a08 <pxCurrentTCBConst>:
 8002a08:	200009c4 	.word	0x200009c4

08002a0c <SysTick_Handler>:
	);
}
/*-----------------------------------------------------------*/

void xPortSysTickHandler( void )
{
 8002a0c:	b580      	push	{r7, lr}
 8002a0e:	b082      	sub	sp, #8
 8002a10:	af00      	add	r7, sp, #0
unsigned long ulDummy;

	/* If using preemption, also force a context switch. */
	#if configUSE_PREEMPTION == 1
		*(portNVIC_INT_CTRL) = portNVIC_PENDSVSET;
 8002a12:	f64e 5304 	movw	r3, #60676	; 0xed04
 8002a16:	f2ce 0300 	movt	r3, #57344	; 0xe000
 8002a1a:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8002a1e:	601a      	str	r2, [r3, #0]
	#endif

	ulDummy = portSET_INTERRUPT_MASK_FROM_ISR();
 8002a20:	2300      	movs	r3, #0
 8002a22:	607b      	str	r3, [r7, #4]
 8002a24:	f04f 00bf 	mov.w	r0, #191	; 0xbf
 8002a28:	f380 8811 	msr	BASEPRI, r0
	{
		vTaskIncrementTick();
 8002a2c:	f7fe ff6e 	bl	800190c <vTaskIncrementTick>
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( ulDummy );
 8002a30:	f04f 0000 	mov.w	r0, #0
 8002a34:	f380 8811 	msr	BASEPRI, r0
}
 8002a38:	3708      	adds	r7, #8
 8002a3a:	46bd      	mov	sp, r7
 8002a3c:	bd80      	pop	{r7, pc}
 8002a3e:	bf00      	nop

08002a40 <prvSetupTimerInterrupt>:
/*
 * Setup the systick timer to generate the tick interrupts at the required
 * frequency.
 */
void prvSetupTimerInterrupt( void )
{
 8002a40:	b480      	push	{r7}
 8002a42:	af00      	add	r7, sp, #0
	/* Configure SysTick to interrupt at the requested rate. */
	*(portNVIC_SYSTICK_LOAD) = ( configCPU_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;
 8002a44:	f24e 0314 	movw	r3, #57364	; 0xe014
 8002a48:	f2ce 0300 	movt	r3, #57344	; 0xe000
 8002a4c:	f240 0224 	movw	r2, #36	; 0x24
 8002a50:	f2c2 0200 	movt	r2, #8192	; 0x2000
 8002a54:	6811      	ldr	r1, [r2, #0]
 8002a56:	f644 52d3 	movw	r2, #19923	; 0x4dd3
 8002a5a:	f2c1 0262 	movt	r2, #4194	; 0x1062
 8002a5e:	fba2 0201 	umull	r0, r2, r2, r1
 8002a62:	0992      	lsrs	r2, r2, #6
 8002a64:	3a01      	subs	r2, #1
 8002a66:	601a      	str	r2, [r3, #0]
	*(portNVIC_SYSTICK_CTRL) = portNVIC_SYSTICK_CLK | portNVIC_SYSTICK_INT | portNVIC_SYSTICK_ENABLE;
 8002a68:	f24e 0310 	movw	r3, #57360	; 0xe010
 8002a6c:	f2ce 0300 	movt	r3, #57344	; 0xe000
 8002a70:	2207      	movs	r2, #7
 8002a72:	601a      	str	r2, [r3, #0]
}
 8002a74:	46bd      	mov	sp, r7
 8002a76:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002a7a:	4770      	bx	lr

08002a7c <vPortEnableVFP>:
/*-----------------------------------------------------------*/

/* This is a naked function. */
static void vPortEnableVFP( void )
{
	__asm volatile
 8002a7c:	f8df 000c 	ldr.w	r0, [pc, #12]	; 8002a8c <vPortEnableVFP+0x10>
 8002a80:	6801      	ldr	r1, [r0, #0]
 8002a82:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
 8002a86:	6001      	str	r1, [r0, #0]
 8002a88:	4770      	bx	lr
 8002a8a:	0000      	.short	0x0000
 8002a8c:	e000ed88 	.word	0xe000ed88

08002a90 <NVIC_Init>:
  * @param  NVIC_InitStruct: pointer to a NVIC_InitTypeDef structure that contains
  *         the configuration information for the specified NVIC peripheral.
  * @retval None
  */
void NVIC_Init(NVIC_InitTypeDef* NVIC_InitStruct)
{
 8002a90:	b480      	push	{r7}
 8002a92:	b085      	sub	sp, #20
 8002a94:	af00      	add	r7, sp, #0
 8002a96:	6078      	str	r0, [r7, #4]
  uint8_t tmppriority = 0x00, tmppre = 0x00, tmpsub = 0x0F;
 8002a98:	2300      	movs	r3, #0
 8002a9a:	73fb      	strb	r3, [r7, #15]
 8002a9c:	2300      	movs	r3, #0
 8002a9e:	73bb      	strb	r3, [r7, #14]
 8002aa0:	230f      	movs	r3, #15
 8002aa2:	737b      	strb	r3, [r7, #13]
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NVIC_InitStruct->NVIC_IRQChannelCmd));
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority));  
  assert_param(IS_NVIC_SUB_PRIORITY(NVIC_InitStruct->NVIC_IRQChannelSubPriority));
    
  if (NVIC_InitStruct->NVIC_IRQChannelCmd != DISABLE)
 8002aa4:	687b      	ldr	r3, [r7, #4]
 8002aa6:	78db      	ldrb	r3, [r3, #3]
 8002aa8:	2b00      	cmp	r3, #0
 8002aaa:	d040      	beq.n	8002b2e <NVIC_Init+0x9e>
  {
    /* Compute the Corresponding IRQ Priority --------------------------------*/    
    tmppriority = (0x700 - ((SCB->AIRCR) & (uint32_t)0x700))>> 0x08;
 8002aac:	f44f 436d 	mov.w	r3, #60672	; 0xed00
 8002ab0:	f2ce 0300 	movt	r3, #57344	; 0xe000
 8002ab4:	68db      	ldr	r3, [r3, #12]
 8002ab6:	43db      	mvns	r3, r3
 8002ab8:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
 8002abc:	0a1b      	lsrs	r3, r3, #8
 8002abe:	73fb      	strb	r3, [r7, #15]
    tmppre = (0x4 - tmppriority);
 8002ac0:	7bfb      	ldrb	r3, [r7, #15]
 8002ac2:	f1c3 0304 	rsb	r3, r3, #4
 8002ac6:	73bb      	strb	r3, [r7, #14]
    tmpsub = tmpsub >> tmppriority;
 8002ac8:	7b7a      	ldrb	r2, [r7, #13]
 8002aca:	7bfb      	ldrb	r3, [r7, #15]
 8002acc:	fa42 f303 	asr.w	r3, r2, r3
 8002ad0:	737b      	strb	r3, [r7, #13]

    tmppriority = NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority << tmppre;
 8002ad2:	687b      	ldr	r3, [r7, #4]
 8002ad4:	785b      	ldrb	r3, [r3, #1]
 8002ad6:	461a      	mov	r2, r3
 8002ad8:	7bbb      	ldrb	r3, [r7, #14]
 8002ada:	fa02 f303 	lsl.w	r3, r2, r3
 8002ade:	73fb      	strb	r3, [r7, #15]
    tmppriority |=  (uint8_t)(NVIC_InitStruct->NVIC_IRQChannelSubPriority & tmpsub);
 8002ae0:	687b      	ldr	r3, [r7, #4]
 8002ae2:	789a      	ldrb	r2, [r3, #2]
 8002ae4:	7b7b      	ldrb	r3, [r7, #13]
 8002ae6:	4013      	ands	r3, r2
 8002ae8:	b2da      	uxtb	r2, r3
 8002aea:	7bfb      	ldrb	r3, [r7, #15]
 8002aec:	4313      	orrs	r3, r2
 8002aee:	73fb      	strb	r3, [r7, #15]
        
    tmppriority = tmppriority << 0x04;
 8002af0:	7bfb      	ldrb	r3, [r7, #15]
 8002af2:	011b      	lsls	r3, r3, #4
 8002af4:	73fb      	strb	r3, [r7, #15]
        
    NVIC->IP[NVIC_InitStruct->NVIC_IRQChannel] = tmppriority;
 8002af6:	f44f 4361 	mov.w	r3, #57600	; 0xe100
 8002afa:	f2ce 0300 	movt	r3, #57344	; 0xe000
 8002afe:	687a      	ldr	r2, [r7, #4]
 8002b00:	7812      	ldrb	r2, [r2, #0]
 8002b02:	4413      	add	r3, r2
 8002b04:	7bfa      	ldrb	r2, [r7, #15]
 8002b06:	f883 2300 	strb.w	r2, [r3, #768]	; 0x300
    
    /* Enable the Selected IRQ Channels --------------------------------------*/
    NVIC->ISER[NVIC_InitStruct->NVIC_IRQChannel >> 0x05] =
 8002b0a:	f44f 4361 	mov.w	r3, #57600	; 0xe100
 8002b0e:	f2ce 0300 	movt	r3, #57344	; 0xe000
 8002b12:	687a      	ldr	r2, [r7, #4]
 8002b14:	7812      	ldrb	r2, [r2, #0]
 8002b16:	0952      	lsrs	r2, r2, #5
 8002b18:	b2d2      	uxtb	r2, r2
      (uint32_t)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (uint8_t)0x1F);
 8002b1a:	6879      	ldr	r1, [r7, #4]
 8002b1c:	7809      	ldrb	r1, [r1, #0]
 8002b1e:	f001 011f 	and.w	r1, r1, #31
 8002b22:	2001      	movs	r0, #1
 8002b24:	fa00 f101 	lsl.w	r1, r0, r1
    tmppriority = tmppriority << 0x04;
        
    NVIC->IP[NVIC_InitStruct->NVIC_IRQChannel] = tmppriority;
    
    /* Enable the Selected IRQ Channels --------------------------------------*/
    NVIC->ISER[NVIC_InitStruct->NVIC_IRQChannel >> 0x05] =
 8002b28:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
 8002b2c:	e011      	b.n	8002b52 <NVIC_Init+0xc2>
      (uint32_t)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (uint8_t)0x1F);
  }
  else
  {
    /* Disable the Selected IRQ Channels -------------------------------------*/
    NVIC->ICER[NVIC_InitStruct->NVIC_IRQChannel >> 0x05] =
 8002b2e:	f44f 4361 	mov.w	r3, #57600	; 0xe100
 8002b32:	f2ce 0300 	movt	r3, #57344	; 0xe000
 8002b36:	687a      	ldr	r2, [r7, #4]
 8002b38:	7812      	ldrb	r2, [r2, #0]
 8002b3a:	0952      	lsrs	r2, r2, #5
 8002b3c:	b2d2      	uxtb	r2, r2
      (uint32_t)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (uint8_t)0x1F);
 8002b3e:	6879      	ldr	r1, [r7, #4]
 8002b40:	7809      	ldrb	r1, [r1, #0]
 8002b42:	f001 011f 	and.w	r1, r1, #31
 8002b46:	2001      	movs	r0, #1
 8002b48:	fa00 f101 	lsl.w	r1, r0, r1
      (uint32_t)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (uint8_t)0x1F);
  }
  else
  {
    /* Disable the Selected IRQ Channels -------------------------------------*/
    NVIC->ICER[NVIC_InitStruct->NVIC_IRQChannel >> 0x05] =
 8002b4c:	3220      	adds	r2, #32
 8002b4e:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
      (uint32_t)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (uint8_t)0x1F);
  }
}
 8002b52:	3714      	adds	r7, #20
 8002b54:	46bd      	mov	sp, r7
 8002b56:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002b5a:	4770      	bx	lr

08002b5c <GPIO_Init>:
  * @param  GPIO_InitStruct: pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void GPIO_Init(GPIO_TypeDef* GPIOx, GPIO_InitTypeDef* GPIO_InitStruct)
{
 8002b5c:	b480      	push	{r7}
 8002b5e:	b087      	sub	sp, #28
 8002b60:	af00      	add	r7, sp, #0
 8002b62:	6078      	str	r0, [r7, #4]
 8002b64:	6039      	str	r1, [r7, #0]
  uint32_t pinpos = 0x00, pos = 0x00 , currentpin = 0x00;
 8002b66:	2300      	movs	r3, #0
 8002b68:	617b      	str	r3, [r7, #20]
 8002b6a:	2300      	movs	r3, #0
 8002b6c:	613b      	str	r3, [r7, #16]
 8002b6e:	2300      	movs	r3, #0
 8002b70:	60fb      	str	r3, [r7, #12]
  assert_param(IS_GPIO_MODE(GPIO_InitStruct->GPIO_Mode));
  assert_param(IS_GPIO_PUPD(GPIO_InitStruct->GPIO_PuPd));

  /* -------------------------Configure the port pins---------------- */
  /*-- GPIO Mode Configuration --*/
  for (pinpos = 0x00; pinpos < 0x10; pinpos++)
 8002b72:	2300      	movs	r3, #0
 8002b74:	617b      	str	r3, [r7, #20]
 8002b76:	e076      	b.n	8002c66 <GPIO_Init+0x10a>
  {
    pos = ((uint32_t)0x01) << pinpos;
 8002b78:	697b      	ldr	r3, [r7, #20]
 8002b7a:	2201      	movs	r2, #1
 8002b7c:	fa02 f303 	lsl.w	r3, r2, r3
 8002b80:	613b      	str	r3, [r7, #16]
    /* Get the port pins position */
    currentpin = (GPIO_InitStruct->GPIO_Pin) & pos;
 8002b82:	683b      	ldr	r3, [r7, #0]
 8002b84:	681a      	ldr	r2, [r3, #0]
 8002b86:	693b      	ldr	r3, [r7, #16]
 8002b88:	4013      	ands	r3, r2
 8002b8a:	60fb      	str	r3, [r7, #12]

    if (currentpin == pos)
 8002b8c:	68fa      	ldr	r2, [r7, #12]
 8002b8e:	693b      	ldr	r3, [r7, #16]
 8002b90:	429a      	cmp	r2, r3
 8002b92:	d165      	bne.n	8002c60 <GPIO_Init+0x104>
    {
      GPIOx->MODER  &= ~(GPIO_MODER_MODER0 << (pinpos * 2));
 8002b94:	687b      	ldr	r3, [r7, #4]
 8002b96:	681a      	ldr	r2, [r3, #0]
 8002b98:	697b      	ldr	r3, [r7, #20]
 8002b9a:	005b      	lsls	r3, r3, #1
 8002b9c:	2103      	movs	r1, #3
 8002b9e:	fa01 f303 	lsl.w	r3, r1, r3
 8002ba2:	43db      	mvns	r3, r3
 8002ba4:	401a      	ands	r2, r3
 8002ba6:	687b      	ldr	r3, [r7, #4]
 8002ba8:	601a      	str	r2, [r3, #0]
      GPIOx->MODER |= (((uint32_t)GPIO_InitStruct->GPIO_Mode) << (pinpos * 2));
 8002baa:	687b      	ldr	r3, [r7, #4]
 8002bac:	681a      	ldr	r2, [r3, #0]
 8002bae:	683b      	ldr	r3, [r7, #0]
 8002bb0:	791b      	ldrb	r3, [r3, #4]
 8002bb2:	4619      	mov	r1, r3
 8002bb4:	697b      	ldr	r3, [r7, #20]
 8002bb6:	005b      	lsls	r3, r3, #1
 8002bb8:	fa01 f303 	lsl.w	r3, r1, r3
 8002bbc:	431a      	orrs	r2, r3
 8002bbe:	687b      	ldr	r3, [r7, #4]
 8002bc0:	601a      	str	r2, [r3, #0]

      if ((GPIO_InitStruct->GPIO_Mode == GPIO_Mode_OUT) || (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_AF))
 8002bc2:	683b      	ldr	r3, [r7, #0]
 8002bc4:	791b      	ldrb	r3, [r3, #4]
 8002bc6:	2b01      	cmp	r3, #1
 8002bc8:	d003      	beq.n	8002bd2 <GPIO_Init+0x76>
 8002bca:	683b      	ldr	r3, [r7, #0]
 8002bcc:	791b      	ldrb	r3, [r3, #4]
 8002bce:	2b02      	cmp	r3, #2
 8002bd0:	d12e      	bne.n	8002c30 <GPIO_Init+0xd4>
      {
        /* Check Speed mode parameters */
        assert_param(IS_GPIO_SPEED(GPIO_InitStruct->GPIO_Speed));

        /* Speed mode configuration */
        GPIOx->OSPEEDR &= ~(GPIO_OSPEEDER_OSPEEDR0 << (pinpos * 2));
 8002bd2:	687b      	ldr	r3, [r7, #4]
 8002bd4:	689a      	ldr	r2, [r3, #8]
 8002bd6:	697b      	ldr	r3, [r7, #20]
 8002bd8:	005b      	lsls	r3, r3, #1
 8002bda:	2103      	movs	r1, #3
 8002bdc:	fa01 f303 	lsl.w	r3, r1, r3
 8002be0:	43db      	mvns	r3, r3
 8002be2:	401a      	ands	r2, r3
 8002be4:	687b      	ldr	r3, [r7, #4]
 8002be6:	609a      	str	r2, [r3, #8]
        GPIOx->OSPEEDR |= ((uint32_t)(GPIO_InitStruct->GPIO_Speed) << (pinpos * 2));
 8002be8:	687b      	ldr	r3, [r7, #4]
 8002bea:	689a      	ldr	r2, [r3, #8]
 8002bec:	683b      	ldr	r3, [r7, #0]
 8002bee:	795b      	ldrb	r3, [r3, #5]
 8002bf0:	4619      	mov	r1, r3
 8002bf2:	697b      	ldr	r3, [r7, #20]
 8002bf4:	005b      	lsls	r3, r3, #1
 8002bf6:	fa01 f303 	lsl.w	r3, r1, r3
 8002bfa:	431a      	orrs	r2, r3
 8002bfc:	687b      	ldr	r3, [r7, #4]
 8002bfe:	609a      	str	r2, [r3, #8]

        /* Check Output mode parameters */
        assert_param(IS_GPIO_OTYPE(GPIO_InitStruct->GPIO_OType));

        /* Output mode configuration*/
        GPIOx->OTYPER  &= ~((GPIO_OTYPER_OT_0) << ((uint16_t)pinpos)) ;
 8002c00:	687b      	ldr	r3, [r7, #4]
 8002c02:	685a      	ldr	r2, [r3, #4]
 8002c04:	697b      	ldr	r3, [r7, #20]
 8002c06:	b29b      	uxth	r3, r3
 8002c08:	2101      	movs	r1, #1
 8002c0a:	fa01 f303 	lsl.w	r3, r1, r3
 8002c0e:	43db      	mvns	r3, r3
 8002c10:	401a      	ands	r2, r3
 8002c12:	687b      	ldr	r3, [r7, #4]
 8002c14:	605a      	str	r2, [r3, #4]
        GPIOx->OTYPER |= (uint16_t)(((uint16_t)GPIO_InitStruct->GPIO_OType) << ((uint16_t)pinpos));
 8002c16:	687b      	ldr	r3, [r7, #4]
 8002c18:	685a      	ldr	r2, [r3, #4]
 8002c1a:	683b      	ldr	r3, [r7, #0]
 8002c1c:	799b      	ldrb	r3, [r3, #6]
 8002c1e:	4619      	mov	r1, r3
 8002c20:	697b      	ldr	r3, [r7, #20]
 8002c22:	b29b      	uxth	r3, r3
 8002c24:	fa01 f303 	lsl.w	r3, r1, r3
 8002c28:	b29b      	uxth	r3, r3
 8002c2a:	431a      	orrs	r2, r3
 8002c2c:	687b      	ldr	r3, [r7, #4]
 8002c2e:	605a      	str	r2, [r3, #4]
      }

      /* Pull-up Pull down resistor configuration*/
      GPIOx->PUPDR &= ~(GPIO_PUPDR_PUPDR0 << ((uint16_t)pinpos * 2));
 8002c30:	687b      	ldr	r3, [r7, #4]
 8002c32:	68da      	ldr	r2, [r3, #12]
 8002c34:	697b      	ldr	r3, [r7, #20]
 8002c36:	b29b      	uxth	r3, r3
 8002c38:	005b      	lsls	r3, r3, #1
 8002c3a:	2103      	movs	r1, #3
 8002c3c:	fa01 f303 	lsl.w	r3, r1, r3
 8002c40:	43db      	mvns	r3, r3
 8002c42:	401a      	ands	r2, r3
 8002c44:	687b      	ldr	r3, [r7, #4]
 8002c46:	60da      	str	r2, [r3, #12]
      GPIOx->PUPDR |= (((uint32_t)GPIO_InitStruct->GPIO_PuPd) << (pinpos * 2));
 8002c48:	687b      	ldr	r3, [r7, #4]
 8002c4a:	68da      	ldr	r2, [r3, #12]
 8002c4c:	683b      	ldr	r3, [r7, #0]
 8002c4e:	79db      	ldrb	r3, [r3, #7]
 8002c50:	4619      	mov	r1, r3
 8002c52:	697b      	ldr	r3, [r7, #20]
 8002c54:	005b      	lsls	r3, r3, #1
 8002c56:	fa01 f303 	lsl.w	r3, r1, r3
 8002c5a:	431a      	orrs	r2, r3
 8002c5c:	687b      	ldr	r3, [r7, #4]
 8002c5e:	60da      	str	r2, [r3, #12]
  assert_param(IS_GPIO_MODE(GPIO_InitStruct->GPIO_Mode));
  assert_param(IS_GPIO_PUPD(GPIO_InitStruct->GPIO_PuPd));

  /* -------------------------Configure the port pins---------------- */
  /*-- GPIO Mode Configuration --*/
  for (pinpos = 0x00; pinpos < 0x10; pinpos++)
 8002c60:	697b      	ldr	r3, [r7, #20]
 8002c62:	3301      	adds	r3, #1
 8002c64:	617b      	str	r3, [r7, #20]
 8002c66:	697b      	ldr	r3, [r7, #20]
 8002c68:	2b0f      	cmp	r3, #15
 8002c6a:	d985      	bls.n	8002b78 <GPIO_Init+0x1c>
      /* Pull-up Pull down resistor configuration*/
      GPIOx->PUPDR &= ~(GPIO_PUPDR_PUPDR0 << ((uint16_t)pinpos * 2));
      GPIOx->PUPDR |= (((uint32_t)GPIO_InitStruct->GPIO_PuPd) << (pinpos * 2));
    }
  }
}
 8002c6c:	371c      	adds	r7, #28
 8002c6e:	46bd      	mov	sp, r7
 8002c70:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002c74:	4770      	bx	lr
 8002c76:	bf00      	nop

08002c78 <GPIO_SetBits>:
  * @param  GPIO_Pin: specifies the port bits to be written.
  *          This parameter can be any combination of GPIO_Pin_x where x can be (0..15).
  * @retval None
  */
void GPIO_SetBits(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
{
 8002c78:	b480      	push	{r7}
 8002c7a:	b083      	sub	sp, #12
 8002c7c:	af00      	add	r7, sp, #0
 8002c7e:	6078      	str	r0, [r7, #4]
 8002c80:	460b      	mov	r3, r1
 8002c82:	807b      	strh	r3, [r7, #2]
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  GPIOx->BSRRL = GPIO_Pin;
 8002c84:	687b      	ldr	r3, [r7, #4]
 8002c86:	887a      	ldrh	r2, [r7, #2]
 8002c88:	831a      	strh	r2, [r3, #24]
}
 8002c8a:	370c      	adds	r7, #12
 8002c8c:	46bd      	mov	sp, r7
 8002c8e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002c92:	4770      	bx	lr

08002c94 <GPIO_ResetBits>:
  * @param  GPIO_Pin: specifies the port bits to be written.
  *          This parameter can be any combination of GPIO_Pin_x where x can be (0..15).
  * @retval None
  */
void GPIO_ResetBits(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
{
 8002c94:	b480      	push	{r7}
 8002c96:	b083      	sub	sp, #12
 8002c98:	af00      	add	r7, sp, #0
 8002c9a:	6078      	str	r0, [r7, #4]
 8002c9c:	460b      	mov	r3, r1
 8002c9e:	807b      	strh	r3, [r7, #2]
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  GPIOx->BSRRH = GPIO_Pin;
 8002ca0:	687b      	ldr	r3, [r7, #4]
 8002ca2:	887a      	ldrh	r2, [r7, #2]
 8002ca4:	835a      	strh	r2, [r3, #26]
}
 8002ca6:	370c      	adds	r7, #12
 8002ca8:	46bd      	mov	sp, r7
 8002caa:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002cae:	4770      	bx	lr

08002cb0 <GPIO_PinAFConfig>:
  *            @arg GPIO_AF_DCMI: Connect DCMI pins to AF13
  *            @arg GPIO_AF_EVENTOUT: Connect EVENTOUT pins to AF15
  * @retval None
  */
void GPIO_PinAFConfig(GPIO_TypeDef* GPIOx, uint16_t GPIO_PinSource, uint8_t GPIO_AF)
{
 8002cb0:	b480      	push	{r7}
 8002cb2:	b085      	sub	sp, #20
 8002cb4:	af00      	add	r7, sp, #0
 8002cb6:	6078      	str	r0, [r7, #4]
 8002cb8:	4613      	mov	r3, r2
 8002cba:	460a      	mov	r2, r1
 8002cbc:	807a      	strh	r2, [r7, #2]
 8002cbe:	707b      	strb	r3, [r7, #1]
  uint32_t temp = 0x00;
 8002cc0:	2300      	movs	r3, #0
 8002cc2:	60fb      	str	r3, [r7, #12]
  uint32_t temp_2 = 0x00;
 8002cc4:	2300      	movs	r3, #0
 8002cc6:	60bb      	str	r3, [r7, #8]
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GPIO_PIN_SOURCE(GPIO_PinSource));
  assert_param(IS_GPIO_AF(GPIO_AF));
  
  temp = ((uint32_t)(GPIO_AF) << ((uint32_t)((uint32_t)GPIO_PinSource & (uint32_t)0x07) * 4)) ;
 8002cc8:	787a      	ldrb	r2, [r7, #1]
 8002cca:	887b      	ldrh	r3, [r7, #2]
 8002ccc:	f003 0307 	and.w	r3, r3, #7
 8002cd0:	009b      	lsls	r3, r3, #2
 8002cd2:	fa02 f303 	lsl.w	r3, r2, r3
 8002cd6:	60fb      	str	r3, [r7, #12]
  GPIOx->AFR[GPIO_PinSource >> 0x03] &= ~((uint32_t)0xF << ((uint32_t)((uint32_t)GPIO_PinSource & (uint32_t)0x07) * 4)) ;
 8002cd8:	887b      	ldrh	r3, [r7, #2]
 8002cda:	08db      	lsrs	r3, r3, #3
 8002cdc:	b29b      	uxth	r3, r3
 8002cde:	461a      	mov	r2, r3
 8002ce0:	887b      	ldrh	r3, [r7, #2]
 8002ce2:	08db      	lsrs	r3, r3, #3
 8002ce4:	b29b      	uxth	r3, r3
 8002ce6:	4619      	mov	r1, r3
 8002ce8:	687b      	ldr	r3, [r7, #4]
 8002cea:	3108      	adds	r1, #8
 8002cec:	f853 1021 	ldr.w	r1, [r3, r1, lsl #2]
 8002cf0:	887b      	ldrh	r3, [r7, #2]
 8002cf2:	f003 0307 	and.w	r3, r3, #7
 8002cf6:	009b      	lsls	r3, r3, #2
 8002cf8:	200f      	movs	r0, #15
 8002cfa:	fa00 f303 	lsl.w	r3, r0, r3
 8002cfe:	43db      	mvns	r3, r3
 8002d00:	4019      	ands	r1, r3
 8002d02:	687b      	ldr	r3, [r7, #4]
 8002d04:	3208      	adds	r2, #8
 8002d06:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
  temp_2 = GPIOx->AFR[GPIO_PinSource >> 0x03] | temp;
 8002d0a:	887b      	ldrh	r3, [r7, #2]
 8002d0c:	08db      	lsrs	r3, r3, #3
 8002d0e:	b29b      	uxth	r3, r3
 8002d10:	461a      	mov	r2, r3
 8002d12:	687b      	ldr	r3, [r7, #4]
 8002d14:	3208      	adds	r2, #8
 8002d16:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 8002d1a:	68fb      	ldr	r3, [r7, #12]
 8002d1c:	4313      	orrs	r3, r2
 8002d1e:	60bb      	str	r3, [r7, #8]
  GPIOx->AFR[GPIO_PinSource >> 0x03] = temp_2;
 8002d20:	887b      	ldrh	r3, [r7, #2]
 8002d22:	08db      	lsrs	r3, r3, #3
 8002d24:	b29b      	uxth	r3, r3
 8002d26:	461a      	mov	r2, r3
 8002d28:	687b      	ldr	r3, [r7, #4]
 8002d2a:	3208      	adds	r2, #8
 8002d2c:	68b9      	ldr	r1, [r7, #8]
 8002d2e:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
}
 8002d32:	3714      	adds	r7, #20
 8002d34:	46bd      	mov	sp, r7
 8002d36:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002d3a:	4770      	bx	lr

08002d3c <RCC_GetClocksFreq>:
  *         configuration based on this function will be incorrect.
  *    
  * @retval None
  */
void RCC_GetClocksFreq(RCC_ClocksTypeDef* RCC_Clocks)
{
 8002d3c:	b480      	push	{r7}
 8002d3e:	b089      	sub	sp, #36	; 0x24
 8002d40:	af00      	add	r7, sp, #0
 8002d42:	6078      	str	r0, [r7, #4]
  uint32_t tmp = 0, presc = 0, pllvco = 0, pllp = 2, pllsource = 0, pllm = 2;
 8002d44:	2300      	movs	r3, #0
 8002d46:	61bb      	str	r3, [r7, #24]
 8002d48:	2300      	movs	r3, #0
 8002d4a:	617b      	str	r3, [r7, #20]
 8002d4c:	2300      	movs	r3, #0
 8002d4e:	61fb      	str	r3, [r7, #28]
 8002d50:	2302      	movs	r3, #2
 8002d52:	613b      	str	r3, [r7, #16]
 8002d54:	2300      	movs	r3, #0
 8002d56:	60fb      	str	r3, [r7, #12]
 8002d58:	2302      	movs	r3, #2
 8002d5a:	60bb      	str	r3, [r7, #8]

  /* Get SYSCLK source -------------------------------------------------------*/
  tmp = RCC->CFGR & RCC_CFGR_SWS;
 8002d5c:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8002d60:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8002d64:	689b      	ldr	r3, [r3, #8]
 8002d66:	f003 030c 	and.w	r3, r3, #12
 8002d6a:	61bb      	str	r3, [r7, #24]

  switch (tmp)
 8002d6c:	69bb      	ldr	r3, [r7, #24]
 8002d6e:	2b04      	cmp	r3, #4
 8002d70:	d00a      	beq.n	8002d88 <RCC_GetClocksFreq+0x4c>
 8002d72:	2b08      	cmp	r3, #8
 8002d74:	d00f      	beq.n	8002d96 <RCC_GetClocksFreq+0x5a>
 8002d76:	2b00      	cmp	r3, #0
 8002d78:	d15a      	bne.n	8002e30 <RCC_GetClocksFreq+0xf4>
  {
    case 0x00:  /* HSI used as system clock source */
      RCC_Clocks->SYSCLK_Frequency = HSI_VALUE;
 8002d7a:	687a      	ldr	r2, [r7, #4]
 8002d7c:	f44f 5310 	mov.w	r3, #9216	; 0x2400
 8002d80:	f2c0 03f4 	movt	r3, #244	; 0xf4
 8002d84:	6013      	str	r3, [r2, #0]
      break;
 8002d86:	e05a      	b.n	8002e3e <RCC_GetClocksFreq+0x102>
    case 0x04:  /* HSE used as system clock  source */
      RCC_Clocks->SYSCLK_Frequency = HSE_VALUE;
 8002d88:	687a      	ldr	r2, [r7, #4]
 8002d8a:	f44f 5390 	mov.w	r3, #4608	; 0x1200
 8002d8e:	f2c0 037a 	movt	r3, #122	; 0x7a
 8002d92:	6013      	str	r3, [r2, #0]
      break;
 8002d94:	e053      	b.n	8002e3e <RCC_GetClocksFreq+0x102>
    case 0x08:  /* PLL used as system clock  source */

      /* PLL_VCO = (HSE_VALUE or HSI_VALUE / PLLM) * PLLN
         SYSCLK = PLL_VCO / PLLP
         */    
      pllsource = (RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) >> 22;
 8002d96:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8002d9a:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8002d9e:	685b      	ldr	r3, [r3, #4]
 8002da0:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
 8002da4:	0d9b      	lsrs	r3, r3, #22
 8002da6:	60fb      	str	r3, [r7, #12]
      pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
 8002da8:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8002dac:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8002db0:	685b      	ldr	r3, [r3, #4]
 8002db2:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 8002db6:	60bb      	str	r3, [r7, #8]
      
      if (pllsource != 0)
 8002db8:	68fb      	ldr	r3, [r7, #12]
 8002dba:	2b00      	cmp	r3, #0
 8002dbc:	d013      	beq.n	8002de6 <RCC_GetClocksFreq+0xaa>
      {
        /* HSE used as PLL clock source */
        pllvco = (HSE_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 6);
 8002dbe:	f44f 5390 	mov.w	r3, #4608	; 0x1200
 8002dc2:	f2c0 037a 	movt	r3, #122	; 0x7a
 8002dc6:	68ba      	ldr	r2, [r7, #8]
 8002dc8:	fbb3 f2f2 	udiv	r2, r3, r2
 8002dcc:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8002dd0:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8002dd4:	6859      	ldr	r1, [r3, #4]
 8002dd6:	f647 73c0 	movw	r3, #32704	; 0x7fc0
 8002dda:	400b      	ands	r3, r1
 8002ddc:	099b      	lsrs	r3, r3, #6
 8002dde:	fb03 f302 	mul.w	r3, r3, r2
 8002de2:	61fb      	str	r3, [r7, #28]
 8002de4:	e012      	b.n	8002e0c <RCC_GetClocksFreq+0xd0>
      }
      else
      {
        /* HSI used as PLL clock source */
        pllvco = (HSI_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 6);      
 8002de6:	f44f 5310 	mov.w	r3, #9216	; 0x2400
 8002dea:	f2c0 03f4 	movt	r3, #244	; 0xf4
 8002dee:	68ba      	ldr	r2, [r7, #8]
 8002df0:	fbb3 f2f2 	udiv	r2, r3, r2
 8002df4:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8002df8:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8002dfc:	6859      	ldr	r1, [r3, #4]
 8002dfe:	f647 73c0 	movw	r3, #32704	; 0x7fc0
 8002e02:	400b      	ands	r3, r1
 8002e04:	099b      	lsrs	r3, r3, #6
 8002e06:	fb03 f302 	mul.w	r3, r3, r2
 8002e0a:	61fb      	str	r3, [r7, #28]
      }

      pllp = (((RCC->PLLCFGR & RCC_PLLCFGR_PLLP) >>16) + 1 ) *2;
 8002e0c:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8002e10:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8002e14:	685b      	ldr	r3, [r3, #4]
 8002e16:	f403 3340 	and.w	r3, r3, #196608	; 0x30000
 8002e1a:	0c1b      	lsrs	r3, r3, #16
 8002e1c:	3301      	adds	r3, #1
 8002e1e:	005b      	lsls	r3, r3, #1
 8002e20:	613b      	str	r3, [r7, #16]
      RCC_Clocks->SYSCLK_Frequency = pllvco/pllp;
 8002e22:	69fa      	ldr	r2, [r7, #28]
 8002e24:	693b      	ldr	r3, [r7, #16]
 8002e26:	fbb2 f2f3 	udiv	r2, r2, r3
 8002e2a:	687b      	ldr	r3, [r7, #4]
 8002e2c:	601a      	str	r2, [r3, #0]
      break;
 8002e2e:	e006      	b.n	8002e3e <RCC_GetClocksFreq+0x102>
    default:
      RCC_Clocks->SYSCLK_Frequency = HSI_VALUE;
 8002e30:	687a      	ldr	r2, [r7, #4]
 8002e32:	f44f 5310 	mov.w	r3, #9216	; 0x2400
 8002e36:	f2c0 03f4 	movt	r3, #244	; 0xf4
 8002e3a:	6013      	str	r3, [r2, #0]
      break;
 8002e3c:	bf00      	nop
  }
  /* Compute HCLK, PCLK1 and PCLK2 clocks frequencies ------------------------*/

  /* Get HCLK prescaler */
  tmp = RCC->CFGR & RCC_CFGR_HPRE;
 8002e3e:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8002e42:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8002e46:	689b      	ldr	r3, [r3, #8]
 8002e48:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
 8002e4c:	61bb      	str	r3, [r7, #24]
  tmp = tmp >> 4;
 8002e4e:	69bb      	ldr	r3, [r7, #24]
 8002e50:	091b      	lsrs	r3, r3, #4
 8002e52:	61bb      	str	r3, [r7, #24]
  presc = APBAHBPrescTable[tmp];
 8002e54:	f240 0334 	movw	r3, #52	; 0x34
 8002e58:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8002e5c:	69ba      	ldr	r2, [r7, #24]
 8002e5e:	4413      	add	r3, r2
 8002e60:	781b      	ldrb	r3, [r3, #0]
 8002e62:	b2db      	uxtb	r3, r3
 8002e64:	617b      	str	r3, [r7, #20]
  /* HCLK clock frequency */
  RCC_Clocks->HCLK_Frequency = RCC_Clocks->SYSCLK_Frequency >> presc;
 8002e66:	687b      	ldr	r3, [r7, #4]
 8002e68:	681a      	ldr	r2, [r3, #0]
 8002e6a:	697b      	ldr	r3, [r7, #20]
 8002e6c:	40da      	lsrs	r2, r3
 8002e6e:	687b      	ldr	r3, [r7, #4]
 8002e70:	605a      	str	r2, [r3, #4]

  /* Get PCLK1 prescaler */
  tmp = RCC->CFGR & RCC_CFGR_PPRE1;
 8002e72:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8002e76:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8002e7a:	689b      	ldr	r3, [r3, #8]
 8002e7c:	f403 53e0 	and.w	r3, r3, #7168	; 0x1c00
 8002e80:	61bb      	str	r3, [r7, #24]
  tmp = tmp >> 10;
 8002e82:	69bb      	ldr	r3, [r7, #24]
 8002e84:	0a9b      	lsrs	r3, r3, #10
 8002e86:	61bb      	str	r3, [r7, #24]
  presc = APBAHBPrescTable[tmp];
 8002e88:	f240 0334 	movw	r3, #52	; 0x34
 8002e8c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8002e90:	69ba      	ldr	r2, [r7, #24]
 8002e92:	4413      	add	r3, r2
 8002e94:	781b      	ldrb	r3, [r3, #0]
 8002e96:	b2db      	uxtb	r3, r3
 8002e98:	617b      	str	r3, [r7, #20]
  /* PCLK1 clock frequency */
  RCC_Clocks->PCLK1_Frequency = RCC_Clocks->HCLK_Frequency >> presc;
 8002e9a:	687b      	ldr	r3, [r7, #4]
 8002e9c:	685a      	ldr	r2, [r3, #4]
 8002e9e:	697b      	ldr	r3, [r7, #20]
 8002ea0:	40da      	lsrs	r2, r3
 8002ea2:	687b      	ldr	r3, [r7, #4]
 8002ea4:	609a      	str	r2, [r3, #8]

  /* Get PCLK2 prescaler */
  tmp = RCC->CFGR & RCC_CFGR_PPRE2;
 8002ea6:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8002eaa:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8002eae:	689b      	ldr	r3, [r3, #8]
 8002eb0:	f403 4360 	and.w	r3, r3, #57344	; 0xe000
 8002eb4:	61bb      	str	r3, [r7, #24]
  tmp = tmp >> 13;
 8002eb6:	69bb      	ldr	r3, [r7, #24]
 8002eb8:	0b5b      	lsrs	r3, r3, #13
 8002eba:	61bb      	str	r3, [r7, #24]
  presc = APBAHBPrescTable[tmp];
 8002ebc:	f240 0334 	movw	r3, #52	; 0x34
 8002ec0:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8002ec4:	69ba      	ldr	r2, [r7, #24]
 8002ec6:	4413      	add	r3, r2
 8002ec8:	781b      	ldrb	r3, [r3, #0]
 8002eca:	b2db      	uxtb	r3, r3
 8002ecc:	617b      	str	r3, [r7, #20]
  /* PCLK2 clock frequency */
  RCC_Clocks->PCLK2_Frequency = RCC_Clocks->HCLK_Frequency >> presc;
 8002ece:	687b      	ldr	r3, [r7, #4]
 8002ed0:	685a      	ldr	r2, [r3, #4]
 8002ed2:	697b      	ldr	r3, [r7, #20]
 8002ed4:	40da      	lsrs	r2, r3
 8002ed6:	687b      	ldr	r3, [r7, #4]
 8002ed8:	60da      	str	r2, [r3, #12]
}
 8002eda:	3724      	adds	r7, #36	; 0x24
 8002edc:	46bd      	mov	sp, r7
 8002ede:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002ee2:	4770      	bx	lr

08002ee4 <RCC_AHB1PeriphClockCmd>:
  * @param  NewState: new state of the specified peripheral clock.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RCC_AHB1PeriphClockCmd(uint32_t RCC_AHB1Periph, FunctionalState NewState)
{
 8002ee4:	b480      	push	{r7}
 8002ee6:	b083      	sub	sp, #12
 8002ee8:	af00      	add	r7, sp, #0
 8002eea:	6078      	str	r0, [r7, #4]
 8002eec:	460b      	mov	r3, r1
 8002eee:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_RCC_AHB1_CLOCK_PERIPH(RCC_AHB1Periph));

  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8002ef0:	78fb      	ldrb	r3, [r7, #3]
 8002ef2:	2b00      	cmp	r3, #0
 8002ef4:	d00c      	beq.n	8002f10 <RCC_AHB1PeriphClockCmd+0x2c>
  {
    RCC->AHB1ENR |= RCC_AHB1Periph;
 8002ef6:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8002efa:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8002efe:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 8002f02:	f2c4 0202 	movt	r2, #16386	; 0x4002
 8002f06:	6b11      	ldr	r1, [r2, #48]	; 0x30
 8002f08:	687a      	ldr	r2, [r7, #4]
 8002f0a:	430a      	orrs	r2, r1
 8002f0c:	631a      	str	r2, [r3, #48]	; 0x30
 8002f0e:	e00c      	b.n	8002f2a <RCC_AHB1PeriphClockCmd+0x46>
  }
  else
  {
    RCC->AHB1ENR &= ~RCC_AHB1Periph;
 8002f10:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8002f14:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8002f18:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 8002f1c:	f2c4 0202 	movt	r2, #16386	; 0x4002
 8002f20:	6b11      	ldr	r1, [r2, #48]	; 0x30
 8002f22:	687a      	ldr	r2, [r7, #4]
 8002f24:	43d2      	mvns	r2, r2
 8002f26:	400a      	ands	r2, r1
 8002f28:	631a      	str	r2, [r3, #48]	; 0x30
  }
}
 8002f2a:	370c      	adds	r7, #12
 8002f2c:	46bd      	mov	sp, r7
 8002f2e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002f32:	4770      	bx	lr

08002f34 <RCC_APB1PeriphClockCmd>:
  * @param  NewState: new state of the specified peripheral clock.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RCC_APB1PeriphClockCmd(uint32_t RCC_APB1Periph, FunctionalState NewState)
{
 8002f34:	b480      	push	{r7}
 8002f36:	b083      	sub	sp, #12
 8002f38:	af00      	add	r7, sp, #0
 8002f3a:	6078      	str	r0, [r7, #4]
 8002f3c:	460b      	mov	r3, r1
 8002f3e:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));  
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 8002f40:	78fb      	ldrb	r3, [r7, #3]
 8002f42:	2b00      	cmp	r3, #0
 8002f44:	d00c      	beq.n	8002f60 <RCC_APB1PeriphClockCmd+0x2c>
  {
    RCC->APB1ENR |= RCC_APB1Periph;
 8002f46:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8002f4a:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8002f4e:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 8002f52:	f2c4 0202 	movt	r2, #16386	; 0x4002
 8002f56:	6c11      	ldr	r1, [r2, #64]	; 0x40
 8002f58:	687a      	ldr	r2, [r7, #4]
 8002f5a:	430a      	orrs	r2, r1
 8002f5c:	641a      	str	r2, [r3, #64]	; 0x40
 8002f5e:	e00c      	b.n	8002f7a <RCC_APB1PeriphClockCmd+0x46>
  }
  else
  {
    RCC->APB1ENR &= ~RCC_APB1Periph;
 8002f60:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8002f64:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8002f68:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 8002f6c:	f2c4 0202 	movt	r2, #16386	; 0x4002
 8002f70:	6c11      	ldr	r1, [r2, #64]	; 0x40
 8002f72:	687a      	ldr	r2, [r7, #4]
 8002f74:	43d2      	mvns	r2, r2
 8002f76:	400a      	ands	r2, r1
 8002f78:	641a      	str	r2, [r3, #64]	; 0x40
  }
}
 8002f7a:	370c      	adds	r7, #12
 8002f7c:	46bd      	mov	sp, r7
 8002f7e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002f82:	4770      	bx	lr

08002f84 <TIM_TimeBaseInit>:
  * @param  TIM_TimeBaseInitStruct: pointer to a TIM_TimeBaseInitTypeDef structure
  *         that contains the configuration information for the specified TIM peripheral.
  * @retval None
  */
void TIM_TimeBaseInit(TIM_TypeDef* TIMx, TIM_TimeBaseInitTypeDef* TIM_TimeBaseInitStruct)
{
 8002f84:	b480      	push	{r7}
 8002f86:	b085      	sub	sp, #20
 8002f88:	af00      	add	r7, sp, #0
 8002f8a:	6078      	str	r0, [r7, #4]
 8002f8c:	6039      	str	r1, [r7, #0]
  uint16_t tmpcr1 = 0;
 8002f8e:	2300      	movs	r3, #0
 8002f90:	81fb      	strh	r3, [r7, #14]
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx)); 
  assert_param(IS_TIM_COUNTER_MODE(TIM_TimeBaseInitStruct->TIM_CounterMode));
  assert_param(IS_TIM_CKD_DIV(TIM_TimeBaseInitStruct->TIM_ClockDivision));

  tmpcr1 = TIMx->CR1;  
 8002f92:	687b      	ldr	r3, [r7, #4]
 8002f94:	881b      	ldrh	r3, [r3, #0]
 8002f96:	81fb      	strh	r3, [r7, #14]

  if((TIMx == TIM1) || (TIMx == TIM8)||
 8002f98:	687a      	ldr	r2, [r7, #4]
 8002f9a:	2300      	movs	r3, #0
 8002f9c:	f2c4 0301 	movt	r3, #16385	; 0x4001
 8002fa0:	429a      	cmp	r2, r3
 8002fa2:	d01f      	beq.n	8002fe4 <TIM_TimeBaseInit+0x60>
 8002fa4:	687a      	ldr	r2, [r7, #4]
 8002fa6:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8002faa:	f2c4 0301 	movt	r3, #16385	; 0x4001
 8002fae:	429a      	cmp	r2, r3
 8002fb0:	d018      	beq.n	8002fe4 <TIM_TimeBaseInit+0x60>
 8002fb2:	687b      	ldr	r3, [r7, #4]
 8002fb4:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
 8002fb8:	d014      	beq.n	8002fe4 <TIM_TimeBaseInit+0x60>
     (TIMx == TIM2) || (TIMx == TIM3)||
 8002fba:	687a      	ldr	r2, [r7, #4]
 8002fbc:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8002fc0:	f2c4 0300 	movt	r3, #16384	; 0x4000
 8002fc4:	429a      	cmp	r2, r3
 8002fc6:	d00d      	beq.n	8002fe4 <TIM_TimeBaseInit+0x60>
 8002fc8:	687a      	ldr	r2, [r7, #4]
 8002fca:	f44f 6300 	mov.w	r3, #2048	; 0x800
 8002fce:	f2c4 0300 	movt	r3, #16384	; 0x4000
 8002fd2:	429a      	cmp	r2, r3
 8002fd4:	d006      	beq.n	8002fe4 <TIM_TimeBaseInit+0x60>
     (TIMx == TIM4) || (TIMx == TIM5)) 
 8002fd6:	687a      	ldr	r2, [r7, #4]
 8002fd8:	f44f 6340 	mov.w	r3, #3072	; 0xc00
 8002fdc:	f2c4 0300 	movt	r3, #16384	; 0x4000
 8002fe0:	429a      	cmp	r2, r3
 8002fe2:	d108      	bne.n	8002ff6 <TIM_TimeBaseInit+0x72>
  {
    /* Select the Counter Mode */
    tmpcr1 &= (uint16_t)(~(TIM_CR1_DIR | TIM_CR1_CMS));
 8002fe4:	89fb      	ldrh	r3, [r7, #14]
 8002fe6:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 8002fea:	81fb      	strh	r3, [r7, #14]
    tmpcr1 |= (uint32_t)TIM_TimeBaseInitStruct->TIM_CounterMode;
 8002fec:	683b      	ldr	r3, [r7, #0]
 8002fee:	885a      	ldrh	r2, [r3, #2]
 8002ff0:	89fb      	ldrh	r3, [r7, #14]
 8002ff2:	4313      	orrs	r3, r2
 8002ff4:	81fb      	strh	r3, [r7, #14]
  }
 
  if((TIMx != TIM6) && (TIMx != TIM7))
 8002ff6:	687a      	ldr	r2, [r7, #4]
 8002ff8:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 8002ffc:	f2c4 0300 	movt	r3, #16384	; 0x4000
 8003000:	429a      	cmp	r2, r3
 8003002:	d00f      	beq.n	8003024 <TIM_TimeBaseInit+0xa0>
 8003004:	687a      	ldr	r2, [r7, #4]
 8003006:	f44f 53a0 	mov.w	r3, #5120	; 0x1400
 800300a:	f2c4 0300 	movt	r3, #16384	; 0x4000
 800300e:	429a      	cmp	r2, r3
 8003010:	d008      	beq.n	8003024 <TIM_TimeBaseInit+0xa0>
  {
    /* Set the clock division */
    tmpcr1 &=  (uint16_t)(~TIM_CR1_CKD);
 8003012:	89fb      	ldrh	r3, [r7, #14]
 8003014:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 8003018:	81fb      	strh	r3, [r7, #14]
    tmpcr1 |= (uint32_t)TIM_TimeBaseInitStruct->TIM_ClockDivision;
 800301a:	683b      	ldr	r3, [r7, #0]
 800301c:	891a      	ldrh	r2, [r3, #8]
 800301e:	89fb      	ldrh	r3, [r7, #14]
 8003020:	4313      	orrs	r3, r2
 8003022:	81fb      	strh	r3, [r7, #14]
  }

  TIMx->CR1 = tmpcr1;
 8003024:	687b      	ldr	r3, [r7, #4]
 8003026:	89fa      	ldrh	r2, [r7, #14]
 8003028:	801a      	strh	r2, [r3, #0]

  /* Set the Autoreload value */
  TIMx->ARR = TIM_TimeBaseInitStruct->TIM_Period ;
 800302a:	683b      	ldr	r3, [r7, #0]
 800302c:	685a      	ldr	r2, [r3, #4]
 800302e:	687b      	ldr	r3, [r7, #4]
 8003030:	62da      	str	r2, [r3, #44]	; 0x2c
 
  /* Set the Prescaler value */
  TIMx->PSC = TIM_TimeBaseInitStruct->TIM_Prescaler;
 8003032:	683b      	ldr	r3, [r7, #0]
 8003034:	881a      	ldrh	r2, [r3, #0]
 8003036:	687b      	ldr	r3, [r7, #4]
 8003038:	851a      	strh	r2, [r3, #40]	; 0x28
    
  if ((TIMx == TIM1) || (TIMx == TIM8))  
 800303a:	687a      	ldr	r2, [r7, #4]
 800303c:	2300      	movs	r3, #0
 800303e:	f2c4 0301 	movt	r3, #16385	; 0x4001
 8003042:	429a      	cmp	r2, r3
 8003044:	d006      	beq.n	8003054 <TIM_TimeBaseInit+0xd0>
 8003046:	687a      	ldr	r2, [r7, #4]
 8003048:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800304c:	f2c4 0301 	movt	r3, #16385	; 0x4001
 8003050:	429a      	cmp	r2, r3
 8003052:	d104      	bne.n	800305e <TIM_TimeBaseInit+0xda>
  {
    /* Set the Repetition Counter value */
    TIMx->RCR = TIM_TimeBaseInitStruct->TIM_RepetitionCounter;
 8003054:	683b      	ldr	r3, [r7, #0]
 8003056:	7a9b      	ldrb	r3, [r3, #10]
 8003058:	461a      	mov	r2, r3
 800305a:	687b      	ldr	r3, [r7, #4]
 800305c:	861a      	strh	r2, [r3, #48]	; 0x30
  }

  /* Generate an update event to reload the Prescaler 
     and the repetition counter(only for TIM1 and TIM8) value immediatly */
  TIMx->EGR = TIM_PSCReloadMode_Immediate;          
 800305e:	687b      	ldr	r3, [r7, #4]
 8003060:	2201      	movs	r2, #1
 8003062:	829a      	strh	r2, [r3, #20]
}
 8003064:	3714      	adds	r7, #20
 8003066:	46bd      	mov	sp, r7
 8003068:	f85d 7b04 	ldr.w	r7, [sp], #4
 800306c:	4770      	bx	lr
 800306e:	bf00      	nop

08003070 <TIM_ARRPreloadConfig>:
  * @param  NewState: new state of the TIMx peripheral Preload register
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void TIM_ARRPreloadConfig(TIM_TypeDef* TIMx, FunctionalState NewState)
{
 8003070:	b480      	push	{r7}
 8003072:	b083      	sub	sp, #12
 8003074:	af00      	add	r7, sp, #0
 8003076:	6078      	str	r0, [r7, #4]
 8003078:	460b      	mov	r3, r1
 800307a:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 800307c:	78fb      	ldrb	r3, [r7, #3]
 800307e:	2b00      	cmp	r3, #0
 8003080:	d008      	beq.n	8003094 <TIM_ARRPreloadConfig+0x24>
  {
    /* Set the ARR Preload Bit */
    TIMx->CR1 |= TIM_CR1_ARPE;
 8003082:	687b      	ldr	r3, [r7, #4]
 8003084:	881b      	ldrh	r3, [r3, #0]
 8003086:	b29b      	uxth	r3, r3
 8003088:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 800308c:	b29a      	uxth	r2, r3
 800308e:	687b      	ldr	r3, [r7, #4]
 8003090:	801a      	strh	r2, [r3, #0]
 8003092:	e007      	b.n	80030a4 <TIM_ARRPreloadConfig+0x34>
  }
  else
  {
    /* Reset the ARR Preload Bit */
    TIMx->CR1 &= (uint16_t)~TIM_CR1_ARPE;
 8003094:	687b      	ldr	r3, [r7, #4]
 8003096:	881b      	ldrh	r3, [r3, #0]
 8003098:	b29b      	uxth	r3, r3
 800309a:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 800309e:	b29a      	uxth	r2, r3
 80030a0:	687b      	ldr	r3, [r7, #4]
 80030a2:	801a      	strh	r2, [r3, #0]
  }
}
 80030a4:	370c      	adds	r7, #12
 80030a6:	46bd      	mov	sp, r7
 80030a8:	f85d 7b04 	ldr.w	r7, [sp], #4
 80030ac:	4770      	bx	lr
 80030ae:	bf00      	nop

080030b0 <TIM_Cmd>:
  * @param  NewState: new state of the TIMx peripheral.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void TIM_Cmd(TIM_TypeDef* TIMx, FunctionalState NewState)
{
 80030b0:	b480      	push	{r7}
 80030b2:	b083      	sub	sp, #12
 80030b4:	af00      	add	r7, sp, #0
 80030b6:	6078      	str	r0, [r7, #4]
 80030b8:	460b      	mov	r3, r1
 80030ba:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx)); 
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 80030bc:	78fb      	ldrb	r3, [r7, #3]
 80030be:	2b00      	cmp	r3, #0
 80030c0:	d008      	beq.n	80030d4 <TIM_Cmd+0x24>
  {
    /* Enable the TIM Counter */
    TIMx->CR1 |= TIM_CR1_CEN;
 80030c2:	687b      	ldr	r3, [r7, #4]
 80030c4:	881b      	ldrh	r3, [r3, #0]
 80030c6:	b29b      	uxth	r3, r3
 80030c8:	f043 0301 	orr.w	r3, r3, #1
 80030cc:	b29a      	uxth	r2, r3
 80030ce:	687b      	ldr	r3, [r7, #4]
 80030d0:	801a      	strh	r2, [r3, #0]
 80030d2:	e007      	b.n	80030e4 <TIM_Cmd+0x34>
  }
  else
  {
    /* Disable the TIM Counter */
    TIMx->CR1 &= (uint16_t)~TIM_CR1_CEN;
 80030d4:	687b      	ldr	r3, [r7, #4]
 80030d6:	881b      	ldrh	r3, [r3, #0]
 80030d8:	b29b      	uxth	r3, r3
 80030da:	f023 0301 	bic.w	r3, r3, #1
 80030de:	b29a      	uxth	r2, r3
 80030e0:	687b      	ldr	r3, [r7, #4]
 80030e2:	801a      	strh	r2, [r3, #0]
  }
}
 80030e4:	370c      	adds	r7, #12
 80030e6:	46bd      	mov	sp, r7
 80030e8:	f85d 7b04 	ldr.w	r7, [sp], #4
 80030ec:	4770      	bx	lr
 80030ee:	bf00      	nop

080030f0 <TIM_OC1Init>:
  * @param  TIM_OCInitStruct: pointer to a TIM_OCInitTypeDef structure that contains
  *         the configuration information for the specified TIM peripheral.
  * @retval None
  */
void TIM_OC1Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
{
 80030f0:	b480      	push	{r7}
 80030f2:	b085      	sub	sp, #20
 80030f4:	af00      	add	r7, sp, #0
 80030f6:	6078      	str	r0, [r7, #4]
 80030f8:	6039      	str	r1, [r7, #0]
  uint16_t tmpccmrx = 0, tmpccer = 0, tmpcr2 = 0;
 80030fa:	2300      	movs	r3, #0
 80030fc:	817b      	strh	r3, [r7, #10]
 80030fe:	2300      	movs	r3, #0
 8003100:	81fb      	strh	r3, [r7, #14]
 8003102:	2300      	movs	r3, #0
 8003104:	81bb      	strh	r3, [r7, #12]
  assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
  assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
  assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   

  /* Disable the Channel 1: Reset the CC1E Bit */
  TIMx->CCER &= (uint16_t)~TIM_CCER_CC1E;
 8003106:	687b      	ldr	r3, [r7, #4]
 8003108:	8c1b      	ldrh	r3, [r3, #32]
 800310a:	b29b      	uxth	r3, r3
 800310c:	f023 0301 	bic.w	r3, r3, #1
 8003110:	b29a      	uxth	r2, r3
 8003112:	687b      	ldr	r3, [r7, #4]
 8003114:	841a      	strh	r2, [r3, #32]
  
  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
 8003116:	687b      	ldr	r3, [r7, #4]
 8003118:	8c1b      	ldrh	r3, [r3, #32]
 800311a:	81fb      	strh	r3, [r7, #14]
  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2;
 800311c:	687b      	ldr	r3, [r7, #4]
 800311e:	889b      	ldrh	r3, [r3, #4]
 8003120:	81bb      	strh	r3, [r7, #12]
  
  /* Get the TIMx CCMR1 register value */
  tmpccmrx = TIMx->CCMR1;
 8003122:	687b      	ldr	r3, [r7, #4]
 8003124:	8b1b      	ldrh	r3, [r3, #24]
 8003126:	817b      	strh	r3, [r7, #10]
    
  /* Reset the Output Compare Mode Bits */
  tmpccmrx &= (uint16_t)~TIM_CCMR1_OC1M;
 8003128:	897b      	ldrh	r3, [r7, #10]
 800312a:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 800312e:	817b      	strh	r3, [r7, #10]
  tmpccmrx &= (uint16_t)~TIM_CCMR1_CC1S;
 8003130:	897b      	ldrh	r3, [r7, #10]
 8003132:	f023 0303 	bic.w	r3, r3, #3
 8003136:	817b      	strh	r3, [r7, #10]
  /* Select the Output Compare Mode */
  tmpccmrx |= TIM_OCInitStruct->TIM_OCMode;
 8003138:	683b      	ldr	r3, [r7, #0]
 800313a:	881a      	ldrh	r2, [r3, #0]
 800313c:	897b      	ldrh	r3, [r7, #10]
 800313e:	4313      	orrs	r3, r2
 8003140:	817b      	strh	r3, [r7, #10]
  
  /* Reset the Output Polarity level */
  tmpccer &= (uint16_t)~TIM_CCER_CC1P;
 8003142:	89fb      	ldrh	r3, [r7, #14]
 8003144:	f023 0302 	bic.w	r3, r3, #2
 8003148:	81fb      	strh	r3, [r7, #14]
  /* Set the Output Compare Polarity */
  tmpccer |= TIM_OCInitStruct->TIM_OCPolarity;
 800314a:	683b      	ldr	r3, [r7, #0]
 800314c:	899a      	ldrh	r2, [r3, #12]
 800314e:	89fb      	ldrh	r3, [r7, #14]
 8003150:	4313      	orrs	r3, r2
 8003152:	81fb      	strh	r3, [r7, #14]
  
  /* Set the Output State */
  tmpccer |= TIM_OCInitStruct->TIM_OutputState;
 8003154:	683b      	ldr	r3, [r7, #0]
 8003156:	885a      	ldrh	r2, [r3, #2]
 8003158:	89fb      	ldrh	r3, [r7, #14]
 800315a:	4313      	orrs	r3, r2
 800315c:	81fb      	strh	r3, [r7, #14]
    
  if((TIMx == TIM1) || (TIMx == TIM8))
 800315e:	687a      	ldr	r2, [r7, #4]
 8003160:	2300      	movs	r3, #0
 8003162:	f2c4 0301 	movt	r3, #16385	; 0x4001
 8003166:	429a      	cmp	r2, r3
 8003168:	d006      	beq.n	8003178 <TIM_OC1Init+0x88>
 800316a:	687a      	ldr	r2, [r7, #4]
 800316c:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8003170:	f2c4 0301 	movt	r3, #16385	; 0x4001
 8003174:	429a      	cmp	r2, r3
 8003176:	d123      	bne.n	80031c0 <TIM_OC1Init+0xd0>
    assert_param(IS_TIM_OCN_POLARITY(TIM_OCInitStruct->TIM_OCNPolarity));
    assert_param(IS_TIM_OCNIDLE_STATE(TIM_OCInitStruct->TIM_OCNIdleState));
    assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
    
    /* Reset the Output N Polarity level */
    tmpccer &= (uint16_t)~TIM_CCER_CC1NP;
 8003178:	89fb      	ldrh	r3, [r7, #14]
 800317a:	f023 0308 	bic.w	r3, r3, #8
 800317e:	81fb      	strh	r3, [r7, #14]
    /* Set the Output N Polarity */
    tmpccer |= TIM_OCInitStruct->TIM_OCNPolarity;
 8003180:	683b      	ldr	r3, [r7, #0]
 8003182:	89da      	ldrh	r2, [r3, #14]
 8003184:	89fb      	ldrh	r3, [r7, #14]
 8003186:	4313      	orrs	r3, r2
 8003188:	81fb      	strh	r3, [r7, #14]
    /* Reset the Output N State */
    tmpccer &= (uint16_t)~TIM_CCER_CC1NE;
 800318a:	89fb      	ldrh	r3, [r7, #14]
 800318c:	f023 0304 	bic.w	r3, r3, #4
 8003190:	81fb      	strh	r3, [r7, #14]
    
    /* Set the Output N State */
    tmpccer |= TIM_OCInitStruct->TIM_OutputNState;
 8003192:	683b      	ldr	r3, [r7, #0]
 8003194:	889a      	ldrh	r2, [r3, #4]
 8003196:	89fb      	ldrh	r3, [r7, #14]
 8003198:	4313      	orrs	r3, r2
 800319a:	81fb      	strh	r3, [r7, #14]
    /* Reset the Output Compare and Output Compare N IDLE State */
    tmpcr2 &= (uint16_t)~TIM_CR2_OIS1;
 800319c:	89bb      	ldrh	r3, [r7, #12]
 800319e:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 80031a2:	81bb      	strh	r3, [r7, #12]
    tmpcr2 &= (uint16_t)~TIM_CR2_OIS1N;
 80031a4:	89bb      	ldrh	r3, [r7, #12]
 80031a6:	f423 7300 	bic.w	r3, r3, #512	; 0x200
 80031aa:	81bb      	strh	r3, [r7, #12]
    /* Set the Output Idle state */
    tmpcr2 |= TIM_OCInitStruct->TIM_OCIdleState;
 80031ac:	683b      	ldr	r3, [r7, #0]
 80031ae:	8a1a      	ldrh	r2, [r3, #16]
 80031b0:	89bb      	ldrh	r3, [r7, #12]
 80031b2:	4313      	orrs	r3, r2
 80031b4:	81bb      	strh	r3, [r7, #12]
    /* Set the Output N Idle state */
    tmpcr2 |= TIM_OCInitStruct->TIM_OCNIdleState;
 80031b6:	683b      	ldr	r3, [r7, #0]
 80031b8:	8a5a      	ldrh	r2, [r3, #18]
 80031ba:	89bb      	ldrh	r3, [r7, #12]
 80031bc:	4313      	orrs	r3, r2
 80031be:	81bb      	strh	r3, [r7, #12]
  }
  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
 80031c0:	687b      	ldr	r3, [r7, #4]
 80031c2:	89ba      	ldrh	r2, [r7, #12]
 80031c4:	809a      	strh	r2, [r3, #4]
  
  /* Write to TIMx CCMR1 */
  TIMx->CCMR1 = tmpccmrx;
 80031c6:	687b      	ldr	r3, [r7, #4]
 80031c8:	897a      	ldrh	r2, [r7, #10]
 80031ca:	831a      	strh	r2, [r3, #24]
  
  /* Set the Capture Compare Register value */
  TIMx->CCR1 = TIM_OCInitStruct->TIM_Pulse;
 80031cc:	683b      	ldr	r3, [r7, #0]
 80031ce:	689a      	ldr	r2, [r3, #8]
 80031d0:	687b      	ldr	r3, [r7, #4]
 80031d2:	635a      	str	r2, [r3, #52]	; 0x34
  
  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
 80031d4:	687b      	ldr	r3, [r7, #4]
 80031d6:	89fa      	ldrh	r2, [r7, #14]
 80031d8:	841a      	strh	r2, [r3, #32]
}
 80031da:	3714      	adds	r7, #20
 80031dc:	46bd      	mov	sp, r7
 80031de:	f85d 7b04 	ldr.w	r7, [sp], #4
 80031e2:	4770      	bx	lr

080031e4 <TIM_OC2Init>:
  * @param  TIM_OCInitStruct: pointer to a TIM_OCInitTypeDef structure that contains
  *         the configuration information for the specified TIM peripheral.
  * @retval None
  */
void TIM_OC2Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
{
 80031e4:	b480      	push	{r7}
 80031e6:	b085      	sub	sp, #20
 80031e8:	af00      	add	r7, sp, #0
 80031ea:	6078      	str	r0, [r7, #4]
 80031ec:	6039      	str	r1, [r7, #0]
  uint16_t tmpccmrx = 0, tmpccer = 0, tmpcr2 = 0;
 80031ee:	2300      	movs	r3, #0
 80031f0:	817b      	strh	r3, [r7, #10]
 80031f2:	2300      	movs	r3, #0
 80031f4:	81fb      	strh	r3, [r7, #14]
 80031f6:	2300      	movs	r3, #0
 80031f8:	81bb      	strh	r3, [r7, #12]
  assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
  assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
  assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   

  /* Disable the Channel 2: Reset the CC2E Bit */
  TIMx->CCER &= (uint16_t)~TIM_CCER_CC2E;
 80031fa:	687b      	ldr	r3, [r7, #4]
 80031fc:	8c1b      	ldrh	r3, [r3, #32]
 80031fe:	b29b      	uxth	r3, r3
 8003200:	f023 0310 	bic.w	r3, r3, #16
 8003204:	b29a      	uxth	r2, r3
 8003206:	687b      	ldr	r3, [r7, #4]
 8003208:	841a      	strh	r2, [r3, #32]
  
  /* Get the TIMx CCER register value */  
  tmpccer = TIMx->CCER;
 800320a:	687b      	ldr	r3, [r7, #4]
 800320c:	8c1b      	ldrh	r3, [r3, #32]
 800320e:	81fb      	strh	r3, [r7, #14]
  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2;
 8003210:	687b      	ldr	r3, [r7, #4]
 8003212:	889b      	ldrh	r3, [r3, #4]
 8003214:	81bb      	strh	r3, [r7, #12]
  
  /* Get the TIMx CCMR1 register value */
  tmpccmrx = TIMx->CCMR1;
 8003216:	687b      	ldr	r3, [r7, #4]
 8003218:	8b1b      	ldrh	r3, [r3, #24]
 800321a:	817b      	strh	r3, [r7, #10]
    
  /* Reset the Output Compare mode and Capture/Compare selection Bits */
  tmpccmrx &= (uint16_t)~TIM_CCMR1_OC2M;
 800321c:	897b      	ldrh	r3, [r7, #10]
 800321e:	f423 43e0 	bic.w	r3, r3, #28672	; 0x7000
 8003222:	817b      	strh	r3, [r7, #10]
  tmpccmrx &= (uint16_t)~TIM_CCMR1_CC2S;
 8003224:	897b      	ldrh	r3, [r7, #10]
 8003226:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 800322a:	817b      	strh	r3, [r7, #10]
  
  /* Select the Output Compare Mode */
  tmpccmrx |= (uint16_t)(TIM_OCInitStruct->TIM_OCMode << 8);
 800322c:	683b      	ldr	r3, [r7, #0]
 800322e:	881b      	ldrh	r3, [r3, #0]
 8003230:	021b      	lsls	r3, r3, #8
 8003232:	b29a      	uxth	r2, r3
 8003234:	897b      	ldrh	r3, [r7, #10]
 8003236:	4313      	orrs	r3, r2
 8003238:	817b      	strh	r3, [r7, #10]
  
  /* Reset the Output Polarity level */
  tmpccer &= (uint16_t)~TIM_CCER_CC2P;
 800323a:	89fb      	ldrh	r3, [r7, #14]
 800323c:	f023 0320 	bic.w	r3, r3, #32
 8003240:	81fb      	strh	r3, [r7, #14]
  /* Set the Output Compare Polarity */
  tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCPolarity << 4);
 8003242:	683b      	ldr	r3, [r7, #0]
 8003244:	899b      	ldrh	r3, [r3, #12]
 8003246:	011b      	lsls	r3, r3, #4
 8003248:	b29a      	uxth	r2, r3
 800324a:	89fb      	ldrh	r3, [r7, #14]
 800324c:	4313      	orrs	r3, r2
 800324e:	81fb      	strh	r3, [r7, #14]
  
  /* Set the Output State */
  tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputState << 4);
 8003250:	683b      	ldr	r3, [r7, #0]
 8003252:	885b      	ldrh	r3, [r3, #2]
 8003254:	011b      	lsls	r3, r3, #4
 8003256:	b29a      	uxth	r2, r3
 8003258:	89fb      	ldrh	r3, [r7, #14]
 800325a:	4313      	orrs	r3, r2
 800325c:	81fb      	strh	r3, [r7, #14]
    
  if((TIMx == TIM1) || (TIMx == TIM8))
 800325e:	687a      	ldr	r2, [r7, #4]
 8003260:	2300      	movs	r3, #0
 8003262:	f2c4 0301 	movt	r3, #16385	; 0x4001
 8003266:	429a      	cmp	r2, r3
 8003268:	d006      	beq.n	8003278 <TIM_OC2Init+0x94>
 800326a:	687a      	ldr	r2, [r7, #4]
 800326c:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8003270:	f2c4 0301 	movt	r3, #16385	; 0x4001
 8003274:	429a      	cmp	r2, r3
 8003276:	d12b      	bne.n	80032d0 <TIM_OC2Init+0xec>
    assert_param(IS_TIM_OCN_POLARITY(TIM_OCInitStruct->TIM_OCNPolarity));
    assert_param(IS_TIM_OCNIDLE_STATE(TIM_OCInitStruct->TIM_OCNIdleState));
    assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
    
    /* Reset the Output N Polarity level */
    tmpccer &= (uint16_t)~TIM_CCER_CC2NP;
 8003278:	89fb      	ldrh	r3, [r7, #14]
 800327a:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 800327e:	81fb      	strh	r3, [r7, #14]
    /* Set the Output N Polarity */
    tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCNPolarity << 4);
 8003280:	683b      	ldr	r3, [r7, #0]
 8003282:	89db      	ldrh	r3, [r3, #14]
 8003284:	011b      	lsls	r3, r3, #4
 8003286:	b29a      	uxth	r2, r3
 8003288:	89fb      	ldrh	r3, [r7, #14]
 800328a:	4313      	orrs	r3, r2
 800328c:	81fb      	strh	r3, [r7, #14]
    /* Reset the Output N State */
    tmpccer &= (uint16_t)~TIM_CCER_CC2NE;
 800328e:	89fb      	ldrh	r3, [r7, #14]
 8003290:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 8003294:	81fb      	strh	r3, [r7, #14]
    
    /* Set the Output N State */
    tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputNState << 4);
 8003296:	683b      	ldr	r3, [r7, #0]
 8003298:	889b      	ldrh	r3, [r3, #4]
 800329a:	011b      	lsls	r3, r3, #4
 800329c:	b29a      	uxth	r2, r3
 800329e:	89fb      	ldrh	r3, [r7, #14]
 80032a0:	4313      	orrs	r3, r2
 80032a2:	81fb      	strh	r3, [r7, #14]
    /* Reset the Output Compare and Output Compare N IDLE State */
    tmpcr2 &= (uint16_t)~TIM_CR2_OIS2;
 80032a4:	89bb      	ldrh	r3, [r7, #12]
 80032a6:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 80032aa:	81bb      	strh	r3, [r7, #12]
    tmpcr2 &= (uint16_t)~TIM_CR2_OIS2N;
 80032ac:	89bb      	ldrh	r3, [r7, #12]
 80032ae:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
 80032b2:	81bb      	strh	r3, [r7, #12]
    /* Set the Output Idle state */
    tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCIdleState << 2);
 80032b4:	683b      	ldr	r3, [r7, #0]
 80032b6:	8a1b      	ldrh	r3, [r3, #16]
 80032b8:	009b      	lsls	r3, r3, #2
 80032ba:	b29a      	uxth	r2, r3
 80032bc:	89bb      	ldrh	r3, [r7, #12]
 80032be:	4313      	orrs	r3, r2
 80032c0:	81bb      	strh	r3, [r7, #12]
    /* Set the Output N Idle state */
    tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCNIdleState << 2);
 80032c2:	683b      	ldr	r3, [r7, #0]
 80032c4:	8a5b      	ldrh	r3, [r3, #18]
 80032c6:	009b      	lsls	r3, r3, #2
 80032c8:	b29a      	uxth	r2, r3
 80032ca:	89bb      	ldrh	r3, [r7, #12]
 80032cc:	4313      	orrs	r3, r2
 80032ce:	81bb      	strh	r3, [r7, #12]
  }
  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
 80032d0:	687b      	ldr	r3, [r7, #4]
 80032d2:	89ba      	ldrh	r2, [r7, #12]
 80032d4:	809a      	strh	r2, [r3, #4]
  
  /* Write to TIMx CCMR1 */
  TIMx->CCMR1 = tmpccmrx;
 80032d6:	687b      	ldr	r3, [r7, #4]
 80032d8:	897a      	ldrh	r2, [r7, #10]
 80032da:	831a      	strh	r2, [r3, #24]
  
  /* Set the Capture Compare Register value */
  TIMx->CCR2 = TIM_OCInitStruct->TIM_Pulse;
 80032dc:	683b      	ldr	r3, [r7, #0]
 80032de:	689a      	ldr	r2, [r3, #8]
 80032e0:	687b      	ldr	r3, [r7, #4]
 80032e2:	639a      	str	r2, [r3, #56]	; 0x38
  
  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
 80032e4:	687b      	ldr	r3, [r7, #4]
 80032e6:	89fa      	ldrh	r2, [r7, #14]
 80032e8:	841a      	strh	r2, [r3, #32]
}
 80032ea:	3714      	adds	r7, #20
 80032ec:	46bd      	mov	sp, r7
 80032ee:	f85d 7b04 	ldr.w	r7, [sp], #4
 80032f2:	4770      	bx	lr

080032f4 <TIM_OC1PreloadConfig>:
  *            @arg TIM_OCPreload_Enable
  *            @arg TIM_OCPreload_Disable
  * @retval None
  */
void TIM_OC1PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload)
{
 80032f4:	b480      	push	{r7}
 80032f6:	b085      	sub	sp, #20
 80032f8:	af00      	add	r7, sp, #0
 80032fa:	6078      	str	r0, [r7, #4]
 80032fc:	460b      	mov	r3, r1
 80032fe:	807b      	strh	r3, [r7, #2]
  uint16_t tmpccmr1 = 0;
 8003300:	2300      	movs	r3, #0
 8003302:	81fb      	strh	r3, [r7, #14]

  /* Check the parameters */
  assert_param(IS_TIM_LIST1_PERIPH(TIMx));
  assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));

  tmpccmr1 = TIMx->CCMR1;
 8003304:	687b      	ldr	r3, [r7, #4]
 8003306:	8b1b      	ldrh	r3, [r3, #24]
 8003308:	81fb      	strh	r3, [r7, #14]

  /* Reset the OC1PE Bit */
  tmpccmr1 &= (uint16_t)(~TIM_CCMR1_OC1PE);
 800330a:	89fb      	ldrh	r3, [r7, #14]
 800330c:	f023 0308 	bic.w	r3, r3, #8
 8003310:	81fb      	strh	r3, [r7, #14]

  /* Enable or Disable the Output Compare Preload feature */
  tmpccmr1 |= TIM_OCPreload;
 8003312:	89fa      	ldrh	r2, [r7, #14]
 8003314:	887b      	ldrh	r3, [r7, #2]
 8003316:	4313      	orrs	r3, r2
 8003318:	81fb      	strh	r3, [r7, #14]

  /* Write to TIMx CCMR1 register */
  TIMx->CCMR1 = tmpccmr1;
 800331a:	687b      	ldr	r3, [r7, #4]
 800331c:	89fa      	ldrh	r2, [r7, #14]
 800331e:	831a      	strh	r2, [r3, #24]
}
 8003320:	3714      	adds	r7, #20
 8003322:	46bd      	mov	sp, r7
 8003324:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003328:	4770      	bx	lr
 800332a:	bf00      	nop

0800332c <TIM_OC2PreloadConfig>:
  *            @arg TIM_OCPreload_Enable
  *            @arg TIM_OCPreload_Disable
  * @retval None
  */
void TIM_OC2PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload)
{
 800332c:	b480      	push	{r7}
 800332e:	b085      	sub	sp, #20
 8003330:	af00      	add	r7, sp, #0
 8003332:	6078      	str	r0, [r7, #4]
 8003334:	460b      	mov	r3, r1
 8003336:	807b      	strh	r3, [r7, #2]
  uint16_t tmpccmr1 = 0;
 8003338:	2300      	movs	r3, #0
 800333a:	81fb      	strh	r3, [r7, #14]

  /* Check the parameters */
  assert_param(IS_TIM_LIST2_PERIPH(TIMx));
  assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));

  tmpccmr1 = TIMx->CCMR1;
 800333c:	687b      	ldr	r3, [r7, #4]
 800333e:	8b1b      	ldrh	r3, [r3, #24]
 8003340:	81fb      	strh	r3, [r7, #14]

  /* Reset the OC2PE Bit */
  tmpccmr1 &= (uint16_t)(~TIM_CCMR1_OC2PE);
 8003342:	89fb      	ldrh	r3, [r7, #14]
 8003344:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
 8003348:	81fb      	strh	r3, [r7, #14]

  /* Enable or Disable the Output Compare Preload feature */
  tmpccmr1 |= (uint16_t)(TIM_OCPreload << 8);
 800334a:	887b      	ldrh	r3, [r7, #2]
 800334c:	021b      	lsls	r3, r3, #8
 800334e:	b29a      	uxth	r2, r3
 8003350:	89fb      	ldrh	r3, [r7, #14]
 8003352:	4313      	orrs	r3, r2
 8003354:	81fb      	strh	r3, [r7, #14]

  /* Write to TIMx CCMR1 register */
  TIMx->CCMR1 = tmpccmr1;
 8003356:	687b      	ldr	r3, [r7, #4]
 8003358:	89fa      	ldrh	r2, [r7, #14]
 800335a:	831a      	strh	r2, [r3, #24]
}
 800335c:	3714      	adds	r7, #20
 800335e:	46bd      	mov	sp, r7
 8003360:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003364:	4770      	bx	lr
 8003366:	bf00      	nop

08003368 <USART_Init>:
  * @param  USART_InitStruct: pointer to a USART_InitTypeDef structure that contains
  *         the configuration information for the specified USART peripheral.
  * @retval None
  */
void USART_Init(USART_TypeDef* USARTx, USART_InitTypeDef* USART_InitStruct)
{
 8003368:	b580      	push	{r7, lr}
 800336a:	b08a      	sub	sp, #40	; 0x28
 800336c:	af00      	add	r7, sp, #0
 800336e:	6078      	str	r0, [r7, #4]
 8003370:	6039      	str	r1, [r7, #0]
  uint32_t tmpreg = 0x00, apbclock = 0x00;
 8003372:	2300      	movs	r3, #0
 8003374:	627b      	str	r3, [r7, #36]	; 0x24
 8003376:	2300      	movs	r3, #0
 8003378:	623b      	str	r3, [r7, #32]
  uint32_t integerdivider = 0x00;
 800337a:	2300      	movs	r3, #0
 800337c:	61fb      	str	r3, [r7, #28]
  uint32_t fractionaldivider = 0x00;
 800337e:	2300      	movs	r3, #0
 8003380:	61bb      	str	r3, [r7, #24]
  {
    assert_param(IS_USART_1236_PERIPH(USARTx));
  }

/*---------------------------- USART CR2 Configuration -----------------------*/
  tmpreg = USARTx->CR2;
 8003382:	687b      	ldr	r3, [r7, #4]
 8003384:	8a1b      	ldrh	r3, [r3, #16]
 8003386:	b29b      	uxth	r3, r3
 8003388:	627b      	str	r3, [r7, #36]	; 0x24

  /* Clear STOP[13:12] bits */
  tmpreg &= (uint32_t)~((uint32_t)USART_CR2_STOP);
 800338a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800338c:	f423 5340 	bic.w	r3, r3, #12288	; 0x3000
 8003390:	627b      	str	r3, [r7, #36]	; 0x24

  /* Configure the USART Stop Bits, Clock, CPOL, CPHA and LastBit :
      Set STOP[13:12] bits according to USART_StopBits value */
  tmpreg |= (uint32_t)USART_InitStruct->USART_StopBits;
 8003392:	683b      	ldr	r3, [r7, #0]
 8003394:	88db      	ldrh	r3, [r3, #6]
 8003396:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8003398:	4313      	orrs	r3, r2
 800339a:	627b      	str	r3, [r7, #36]	; 0x24
  
  /* Write to USART CR2 */
  USARTx->CR2 = (uint16_t)tmpreg;
 800339c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800339e:	b29a      	uxth	r2, r3
 80033a0:	687b      	ldr	r3, [r7, #4]
 80033a2:	821a      	strh	r2, [r3, #16]

/*---------------------------- USART CR1 Configuration -----------------------*/
  tmpreg = USARTx->CR1;
 80033a4:	687b      	ldr	r3, [r7, #4]
 80033a6:	899b      	ldrh	r3, [r3, #12]
 80033a8:	b29b      	uxth	r3, r3
 80033aa:	627b      	str	r3, [r7, #36]	; 0x24

  /* Clear M, PCE, PS, TE and RE bits */
  tmpreg &= (uint32_t)~((uint32_t)CR1_CLEAR_MASK);
 80033ac:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80033ae:	f423 53b0 	bic.w	r3, r3, #5632	; 0x1600
 80033b2:	f023 030c 	bic.w	r3, r3, #12
 80033b6:	627b      	str	r3, [r7, #36]	; 0x24

  /* Configure the USART Word Length, Parity and mode: 
     Set the M bits according to USART_WordLength value 
     Set PCE and PS bits according to USART_Parity value
     Set TE and RE bits according to USART_Mode value */
  tmpreg |= (uint32_t)USART_InitStruct->USART_WordLength | USART_InitStruct->USART_Parity |
 80033b8:	683b      	ldr	r3, [r7, #0]
 80033ba:	889a      	ldrh	r2, [r3, #4]
 80033bc:	683b      	ldr	r3, [r7, #0]
 80033be:	891b      	ldrh	r3, [r3, #8]
 80033c0:	4313      	orrs	r3, r2
 80033c2:	b29a      	uxth	r2, r3
            USART_InitStruct->USART_Mode;
 80033c4:	683b      	ldr	r3, [r7, #0]
 80033c6:	895b      	ldrh	r3, [r3, #10]

  /* Configure the USART Word Length, Parity and mode: 
     Set the M bits according to USART_WordLength value 
     Set PCE and PS bits according to USART_Parity value
     Set TE and RE bits according to USART_Mode value */
  tmpreg |= (uint32_t)USART_InitStruct->USART_WordLength | USART_InitStruct->USART_Parity |
 80033c8:	4313      	orrs	r3, r2
 80033ca:	b29b      	uxth	r3, r3
 80033cc:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 80033ce:	4313      	orrs	r3, r2
 80033d0:	627b      	str	r3, [r7, #36]	; 0x24
            USART_InitStruct->USART_Mode;

  /* Write to USART CR1 */
  USARTx->CR1 = (uint16_t)tmpreg;
 80033d2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80033d4:	b29a      	uxth	r2, r3
 80033d6:	687b      	ldr	r3, [r7, #4]
 80033d8:	819a      	strh	r2, [r3, #12]

/*---------------------------- USART CR3 Configuration -----------------------*/  
  tmpreg = USARTx->CR3;
 80033da:	687b      	ldr	r3, [r7, #4]
 80033dc:	8a9b      	ldrh	r3, [r3, #20]
 80033de:	b29b      	uxth	r3, r3
 80033e0:	627b      	str	r3, [r7, #36]	; 0x24

  /* Clear CTSE and RTSE bits */
  tmpreg &= (uint32_t)~((uint32_t)CR3_CLEAR_MASK);
 80033e2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80033e4:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 80033e8:	627b      	str	r3, [r7, #36]	; 0x24

  /* Configure the USART HFC : 
      Set CTSE and RTSE bits according to USART_HardwareFlowControl value */
  tmpreg |= USART_InitStruct->USART_HardwareFlowControl;
 80033ea:	683b      	ldr	r3, [r7, #0]
 80033ec:	899b      	ldrh	r3, [r3, #12]
 80033ee:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 80033f0:	4313      	orrs	r3, r2
 80033f2:	627b      	str	r3, [r7, #36]	; 0x24

  /* Write to USART CR3 */
  USARTx->CR3 = (uint16_t)tmpreg;
 80033f4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80033f6:	b29a      	uxth	r2, r3
 80033f8:	687b      	ldr	r3, [r7, #4]
 80033fa:	829a      	strh	r2, [r3, #20]

/*---------------------------- USART BRR Configuration -----------------------*/
  /* Configure the USART Baud Rate */
  RCC_GetClocksFreq(&RCC_ClocksStatus);
 80033fc:	f107 0308 	add.w	r3, r7, #8
 8003400:	4618      	mov	r0, r3
 8003402:	f7ff fc9b 	bl	8002d3c <RCC_GetClocksFreq>

  if ((USARTx == USART1) || (USARTx == USART6))
 8003406:	687a      	ldr	r2, [r7, #4]
 8003408:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 800340c:	f2c4 0301 	movt	r3, #16385	; 0x4001
 8003410:	429a      	cmp	r2, r3
 8003412:	d006      	beq.n	8003422 <USART_Init+0xba>
 8003414:	687a      	ldr	r2, [r7, #4]
 8003416:	f44f 53a0 	mov.w	r3, #5120	; 0x1400
 800341a:	f2c4 0301 	movt	r3, #16385	; 0x4001
 800341e:	429a      	cmp	r2, r3
 8003420:	d102      	bne.n	8003428 <USART_Init+0xc0>
  {
    apbclock = RCC_ClocksStatus.PCLK2_Frequency;
 8003422:	697b      	ldr	r3, [r7, #20]
 8003424:	623b      	str	r3, [r7, #32]
 8003426:	e001      	b.n	800342c <USART_Init+0xc4>
  }
  else
  {
    apbclock = RCC_ClocksStatus.PCLK1_Frequency;
 8003428:	693b      	ldr	r3, [r7, #16]
 800342a:	623b      	str	r3, [r7, #32]
  }
  
  /* Determine the integer part */
  if ((USARTx->CR1 & USART_CR1_OVER8) != 0)
 800342c:	687b      	ldr	r3, [r7, #4]
 800342e:	899b      	ldrh	r3, [r3, #12]
 8003430:	b29b      	uxth	r3, r3
 8003432:	b29b      	uxth	r3, r3
 8003434:	b21b      	sxth	r3, r3
 8003436:	2b00      	cmp	r3, #0
 8003438:	da0c      	bge.n	8003454 <USART_Init+0xec>
  {
    /* Integer part computing in case Oversampling mode is 8 Samples */
    integerdivider = ((25 * apbclock) / (2 * (USART_InitStruct->USART_BaudRate)));    
 800343a:	6a3a      	ldr	r2, [r7, #32]
 800343c:	4613      	mov	r3, r2
 800343e:	009b      	lsls	r3, r3, #2
 8003440:	4413      	add	r3, r2
 8003442:	009a      	lsls	r2, r3, #2
 8003444:	441a      	add	r2, r3
 8003446:	683b      	ldr	r3, [r7, #0]
 8003448:	681b      	ldr	r3, [r3, #0]
 800344a:	005b      	lsls	r3, r3, #1
 800344c:	fbb2 f3f3 	udiv	r3, r2, r3
 8003450:	61fb      	str	r3, [r7, #28]
 8003452:	e00b      	b.n	800346c <USART_Init+0x104>
  }
  else /* if ((USARTx->CR1 & USART_CR1_OVER8) == 0) */
  {
    /* Integer part computing in case Oversampling mode is 16 Samples */
    integerdivider = ((25 * apbclock) / (4 * (USART_InitStruct->USART_BaudRate)));    
 8003454:	6a3a      	ldr	r2, [r7, #32]
 8003456:	4613      	mov	r3, r2
 8003458:	009b      	lsls	r3, r3, #2
 800345a:	4413      	add	r3, r2
 800345c:	009a      	lsls	r2, r3, #2
 800345e:	441a      	add	r2, r3
 8003460:	683b      	ldr	r3, [r7, #0]
 8003462:	681b      	ldr	r3, [r3, #0]
 8003464:	009b      	lsls	r3, r3, #2
 8003466:	fbb2 f3f3 	udiv	r3, r2, r3
 800346a:	61fb      	str	r3, [r7, #28]
  }
  tmpreg = (integerdivider / 100) << 4;
 800346c:	69fa      	ldr	r2, [r7, #28]
 800346e:	f248 531f 	movw	r3, #34079	; 0x851f
 8003472:	f2c5 13eb 	movt	r3, #20971	; 0x51eb
 8003476:	fba3 1302 	umull	r1, r3, r3, r2
 800347a:	095b      	lsrs	r3, r3, #5
 800347c:	011b      	lsls	r3, r3, #4
 800347e:	627b      	str	r3, [r7, #36]	; 0x24

  /* Determine the fractional part */
  fractionaldivider = integerdivider - (100 * (tmpreg >> 4));
 8003480:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8003482:	091b      	lsrs	r3, r3, #4
 8003484:	2264      	movs	r2, #100	; 0x64
 8003486:	fb02 f303 	mul.w	r3, r2, r3
 800348a:	69fa      	ldr	r2, [r7, #28]
 800348c:	1ad3      	subs	r3, r2, r3
 800348e:	61bb      	str	r3, [r7, #24]

  /* Implement the fractional part in the register */
  if ((USARTx->CR1 & USART_CR1_OVER8) != 0)
 8003490:	687b      	ldr	r3, [r7, #4]
 8003492:	899b      	ldrh	r3, [r3, #12]
 8003494:	b29b      	uxth	r3, r3
 8003496:	b29b      	uxth	r3, r3
 8003498:	b21b      	sxth	r3, r3
 800349a:	2b00      	cmp	r3, #0
 800349c:	da10      	bge.n	80034c0 <USART_Init+0x158>
  {
    tmpreg |= ((((fractionaldivider * 8) + 50) / 100)) & ((uint8_t)0x07);
 800349e:	69bb      	ldr	r3, [r7, #24]
 80034a0:	00db      	lsls	r3, r3, #3
 80034a2:	f103 0232 	add.w	r2, r3, #50	; 0x32
 80034a6:	f248 531f 	movw	r3, #34079	; 0x851f
 80034aa:	f2c5 13eb 	movt	r3, #20971	; 0x51eb
 80034ae:	fba3 1302 	umull	r1, r3, r3, r2
 80034b2:	095b      	lsrs	r3, r3, #5
 80034b4:	f003 0307 	and.w	r3, r3, #7
 80034b8:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 80034ba:	4313      	orrs	r3, r2
 80034bc:	627b      	str	r3, [r7, #36]	; 0x24
 80034be:	e00f      	b.n	80034e0 <USART_Init+0x178>
  }
  else /* if ((USARTx->CR1 & USART_CR1_OVER8) == 0) */
  {
    tmpreg |= ((((fractionaldivider * 16) + 50) / 100)) & ((uint8_t)0x0F);
 80034c0:	69bb      	ldr	r3, [r7, #24]
 80034c2:	011b      	lsls	r3, r3, #4
 80034c4:	f103 0232 	add.w	r2, r3, #50	; 0x32
 80034c8:	f248 531f 	movw	r3, #34079	; 0x851f
 80034cc:	f2c5 13eb 	movt	r3, #20971	; 0x51eb
 80034d0:	fba3 1302 	umull	r1, r3, r3, r2
 80034d4:	095b      	lsrs	r3, r3, #5
 80034d6:	f003 030f 	and.w	r3, r3, #15
 80034da:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 80034dc:	4313      	orrs	r3, r2
 80034de:	627b      	str	r3, [r7, #36]	; 0x24
  }
  
  /* Write to USART BRR register */
  USARTx->BRR = (uint16_t)tmpreg;
 80034e0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80034e2:	b29a      	uxth	r2, r3
 80034e4:	687b      	ldr	r3, [r7, #4]
 80034e6:	811a      	strh	r2, [r3, #8]
}
 80034e8:	3728      	adds	r7, #40	; 0x28
 80034ea:	46bd      	mov	sp, r7
 80034ec:	bd80      	pop	{r7, pc}
 80034ee:	bf00      	nop

080034f0 <USART_Cmd>:
  * @param  NewState: new state of the USARTx peripheral.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void USART_Cmd(USART_TypeDef* USARTx, FunctionalState NewState)
{
 80034f0:	b480      	push	{r7}
 80034f2:	b083      	sub	sp, #12
 80034f4:	af00      	add	r7, sp, #0
 80034f6:	6078      	str	r0, [r7, #4]
 80034f8:	460b      	mov	r3, r1
 80034fa:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 80034fc:	78fb      	ldrb	r3, [r7, #3]
 80034fe:	2b00      	cmp	r3, #0
 8003500:	d008      	beq.n	8003514 <USART_Cmd+0x24>
  {
    /* Enable the selected USART by setting the UE bit in the CR1 register */
    USARTx->CR1 |= USART_CR1_UE;
 8003502:	687b      	ldr	r3, [r7, #4]
 8003504:	899b      	ldrh	r3, [r3, #12]
 8003506:	b29b      	uxth	r3, r3
 8003508:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 800350c:	b29a      	uxth	r2, r3
 800350e:	687b      	ldr	r3, [r7, #4]
 8003510:	819a      	strh	r2, [r3, #12]
 8003512:	e007      	b.n	8003524 <USART_Cmd+0x34>
  }
  else
  {
    /* Disable the selected USART by clearing the UE bit in the CR1 register */
    USARTx->CR1 &= (uint16_t)~((uint16_t)USART_CR1_UE);
 8003514:	687b      	ldr	r3, [r7, #4]
 8003516:	899b      	ldrh	r3, [r3, #12]
 8003518:	b29b      	uxth	r3, r3
 800351a:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
 800351e:	b29a      	uxth	r2, r3
 8003520:	687b      	ldr	r3, [r7, #4]
 8003522:	819a      	strh	r2, [r3, #12]
  }
}
 8003524:	370c      	adds	r7, #12
 8003526:	46bd      	mov	sp, r7
 8003528:	f85d 7b04 	ldr.w	r7, [sp], #4
 800352c:	4770      	bx	lr
 800352e:	bf00      	nop

08003530 <USART_SendData>:
  *         UART peripheral.
  * @param  Data: the data to transmit.
  * @retval None
  */
void USART_SendData(USART_TypeDef* USARTx, uint16_t Data)
{
 8003530:	b480      	push	{r7}
 8003532:	b083      	sub	sp, #12
 8003534:	af00      	add	r7, sp, #0
 8003536:	6078      	str	r0, [r7, #4]
 8003538:	460b      	mov	r3, r1
 800353a:	807b      	strh	r3, [r7, #2]
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_USART_DATA(Data)); 
    
  /* Transmit Data */
  USARTx->DR = (Data & (uint16_t)0x01FF);
 800353c:	887b      	ldrh	r3, [r7, #2]
 800353e:	f3c3 0308 	ubfx	r3, r3, #0, #9
 8003542:	b29a      	uxth	r2, r3
 8003544:	687b      	ldr	r3, [r7, #4]
 8003546:	809a      	strh	r2, [r3, #4]
}
 8003548:	370c      	adds	r7, #12
 800354a:	46bd      	mov	sp, r7
 800354c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003550:	4770      	bx	lr
 8003552:	bf00      	nop

08003554 <USART_ITConfig>:
  * @param  NewState: new state of the specified USARTx interrupts.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void USART_ITConfig(USART_TypeDef* USARTx, uint16_t USART_IT, FunctionalState NewState)
{
 8003554:	b480      	push	{r7}
 8003556:	b087      	sub	sp, #28
 8003558:	af00      	add	r7, sp, #0
 800355a:	6078      	str	r0, [r7, #4]
 800355c:	4613      	mov	r3, r2
 800355e:	460a      	mov	r2, r1
 8003560:	807a      	strh	r2, [r7, #2]
 8003562:	707b      	strb	r3, [r7, #1]
  uint32_t usartreg = 0x00, itpos = 0x00, itmask = 0x00;
 8003564:	2300      	movs	r3, #0
 8003566:	613b      	str	r3, [r7, #16]
 8003568:	2300      	movs	r3, #0
 800356a:	60fb      	str	r3, [r7, #12]
 800356c:	2300      	movs	r3, #0
 800356e:	60bb      	str	r3, [r7, #8]
  uint32_t usartxbase = 0x00;
 8003570:	2300      	movs	r3, #0
 8003572:	617b      	str	r3, [r7, #20]
  if (USART_IT == USART_IT_CTS)
  {
    assert_param(IS_USART_1236_PERIPH(USARTx));
  } 
    
  usartxbase = (uint32_t)USARTx;
 8003574:	687b      	ldr	r3, [r7, #4]
 8003576:	617b      	str	r3, [r7, #20]

  /* Get the USART register index */
  usartreg = (((uint8_t)USART_IT) >> 0x05);
 8003578:	887b      	ldrh	r3, [r7, #2]
 800357a:	b2db      	uxtb	r3, r3
 800357c:	095b      	lsrs	r3, r3, #5
 800357e:	b2db      	uxtb	r3, r3
 8003580:	613b      	str	r3, [r7, #16]

  /* Get the interrupt position */
  itpos = USART_IT & IT_MASK;
 8003582:	887b      	ldrh	r3, [r7, #2]
 8003584:	f003 031f 	and.w	r3, r3, #31
 8003588:	60fb      	str	r3, [r7, #12]
  itmask = (((uint32_t)0x01) << itpos);
 800358a:	68fb      	ldr	r3, [r7, #12]
 800358c:	2201      	movs	r2, #1
 800358e:	fa02 f303 	lsl.w	r3, r2, r3
 8003592:	60bb      	str	r3, [r7, #8]
    
  if (usartreg == 0x01) /* The IT is in CR1 register */
 8003594:	693b      	ldr	r3, [r7, #16]
 8003596:	2b01      	cmp	r3, #1
 8003598:	d103      	bne.n	80035a2 <USART_ITConfig+0x4e>
  {
    usartxbase += 0x0C;
 800359a:	697b      	ldr	r3, [r7, #20]
 800359c:	330c      	adds	r3, #12
 800359e:	617b      	str	r3, [r7, #20]
 80035a0:	e009      	b.n	80035b6 <USART_ITConfig+0x62>
  }
  else if (usartreg == 0x02) /* The IT is in CR2 register */
 80035a2:	693b      	ldr	r3, [r7, #16]
 80035a4:	2b02      	cmp	r3, #2
 80035a6:	d103      	bne.n	80035b0 <USART_ITConfig+0x5c>
  {
    usartxbase += 0x10;
 80035a8:	697b      	ldr	r3, [r7, #20]
 80035aa:	3310      	adds	r3, #16
 80035ac:	617b      	str	r3, [r7, #20]
 80035ae:	e002      	b.n	80035b6 <USART_ITConfig+0x62>
  }
  else /* The IT is in CR3 register */
  {
    usartxbase += 0x14; 
 80035b0:	697b      	ldr	r3, [r7, #20]
 80035b2:	3314      	adds	r3, #20
 80035b4:	617b      	str	r3, [r7, #20]
  }
  if (NewState != DISABLE)
 80035b6:	787b      	ldrb	r3, [r7, #1]
 80035b8:	2b00      	cmp	r3, #0
 80035ba:	d006      	beq.n	80035ca <USART_ITConfig+0x76>
  {
    *(__IO uint32_t*)usartxbase  |= itmask;
 80035bc:	697b      	ldr	r3, [r7, #20]
 80035be:	697a      	ldr	r2, [r7, #20]
 80035c0:	6811      	ldr	r1, [r2, #0]
 80035c2:	68ba      	ldr	r2, [r7, #8]
 80035c4:	430a      	orrs	r2, r1
 80035c6:	601a      	str	r2, [r3, #0]
 80035c8:	e006      	b.n	80035d8 <USART_ITConfig+0x84>
  }
  else
  {
    *(__IO uint32_t*)usartxbase &= ~itmask;
 80035ca:	697b      	ldr	r3, [r7, #20]
 80035cc:	697a      	ldr	r2, [r7, #20]
 80035ce:	6811      	ldr	r1, [r2, #0]
 80035d0:	68ba      	ldr	r2, [r7, #8]
 80035d2:	43d2      	mvns	r2, r2
 80035d4:	400a      	ands	r2, r1
 80035d6:	601a      	str	r2, [r3, #0]
  }
}
 80035d8:	371c      	adds	r7, #28
 80035da:	46bd      	mov	sp, r7
 80035dc:	f85d 7b04 	ldr.w	r7, [sp], #4
 80035e0:	4770      	bx	lr
 80035e2:	bf00      	nop

080035e4 <USART_GetITStatus>:
  *            @arg USART_IT_FE:   Framing Error interrupt
  *            @arg USART_IT_PE:   Parity Error interrupt
  * @retval The new state of USART_IT (SET or RESET).
  */
ITStatus USART_GetITStatus(USART_TypeDef* USARTx, uint16_t USART_IT)
{
 80035e4:	b480      	push	{r7}
 80035e6:	b087      	sub	sp, #28
 80035e8:	af00      	add	r7, sp, #0
 80035ea:	6078      	str	r0, [r7, #4]
 80035ec:	460b      	mov	r3, r1
 80035ee:	807b      	strh	r3, [r7, #2]
  uint32_t bitpos = 0x00, itmask = 0x00, usartreg = 0x00;
 80035f0:	2300      	movs	r3, #0
 80035f2:	60fb      	str	r3, [r7, #12]
 80035f4:	2300      	movs	r3, #0
 80035f6:	617b      	str	r3, [r7, #20]
 80035f8:	2300      	movs	r3, #0
 80035fa:	60bb      	str	r3, [r7, #8]
  ITStatus bitstatus = RESET;
 80035fc:	2300      	movs	r3, #0
 80035fe:	74fb      	strb	r3, [r7, #19]
  {
    assert_param(IS_USART_1236_PERIPH(USARTx));
  } 
    
  /* Get the USART register index */
  usartreg = (((uint8_t)USART_IT) >> 0x05);
 8003600:	887b      	ldrh	r3, [r7, #2]
 8003602:	b2db      	uxtb	r3, r3
 8003604:	095b      	lsrs	r3, r3, #5
 8003606:	b2db      	uxtb	r3, r3
 8003608:	60bb      	str	r3, [r7, #8]
  /* Get the interrupt position */
  itmask = USART_IT & IT_MASK;
 800360a:	887b      	ldrh	r3, [r7, #2]
 800360c:	f003 031f 	and.w	r3, r3, #31
 8003610:	617b      	str	r3, [r7, #20]
  itmask = (uint32_t)0x01 << itmask;
 8003612:	697b      	ldr	r3, [r7, #20]
 8003614:	2201      	movs	r2, #1
 8003616:	fa02 f303 	lsl.w	r3, r2, r3
 800361a:	617b      	str	r3, [r7, #20]
  
  if (usartreg == 0x01) /* The IT  is in CR1 register */
 800361c:	68bb      	ldr	r3, [r7, #8]
 800361e:	2b01      	cmp	r3, #1
 8003620:	d106      	bne.n	8003630 <USART_GetITStatus+0x4c>
  {
    itmask &= USARTx->CR1;
 8003622:	687b      	ldr	r3, [r7, #4]
 8003624:	899b      	ldrh	r3, [r3, #12]
 8003626:	b29b      	uxth	r3, r3
 8003628:	697a      	ldr	r2, [r7, #20]
 800362a:	4013      	ands	r3, r2
 800362c:	617b      	str	r3, [r7, #20]
 800362e:	e00f      	b.n	8003650 <USART_GetITStatus+0x6c>
  }
  else if (usartreg == 0x02) /* The IT  is in CR2 register */
 8003630:	68bb      	ldr	r3, [r7, #8]
 8003632:	2b02      	cmp	r3, #2
 8003634:	d106      	bne.n	8003644 <USART_GetITStatus+0x60>
  {
    itmask &= USARTx->CR2;
 8003636:	687b      	ldr	r3, [r7, #4]
 8003638:	8a1b      	ldrh	r3, [r3, #16]
 800363a:	b29b      	uxth	r3, r3
 800363c:	697a      	ldr	r2, [r7, #20]
 800363e:	4013      	ands	r3, r2
 8003640:	617b      	str	r3, [r7, #20]
 8003642:	e005      	b.n	8003650 <USART_GetITStatus+0x6c>
  }
  else /* The IT  is in CR3 register */
  {
    itmask &= USARTx->CR3;
 8003644:	687b      	ldr	r3, [r7, #4]
 8003646:	8a9b      	ldrh	r3, [r3, #20]
 8003648:	b29b      	uxth	r3, r3
 800364a:	697a      	ldr	r2, [r7, #20]
 800364c:	4013      	ands	r3, r2
 800364e:	617b      	str	r3, [r7, #20]
  }
  
  bitpos = USART_IT >> 0x08;
 8003650:	887b      	ldrh	r3, [r7, #2]
 8003652:	0a1b      	lsrs	r3, r3, #8
 8003654:	b29b      	uxth	r3, r3
 8003656:	60fb      	str	r3, [r7, #12]
  bitpos = (uint32_t)0x01 << bitpos;
 8003658:	68fb      	ldr	r3, [r7, #12]
 800365a:	2201      	movs	r2, #1
 800365c:	fa02 f303 	lsl.w	r3, r2, r3
 8003660:	60fb      	str	r3, [r7, #12]
  bitpos &= USARTx->SR;
 8003662:	687b      	ldr	r3, [r7, #4]
 8003664:	881b      	ldrh	r3, [r3, #0]
 8003666:	b29b      	uxth	r3, r3
 8003668:	68fa      	ldr	r2, [r7, #12]
 800366a:	4013      	ands	r3, r2
 800366c:	60fb      	str	r3, [r7, #12]
  if ((itmask != (uint16_t)RESET)&&(bitpos != (uint16_t)RESET))
 800366e:	697b      	ldr	r3, [r7, #20]
 8003670:	2b00      	cmp	r3, #0
 8003672:	d005      	beq.n	8003680 <USART_GetITStatus+0x9c>
 8003674:	68fb      	ldr	r3, [r7, #12]
 8003676:	2b00      	cmp	r3, #0
 8003678:	d002      	beq.n	8003680 <USART_GetITStatus+0x9c>
  {
    bitstatus = SET;
 800367a:	2301      	movs	r3, #1
 800367c:	74fb      	strb	r3, [r7, #19]
 800367e:	e001      	b.n	8003684 <USART_GetITStatus+0xa0>
  }
  else
  {
    bitstatus = RESET;
 8003680:	2300      	movs	r3, #0
 8003682:	74fb      	strb	r3, [r7, #19]
  }
  
  return bitstatus;  
 8003684:	7cfb      	ldrb	r3, [r7, #19]
}
 8003686:	4618      	mov	r0, r3
 8003688:	371c      	adds	r7, #28
 800368a:	46bd      	mov	sp, r7
 800368c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003690:	4770      	bx	lr
 8003692:	bf00      	nop

08003694 <atexit>:
 8003694:	4601      	mov	r1, r0
 8003696:	2000      	movs	r0, #0
 8003698:	4602      	mov	r2, r0
 800369a:	4603      	mov	r3, r0
 800369c:	f000 bb88 	b.w	8003db0 <__register_exitproc>

080036a0 <__libc_fini_array>:
 80036a0:	b538      	push	{r3, r4, r5, lr}
 80036a2:	f244 3464 	movw	r4, #17252	; 0x4364
 80036a6:	f244 3560 	movw	r5, #17248	; 0x4360
 80036aa:	f6c0 0500 	movt	r5, #2048	; 0x800
 80036ae:	f6c0 0400 	movt	r4, #2048	; 0x800
 80036b2:	1b64      	subs	r4, r4, r5
 80036b4:	10a4      	asrs	r4, r4, #2
 80036b6:	bf18      	it	ne
 80036b8:	eb05 0584 	addne.w	r5, r5, r4, lsl #2
 80036bc:	d005      	beq.n	80036ca <__libc_fini_array+0x2a>
 80036be:	3c01      	subs	r4, #1
 80036c0:	f855 3d04 	ldr.w	r3, [r5, #-4]!
 80036c4:	4798      	blx	r3
 80036c6:	2c00      	cmp	r4, #0
 80036c8:	d1f9      	bne.n	80036be <__libc_fini_array+0x1e>
 80036ca:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 80036ce:	f000 be3d 	b.w	800434c <_fini>
 80036d2:	bf00      	nop

080036d4 <__libc_init_array>:
 80036d4:	b570      	push	{r4, r5, r6, lr}
 80036d6:	f244 3658 	movw	r6, #17240	; 0x4358
 80036da:	f244 3558 	movw	r5, #17240	; 0x4358
 80036de:	f6c0 0500 	movt	r5, #2048	; 0x800
 80036e2:	f6c0 0600 	movt	r6, #2048	; 0x800
 80036e6:	1b76      	subs	r6, r6, r5
 80036e8:	10b6      	asrs	r6, r6, #2
 80036ea:	bf1c      	itt	ne
 80036ec:	3d04      	subne	r5, #4
 80036ee:	2400      	movne	r4, #0
 80036f0:	d005      	beq.n	80036fe <__libc_init_array+0x2a>
 80036f2:	3401      	adds	r4, #1
 80036f4:	f855 3f04 	ldr.w	r3, [r5, #4]!
 80036f8:	4798      	blx	r3
 80036fa:	42a6      	cmp	r6, r4
 80036fc:	d1f9      	bne.n	80036f2 <__libc_init_array+0x1e>
 80036fe:	f244 3660 	movw	r6, #17248	; 0x4360
 8003702:	f244 3558 	movw	r5, #17240	; 0x4358
 8003706:	f6c0 0500 	movt	r5, #2048	; 0x800
 800370a:	f6c0 0600 	movt	r6, #2048	; 0x800
 800370e:	1b76      	subs	r6, r6, r5
 8003710:	f000 fe16 	bl	8004340 <_init>
 8003714:	10b6      	asrs	r6, r6, #2
 8003716:	bf1c      	itt	ne
 8003718:	3d04      	subne	r5, #4
 800371a:	2400      	movne	r4, #0
 800371c:	d006      	beq.n	800372c <__libc_init_array+0x58>
 800371e:	3401      	adds	r4, #1
 8003720:	f855 3f04 	ldr.w	r3, [r5, #4]!
 8003724:	4798      	blx	r3
 8003726:	42a6      	cmp	r6, r4
 8003728:	d1f9      	bne.n	800371e <__libc_init_array+0x4a>
 800372a:	bd70      	pop	{r4, r5, r6, pc}
 800372c:	bd70      	pop	{r4, r5, r6, pc}
 800372e:	bf00      	nop

08003730 <malloc>:
 8003730:	f240 4370 	movw	r3, #1136	; 0x470
 8003734:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8003738:	4601      	mov	r1, r0
 800373a:	6818      	ldr	r0, [r3, #0]
 800373c:	f000 b808 	b.w	8003750 <_malloc_r>

08003740 <free>:
 8003740:	f240 4370 	movw	r3, #1136	; 0x470
 8003744:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8003748:	4601      	mov	r1, r0
 800374a:	6818      	ldr	r0, [r3, #0]
 800374c:	f000 bbe4 	b.w	8003f18 <_free_r>

08003750 <_malloc_r>:
 8003750:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8003754:	f101 050b 	add.w	r5, r1, #11
 8003758:	2d16      	cmp	r5, #22
 800375a:	bf87      	ittee	hi
 800375c:	f025 0507 	bichi.w	r5, r5, #7
 8003760:	0feb      	lsrhi	r3, r5, #31
 8003762:	2300      	movls	r3, #0
 8003764:	2510      	movls	r5, #16
 8003766:	428d      	cmp	r5, r1
 8003768:	bf2c      	ite	cs
 800376a:	4619      	movcs	r1, r3
 800376c:	f043 0101 	orrcc.w	r1, r3, #1
 8003770:	b083      	sub	sp, #12
 8003772:	4607      	mov	r7, r0
 8003774:	2900      	cmp	r1, #0
 8003776:	f040 80b5 	bne.w	80038e4 <_malloc_r+0x194>
 800377a:	f7fd fe0f 	bl	800139c <__malloc_lock>
 800377e:	f5b5 7ffc 	cmp.w	r5, #504	; 0x1f8
 8003782:	d21f      	bcs.n	80037c4 <_malloc_r+0x74>
 8003784:	f240 4674 	movw	r6, #1140	; 0x474
 8003788:	f2c2 0600 	movt	r6, #8192	; 0x2000
 800378c:	ea4f 0cd5 	mov.w	ip, r5, lsr #3
 8003790:	eb06 03cc 	add.w	r3, r6, ip, lsl #3
 8003794:	68dc      	ldr	r4, [r3, #12]
 8003796:	429c      	cmp	r4, r3
 8003798:	f000 81f4 	beq.w	8003b84 <_malloc_r+0x434>
 800379c:	6863      	ldr	r3, [r4, #4]
 800379e:	68e2      	ldr	r2, [r4, #12]
 80037a0:	68a1      	ldr	r1, [r4, #8]
 80037a2:	f023 0303 	bic.w	r3, r3, #3
 80037a6:	4423      	add	r3, r4
 80037a8:	4638      	mov	r0, r7
 80037aa:	685d      	ldr	r5, [r3, #4]
 80037ac:	60ca      	str	r2, [r1, #12]
 80037ae:	f045 0501 	orr.w	r5, r5, #1
 80037b2:	6091      	str	r1, [r2, #8]
 80037b4:	605d      	str	r5, [r3, #4]
 80037b6:	f7fd fdfb 	bl	80013b0 <__malloc_unlock>
 80037ba:	3408      	adds	r4, #8
 80037bc:	4620      	mov	r0, r4
 80037be:	b003      	add	sp, #12
 80037c0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80037c4:	ea5f 2c55 	movs.w	ip, r5, lsr #9
 80037c8:	bf04      	itt	eq
 80037ca:	217e      	moveq	r1, #126	; 0x7e
 80037cc:	f04f 0c3f 	moveq.w	ip, #63	; 0x3f
 80037d0:	f040 808f 	bne.w	80038f2 <_malloc_r+0x1a2>
 80037d4:	f240 4674 	movw	r6, #1140	; 0x474
 80037d8:	f2c2 0600 	movt	r6, #8192	; 0x2000
 80037dc:	eb06 0181 	add.w	r1, r6, r1, lsl #2
 80037e0:	68cc      	ldr	r4, [r1, #12]
 80037e2:	42a1      	cmp	r1, r4
 80037e4:	d106      	bne.n	80037f4 <_malloc_r+0xa4>
 80037e6:	e00d      	b.n	8003804 <_malloc_r+0xb4>
 80037e8:	2b00      	cmp	r3, #0
 80037ea:	f280 8163 	bge.w	8003ab4 <_malloc_r+0x364>
 80037ee:	68e4      	ldr	r4, [r4, #12]
 80037f0:	42a1      	cmp	r1, r4
 80037f2:	d007      	beq.n	8003804 <_malloc_r+0xb4>
 80037f4:	6862      	ldr	r2, [r4, #4]
 80037f6:	f022 0203 	bic.w	r2, r2, #3
 80037fa:	1b53      	subs	r3, r2, r5
 80037fc:	2b0f      	cmp	r3, #15
 80037fe:	ddf3      	ble.n	80037e8 <_malloc_r+0x98>
 8003800:	f10c 3cff 	add.w	ip, ip, #4294967295	; 0xffffffff
 8003804:	f10c 0c01 	add.w	ip, ip, #1
 8003808:	f240 4374 	movw	r3, #1140	; 0x474
 800380c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8003810:	6934      	ldr	r4, [r6, #16]
 8003812:	f103 0e08 	add.w	lr, r3, #8
 8003816:	4574      	cmp	r4, lr
 8003818:	bf08      	it	eq
 800381a:	685a      	ldreq	r2, [r3, #4]
 800381c:	d022      	beq.n	8003864 <_malloc_r+0x114>
 800381e:	6861      	ldr	r1, [r4, #4]
 8003820:	f021 0103 	bic.w	r1, r1, #3
 8003824:	1b4a      	subs	r2, r1, r5
 8003826:	2a0f      	cmp	r2, #15
 8003828:	f300 8190 	bgt.w	8003b4c <_malloc_r+0x3fc>
 800382c:	2a00      	cmp	r2, #0
 800382e:	f8c3 e014 	str.w	lr, [r3, #20]
 8003832:	f8c3 e010 	str.w	lr, [r3, #16]
 8003836:	da67      	bge.n	8003908 <_malloc_r+0x1b8>
 8003838:	f5b1 7f00 	cmp.w	r1, #512	; 0x200
 800383c:	f080 815f 	bcs.w	8003afe <_malloc_r+0x3ae>
 8003840:	08c9      	lsrs	r1, r1, #3
 8003842:	eb03 00c1 	add.w	r0, r3, r1, lsl #3
 8003846:	ea4f 08a1 	mov.w	r8, r1, asr #2
 800384a:	685a      	ldr	r2, [r3, #4]
 800384c:	6881      	ldr	r1, [r0, #8]
 800384e:	60e0      	str	r0, [r4, #12]
 8003850:	f04f 0901 	mov.w	r9, #1
 8003854:	fa09 f808 	lsl.w	r8, r9, r8
 8003858:	ea48 0202 	orr.w	r2, r8, r2
 800385c:	60a1      	str	r1, [r4, #8]
 800385e:	605a      	str	r2, [r3, #4]
 8003860:	6084      	str	r4, [r0, #8]
 8003862:	60cc      	str	r4, [r1, #12]
 8003864:	ea4f 03ac 	mov.w	r3, ip, asr #2
 8003868:	2001      	movs	r0, #1
 800386a:	4098      	lsls	r0, r3
 800386c:	4290      	cmp	r0, r2
 800386e:	d858      	bhi.n	8003922 <_malloc_r+0x1d2>
 8003870:	4202      	tst	r2, r0
 8003872:	d106      	bne.n	8003882 <_malloc_r+0x132>
 8003874:	f02c 0c03 	bic.w	ip, ip, #3
 8003878:	0040      	lsls	r0, r0, #1
 800387a:	4202      	tst	r2, r0
 800387c:	f10c 0c04 	add.w	ip, ip, #4
 8003880:	d0fa      	beq.n	8003878 <_malloc_r+0x128>
 8003882:	eb06 08cc 	add.w	r8, r6, ip, lsl #3
 8003886:	4644      	mov	r4, r8
 8003888:	46e1      	mov	r9, ip
 800388a:	68e3      	ldr	r3, [r4, #12]
 800388c:	429c      	cmp	r4, r3
 800388e:	d107      	bne.n	80038a0 <_malloc_r+0x150>
 8003890:	e16f      	b.n	8003b72 <_malloc_r+0x422>
 8003892:	2a00      	cmp	r2, #0
 8003894:	f280 8180 	bge.w	8003b98 <_malloc_r+0x448>
 8003898:	68db      	ldr	r3, [r3, #12]
 800389a:	429c      	cmp	r4, r3
 800389c:	f000 8169 	beq.w	8003b72 <_malloc_r+0x422>
 80038a0:	6859      	ldr	r1, [r3, #4]
 80038a2:	f021 0103 	bic.w	r1, r1, #3
 80038a6:	1b4a      	subs	r2, r1, r5
 80038a8:	2a0f      	cmp	r2, #15
 80038aa:	ddf2      	ble.n	8003892 <_malloc_r+0x142>
 80038ac:	461c      	mov	r4, r3
 80038ae:	f8d3 c00c 	ldr.w	ip, [r3, #12]
 80038b2:	f854 8f08 	ldr.w	r8, [r4, #8]!
 80038b6:	1959      	adds	r1, r3, r5
 80038b8:	f045 0901 	orr.w	r9, r5, #1
 80038bc:	f042 0501 	orr.w	r5, r2, #1
 80038c0:	f8c3 9004 	str.w	r9, [r3, #4]
 80038c4:	4638      	mov	r0, r7
 80038c6:	f8c8 c00c 	str.w	ip, [r8, #12]
 80038ca:	f8cc 8008 	str.w	r8, [ip, #8]
 80038ce:	6171      	str	r1, [r6, #20]
 80038d0:	6131      	str	r1, [r6, #16]
 80038d2:	f8c1 e00c 	str.w	lr, [r1, #12]
 80038d6:	f8c1 e008 	str.w	lr, [r1, #8]
 80038da:	604d      	str	r5, [r1, #4]
 80038dc:	508a      	str	r2, [r1, r2]
 80038de:	f7fd fd67 	bl	80013b0 <__malloc_unlock>
 80038e2:	e76b      	b.n	80037bc <_malloc_r+0x6c>
 80038e4:	230c      	movs	r3, #12
 80038e6:	2400      	movs	r4, #0
 80038e8:	6003      	str	r3, [r0, #0]
 80038ea:	4620      	mov	r0, r4
 80038ec:	b003      	add	sp, #12
 80038ee:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80038f2:	f1bc 0f04 	cmp.w	ip, #4
 80038f6:	f200 80ee 	bhi.w	8003ad6 <_malloc_r+0x386>
 80038fa:	ea4f 1c95 	mov.w	ip, r5, lsr #6
 80038fe:	f10c 0c38 	add.w	ip, ip, #56	; 0x38
 8003902:	ea4f 014c 	mov.w	r1, ip, lsl #1
 8003906:	e765      	b.n	80037d4 <_malloc_r+0x84>
 8003908:	4421      	add	r1, r4
 800390a:	4638      	mov	r0, r7
 800390c:	684b      	ldr	r3, [r1, #4]
 800390e:	f043 0301 	orr.w	r3, r3, #1
 8003912:	604b      	str	r3, [r1, #4]
 8003914:	f7fd fd4c 	bl	80013b0 <__malloc_unlock>
 8003918:	3408      	adds	r4, #8
 800391a:	4620      	mov	r0, r4
 800391c:	b003      	add	sp, #12
 800391e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8003922:	68b4      	ldr	r4, [r6, #8]
 8003924:	6863      	ldr	r3, [r4, #4]
 8003926:	f023 0903 	bic.w	r9, r3, #3
 800392a:	454d      	cmp	r5, r9
 800392c:	d804      	bhi.n	8003938 <_malloc_r+0x1e8>
 800392e:	ebc5 0309 	rsb	r3, r5, r9
 8003932:	2b0f      	cmp	r3, #15
 8003934:	f300 80ae 	bgt.w	8003a94 <_malloc_r+0x344>
 8003938:	f640 23d4 	movw	r3, #2772	; 0xad4
 800393c:	f640 0a80 	movw	sl, #2176	; 0x880
 8003940:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8003944:	f2c2 0a00 	movt	sl, #8192	; 0x2000
 8003948:	681b      	ldr	r3, [r3, #0]
 800394a:	f8da 1000 	ldr.w	r1, [sl]
 800394e:	442b      	add	r3, r5
 8003950:	3101      	adds	r1, #1
 8003952:	bf1d      	ittte	ne
 8003954:	f503 5380 	addne.w	r3, r3, #4096	; 0x1000
 8003958:	330f      	addne	r3, #15
 800395a:	f423 637f 	bicne.w	r3, r3, #4080	; 0xff0
 800395e:	f103 0c10 	addeq.w	ip, r3, #16
 8003962:	bf18      	it	ne
 8003964:	f023 0c0f 	bicne.w	ip, r3, #15
 8003968:	eb04 0209 	add.w	r2, r4, r9
 800396c:	4661      	mov	r1, ip
 800396e:	4638      	mov	r0, r7
 8003970:	9201      	str	r2, [sp, #4]
 8003972:	f8cd c000 	str.w	ip, [sp]
 8003976:	f7fd fcc9 	bl	800130c <_sbrk_r>
 800397a:	f1b0 3fff 	cmp.w	r0, #4294967295	; 0xffffffff
 800397e:	4680      	mov	r8, r0
 8003980:	9a01      	ldr	r2, [sp, #4]
 8003982:	f8dd c000 	ldr.w	ip, [sp]
 8003986:	f000 811d 	beq.w	8003bc4 <_malloc_r+0x474>
 800398a:	4282      	cmp	r2, r0
 800398c:	f200 8117 	bhi.w	8003bbe <_malloc_r+0x46e>
 8003990:	f640 2bd8 	movw	fp, #2776	; 0xad8
 8003994:	f2c2 0b00 	movt	fp, #8192	; 0x2000
 8003998:	4542      	cmp	r2, r8
 800399a:	f8db 3000 	ldr.w	r3, [fp]
 800399e:	4463      	add	r3, ip
 80039a0:	f8cb 3000 	str.w	r3, [fp]
 80039a4:	f000 815d 	beq.w	8003c62 <_malloc_r+0x512>
 80039a8:	f8da 0000 	ldr.w	r0, [sl]
 80039ac:	f640 0180 	movw	r1, #2176	; 0x880
 80039b0:	3001      	adds	r0, #1
 80039b2:	bf18      	it	ne
 80039b4:	ebc2 0208 	rsbne	r2, r2, r8
 80039b8:	f2c2 0100 	movt	r1, #8192	; 0x2000
 80039bc:	bf16      	itet	ne
 80039be:	189b      	addne	r3, r3, r2
 80039c0:	f8c1 8000 	streq.w	r8, [r1]
 80039c4:	f8cb 3000 	strne.w	r3, [fp]
 80039c8:	f018 0307 	ands.w	r3, r8, #7
 80039cc:	bf1f      	itttt	ne
 80039ce:	f1c3 0208 	rsbne	r2, r3, #8
 80039d2:	4490      	addne	r8, r2
 80039d4:	f5c3 5380 	rsbne	r3, r3, #4096	; 0x1000
 80039d8:	f103 0a08 	addne.w	sl, r3, #8
 80039dc:	eb08 030c 	add.w	r3, r8, ip
 80039e0:	bf08      	it	eq
 80039e2:	f44f 5a80 	moveq.w	sl, #4096	; 0x1000
 80039e6:	f3c3 030b 	ubfx	r3, r3, #0, #12
 80039ea:	ebc3 0a0a 	rsb	sl, r3, sl
 80039ee:	4651      	mov	r1, sl
 80039f0:	4638      	mov	r0, r7
 80039f2:	f7fd fc8b 	bl	800130c <_sbrk_r>
 80039f6:	1c43      	adds	r3, r0, #1
 80039f8:	bf18      	it	ne
 80039fa:	ebc8 0200 	rsbne	r2, r8, r0
 80039fe:	f8db 3000 	ldr.w	r3, [fp]
 8003a02:	f8c6 8008 	str.w	r8, [r6, #8]
 8003a06:	bf15      	itete	ne
 8003a08:	4452      	addne	r2, sl
 8003a0a:	f04f 0a00 	moveq.w	sl, #0
 8003a0e:	f042 0201 	orrne.w	r2, r2, #1
 8003a12:	2201      	moveq	r2, #1
 8003a14:	4453      	add	r3, sl
 8003a16:	42b4      	cmp	r4, r6
 8003a18:	f640 2ad8 	movw	sl, #2776	; 0xad8
 8003a1c:	f8c8 2004 	str.w	r2, [r8, #4]
 8003a20:	f8cb 3000 	str.w	r3, [fp]
 8003a24:	f2c2 0a00 	movt	sl, #8192	; 0x2000
 8003a28:	d015      	beq.n	8003a56 <_malloc_r+0x306>
 8003a2a:	f1b9 0f0f 	cmp.w	r9, #15
 8003a2e:	f240 80f8 	bls.w	8003c22 <_malloc_r+0x4d2>
 8003a32:	6861      	ldr	r1, [r4, #4]
 8003a34:	f1a9 020c 	sub.w	r2, r9, #12
 8003a38:	f022 0207 	bic.w	r2, r2, #7
 8003a3c:	f001 0e01 	and.w	lr, r1, #1
 8003a40:	18a1      	adds	r1, r4, r2
 8003a42:	2005      	movs	r0, #5
 8003a44:	ea42 0e0e 	orr.w	lr, r2, lr
 8003a48:	2a0f      	cmp	r2, #15
 8003a4a:	f8c4 e004 	str.w	lr, [r4, #4]
 8003a4e:	6048      	str	r0, [r1, #4]
 8003a50:	6088      	str	r0, [r1, #8]
 8003a52:	f200 8112 	bhi.w	8003c7a <_malloc_r+0x52a>
 8003a56:	f640 22d0 	movw	r2, #2768	; 0xad0
 8003a5a:	f2c2 0200 	movt	r2, #8192	; 0x2000
 8003a5e:	68b4      	ldr	r4, [r6, #8]
 8003a60:	6811      	ldr	r1, [r2, #0]
 8003a62:	428b      	cmp	r3, r1
 8003a64:	bf88      	it	hi
 8003a66:	6013      	strhi	r3, [r2, #0]
 8003a68:	f640 22cc 	movw	r2, #2764	; 0xacc
 8003a6c:	f2c2 0200 	movt	r2, #8192	; 0x2000
 8003a70:	6811      	ldr	r1, [r2, #0]
 8003a72:	428b      	cmp	r3, r1
 8003a74:	bf88      	it	hi
 8003a76:	6013      	strhi	r3, [r2, #0]
 8003a78:	6862      	ldr	r2, [r4, #4]
 8003a7a:	f022 0203 	bic.w	r2, r2, #3
 8003a7e:	4295      	cmp	r5, r2
 8003a80:	ebc5 0302 	rsb	r3, r5, r2
 8003a84:	d801      	bhi.n	8003a8a <_malloc_r+0x33a>
 8003a86:	2b0f      	cmp	r3, #15
 8003a88:	dc04      	bgt.n	8003a94 <_malloc_r+0x344>
 8003a8a:	4638      	mov	r0, r7
 8003a8c:	f7fd fc90 	bl	80013b0 <__malloc_unlock>
 8003a90:	2400      	movs	r4, #0
 8003a92:	e693      	b.n	80037bc <_malloc_r+0x6c>
 8003a94:	1962      	adds	r2, r4, r5
 8003a96:	f043 0301 	orr.w	r3, r3, #1
 8003a9a:	f045 0501 	orr.w	r5, r5, #1
 8003a9e:	6065      	str	r5, [r4, #4]
 8003aa0:	4638      	mov	r0, r7
 8003aa2:	60b2      	str	r2, [r6, #8]
 8003aa4:	6053      	str	r3, [r2, #4]
 8003aa6:	f7fd fc83 	bl	80013b0 <__malloc_unlock>
 8003aaa:	3408      	adds	r4, #8
 8003aac:	4620      	mov	r0, r4
 8003aae:	b003      	add	sp, #12
 8003ab0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8003ab4:	4422      	add	r2, r4
 8003ab6:	68e3      	ldr	r3, [r4, #12]
 8003ab8:	6850      	ldr	r0, [r2, #4]
 8003aba:	68a1      	ldr	r1, [r4, #8]
 8003abc:	f040 0501 	orr.w	r5, r0, #1
 8003ac0:	60cb      	str	r3, [r1, #12]
 8003ac2:	4638      	mov	r0, r7
 8003ac4:	6099      	str	r1, [r3, #8]
 8003ac6:	6055      	str	r5, [r2, #4]
 8003ac8:	f7fd fc72 	bl	80013b0 <__malloc_unlock>
 8003acc:	3408      	adds	r4, #8
 8003ace:	4620      	mov	r0, r4
 8003ad0:	b003      	add	sp, #12
 8003ad2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8003ad6:	f1bc 0f14 	cmp.w	ip, #20
 8003ada:	bf9c      	itt	ls
 8003adc:	f10c 0c5b 	addls.w	ip, ip, #91	; 0x5b
 8003ae0:	ea4f 014c 	movls.w	r1, ip, lsl #1
 8003ae4:	f67f ae76 	bls.w	80037d4 <_malloc_r+0x84>
 8003ae8:	f1bc 0f54 	cmp.w	ip, #84	; 0x54
 8003aec:	f200 808f 	bhi.w	8003c0e <_malloc_r+0x4be>
 8003af0:	ea4f 3c15 	mov.w	ip, r5, lsr #12
 8003af4:	f10c 0c6e 	add.w	ip, ip, #110	; 0x6e
 8003af8:	ea4f 014c 	mov.w	r1, ip, lsl #1
 8003afc:	e66a      	b.n	80037d4 <_malloc_r+0x84>
 8003afe:	0a4b      	lsrs	r3, r1, #9
 8003b00:	2b04      	cmp	r3, #4
 8003b02:	d958      	bls.n	8003bb6 <_malloc_r+0x466>
 8003b04:	2b14      	cmp	r3, #20
 8003b06:	bf9c      	itt	ls
 8003b08:	f103 025b 	addls.w	r2, r3, #91	; 0x5b
 8003b0c:	0050      	lslls	r0, r2, #1
 8003b0e:	d905      	bls.n	8003b1c <_malloc_r+0x3cc>
 8003b10:	2b54      	cmp	r3, #84	; 0x54
 8003b12:	f200 80ba 	bhi.w	8003c8a <_malloc_r+0x53a>
 8003b16:	0b0a      	lsrs	r2, r1, #12
 8003b18:	326e      	adds	r2, #110	; 0x6e
 8003b1a:	0050      	lsls	r0, r2, #1
 8003b1c:	eb06 0080 	add.w	r0, r6, r0, lsl #2
 8003b20:	f240 4874 	movw	r8, #1140	; 0x474
 8003b24:	6883      	ldr	r3, [r0, #8]
 8003b26:	4283      	cmp	r3, r0
 8003b28:	f2c2 0800 	movt	r8, #8192	; 0x2000
 8003b2c:	d07f      	beq.n	8003c2e <_malloc_r+0x4de>
 8003b2e:	685a      	ldr	r2, [r3, #4]
 8003b30:	f022 0203 	bic.w	r2, r2, #3
 8003b34:	4291      	cmp	r1, r2
 8003b36:	d202      	bcs.n	8003b3e <_malloc_r+0x3ee>
 8003b38:	689b      	ldr	r3, [r3, #8]
 8003b3a:	4298      	cmp	r0, r3
 8003b3c:	d1f7      	bne.n	8003b2e <_malloc_r+0x3de>
 8003b3e:	68d9      	ldr	r1, [r3, #12]
 8003b40:	6872      	ldr	r2, [r6, #4]
 8003b42:	60e1      	str	r1, [r4, #12]
 8003b44:	60a3      	str	r3, [r4, #8]
 8003b46:	608c      	str	r4, [r1, #8]
 8003b48:	60dc      	str	r4, [r3, #12]
 8003b4a:	e68b      	b.n	8003864 <_malloc_r+0x114>
 8003b4c:	1961      	adds	r1, r4, r5
 8003b4e:	f042 0601 	orr.w	r6, r2, #1
 8003b52:	f045 0501 	orr.w	r5, r5, #1
 8003b56:	6065      	str	r5, [r4, #4]
 8003b58:	4638      	mov	r0, r7
 8003b5a:	6159      	str	r1, [r3, #20]
 8003b5c:	6119      	str	r1, [r3, #16]
 8003b5e:	f8c1 e00c 	str.w	lr, [r1, #12]
 8003b62:	f8c1 e008 	str.w	lr, [r1, #8]
 8003b66:	604e      	str	r6, [r1, #4]
 8003b68:	508a      	str	r2, [r1, r2]
 8003b6a:	3408      	adds	r4, #8
 8003b6c:	f7fd fc20 	bl	80013b0 <__malloc_unlock>
 8003b70:	e624      	b.n	80037bc <_malloc_r+0x6c>
 8003b72:	f109 0901 	add.w	r9, r9, #1
 8003b76:	f019 0f03 	tst.w	r9, #3
 8003b7a:	f104 0408 	add.w	r4, r4, #8
 8003b7e:	f47f ae84 	bne.w	800388a <_malloc_r+0x13a>
 8003b82:	e028      	b.n	8003bd6 <_malloc_r+0x486>
 8003b84:	f104 0308 	add.w	r3, r4, #8
 8003b88:	6964      	ldr	r4, [r4, #20]
 8003b8a:	42a3      	cmp	r3, r4
 8003b8c:	bf08      	it	eq
 8003b8e:	f10c 0c02 	addeq.w	ip, ip, #2
 8003b92:	f43f ae39 	beq.w	8003808 <_malloc_r+0xb8>
 8003b96:	e601      	b.n	800379c <_malloc_r+0x4c>
 8003b98:	4419      	add	r1, r3
 8003b9a:	461c      	mov	r4, r3
 8003b9c:	6848      	ldr	r0, [r1, #4]
 8003b9e:	68db      	ldr	r3, [r3, #12]
 8003ba0:	f854 2f08 	ldr.w	r2, [r4, #8]!
 8003ba4:	f040 0501 	orr.w	r5, r0, #1
 8003ba8:	604d      	str	r5, [r1, #4]
 8003baa:	4638      	mov	r0, r7
 8003bac:	60d3      	str	r3, [r2, #12]
 8003bae:	609a      	str	r2, [r3, #8]
 8003bb0:	f7fd fbfe 	bl	80013b0 <__malloc_unlock>
 8003bb4:	e602      	b.n	80037bc <_malloc_r+0x6c>
 8003bb6:	098a      	lsrs	r2, r1, #6
 8003bb8:	3238      	adds	r2, #56	; 0x38
 8003bba:	0050      	lsls	r0, r2, #1
 8003bbc:	e7ae      	b.n	8003b1c <_malloc_r+0x3cc>
 8003bbe:	42b4      	cmp	r4, r6
 8003bc0:	f43f aee6 	beq.w	8003990 <_malloc_r+0x240>
 8003bc4:	68b4      	ldr	r4, [r6, #8]
 8003bc6:	6862      	ldr	r2, [r4, #4]
 8003bc8:	f022 0203 	bic.w	r2, r2, #3
 8003bcc:	e757      	b.n	8003a7e <_malloc_r+0x32e>
 8003bce:	f8d8 8000 	ldr.w	r8, [r8]
 8003bd2:	4598      	cmp	r8, r3
 8003bd4:	d16b      	bne.n	8003cae <_malloc_r+0x55e>
 8003bd6:	f01c 0f03 	tst.w	ip, #3
 8003bda:	f1a8 0308 	sub.w	r3, r8, #8
 8003bde:	f10c 3cff 	add.w	ip, ip, #4294967295	; 0xffffffff
 8003be2:	d1f4      	bne.n	8003bce <_malloc_r+0x47e>
 8003be4:	6873      	ldr	r3, [r6, #4]
 8003be6:	ea23 0300 	bic.w	r3, r3, r0
 8003bea:	6073      	str	r3, [r6, #4]
 8003bec:	0040      	lsls	r0, r0, #1
 8003bee:	4298      	cmp	r0, r3
 8003bf0:	f63f ae97 	bhi.w	8003922 <_malloc_r+0x1d2>
 8003bf4:	2800      	cmp	r0, #0
 8003bf6:	f43f ae94 	beq.w	8003922 <_malloc_r+0x1d2>
 8003bfa:	4203      	tst	r3, r0
 8003bfc:	46cc      	mov	ip, r9
 8003bfe:	f47f ae40 	bne.w	8003882 <_malloc_r+0x132>
 8003c02:	0040      	lsls	r0, r0, #1
 8003c04:	4203      	tst	r3, r0
 8003c06:	f10c 0c04 	add.w	ip, ip, #4
 8003c0a:	d0fa      	beq.n	8003c02 <_malloc_r+0x4b2>
 8003c0c:	e639      	b.n	8003882 <_malloc_r+0x132>
 8003c0e:	f5bc 7faa 	cmp.w	ip, #340	; 0x154
 8003c12:	d817      	bhi.n	8003c44 <_malloc_r+0x4f4>
 8003c14:	ea4f 3cd5 	mov.w	ip, r5, lsr #15
 8003c18:	f10c 0c77 	add.w	ip, ip, #119	; 0x77
 8003c1c:	ea4f 014c 	mov.w	r1, ip, lsl #1
 8003c20:	e5d8      	b.n	80037d4 <_malloc_r+0x84>
 8003c22:	2301      	movs	r3, #1
 8003c24:	f8c8 3004 	str.w	r3, [r8, #4]
 8003c28:	4644      	mov	r4, r8
 8003c2a:	2200      	movs	r2, #0
 8003c2c:	e727      	b.n	8003a7e <_malloc_r+0x32e>
 8003c2e:	1091      	asrs	r1, r2, #2
 8003c30:	2001      	movs	r0, #1
 8003c32:	f8d8 2004 	ldr.w	r2, [r8, #4]
 8003c36:	fa00 f101 	lsl.w	r1, r0, r1
 8003c3a:	430a      	orrs	r2, r1
 8003c3c:	f8c8 2004 	str.w	r2, [r8, #4]
 8003c40:	4619      	mov	r1, r3
 8003c42:	e77e      	b.n	8003b42 <_malloc_r+0x3f2>
 8003c44:	f240 5354 	movw	r3, #1364	; 0x554
 8003c48:	459c      	cmp	ip, r3
 8003c4a:	bf9d      	ittte	ls
 8003c4c:	ea4f 4c95 	movls.w	ip, r5, lsr #18
 8003c50:	f10c 0c7c 	addls.w	ip, ip, #124	; 0x7c
 8003c54:	ea4f 014c 	movls.w	r1, ip, lsl #1
 8003c58:	21fc      	movhi	r1, #252	; 0xfc
 8003c5a:	bf88      	it	hi
 8003c5c:	f04f 0c7e 	movhi.w	ip, #126	; 0x7e
 8003c60:	e5b8      	b.n	80037d4 <_malloc_r+0x84>
 8003c62:	f3c2 010b 	ubfx	r1, r2, #0, #12
 8003c66:	2900      	cmp	r1, #0
 8003c68:	f47f ae9e 	bne.w	80039a8 <_malloc_r+0x258>
 8003c6c:	eb0c 0109 	add.w	r1, ip, r9
 8003c70:	68b2      	ldr	r2, [r6, #8]
 8003c72:	f041 0101 	orr.w	r1, r1, #1
 8003c76:	6051      	str	r1, [r2, #4]
 8003c78:	e6ed      	b.n	8003a56 <_malloc_r+0x306>
 8003c7a:	f104 0108 	add.w	r1, r4, #8
 8003c7e:	4638      	mov	r0, r7
 8003c80:	f000 f94a 	bl	8003f18 <_free_r>
 8003c84:	f8da 3000 	ldr.w	r3, [sl]
 8003c88:	e6e5      	b.n	8003a56 <_malloc_r+0x306>
 8003c8a:	f5b3 7faa 	cmp.w	r3, #340	; 0x154
 8003c8e:	d803      	bhi.n	8003c98 <_malloc_r+0x548>
 8003c90:	0bca      	lsrs	r2, r1, #15
 8003c92:	3277      	adds	r2, #119	; 0x77
 8003c94:	0050      	lsls	r0, r2, #1
 8003c96:	e741      	b.n	8003b1c <_malloc_r+0x3cc>
 8003c98:	f240 5254 	movw	r2, #1364	; 0x554
 8003c9c:	4293      	cmp	r3, r2
 8003c9e:	bf9d      	ittte	ls
 8003ca0:	0c8a      	lsrls	r2, r1, #18
 8003ca2:	327c      	addls	r2, #124	; 0x7c
 8003ca4:	0050      	lslls	r0, r2, #1
 8003ca6:	20fc      	movhi	r0, #252	; 0xfc
 8003ca8:	bf88      	it	hi
 8003caa:	227e      	movhi	r2, #126	; 0x7e
 8003cac:	e736      	b.n	8003b1c <_malloc_r+0x3cc>
 8003cae:	6873      	ldr	r3, [r6, #4]
 8003cb0:	e79c      	b.n	8003bec <_malloc_r+0x49c>
 8003cb2:	bf00      	nop

08003cb4 <memset>:
 8003cb4:	b4f0      	push	{r4, r5, r6, r7}
 8003cb6:	0784      	lsls	r4, r0, #30
 8003cb8:	d043      	beq.n	8003d42 <memset+0x8e>
 8003cba:	1e54      	subs	r4, r2, #1
 8003cbc:	2a00      	cmp	r2, #0
 8003cbe:	d03e      	beq.n	8003d3e <memset+0x8a>
 8003cc0:	b2cd      	uxtb	r5, r1
 8003cc2:	4603      	mov	r3, r0
 8003cc4:	e003      	b.n	8003cce <memset+0x1a>
 8003cc6:	1e62      	subs	r2, r4, #1
 8003cc8:	2c00      	cmp	r4, #0
 8003cca:	d038      	beq.n	8003d3e <memset+0x8a>
 8003ccc:	4614      	mov	r4, r2
 8003cce:	f803 5b01 	strb.w	r5, [r3], #1
 8003cd2:	079a      	lsls	r2, r3, #30
 8003cd4:	d1f7      	bne.n	8003cc6 <memset+0x12>
 8003cd6:	2c03      	cmp	r4, #3
 8003cd8:	d92a      	bls.n	8003d30 <memset+0x7c>
 8003cda:	b2cd      	uxtb	r5, r1
 8003cdc:	ea45 2505 	orr.w	r5, r5, r5, lsl #8
 8003ce0:	2c0f      	cmp	r4, #15
 8003ce2:	ea45 4505 	orr.w	r5, r5, r5, lsl #16
 8003ce6:	d915      	bls.n	8003d14 <memset+0x60>
 8003ce8:	f1a4 0710 	sub.w	r7, r4, #16
 8003cec:	093f      	lsrs	r7, r7, #4
 8003cee:	f103 0610 	add.w	r6, r3, #16
 8003cf2:	eb06 1607 	add.w	r6, r6, r7, lsl #4
 8003cf6:	461a      	mov	r2, r3
 8003cf8:	6015      	str	r5, [r2, #0]
 8003cfa:	6055      	str	r5, [r2, #4]
 8003cfc:	6095      	str	r5, [r2, #8]
 8003cfe:	60d5      	str	r5, [r2, #12]
 8003d00:	3210      	adds	r2, #16
 8003d02:	42b2      	cmp	r2, r6
 8003d04:	d1f8      	bne.n	8003cf8 <memset+0x44>
 8003d06:	f004 040f 	and.w	r4, r4, #15
 8003d0a:	3701      	adds	r7, #1
 8003d0c:	2c03      	cmp	r4, #3
 8003d0e:	eb03 1307 	add.w	r3, r3, r7, lsl #4
 8003d12:	d90d      	bls.n	8003d30 <memset+0x7c>
 8003d14:	461e      	mov	r6, r3
 8003d16:	4622      	mov	r2, r4
 8003d18:	3a04      	subs	r2, #4
 8003d1a:	2a03      	cmp	r2, #3
 8003d1c:	f846 5b04 	str.w	r5, [r6], #4
 8003d20:	d8fa      	bhi.n	8003d18 <memset+0x64>
 8003d22:	1f22      	subs	r2, r4, #4
 8003d24:	f022 0203 	bic.w	r2, r2, #3
 8003d28:	3204      	adds	r2, #4
 8003d2a:	4413      	add	r3, r2
 8003d2c:	f004 0403 	and.w	r4, r4, #3
 8003d30:	b12c      	cbz	r4, 8003d3e <memset+0x8a>
 8003d32:	b2c9      	uxtb	r1, r1
 8003d34:	441c      	add	r4, r3
 8003d36:	f803 1b01 	strb.w	r1, [r3], #1
 8003d3a:	42a3      	cmp	r3, r4
 8003d3c:	d1fb      	bne.n	8003d36 <memset+0x82>
 8003d3e:	bcf0      	pop	{r4, r5, r6, r7}
 8003d40:	4770      	bx	lr
 8003d42:	4614      	mov	r4, r2
 8003d44:	4603      	mov	r3, r0
 8003d46:	e7c6      	b.n	8003cd6 <memset+0x22>

08003d48 <strncpy>:
 8003d48:	ea40 0301 	orr.w	r3, r0, r1
 8003d4c:	079b      	lsls	r3, r3, #30
 8003d4e:	b470      	push	{r4, r5, r6}
 8003d50:	d12b      	bne.n	8003daa <strncpy+0x62>
 8003d52:	2a03      	cmp	r2, #3
 8003d54:	bf84      	itt	hi
 8003d56:	460c      	movhi	r4, r1
 8003d58:	4603      	movhi	r3, r0
 8003d5a:	d926      	bls.n	8003daa <strncpy+0x62>
 8003d5c:	4621      	mov	r1, r4
 8003d5e:	f854 5b04 	ldr.w	r5, [r4], #4
 8003d62:	f1a5 3601 	sub.w	r6, r5, #16843009	; 0x1010101
 8003d66:	ea26 0605 	bic.w	r6, r6, r5
 8003d6a:	f016 3f80 	tst.w	r6, #2155905152	; 0x80808080
 8003d6e:	d105      	bne.n	8003d7c <strncpy+0x34>
 8003d70:	3a04      	subs	r2, #4
 8003d72:	2a03      	cmp	r2, #3
 8003d74:	f843 5b04 	str.w	r5, [r3], #4
 8003d78:	4621      	mov	r1, r4
 8003d7a:	d8ef      	bhi.n	8003d5c <strncpy+0x14>
 8003d7c:	b19a      	cbz	r2, 8003da6 <strncpy+0x5e>
 8003d7e:	780c      	ldrb	r4, [r1, #0]
 8003d80:	3a01      	subs	r2, #1
 8003d82:	701c      	strb	r4, [r3, #0]
 8003d84:	3301      	adds	r3, #1
 8003d86:	b13c      	cbz	r4, 8003d98 <strncpy+0x50>
 8003d88:	b16a      	cbz	r2, 8003da6 <strncpy+0x5e>
 8003d8a:	f811 4f01 	ldrb.w	r4, [r1, #1]!
 8003d8e:	3a01      	subs	r2, #1
 8003d90:	f803 4b01 	strb.w	r4, [r3], #1
 8003d94:	2c00      	cmp	r4, #0
 8003d96:	d1f7      	bne.n	8003d88 <strncpy+0x40>
 8003d98:	b12a      	cbz	r2, 8003da6 <strncpy+0x5e>
 8003d9a:	441a      	add	r2, r3
 8003d9c:	2100      	movs	r1, #0
 8003d9e:	f803 1b01 	strb.w	r1, [r3], #1
 8003da2:	4293      	cmp	r3, r2
 8003da4:	d1fb      	bne.n	8003d9e <strncpy+0x56>
 8003da6:	bc70      	pop	{r4, r5, r6}
 8003da8:	4770      	bx	lr
 8003daa:	4603      	mov	r3, r0
 8003dac:	e7e6      	b.n	8003d7c <strncpy+0x34>
 8003dae:	bf00      	nop

08003db0 <__register_exitproc>:
 8003db0:	b5f0      	push	{r4, r5, r6, r7, lr}
 8003db2:	f244 343c 	movw	r4, #17212	; 0x433c
 8003db6:	f6c0 0400 	movt	r4, #2048	; 0x800
 8003dba:	b085      	sub	sp, #20
 8003dbc:	6826      	ldr	r6, [r4, #0]
 8003dbe:	f8d6 4148 	ldr.w	r4, [r6, #328]	; 0x148
 8003dc2:	4607      	mov	r7, r0
 8003dc4:	2c00      	cmp	r4, #0
 8003dc6:	d044      	beq.n	8003e52 <__register_exitproc+0xa2>
 8003dc8:	6865      	ldr	r5, [r4, #4]
 8003dca:	2d1f      	cmp	r5, #31
 8003dcc:	dd21      	ble.n	8003e12 <__register_exitproc+0x62>
 8003dce:	f243 7431 	movw	r4, #14129	; 0x3731
 8003dd2:	f6c0 0400 	movt	r4, #2048	; 0x800
 8003dd6:	b91c      	cbnz	r4, 8003de0 <__register_exitproc+0x30>
 8003dd8:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8003ddc:	b005      	add	sp, #20
 8003dde:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8003de0:	f44f 70c8 	mov.w	r0, #400	; 0x190
 8003de4:	9103      	str	r1, [sp, #12]
 8003de6:	9202      	str	r2, [sp, #8]
 8003de8:	9301      	str	r3, [sp, #4]
 8003dea:	f7ff fca1 	bl	8003730 <malloc>
 8003dee:	9903      	ldr	r1, [sp, #12]
 8003df0:	9a02      	ldr	r2, [sp, #8]
 8003df2:	9b01      	ldr	r3, [sp, #4]
 8003df4:	4604      	mov	r4, r0
 8003df6:	2800      	cmp	r0, #0
 8003df8:	d0ee      	beq.n	8003dd8 <__register_exitproc+0x28>
 8003dfa:	f8d6 5148 	ldr.w	r5, [r6, #328]	; 0x148
 8003dfe:	2000      	movs	r0, #0
 8003e00:	6025      	str	r5, [r4, #0]
 8003e02:	6060      	str	r0, [r4, #4]
 8003e04:	4605      	mov	r5, r0
 8003e06:	f8c6 4148 	str.w	r4, [r6, #328]	; 0x148
 8003e0a:	f8c4 0188 	str.w	r0, [r4, #392]	; 0x188
 8003e0e:	f8c4 018c 	str.w	r0, [r4, #396]	; 0x18c
 8003e12:	b93f      	cbnz	r7, 8003e24 <__register_exitproc+0x74>
 8003e14:	1cab      	adds	r3, r5, #2
 8003e16:	2000      	movs	r0, #0
 8003e18:	3501      	adds	r5, #1
 8003e1a:	6065      	str	r5, [r4, #4]
 8003e1c:	f844 1023 	str.w	r1, [r4, r3, lsl #2]
 8003e20:	b005      	add	sp, #20
 8003e22:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8003e24:	eb04 0085 	add.w	r0, r4, r5, lsl #2
 8003e28:	f04f 0c01 	mov.w	ip, #1
 8003e2c:	f8c0 2088 	str.w	r2, [r0, #136]	; 0x88
 8003e30:	f8d4 6188 	ldr.w	r6, [r4, #392]	; 0x188
 8003e34:	fa0c f205 	lsl.w	r2, ip, r5
 8003e38:	4316      	orrs	r6, r2
 8003e3a:	2f02      	cmp	r7, #2
 8003e3c:	f8c4 6188 	str.w	r6, [r4, #392]	; 0x188
 8003e40:	f8c0 3108 	str.w	r3, [r0, #264]	; 0x108
 8003e44:	bf02      	ittt	eq
 8003e46:	f8d4 318c 	ldreq.w	r3, [r4, #396]	; 0x18c
 8003e4a:	431a      	orreq	r2, r3
 8003e4c:	f8c4 218c 	streq.w	r2, [r4, #396]	; 0x18c
 8003e50:	e7e0      	b.n	8003e14 <__register_exitproc+0x64>
 8003e52:	f506 74a6 	add.w	r4, r6, #332	; 0x14c
 8003e56:	f8c6 4148 	str.w	r4, [r6, #328]	; 0x148
 8003e5a:	e7b5      	b.n	8003dc8 <__register_exitproc+0x18>

08003e5c <register_fini>:
 8003e5c:	f240 0300 	movw	r3, #0
 8003e60:	f2c0 0300 	movt	r3, #0
 8003e64:	b12b      	cbz	r3, 8003e72 <register_fini+0x16>
 8003e66:	f243 60a1 	movw	r0, #13985	; 0x36a1
 8003e6a:	f6c0 0000 	movt	r0, #2048	; 0x800
 8003e6e:	f7ff bc11 	b.w	8003694 <atexit>
 8003e72:	4770      	bx	lr

08003e74 <_malloc_trim_r>:
 8003e74:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8003e76:	f240 4474 	movw	r4, #1140	; 0x474
 8003e7a:	f2c2 0400 	movt	r4, #8192	; 0x2000
 8003e7e:	460f      	mov	r7, r1
 8003e80:	4605      	mov	r5, r0
 8003e82:	f7fd fa8b 	bl	800139c <__malloc_lock>
 8003e86:	68a3      	ldr	r3, [r4, #8]
 8003e88:	685e      	ldr	r6, [r3, #4]
 8003e8a:	f026 0603 	bic.w	r6, r6, #3
 8003e8e:	1bf7      	subs	r7, r6, r7
 8003e90:	f607 77ef 	addw	r7, r7, #4079	; 0xfef
 8003e94:	0b3f      	lsrs	r7, r7, #12
 8003e96:	3f01      	subs	r7, #1
 8003e98:	033f      	lsls	r7, r7, #12
 8003e9a:	f5b7 5f80 	cmp.w	r7, #4096	; 0x1000
 8003e9e:	db07      	blt.n	8003eb0 <_malloc_trim_r+0x3c>
 8003ea0:	4628      	mov	r0, r5
 8003ea2:	2100      	movs	r1, #0
 8003ea4:	f7fd fa32 	bl	800130c <_sbrk_r>
 8003ea8:	68a3      	ldr	r3, [r4, #8]
 8003eaa:	4433      	add	r3, r6
 8003eac:	4298      	cmp	r0, r3
 8003eae:	d004      	beq.n	8003eba <_malloc_trim_r+0x46>
 8003eb0:	4628      	mov	r0, r5
 8003eb2:	f7fd fa7d 	bl	80013b0 <__malloc_unlock>
 8003eb6:	2000      	movs	r0, #0
 8003eb8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8003eba:	4628      	mov	r0, r5
 8003ebc:	4279      	negs	r1, r7
 8003ebe:	f7fd fa25 	bl	800130c <_sbrk_r>
 8003ec2:	3001      	adds	r0, #1
 8003ec4:	d010      	beq.n	8003ee8 <_malloc_trim_r+0x74>
 8003ec6:	f640 23d8 	movw	r3, #2776	; 0xad8
 8003eca:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8003ece:	68a1      	ldr	r1, [r4, #8]
 8003ed0:	681a      	ldr	r2, [r3, #0]
 8003ed2:	1bf6      	subs	r6, r6, r7
 8003ed4:	f046 0601 	orr.w	r6, r6, #1
 8003ed8:	4628      	mov	r0, r5
 8003eda:	1bd7      	subs	r7, r2, r7
 8003edc:	604e      	str	r6, [r1, #4]
 8003ede:	601f      	str	r7, [r3, #0]
 8003ee0:	f7fd fa66 	bl	80013b0 <__malloc_unlock>
 8003ee4:	2001      	movs	r0, #1
 8003ee6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8003ee8:	4628      	mov	r0, r5
 8003eea:	2100      	movs	r1, #0
 8003eec:	f7fd fa0e 	bl	800130c <_sbrk_r>
 8003ef0:	68a3      	ldr	r3, [r4, #8]
 8003ef2:	1ac2      	subs	r2, r0, r3
 8003ef4:	2a0f      	cmp	r2, #15
 8003ef6:	dddb      	ble.n	8003eb0 <_malloc_trim_r+0x3c>
 8003ef8:	f640 0480 	movw	r4, #2176	; 0x880
 8003efc:	f2c2 0400 	movt	r4, #8192	; 0x2000
 8003f00:	f640 21d8 	movw	r1, #2776	; 0xad8
 8003f04:	6824      	ldr	r4, [r4, #0]
 8003f06:	f2c2 0100 	movt	r1, #8192	; 0x2000
 8003f0a:	f042 0201 	orr.w	r2, r2, #1
 8003f0e:	1b00      	subs	r0, r0, r4
 8003f10:	605a      	str	r2, [r3, #4]
 8003f12:	6008      	str	r0, [r1, #0]
 8003f14:	e7cc      	b.n	8003eb0 <_malloc_trim_r+0x3c>
 8003f16:	bf00      	nop

08003f18 <_free_r>:
 8003f18:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8003f1c:	460e      	mov	r6, r1
 8003f1e:	4681      	mov	r9, r0
 8003f20:	2900      	cmp	r1, #0
 8003f22:	d060      	beq.n	8003fe6 <_free_r+0xce>
 8003f24:	f7fd fa3a 	bl	800139c <__malloc_lock>
 8003f28:	f856 1c04 	ldr.w	r1, [r6, #-4]
 8003f2c:	f1a6 0408 	sub.w	r4, r6, #8
 8003f30:	f021 0301 	bic.w	r3, r1, #1
 8003f34:	18e2      	adds	r2, r4, r3
 8003f36:	f240 4574 	movw	r5, #1140	; 0x474
 8003f3a:	6857      	ldr	r7, [r2, #4]
 8003f3c:	f2c2 0500 	movt	r5, #8192	; 0x2000
 8003f40:	f027 0003 	bic.w	r0, r7, #3
 8003f44:	68af      	ldr	r7, [r5, #8]
 8003f46:	4297      	cmp	r7, r2
 8003f48:	d063      	beq.n	8004012 <_free_r+0xfa>
 8003f4a:	f011 0c01 	ands.w	ip, r1, #1
 8003f4e:	6050      	str	r0, [r2, #4]
 8003f50:	bf18      	it	ne
 8003f52:	2100      	movne	r1, #0
 8003f54:	d111      	bne.n	8003f7a <_free_r+0x62>
 8003f56:	f856 1c08 	ldr.w	r1, [r6, #-8]
 8003f5a:	1a64      	subs	r4, r4, r1
 8003f5c:	f105 0808 	add.w	r8, r5, #8
 8003f60:	68a6      	ldr	r6, [r4, #8]
 8003f62:	4546      	cmp	r6, r8
 8003f64:	bf18      	it	ne
 8003f66:	f8d4 800c 	ldrne.w	r8, [r4, #12]
 8003f6a:	440b      	add	r3, r1
 8003f6c:	bf1d      	ittte	ne
 8003f6e:	f8c6 800c 	strne.w	r8, [r6, #12]
 8003f72:	4661      	movne	r1, ip
 8003f74:	f8c8 6008 	strne.w	r6, [r8, #8]
 8003f78:	2101      	moveq	r1, #1
 8003f7a:	1816      	adds	r6, r2, r0
 8003f7c:	6876      	ldr	r6, [r6, #4]
 8003f7e:	07f6      	lsls	r6, r6, #31
 8003f80:	d408      	bmi.n	8003f94 <_free_r+0x7c>
 8003f82:	4403      	add	r3, r0
 8003f84:	6890      	ldr	r0, [r2, #8]
 8003f86:	b911      	cbnz	r1, 8003f8e <_free_r+0x76>
 8003f88:	4e49      	ldr	r6, [pc, #292]	; (80040b0 <_free_r+0x198>)
 8003f8a:	42b0      	cmp	r0, r6
 8003f8c:	d060      	beq.n	8004050 <_free_r+0x138>
 8003f8e:	68d2      	ldr	r2, [r2, #12]
 8003f90:	60c2      	str	r2, [r0, #12]
 8003f92:	6090      	str	r0, [r2, #8]
 8003f94:	f043 0201 	orr.w	r2, r3, #1
 8003f98:	6062      	str	r2, [r4, #4]
 8003f9a:	50e3      	str	r3, [r4, r3]
 8003f9c:	b9f1      	cbnz	r1, 8003fdc <_free_r+0xc4>
 8003f9e:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 8003fa2:	d322      	bcc.n	8003fea <_free_r+0xd2>
 8003fa4:	0a5a      	lsrs	r2, r3, #9
 8003fa6:	2a04      	cmp	r2, #4
 8003fa8:	d85b      	bhi.n	8004062 <_free_r+0x14a>
 8003faa:	0998      	lsrs	r0, r3, #6
 8003fac:	3038      	adds	r0, #56	; 0x38
 8003fae:	0041      	lsls	r1, r0, #1
 8003fb0:	eb05 0581 	add.w	r5, r5, r1, lsl #2
 8003fb4:	f240 4174 	movw	r1, #1140	; 0x474
 8003fb8:	68aa      	ldr	r2, [r5, #8]
 8003fba:	42aa      	cmp	r2, r5
 8003fbc:	f2c2 0100 	movt	r1, #8192	; 0x2000
 8003fc0:	d05b      	beq.n	800407a <_free_r+0x162>
 8003fc2:	6851      	ldr	r1, [r2, #4]
 8003fc4:	f021 0103 	bic.w	r1, r1, #3
 8003fc8:	428b      	cmp	r3, r1
 8003fca:	d202      	bcs.n	8003fd2 <_free_r+0xba>
 8003fcc:	6892      	ldr	r2, [r2, #8]
 8003fce:	4295      	cmp	r5, r2
 8003fd0:	d1f7      	bne.n	8003fc2 <_free_r+0xaa>
 8003fd2:	68d3      	ldr	r3, [r2, #12]
 8003fd4:	60e3      	str	r3, [r4, #12]
 8003fd6:	60a2      	str	r2, [r4, #8]
 8003fd8:	609c      	str	r4, [r3, #8]
 8003fda:	60d4      	str	r4, [r2, #12]
 8003fdc:	4648      	mov	r0, r9
 8003fde:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8003fe2:	f7fd b9e5 	b.w	80013b0 <__malloc_unlock>
 8003fe6:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8003fea:	08db      	lsrs	r3, r3, #3
 8003fec:	eb05 02c3 	add.w	r2, r5, r3, lsl #3
 8003ff0:	6868      	ldr	r0, [r5, #4]
 8003ff2:	6891      	ldr	r1, [r2, #8]
 8003ff4:	60e2      	str	r2, [r4, #12]
 8003ff6:	2601      	movs	r6, #1
 8003ff8:	109b      	asrs	r3, r3, #2
 8003ffa:	fa06 f303 	lsl.w	r3, r6, r3
 8003ffe:	4318      	orrs	r0, r3
 8004000:	60a1      	str	r1, [r4, #8]
 8004002:	6068      	str	r0, [r5, #4]
 8004004:	6094      	str	r4, [r2, #8]
 8004006:	4648      	mov	r0, r9
 8004008:	60cc      	str	r4, [r1, #12]
 800400a:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 800400e:	f7fd b9cf 	b.w	80013b0 <__malloc_unlock>
 8004012:	07cf      	lsls	r7, r1, #31
 8004014:	4418      	add	r0, r3
 8004016:	d407      	bmi.n	8004028 <_free_r+0x110>
 8004018:	f856 3c08 	ldr.w	r3, [r6, #-8]
 800401c:	1ae4      	subs	r4, r4, r3
 800401e:	4418      	add	r0, r3
 8004020:	68a2      	ldr	r2, [r4, #8]
 8004022:	68e3      	ldr	r3, [r4, #12]
 8004024:	60d3      	str	r3, [r2, #12]
 8004026:	609a      	str	r2, [r3, #8]
 8004028:	f640 027c 	movw	r2, #2172	; 0x87c
 800402c:	f2c2 0200 	movt	r2, #8192	; 0x2000
 8004030:	f040 0101 	orr.w	r1, r0, #1
 8004034:	6813      	ldr	r3, [r2, #0]
 8004036:	6061      	str	r1, [r4, #4]
 8004038:	4298      	cmp	r0, r3
 800403a:	60ac      	str	r4, [r5, #8]
 800403c:	d3ce      	bcc.n	8003fdc <_free_r+0xc4>
 800403e:	f640 23d4 	movw	r3, #2772	; 0xad4
 8004042:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8004046:	4648      	mov	r0, r9
 8004048:	6819      	ldr	r1, [r3, #0]
 800404a:	f7ff ff13 	bl	8003e74 <_malloc_trim_r>
 800404e:	e7c5      	b.n	8003fdc <_free_r+0xc4>
 8004050:	f043 0201 	orr.w	r2, r3, #1
 8004054:	616c      	str	r4, [r5, #20]
 8004056:	612c      	str	r4, [r5, #16]
 8004058:	60e0      	str	r0, [r4, #12]
 800405a:	60a0      	str	r0, [r4, #8]
 800405c:	6062      	str	r2, [r4, #4]
 800405e:	50e3      	str	r3, [r4, r3]
 8004060:	e7bc      	b.n	8003fdc <_free_r+0xc4>
 8004062:	2a14      	cmp	r2, #20
 8004064:	bf9c      	itt	ls
 8004066:	f102 005b 	addls.w	r0, r2, #91	; 0x5b
 800406a:	0041      	lslls	r1, r0, #1
 800406c:	d9a0      	bls.n	8003fb0 <_free_r+0x98>
 800406e:	2a54      	cmp	r2, #84	; 0x54
 8004070:	d80c      	bhi.n	800408c <_free_r+0x174>
 8004072:	0b18      	lsrs	r0, r3, #12
 8004074:	306e      	adds	r0, #110	; 0x6e
 8004076:	0041      	lsls	r1, r0, #1
 8004078:	e79a      	b.n	8003fb0 <_free_r+0x98>
 800407a:	684b      	ldr	r3, [r1, #4]
 800407c:	1080      	asrs	r0, r0, #2
 800407e:	2501      	movs	r5, #1
 8004080:	fa05 f000 	lsl.w	r0, r5, r0
 8004084:	4303      	orrs	r3, r0
 8004086:	604b      	str	r3, [r1, #4]
 8004088:	4613      	mov	r3, r2
 800408a:	e7a3      	b.n	8003fd4 <_free_r+0xbc>
 800408c:	f5b2 7faa 	cmp.w	r2, #340	; 0x154
 8004090:	d803      	bhi.n	800409a <_free_r+0x182>
 8004092:	0bd8      	lsrs	r0, r3, #15
 8004094:	3077      	adds	r0, #119	; 0x77
 8004096:	0041      	lsls	r1, r0, #1
 8004098:	e78a      	b.n	8003fb0 <_free_r+0x98>
 800409a:	f240 5154 	movw	r1, #1364	; 0x554
 800409e:	428a      	cmp	r2, r1
 80040a0:	bf9d      	ittte	ls
 80040a2:	0c98      	lsrls	r0, r3, #18
 80040a4:	307c      	addls	r0, #124	; 0x7c
 80040a6:	0041      	lslls	r1, r0, #1
 80040a8:	21fc      	movhi	r1, #252	; 0xfc
 80040aa:	bf88      	it	hi
 80040ac:	207e      	movhi	r0, #126	; 0x7e
 80040ae:	e77f      	b.n	8003fb0 <_free_r+0x98>
 80040b0:	2000047c 	.word	0x2000047c
 80040b4:	454c4449 	.word	0x454c4449
 80040b8:	00000000 	.word	0x00000000
 80040bc:	00000a0d 	.word	0x00000a0d
 80040c0:	20207525 	.word	0x20207525
 80040c4:	20206325 	.word	0x20206325
 80040c8:	36312d25 	.word	0x36312d25
 80040cc:	20202073 	.word	0x20202073
 80040d0:	20202020 	.word	0x20202020
 80040d4:	30202020 	.word	0x30202020
 80040d8:	30202020 	.word	0x30202020
 80040dc:	20202525 	.word	0x20202525
 80040e0:	0d753525 	.word	0x0d753525
 80040e4:	0000000a 	.word	0x0000000a
 80040e8:	20207525 	.word	0x20207525
 80040ec:	20206325 	.word	0x20206325
 80040f0:	36312d25 	.word	0x36312d25
 80040f4:	31252073 	.word	0x31252073
 80040f8:	25207530 	.word	0x25207530
 80040fc:	25257533 	.word	0x25257533
 8004100:	35252020 	.word	0x35252020
 8004104:	000a0d75 	.word	0x000a0d75
 8004108:	20207525 	.word	0x20207525
 800410c:	20206325 	.word	0x20206325
 8004110:	36312d25 	.word	0x36312d25
 8004114:	31252073 	.word	0x31252073
 8004118:	20207530 	.word	0x20207530
 800411c:	2525313c 	.word	0x2525313c
 8004120:	35252020 	.word	0x35252020
 8004124:	000a0d75 	.word	0x000a0d75
 8004128:	6d6d6f43 	.word	0x6d6d6f43
 800412c:	3a646e61 	.word	0x3a646e61
 8004130:	00000020 	.word	0x00000020
 8004134:	64616552 	.word	0x64616552
 8004138:	20487020 	.word	0x20487020
 800413c:	6574654d 	.word	0x6574654d
 8004140:	2e2e2e72 	.word	0x2e2e2e72
 8004144:	00000a0d 	.word	0x00000a0d
 8004148:	4c554f43 	.word	0x4c554f43
 800414c:	20544e44 	.word	0x20544e44
 8004150:	454b4154 	.word	0x454b4154
 8004154:	4d455320 	.word	0x4d455320
 8004158:	4f485041 	.word	0x4f485041
 800415c:	00004552 	.word	0x00004552
 8004160:	72617453 	.word	0x72617453
 8004164:	676e6974 	.word	0x676e6974
 8004168:	206f7420 	.word	0x206f7420
 800416c:	70736964 	.word	0x70736964
 8004170:	65736e65 	.word	0x65736e65
 8004174:	0d2e2e2e 	.word	0x0d2e2e2e
 8004178:	0000000a 	.word	0x0000000a
 800417c:	696e6946 	.word	0x696e6946
 8004180:	64656873 	.word	0x64656873
 8004184:	73696420 	.word	0x73696420
 8004188:	736e6570 	.word	0x736e6570
 800418c:	0d676e69 	.word	0x0d676e69
 8004190:	0000000a 	.word	0x0000000a
 8004194:	4d555050 	.word	0x4d555050
 8004198:	49445f50 	.word	0x49445f50
 800419c:	4e455053 	.word	0x4e455053
 80041a0:	43204553 	.word	0x43204553
 80041a4:	444c554f 	.word	0x444c554f
 80041a8:	4720544e 	.word	0x4720544e
 80041ac:	4d205445 	.word	0x4d205445
 80041b0:	58455455 	.word	0x58455455
 80041b4:	00000a0d 	.word	0x00000a0d
 80041b8:	2d2d2d2d 	.word	0x2d2d2d2d
 80041bc:	2d2d2d2d 	.word	0x2d2d2d2d
 80041c0:	2d2d2d2d 	.word	0x2d2d2d2d
 80041c4:	2d2d2d2d 	.word	0x2d2d2d2d
 80041c8:	280a0d2d 	.word	0x280a0d2d
 80041cc:	61742931 	.word	0x61742931
 80041d0:	74656772 	.word	0x74656772
 80041d4:	3a687020 	.word	0x3a687020
 80041d8:	00000020 	.word	0x00000020
 80041dc:	63657845 	.word	0x63657845
 80041e0:	6e697475 	.word	0x6e697475
 80041e4:	48502067 	.word	0x48502067
 80041e8:	7361745f 	.word	0x7361745f
 80041ec:	2e2e2e6b 	.word	0x2e2e2e6b
 80041f0:	00000a0d 	.word	0x00000a0d
 80041f4:	4d5f4850 	.word	0x4d5f4850
 80041f8:	52455445 	.word	0x52455445
 80041fc:	756d3e2d 	.word	0x756d3e2d
 8004200:	20786574 	.word	0x20786574
 8004204:	4e203d3d 	.word	0x4e203d3d
 8004208:	0d4c4c55 	.word	0x0d4c4c55
 800420c:	0000000a 	.word	0x0000000a
 8004210:	2d2d2d2d 	.word	0x2d2d2d2d
 8004214:	2d2d2d2d 	.word	0x2d2d2d2d
 8004218:	2d2d2d2d 	.word	0x2d2d2d2d
 800421c:	2d2d2d2d 	.word	0x2d2d2d2d
 8004220:	740a0d2d 	.word	0x740a0d2d
 8004224:	65677261 	.word	0x65677261
 8004228:	68702074 	.word	0x68702074
 800422c:	0000203a 	.word	0x0000203a
 8004230:	52204850 	.word	0x52204850
 8004234:	00646165 	.word	0x00646165
 8004238:	4554454d 	.word	0x4554454d
 800423c:	45522052 	.word	0x45522052
 8004240:	53204441 	.word	0x53204441
 8004244:	45434355 	.word	0x45434355
 8004248:	55465353 	.word	0x55465353
 800424c:	2e594c4c 	.word	0x2e594c4c
 8004250:	3d485020 	.word	0x3d485020
 8004254:	00000000 	.word	0x00000000
 8004258:	72617409 	.word	0x72617409
 800425c:	5f746567 	.word	0x5f746567
 8004260:	003d4850 	.word	0x003d4850
 8004264:	49444441 	.word	0x49444441
 8004268:	5020474e 	.word	0x5020474e
 800426c:	50552048 	.word	0x50552048
 8004270:	00000a0d 	.word	0x00000a0d
 8004274:	00005050 	.word	0x00005050
 8004278:	49444441 	.word	0x49444441
 800427c:	5020474e 	.word	0x5020474e
 8004280:	4f442048 	.word	0x4f442048
 8004284:	0a0d4e57 	.word	0x0a0d4e57
 8004288:	00000000 	.word	0x00000000
 800428c:	42415453 	.word	0x42415453
 8004290:	5a494c49 	.word	0x5a494c49
 8004294:	50204445 	.word	0x50204445
 8004298:	454c2048 	.word	0x454c2048
 800429c:	534c4556 	.word	0x534c4556
 80042a0:	00004020 	.word	0x00004020
 80042a4:	4c554f43 	.word	0x4c554f43
 80042a8:	20544e44 	.word	0x20544e44
 80042ac:	45434341 	.word	0x45434341
 80042b0:	53205353 	.word	0x53205353
 80042b4:	4c454641 	.word	0x4c454641
 80042b8:	4e492059 	.word	0x4e492059
 80042bc:	5f485020 	.word	0x5f485020
 80042c0:	4b534154 	.word	0x4b534154
 80042c4:	00000a0d 	.word	0x00000a0d
 80042c8:	646e6168 	.word	0x646e6168
 80042cc:	755f656c 	.word	0x755f656c
 80042d0:	5f747261 	.word	0x5f747261
 80042d4:	6d6d6f63 	.word	0x6d6d6f63
 80042d8:	00646e61 	.word	0x00646e61
 80042dc:	63657845 	.word	0x63657845
 80042e0:	64657475 	.word	0x64657475
 80042e4:	67694c20 	.word	0x67694c20
 80042e8:	745f7468 	.word	0x745f7468
 80042ec:	0d6b7361 	.word	0x0d6b7361
 80042f0:	0000000a 	.word	0x0000000a
 80042f4:	746f6f42 	.word	0x746f6f42
 80042f8:	20676e69 	.word	0x20676e69
 80042fc:	2e2e7075 	.word	0x2e2e7075
 8004300:	000a0d2e 	.word	0x000a0d2e
 8004304:	656c6469 	.word	0x656c6469
 8004308:	696c625f 	.word	0x696c625f
 800430c:	00796b6e 	.word	0x00796b6e
 8004310:	00485076 	.word	0x00485076
 8004314:	2d2d2d2d 	.word	0x2d2d2d2d
 8004318:	2d2d2d2d 	.word	0x2d2d2d2d
 800431c:	2d2d2d2d 	.word	0x2d2d2d2d
 8004320:	2d2d2d2d 	.word	0x2d2d2d2d
 8004324:	280a0d2d 	.word	0x280a0d2d
 8004328:	61742932 	.word	0x61742932
 800432c:	74656772 	.word	0x74656772
 8004330:	3a687020 	.word	0x3a687020
 8004334:	00000020 	.word	0x00000020
 8004338:	00000043 	.word	0x00000043

0800433c <_global_impure_ptr>:
 800433c:	20000048                                H.. 

08004340 <_init>:
 8004340:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8004342:	bf00      	nop
 8004344:	bcf8      	pop	{r3, r4, r5, r6, r7}
 8004346:	bc08      	pop	{r3}
 8004348:	469e      	mov	lr, r3
 800434a:	4770      	bx	lr

0800434c <_fini>:
 800434c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800434e:	bf00      	nop
 8004350:	bcf8      	pop	{r3, r4, r5, r6, r7}
 8004352:	bc08      	pop	{r3}
 8004354:	469e      	mov	lr, r3
 8004356:	4770      	bx	lr
