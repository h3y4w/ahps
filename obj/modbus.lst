   1              		.syntax unified
   2              		.cpu cortex-m4
   3              		.eabi_attribute 27, 3
   4              		.fpu fpv4-sp-d16
   5              		.eabi_attribute 20, 1
   6              		.eabi_attribute 21, 1
   7              		.eabi_attribute 23, 3
   8              		.eabi_attribute 24, 1
   9              		.eabi_attribute 25, 1
  10              		.eabi_attribute 26, 1
  11              		.eabi_attribute 30, 1
  12              		.eabi_attribute 34, 1
  13              		.eabi_attribute 18, 4
  14              		.thumb
  15              		.file	"modbus.c"
  16              		.text
  17              	.Ltext0:
  18              		.cfi_sections	.debug_frame
  19              		.section	.text.addData,"ax",%progbits
  20              		.align	2
  21              		.global	addData
  22              		.thumb
  23              		.thumb_func
  25              	addData:
  26              	.LFB0:
  27              		.file 1 "src/modbus.c"
   1:src/modbus.c  **** /*
   2:src/modbus.c  ****  * modbus.h
   3:src/modbus.c  ****  *
   4:src/modbus.c  ****  *  Created on: 29-Nov-2012
   5:src/modbus.c  ****  *  Author: chetanpatil
   6:src/modbus.c  ****  */
   7:src/modbus.c  **** 
   8:src/modbus.c  **** #include "modbus.h"
   9:src/modbus.c  **** 
  10:src/modbus.c  **** uint32_t firstRequest = 0;
  11:src/modbus.c  **** uint32_t totalRequest = 0;
  12:src/modbus.c  **** uint32_t writeRequest = 0;
  13:src/modbus.c  **** 
  14:src/modbus.c  **** // Creating packet to send the data back to Master as requested
  15:src/modbus.c  **** uint32_t arrayResponsePacket[50] = { 0 };
  16:src/modbus.c  **** uint32_t *rPacket = arrayResponsePacket;
  17:src/modbus.c  **** 
  18:src/modbus.c  **** // HASHMAP : Using uthash.h
  19:src/modbus.c  **** struct heapStruct *users = NULL;
  20:src/modbus.c  **** struct heapStruct *s;
  21:src/modbus.c  **** 
  22:src/modbus.c  **** //Add the data in HASH MAP
  23:src/modbus.c  **** void addData(uint32_t keyID, uint32_t *keyValue) {
  28              		.loc 1 23 0
  29              		.cfi_startproc
  30              		@ args = 0, pretend = 0, frame = 8
  31              		@ frame_needed = 0, uses_anonymous_args = 0
  32              	.LVL0:
  33 0000 2DE9F047 		push	{r4, r5, r6, r7, r8, r9, r10, lr}
  34              	.LCFI0:
  35              		.cfi_def_cfa_offset 32
  36              		.cfi_offset 4, -32
  37              		.cfi_offset 5, -28
  38              		.cfi_offset 6, -24
  39              		.cfi_offset 7, -20
  40              		.cfi_offset 8, -16
  41              		.cfi_offset 9, -12
  42              		.cfi_offset 10, -8
  43              		.cfi_offset 14, -4
  44 0004 82B0     		sub	sp, sp, #8
  45              	.LCFI1:
  46              		.cfi_def_cfa_offset 40
  47 0006 0190     		str	r0, [sp, #4]
  48 0008 8A46     		mov	r10, r1
  49              	.LVL1:
  50              	.LBB2:
  24:src/modbus.c  **** 	struct heapStruct *s;
  25:src/modbus.c  **** 
  26:src/modbus.c  **** 	HASH_FIND_INT(users, &keyID, s);
  51              		.loc 1 26 0
  52 000a 40F20003 		movw	r3, #:lower16:.LANCHOR0
  53 000e C0F20003 		movt	r3, #:upper16:.LANCHOR0
  54 0012 D3F80090 		ldr	r9, [r3]
  55 0016 0024     		movs	r4, #0
  56 0018 B9F1000F 		cmp	r9, #0
  57 001c 67D0     		beq	.L2
  58              	.LVL2:
  59              	.LBB3:
  60              		.loc 1 26 0 is_stmt 0 discriminator 1
  61 001e 9DF80720 		ldrb	r2, [sp, #7]	@ zero_extendqisi2
  62 0022 47F6B913 		movw	r3, #31161
  63 0026 C9F63763 		movt	r3, 40503
  64 002a 03EB0263 		add	r3, r3, r2, lsl #24
  65              	.LVL3:
  66 002e 9DF80620 		ldrb	r2, [sp, #6]	@ zero_extendqisi2
  67 0032 03EB0243 		add	r3, r3, r2, lsl #16
  68              	.LVL4:
  69 0036 9DF80520 		ldrb	r2, [sp, #5]	@ zero_extendqisi2
  70 003a 03EB0222 		add	r2, r3, r2, lsl #8
  71              	.LVL5:
  72 003e 9DF80430 		ldrb	r3, [sp, #4]	@ zero_extendqisi2
  73 0042 1344     		add	r3, r3, r2
  74              	.LVL6:
  75 0044 4CF25472 		movw	r2, #51028
  76 0048 C6F2DA22 		movt	r2, 25306
  77              	.LVL7:
  78 004c 1A44     		add	r2, r2, r3
  79              	.LVL8:
  80 004e 4FF26D73 		movw	r3, #63341
  81 0052 C0F20703 		movt	r3, 7
  82              	.LVL9:
  83 0056 5340     		eors	r3, r3, r2
  84              	.LVL10:
  85 0058 4BF6C622 		movw	r2, #47814
  86 005c C9F64972 		movt	r2, 40777
  87              	.LVL11:
  88 0060 D21A     		subs	r2, r2, r3
  89              	.LVL12:
  90 0062 82EA0322 		eor	r2, r2, r3, lsl #8
  91              	.LVL13:
  92 0066 4BF6F360 		movw	r0, #48883
  93              	.LVL14:
  94 006a CFF6ED60 		movt	r0, 65261
  95              	.LVL15:
  96 006e C01A     		subs	r0, r0, r3
  97              	.LVL16:
  98 0070 801A     		subs	r0, r0, r2
  99              	.LVL17:
 100 0072 80EA5230 		eor	r0, r0, r2, lsr #13
 101              	.LVL18:
 102 0076 991A     		subs	r1, r3, r2
 103              	.LVL19:
 104 0078 091A     		subs	r1, r1, r0
 105              	.LVL20:
 106 007a 81EA1031 		eor	r1, r1, r0, lsr #12
 107              	.LVL21:
 108 007e 121A     		subs	r2, r2, r0
 109              	.LVL22:
 110 0080 521A     		subs	r2, r2, r1
 111              	.LVL23:
 112 0082 82EA0142 		eor	r2, r2, r1, lsl #16
 113              	.LVL24:
 114 0086 431A     		subs	r3, r0, r1
 115              	.LVL25:
 116 0088 9B1A     		subs	r3, r3, r2
 117              	.LVL26:
 118 008a 83EA5213 		eor	r3, r3, r2, lsr #5
 119              	.LVL27:
 120 008e 891A     		subs	r1, r1, r2
 121              	.LVL28:
 122 0090 C91A     		subs	r1, r1, r3
 123              	.LVL29:
 124 0092 81EAD301 		eor	r1, r1, r3, lsr #3
 125              	.LVL30:
 126 0096 D21A     		subs	r2, r2, r3
 127              	.LVL31:
 128 0098 521A     		subs	r2, r2, r1
 129              	.LVL32:
 130 009a 82EA8122 		eor	r2, r2, r1, lsl #10
 131              	.LVL33:
 132 009e 5B1A     		subs	r3, r3, r1
 133              	.LVL34:
 134 00a0 9B1A     		subs	r3, r3, r2
 135              	.LVL35:
 136 00a2 83EAD232 		eor	r2, r3, r2, lsr #15
 137              	.LVL36:
 138 00a6 D9F80850 		ldr	r5, [r9, #8]
 139 00aa 6968     		ldr	r1, [r5, #4]
 140              	.LVL37:
 141 00ac 4B1E     		subs	r3, r1, #1
 142 00ae 1340     		ands	r3, r3, r2
 143              	.LVL38:
 144              	.LBE3:
 145 00b0 2A68     		ldr	r2, [r5]
 146              	.LVL39:
 147 00b2 03EB4303 		add	r3, r3, r3, lsl #1
 148              	.LVL40:
 149 00b6 52F82330 		ldr	r3, [r2, r3, lsl #2]
 150 00ba 0024     		movs	r4, #0
 151 00bc 8BB1     		cbz	r3, .L28
 152 00be 6C69     		ldr	r4, [r5, #20]
 153 00c0 1C1B     		subs	r4, r3, r4
 154              	.LVL41:
 155 00c2 0EE0     		b	.L28
 156              	.L7:
 157              		.loc 1 26 0 discriminator 2
 158 00c4 236A     		ldr	r3, [r4, #32]
 159 00c6 042B     		cmp	r3, #4
 160 00c8 05D1     		bne	.L5
 161              		.loc 1 26 0 discriminator 1
 162 00ca E069     		ldr	r0, [r4, #28]
 163 00cc 01A9     		add	r1, sp, #4
 164              	.LVL42:
 165 00ce 4246     		mov	r2, r8
 166 00d0 FFF7FEFF 		bl	memcmp
 167              	.LVL43:
 168 00d4 58B1     		cbz	r0, .L2
 169              	.L5:
 170              		.loc 1 26 0 discriminator 2
 171 00d6 A369     		ldr	r3, [r4, #24]
 172 00d8 3446     		mov	r4, r6
 173              	.LVL44:
 174 00da 2BB1     		cbz	r3, .L27
 175              		.loc 1 26 0 discriminator 1
 176 00dc 6C69     		ldr	r4, [r5, #20]
 177 00de 1C1B     		subs	r4, r3, r4
 178              	.LVL45:
 179 00e0 02E0     		b	.L27
 180              	.LVL46:
 181              	.L28:
 182 00e2 4FF00408 		mov	r8, #4
 183 00e6 0026     		movs	r6, #0
 184              	.L27:
 185              	.LVL47:
 186 00e8 002C     		cmp	r4, #0
 187 00ea EBD1     		bne	.L7
 188 00ec FFE7     		b	.L2
 189              	.LVL48:
 190              	.L2:
 191              	.LBE2:
  27:src/modbus.c  **** 	// id already in the hash?
  28:src/modbus.c  **** 	if (s == NULL) {
 192              		.loc 1 28 0 is_stmt 1
 193 00ee 002C     		cmp	r4, #0
 194 00f0 40F06F81 		bne	.L8
  29:src/modbus.c  **** 		s = (struct heapStruct*) malloc(sizeof(struct heapStruct));
 195              		.loc 1 29 0
 196 00f4 2820     		movs	r0, #40
 197 00f6 FFF7FEFF 		bl	malloc
 198              	.LVL49:
 199 00fa 0446     		mov	r4, r0
 200              	.LVL50:
  30:src/modbus.c  **** 		s->key = keyID;
 201              		.loc 1 30 0
 202 00fc 019B     		ldr	r3, [sp, #4]
 203 00fe 0360     		str	r3, [r0]
 204              	.LBB4:
  31:src/modbus.c  **** 		HASH_ADD_INT( users, key, s);
 205              		.loc 1 31 0
 206 0100 0023     		movs	r3, #0
 207 0102 0361     		str	r3, [r0, #16]
 208 0104 0546     		mov	r5, r0
 209 0106 E061     		str	r0, [r4, #28]
 210 0108 0423     		movs	r3, #4
 211 010a 0362     		str	r3, [r0, #32]
 212 010c B9F1000F 		cmp	r9, #0
 213 0110 59D1     		bne	.L9
 214              		.loc 1 31 0 is_stmt 0 discriminator 1
 215 0112 40F20003 		movw	r3, #:lower16:.LANCHOR0
 216 0116 C0F20003 		movt	r3, #:upper16:.LANCHOR0
 217 011a 1860     		str	r0, [r3]
 218 011c 0023     		movs	r3, #0
 219 011e C360     		str	r3, [r0, #12]
 220 0120 2C20     		movs	r0, #44
 221              	.LVL51:
 222 0122 FFF7FEFF 		bl	malloc
 223              	.LVL52:
 224 0126 A060     		str	r0, [r4, #8]
 225 0128 18B9     		cbnz	r0, .L10
 226 012a 4FF0FF30 		mov	r0, #-1
 227 012e FFF7FEFF 		bl	exit
 228              	.LVL53:
 229              	.L10:
 230              		.loc 1 31 0 discriminator 2
 231 0132 0022     		movs	r2, #0
 232 0134 0346     		mov	r3, r0
 233 0136 43F8042B 		str	r2, [r3], #4
 234 013a 4260     		str	r2, [r0, #4]
 235 013c 0433     		adds	r3, r3, #4
 236 013e 43F8042B 		str	r2, [r3], #4
 237 0142 43F8042B 		str	r2, [r3], #4
 238 0146 43F8042B 		str	r2, [r3], #4
 239 014a 43F8042B 		str	r2, [r3], #4
 240 014e 43F8042B 		str	r2, [r3], #4
 241 0152 43F8042B 		str	r2, [r3], #4
 242 0156 43F8042B 		str	r2, [r3], #4
 243 015a 43F8042B 		str	r2, [r3], #4
 244 015e 1A60     		str	r2, [r3]
 245 0160 40F20006 		movw	r6, #:lower16:.LANCHOR0
 246 0164 C0F20006 		movt	r6, #:upper16:.LANCHOR0
 247 0168 3368     		ldr	r3, [r6]
 248 016a 1A46     		mov	r2, r3
 249 016c 52F8081F 		ldr	r1, [r2, #8]!
 250 0170 0A61     		str	r2, [r1, #16]
 251 0172 9A68     		ldr	r2, [r3, #8]
 252 0174 2021     		movs	r1, #32
 253 0176 5160     		str	r1, [r2, #4]
 254 0178 9A68     		ldr	r2, [r3, #8]
 255 017a 0521     		movs	r1, #5
 256 017c 9160     		str	r1, [r2, #8]
 257 017e 9A68     		ldr	r2, [r3, #8]
 258 0180 0821     		movs	r1, #8
 259 0182 5161     		str	r1, [r2, #20]
 260 0184 D3F80880 		ldr	r8, [r3, #8]
 261 0188 4FF4C070 		mov	r0, #384
 262 018c FFF7FEFF 		bl	malloc
 263              	.LVL54:
 264 0190 C8F80000 		str	r0, [r8]
 265 0194 3368     		ldr	r3, [r6]
 266 0196 9B68     		ldr	r3, [r3, #8]
 267 0198 1868     		ldr	r0, [r3]
 268 019a 18B9     		cbnz	r0, .L11
 269              		.loc 1 31 0 discriminator 1
 270 019c 4FF0FF30 		mov	r0, #-1
 271 01a0 FFF7FEFF 		bl	exit
 272              	.LVL55:
 273              	.L11:
 274              		.loc 1 31 0 discriminator 2
 275 01a4 0021     		movs	r1, #0
 276 01a6 4FF4C072 		mov	r2, #384
 277 01aa FFF7FEFF 		bl	memset
 278              	.LVL56:
 279 01ae 40F20003 		movw	r3, #:lower16:.LANCHOR0
 280 01b2 C0F20003 		movt	r3, #:upper16:.LANCHOR0
 281 01b6 1B68     		ldr	r3, [r3]
 282 01b8 9A68     		ldr	r2, [r3, #8]
 283 01ba 41F6E173 		movw	r3, #8161
 284 01be CAF21103 		movt	r3, 40977
 285 01c2 9362     		str	r3, [r2, #40]
 286 01c4 0EE0     		b	.L12
 287              	.LVL57:
 288              	.L9:
 289 01c6 D9F80830 		ldr	r3, [r9, #8]
 290 01ca 1B69     		ldr	r3, [r3, #16]
 291 01cc 9860     		str	r0, [r3, #8]
 292 01ce D9F80830 		ldr	r3, [r9, #8]
 293 01d2 1A69     		ldr	r2, [r3, #16]
 294 01d4 5B69     		ldr	r3, [r3, #20]
 295 01d6 D31A     		subs	r3, r2, r3
 296 01d8 C360     		str	r3, [r0, #12]
 297 01da D9F80830 		ldr	r3, [r9, #8]
 298 01de 00F10802 		add	r2, r0, #8
 299 01e2 1A61     		str	r2, [r3, #16]
 300              	.LVL58:
 301              	.L12:
 302              		.loc 1 31 0 discriminator 1
 303 01e4 40F20003 		movw	r3, #:lower16:.LANCHOR0
 304 01e8 C0F20003 		movt	r3, #:upper16:.LANCHOR0
 305 01ec 1A68     		ldr	r2, [r3]
 306 01ee 9368     		ldr	r3, [r2, #8]
 307 01f0 D968     		ldr	r1, [r3, #12]
 308 01f2 0131     		adds	r1, r1, #1
 309 01f4 D960     		str	r1, [r3, #12]
 310 01f6 9368     		ldr	r3, [r2, #8]
 311 01f8 A360     		str	r3, [r4, #8]
 312              	.LVL59:
 313              	.LBB5:
 314 01fa 4BF6F360 		movw	r0, #48883
 315 01fe CFF6ED60 		movt	r0, 65261
 316 0202 6062     		str	r0, [r4, #36]
 317 0204 E978     		ldrb	r1, [r5, #3]	@ zero_extendqisi2
 318 0206 47F6B913 		movw	r3, #31161
 319 020a C9F63763 		movt	r3, 40503
 320 020e 03EB0163 		add	r3, r3, r1, lsl #24
 321              	.LVL60:
 322 0212 A978     		ldrb	r1, [r5, #2]	@ zero_extendqisi2
 323 0214 03EB0143 		add	r3, r3, r1, lsl #16
 324              	.LVL61:
 325 0218 6978     		ldrb	r1, [r5, #1]	@ zero_extendqisi2
 326 021a 03EB0121 		add	r1, r3, r1, lsl #8
 327              	.LVL62:
 328 021e 2B78     		ldrb	r3, [r5]	@ zero_extendqisi2
 329 0220 0B44     		add	r3, r3, r1
 330              	.LVL63:
 331 0222 4CF25471 		movw	r1, #51028
 332 0226 C6F2DA21 		movt	r1, 25306
 333              	.LVL64:
 334 022a 1944     		add	r1, r1, r3
 335              	.LVL65:
 336 022c 4FF26D73 		movw	r3, #63341
 337 0230 C0F20703 		movt	r3, 7
 338              	.LVL66:
 339 0234 4B40     		eors	r3, r3, r1
 340              	.LVL67:
 341 0236 4BF6C621 		movw	r1, #47814
 342 023a C9F64971 		movt	r1, 40777
 343              	.LVL68:
 344 023e C91A     		subs	r1, r1, r3
 345              	.LVL69:
 346 0240 81EA0321 		eor	r1, r1, r3, lsl #8
 347              	.LVL70:
 348 0244 C01A     		subs	r0, r0, r3
 349 0246 451A     		subs	r5, r0, r1
 350 0248 85EA5135 		eor	r5, r5, r1, lsr #13
 351 024c 5B1A     		subs	r3, r3, r1
 352              	.LVL71:
 353 024e 581B     		subs	r0, r3, r5
 354              	.LVL72:
 355 0250 80EA1530 		eor	r0, r0, r5, lsr #12
 356              	.LVL73:
 357 0254 491B     		subs	r1, r1, r5
 358              	.LVL74:
 359 0256 091A     		subs	r1, r1, r0
 360              	.LVL75:
 361 0258 81EA0041 		eor	r1, r1, r0, lsl #16
 362              	.LVL76:
 363 025c 2B1A     		subs	r3, r5, r0
 364 025e 5B1A     		subs	r3, r3, r1
 365 0260 83EA5113 		eor	r3, r3, r1, lsr #5
 366 0264 401A     		subs	r0, r0, r1
 367              	.LVL77:
 368 0266 C01A     		subs	r0, r0, r3
 369              	.LVL78:
 370 0268 80EAD300 		eor	r0, r0, r3, lsr #3
 371              	.LVL79:
 372 026c C91A     		subs	r1, r1, r3
 373              	.LVL80:
 374 026e 091A     		subs	r1, r1, r0
 375              	.LVL81:
 376 0270 81EA8021 		eor	r1, r1, r0, lsl #10
 377              	.LVL82:
 378 0274 1B1A     		subs	r3, r3, r0
 379 0276 5B1A     		subs	r3, r3, r1
 380 0278 83EAD133 		eor	r3, r3, r1, lsr #15
 381 027c 6362     		str	r3, [r4, #36]
 382 027e 9168     		ldr	r1, [r2, #8]
 383              	.LVL83:
 384 0280 4868     		ldr	r0, [r1, #4]
 385              	.LVL84:
 386 0282 0138     		subs	r0, r0, #1
 387 0284 0340     		ands	r3, r3, r0
 388              	.LVL85:
 389              	.LBE5:
 390 0286 0968     		ldr	r1, [r1]
 391 0288 03EB4303 		add	r3, r3, r3, lsl #1
 392              	.LVL86:
 393 028c 9B00     		lsls	r3, r3, #2
 394 028e 1944     		add	r1, r1, r3
 395 0290 4868     		ldr	r0, [r1, #4]
 396              	.LVL87:
 397 0292 0130     		adds	r0, r0, #1
 398 0294 4860     		str	r0, [r1, #4]
 399              	.LVL88:
 400 0296 9168     		ldr	r1, [r2, #8]
 401 0298 0968     		ldr	r1, [r1]
 402 029a C958     		ldr	r1, [r1, r3]
 403 029c A161     		str	r1, [r4, #24]
 404 029e 0021     		movs	r1, #0
 405 02a0 6161     		str	r1, [r4, #20]
 406 02a2 9168     		ldr	r1, [r2, #8]
 407 02a4 0968     		ldr	r1, [r1]
 408 02a6 C958     		ldr	r1, [r1, r3]
 409 02a8 11B1     		cbz	r1, .L13
 410 02aa 04F10800 		add	r0, r4, #8
 411 02ae C860     		str	r0, [r1, #12]
 412              	.L13:
 413              		.loc 1 31 0 discriminator 2
 414 02b0 9268     		ldr	r2, [r2, #8]
 415 02b2 1268     		ldr	r2, [r2]
 416 02b4 04F10801 		add	r1, r4, #8
 417 02b8 D150     		str	r1, [r2, r3]
 418 02ba 40F20002 		movw	r2, #:lower16:.LANCHOR0
 419 02be C0F20002 		movt	r2, #:upper16:.LANCHOR0
 420 02c2 1268     		ldr	r2, [r2]
 421 02c4 9268     		ldr	r2, [r2, #8]
 422 02c6 1268     		ldr	r2, [r2]
 423 02c8 1344     		add	r3, r3, r2
 424 02ca 5A68     		ldr	r2, [r3, #4]
 425 02cc 9B68     		ldr	r3, [r3, #8]
 426 02ce 0133     		adds	r3, r3, #1
 427 02d0 03EB8303 		add	r3, r3, r3, lsl #2
 428 02d4 B2EB430F 		cmp	r2, r3, lsl #1
 429 02d8 7BD3     		bcc	.L8
 430              		.loc 1 31 0 discriminator 1
 431 02da A668     		ldr	r6, [r4, #8]
 432 02dc 736A     		ldr	r3, [r6, #36]
 433 02de 012B     		cmp	r3, #1
 434 02e0 77D0     		beq	.L8
 435              	.LBB6:
 436 02e2 7368     		ldr	r3, [r6, #4]
 437 02e4 03EB4303 		add	r3, r3, r3, lsl #1
 438 02e8 4FEAC308 		lsl	r8, r3, #3
 439 02ec 4046     		mov	r0, r8
 440 02ee FFF7FEFF 		bl	malloc
 441              	.LVL89:
 442 02f2 0546     		mov	r5, r0
 443 02f4 18B9     		cbnz	r0, .L14
 444 02f6 4FF0FF30 		mov	r0, #-1
 445              	.LVL90:
 446 02fa FFF7FEFF 		bl	exit
 447              	.LVL91:
 448              	.L14:
 449              		.loc 1 31 0 discriminator 2
 450 02fe 0021     		movs	r1, #0
 451 0300 4246     		mov	r2, r8
 452 0302 FFF7FEFF 		bl	memset
 453              	.LVL92:
 454 0306 F368     		ldr	r3, [r6, #12]
 455 0308 B268     		ldr	r2, [r6, #8]
 456 030a 0132     		adds	r2, r2, #1
 457 030c 23FA02F1 		lsr	r1, r3, r2
 458 0310 7268     		ldr	r2, [r6, #4]
 459 0312 5200     		lsls	r2, r2, #1
 460 0314 013A     		subs	r2, r2, #1
 461 0316 1340     		ands	r3, r3, r2
 462 0318 002B     		cmp	r3, #0
 463 031a 0CBF     		ite	eq
 464 031c 0B46     		moveq	r3, r1
 465 031e 4B1C     		addne	r3, r1, #1
 466 0320 B361     		str	r3, [r6, #24]
 467 0322 A268     		ldr	r2, [r4, #8]
 468 0324 0023     		movs	r3, #0
 469 0326 D361     		str	r3, [r2, #28]
 470              	.LVL93:
 471 0328 9946     		mov	r9, r3
 472 032a 9C46     		mov	ip, r3
 473 032c 30E0     		b	.L16
 474              	.LVL94:
 475              	.L21:
 476 032e 1B68     		ldr	r3, [r3]
 477 0330 09EB4902 		add	r2, r9, r9, lsl #1
 478 0334 53F82230 		ldr	r3, [r3, r2, lsl #2]
 479              	.LVL95:
 480 0338 26E0     		b	.L17
 481              	.L20:
 482 033a D3F810E0 		ldr	lr, [r3, #16]
 483              	.LVL96:
 484 033e D969     		ldr	r1, [r3, #28]
 485 0340 A668     		ldr	r6, [r4, #8]
 486 0342 7268     		ldr	r2, [r6, #4]
 487 0344 5200     		lsls	r2, r2, #1
 488 0346 013A     		subs	r2, r2, #1
 489 0348 0A40     		ands	r2, r2, r1
 490              	.LVL97:
 491 034a 02EB4202 		add	r2, r2, r2, lsl #1
 492              	.LVL98:
 493 034e 05EB8200 		add	r0, r5, r2, lsl #2
 494              	.LVL99:
 495 0352 4168     		ldr	r1, [r0, #4]
 496              	.LVL100:
 497 0354 0131     		adds	r1, r1, #1
 498 0356 4160     		str	r1, [r0, #4]
 499              	.LVL101:
 500 0358 B769     		ldr	r7, [r6, #24]
 501 035a B942     		cmp	r1, r7
 502 035c 08D9     		bls	.L18
 503              		.loc 1 31 0 discriminator 1
 504 035e F169     		ldr	r1, [r6, #28]
 505 0360 0131     		adds	r1, r1, #1
 506 0362 F161     		str	r1, [r6, #28]
 507 0364 4168     		ldr	r1, [r0, #4]
 508 0366 A668     		ldr	r6, [r4, #8]
 509 0368 B669     		ldr	r6, [r6, #24]
 510 036a B1FBF6F1 		udiv	r1, r1, r6
 511 036e 8160     		str	r1, [r0, #8]
 512              	.L18:
 513              		.loc 1 31 0 discriminator 2
 514 0370 C3F80CC0 		str	ip, [r3, #12]
 515 0374 55F82210 		ldr	r1, [r5, r2, lsl #2]
 516 0378 1961     		str	r1, [r3, #16]
 517 037a 55F82210 		ldr	r1, [r5, r2, lsl #2]
 518 037e 01B1     		cbz	r1, .L19
 519              		.loc 1 31 0 discriminator 1
 520 0380 CB60     		str	r3, [r1, #12]
 521              	.L19:
 522              		.loc 1 31 0 discriminator 2
 523 0382 45F82230 		str	r3, [r5, r2, lsl #2]
 524              	.LVL102:
 525 0386 7346     		mov	r3, lr
 526              	.LVL103:
 527              	.L17:
 528              		.loc 1 31 0 discriminator 1
 529 0388 002B     		cmp	r3, #0
 530 038a D6D1     		bne	.L20
 531              		.loc 1 31 0 discriminator 3
 532 038c 09F10109 		add	r9, r9, #1
 533              	.LVL104:
 534              	.L16:
 535              		.loc 1 31 0 discriminator 1
 536 0390 A368     		ldr	r3, [r4, #8]
 537 0392 5A68     		ldr	r2, [r3, #4]
 538 0394 4A45     		cmp	r2, r9
 539 0396 CAD8     		bhi	.L21
 540              		.loc 1 31 0 discriminator 3
 541 0398 1868     		ldr	r0, [r3]
 542 039a FFF7FEFF 		bl	free
 543              	.LVL105:
 544 039e A368     		ldr	r3, [r4, #8]
 545 03a0 5A68     		ldr	r2, [r3, #4]
 546 03a2 5200     		lsls	r2, r2, #1
 547 03a4 5A60     		str	r2, [r3, #4]
 548 03a6 A368     		ldr	r3, [r4, #8]
 549 03a8 9A68     		ldr	r2, [r3, #8]
 550 03aa 0132     		adds	r2, r2, #1
 551 03ac 9A60     		str	r2, [r3, #8]
 552 03ae A368     		ldr	r3, [r4, #8]
 553 03b0 1D60     		str	r5, [r3]
 554 03b2 A368     		ldr	r3, [r4, #8]
 555 03b4 DA69     		ldr	r2, [r3, #28]
 556 03b6 D968     		ldr	r1, [r3, #12]
 557 03b8 B2EB510F 		cmp	r2, r1, lsr #1
 558 03bc 86BF     		itte	hi
 559 03be 1A6A     		ldrhi	r2, [r3, #32]
 560 03c0 0132     		addhi	r2, r2, #1
 561 03c2 0022     		movls	r2, #0
 562 03c4 1A62     		str	r2, [r3, #32]
 563 03c6 A368     		ldr	r3, [r4, #8]
 564 03c8 1A6A     		ldr	r2, [r3, #32]
 565 03ca 012A     		cmp	r2, #1
 566 03cc 84BF     		itt	hi
 567 03ce 0122     		movhi	r2, #1
 568 03d0 5A62     		strhi	r2, [r3, #36]
 569              	.LVL106:
 570              	.L8:
 571              	.LBE6:
 572              	.LBE4:
  32:src/modbus.c  **** 		// id: name of key field
  33:src/modbus.c  **** 	}
  34:src/modbus.c  **** 
  35:src/modbus.c  **** 	s->value = (int) keyValue;
 573              		.loc 1 35 0 is_stmt 1
 574 03d2 C4F804A0 		str	r10, [r4, #4]
  36:src/modbus.c  **** }
 575              		.loc 1 36 0
 576 03d6 02B0     		add	sp, sp, #8
 577              		@ sp needed
 578 03d8 BDE8F087 		pop	{r4, r5, r6, r7, r8, r9, r10, pc}
 579              		.cfi_endproc
 580              	.LFE0:
 582              		.section	.text.putData,"ax",%progbits
 583              		.align	2
 584              		.global	putData
 585              		.thumb
 586              		.thumb_func
 588              	putData:
 589              	.LFB1:
  37:src/modbus.c  **** 
  38:src/modbus.c  **** //Print the data from HASH MAP
  39:src/modbus.c  **** void putData() {
 590              		.loc 1 39 0
 591              		.cfi_startproc
 592              		@ args = 0, pretend = 0, frame = 0
 593              		@ frame_needed = 0, uses_anonymous_args = 0
 594 0000 38B5     		push	{r3, r4, r5, lr}
 595              	.LCFI2:
 596              		.cfi_def_cfa_offset 16
 597              		.cfi_offset 3, -16
 598              		.cfi_offset 4, -12
 599              		.cfi_offset 5, -8
 600              		.cfi_offset 14, -4
  40:src/modbus.c  **** 	struct heapStruct *s;
  41:src/modbus.c  **** 
  42:src/modbus.c  **** 	for (s = users; s != NULL; s = (struct heapStruct*) (s->hh.next)) {
 601              		.loc 1 42 0
 602 0002 40F20003 		movw	r3, #:lower16:.LANCHOR0
 603 0006 C0F20003 		movt	r3, #:upper16:.LANCHOR0
 604 000a 1C68     		ldr	r4, [r3]
 605              	.LVL107:
  43:src/modbus.c  **** 		printf("Key 0x%x --> Data 0x%x\n", s->key, s->value);
 606              		.loc 1 43 0
 607 000c 40F20005 		movw	r5, #:lower16:.LC0
 608 0010 C0F20005 		movt	r5, #:upper16:.LC0
  42:src/modbus.c  **** 		printf("Key 0x%x --> Data 0x%x\n", s->key, s->value);
 609              		.loc 1 42 0
 610 0014 05E0     		b	.L30
 611              	.L31:
 612              		.loc 1 43 0 discriminator 2
 613 0016 2846     		mov	r0, r5
 614 0018 2168     		ldr	r1, [r4]
 615 001a 6268     		ldr	r2, [r4, #4]
 616 001c FFF7FEFF 		bl	printf
 617              	.LVL108:
  42:src/modbus.c  **** 		printf("Key 0x%x --> Data 0x%x\n", s->key, s->value);
 618              		.loc 1 42 0 discriminator 2
 619 0020 2469     		ldr	r4, [r4, #16]
 620              	.LVL109:
 621              	.L30:
  42:src/modbus.c  **** 		printf("Key 0x%x --> Data 0x%x\n", s->key, s->value);
 622              		.loc 1 42 0 is_stmt 0 discriminator 1
 623 0022 002C     		cmp	r4, #0
 624 0024 F7D1     		bne	.L31
  44:src/modbus.c  **** 	}
  45:src/modbus.c  **** }
 625              		.loc 1 45 0 is_stmt 1
 626 0026 38BD     		pop	{r3, r4, r5, pc}
 627              		.cfi_endproc
 628              	.LFE1:
 630              		.section	.text.getData,"ax",%progbits
 631              		.align	2
 632              		.global	getData
 633              		.thumb
 634              		.thumb_func
 636              	getData:
 637              	.LFB2:
  46:src/modbus.c  **** 
  47:src/modbus.c  **** //Fetch the data from HASH MAP
  48:src/modbus.c  **** struct heapStruct *getData(int key) {
 638              		.loc 1 48 0
 639              		.cfi_startproc
 640              		@ args = 0, pretend = 0, frame = 8
 641              		@ frame_needed = 0, uses_anonymous_args = 0
 642              	.LVL110:
 643 0000 F0B5     		push	{r4, r5, r6, r7, lr}
 644              	.LCFI3:
 645              		.cfi_def_cfa_offset 20
 646              		.cfi_offset 4, -20
 647              		.cfi_offset 5, -16
 648              		.cfi_offset 6, -12
 649              		.cfi_offset 7, -8
 650              		.cfi_offset 14, -4
 651 0002 83B0     		sub	sp, sp, #12
 652              	.LCFI4:
 653              		.cfi_def_cfa_offset 32
 654 0004 0190     		str	r0, [sp, #4]
 655              	.LVL111:
 656              	.LBB7:
  49:src/modbus.c  **** 	struct heapStruct *s;
  50:src/modbus.c  **** 	HASH_FIND_INT( users, &key, s);
 657              		.loc 1 50 0
 658 0006 40F20003 		movw	r3, #:lower16:.LANCHOR0
 659 000a C0F20003 		movt	r3, #:upper16:.LANCHOR0
 660 000e 1C68     		ldr	r4, [r3]
 661 0010 002C     		cmp	r4, #0
 662 0012 65D0     		beq	.L39
 663              	.LVL112:
 664              	.LBB8:
 665              		.loc 1 50 0 is_stmt 0 discriminator 1
 666 0014 9DF80720 		ldrb	r2, [sp, #7]	@ zero_extendqisi2
 667 0018 47F6B913 		movw	r3, #31161
 668 001c C9F63763 		movt	r3, 40503
 669 0020 03EB0263 		add	r3, r3, r2, lsl #24
 670              	.LVL113:
 671 0024 9DF80620 		ldrb	r2, [sp, #6]	@ zero_extendqisi2
 672 0028 03EB0243 		add	r3, r3, r2, lsl #16
 673              	.LVL114:
 674 002c 9DF80520 		ldrb	r2, [sp, #5]	@ zero_extendqisi2
 675 0030 03EB0222 		add	r2, r3, r2, lsl #8
 676              	.LVL115:
 677 0034 9DF80430 		ldrb	r3, [sp, #4]	@ zero_extendqisi2
 678 0038 1344     		add	r3, r3, r2
 679              	.LVL116:
 680 003a 4CF25472 		movw	r2, #51028
 681 003e C6F2DA22 		movt	r2, 25306
 682              	.LVL117:
 683 0042 1A44     		add	r2, r2, r3
 684              	.LVL118:
 685 0044 4FF26D73 		movw	r3, #63341
 686 0048 C0F20703 		movt	r3, 7
 687              	.LVL119:
 688 004c 5340     		eors	r3, r3, r2
 689              	.LVL120:
 690 004e 4BF6C622 		movw	r2, #47814
 691 0052 C9F64972 		movt	r2, 40777
 692              	.LVL121:
 693 0056 D21A     		subs	r2, r2, r3
 694              	.LVL122:
 695 0058 82EA0322 		eor	r2, r2, r3, lsl #8
 696              	.LVL123:
 697 005c 4BF6F360 		movw	r0, #48883
 698              	.LVL124:
 699 0060 CFF6ED60 		movt	r0, 65261
 700              	.LVL125:
 701 0064 C01A     		subs	r0, r0, r3
 702              	.LVL126:
 703 0066 801A     		subs	r0, r0, r2
 704              	.LVL127:
 705 0068 80EA5230 		eor	r0, r0, r2, lsr #13
 706              	.LVL128:
 707 006c 991A     		subs	r1, r3, r2
 708              	.LVL129:
 709 006e 091A     		subs	r1, r1, r0
 710              	.LVL130:
 711 0070 81EA1031 		eor	r1, r1, r0, lsr #12
 712              	.LVL131:
 713 0074 121A     		subs	r2, r2, r0
 714              	.LVL132:
 715 0076 521A     		subs	r2, r2, r1
 716              	.LVL133:
 717 0078 82EA0142 		eor	r2, r2, r1, lsl #16
 718              	.LVL134:
 719 007c 431A     		subs	r3, r0, r1
 720              	.LVL135:
 721 007e 9B1A     		subs	r3, r3, r2
 722              	.LVL136:
 723 0080 83EA5213 		eor	r3, r3, r2, lsr #5
 724              	.LVL137:
 725 0084 891A     		subs	r1, r1, r2
 726              	.LVL138:
 727 0086 C91A     		subs	r1, r1, r3
 728              	.LVL139:
 729 0088 81EAD301 		eor	r1, r1, r3, lsr #3
 730              	.LVL140:
 731 008c D21A     		subs	r2, r2, r3
 732              	.LVL141:
 733 008e 521A     		subs	r2, r2, r1
 734              	.LVL142:
 735 0090 82EA8122 		eor	r2, r2, r1, lsl #10
 736              	.LVL143:
 737 0094 5B1A     		subs	r3, r3, r1
 738              	.LVL144:
 739 0096 9B1A     		subs	r3, r3, r2
 740              	.LVL145:
 741 0098 83EAD232 		eor	r2, r3, r2, lsr #15
 742              	.LVL146:
 743 009c A568     		ldr	r5, [r4, #8]
 744 009e 6968     		ldr	r1, [r5, #4]
 745              	.LVL147:
 746 00a0 4B1E     		subs	r3, r1, #1
 747 00a2 1340     		ands	r3, r3, r2
 748              	.LVL148:
 749              	.LBE8:
 750 00a4 2A68     		ldr	r2, [r5]
 751              	.LVL149:
 752 00a6 03EB4303 		add	r3, r3, r3, lsl #1
 753              	.LVL150:
 754 00aa 52F82330 		ldr	r3, [r2, r3, lsl #2]
 755 00ae 0024     		movs	r4, #0
 756 00b0 8BB1     		cbz	r3, .L42
 757 00b2 6C69     		ldr	r4, [r5, #20]
 758 00b4 1C1B     		subs	r4, r3, r4
 759              	.LVL151:
 760 00b6 0EE0     		b	.L42
 761              	.L38:
 762              		.loc 1 50 0 discriminator 2
 763 00b8 236A     		ldr	r3, [r4, #32]
 764 00ba 042B     		cmp	r3, #4
 765 00bc 05D1     		bne	.L36
 766              		.loc 1 50 0 discriminator 1
 767 00be E069     		ldr	r0, [r4, #28]
 768 00c0 01A9     		add	r1, sp, #4
 769              	.LVL152:
 770 00c2 3A46     		mov	r2, r7
 771 00c4 FFF7FEFF 		bl	memcmp
 772              	.LVL153:
 773 00c8 58B1     		cbz	r0, .L33
 774              	.L36:
 775              		.loc 1 50 0 discriminator 2
 776 00ca A369     		ldr	r3, [r4, #24]
 777 00cc 3446     		mov	r4, r6
 778              	.LVL154:
 779 00ce 23B1     		cbz	r3, .L41
 780              		.loc 1 50 0 discriminator 1
 781 00d0 6C69     		ldr	r4, [r5, #20]
 782 00d2 1C1B     		subs	r4, r3, r4
 783              	.LVL155:
 784 00d4 01E0     		b	.L41
 785              	.LVL156:
 786              	.L42:
 787 00d6 0427     		movs	r7, #4
 788 00d8 0026     		movs	r6, #0
 789              	.L41:
 790              	.LVL157:
 791 00da 002C     		cmp	r4, #0
 792 00dc ECD1     		bne	.L38
 793 00de 00E0     		b	.L33
 794              	.LVL158:
 795              	.L39:
 796              		.loc 1 50 0
 797 00e0 0024     		movs	r4, #0
 798              	.LVL159:
 799              	.L33:
 800              	.LBE7:
  51:src/modbus.c  **** 	//s: output pointer
  52:src/modbus.c  **** 	//printf("Data: 0x%x\n", s ? s->name : "unknown");
  53:src/modbus.c  **** 	return s;
  54:src/modbus.c  **** }
 801              		.loc 1 54 0 is_stmt 1
 802 00e2 2046     		mov	r0, r4
 803 00e4 03B0     		add	sp, sp, #12
 804              		@ sp needed
 805 00e6 F0BD     		pop	{r4, r5, r6, r7, pc}
 806              		.cfi_endproc
 807              	.LFE2:
 809              		.section	.text.validateSlaveID,"ax",%progbits
 810              		.align	2
 811              		.global	validateSlaveID
 812              		.thumb
 813              		.thumb_func
 815              	validateSlaveID:
 816              	.LFB3:
  55:src/modbus.c  **** 
  56:src/modbus.c  **** // MODBUS :
  57:src/modbus.c  **** 
  58:src/modbus.c  **** //Validating the slaveID
  59:src/modbus.c  **** uint32_t validateSlaveID(uint32_t *qPacket, uint32_t deviceID) {
 817              		.loc 1 59 0
 818              		.cfi_startproc
 819              		@ args = 0, pretend = 0, frame = 0
 820              		@ frame_needed = 0, uses_anonymous_args = 0
 821              		@ link register save eliminated.
 822              	.LVL160:
  60:src/modbus.c  **** 	if (*qPacket == deviceID) {
 823              		.loc 1 60 0
 824 0000 0368     		ldr	r3, [r0]
 825 0002 8B42     		cmp	r3, r1
 826 0004 0AD1     		bne	.L45
  61:src/modbus.c  **** 
  62:src/modbus.c  **** 		//Copy deviceID into repose packet
  63:src/modbus.c  **** 		*rPacket = *qPacket;
 827              		.loc 1 63 0
 828 0006 40F20002 		movw	r2, #:lower16:.LANCHOR1
 829 000a C0F20002 		movt	r2, #:upper16:.LANCHOR1
 830 000e 1168     		ldr	r1, [r2]
 831              	.LVL161:
 832 0010 0B60     		str	r3, [r1]
  64:src/modbus.c  **** 		//printf("%d\n",*rPacket);
  65:src/modbus.c  **** 		rPacket++;
 833              		.loc 1 65 0
 834 0012 1368     		ldr	r3, [r2]
 835 0014 0433     		adds	r3, r3, #4
 836 0016 1360     		str	r3, [r2]
  66:src/modbus.c  **** 		return 1;
 837              		.loc 1 66 0
 838 0018 0120     		movs	r0, #1
 839              	.LVL162:
 840 001a 7047     		bx	lr
 841              	.LVL163:
 842              	.L45:
  67:src/modbus.c  **** 	} else {
  68:src/modbus.c  **** 		return 0;
 843              		.loc 1 68 0
 844 001c 0020     		movs	r0, #0
 845              	.LVL164:
  69:src/modbus.c  **** 	}
  70:src/modbus.c  **** }
 846              		.loc 1 70 0
 847 001e 7047     		bx	lr
 848              		.cfi_endproc
 849              	.LFE3:
 851              		.section	.text.validateCrc,"ax",%progbits
 852              		.align	2
 853              		.global	validateCrc
 854              		.thumb
 855              		.thumb_func
 857              	validateCrc:
 858              	.LFB4:
  71:src/modbus.c  **** 
  72:src/modbus.c  **** uint32_t validateCrc(uint32_t *qPacket,uint32_t usDataLen,uint32_t *tempCRC){
 859              		.loc 1 72 0
 860              		.cfi_startproc
 861              		@ args = 0, pretend = 0, frame = 0
 862              		@ frame_needed = 0, uses_anonymous_args = 0
 863              		@ link register save eliminated.
 864              	.LVL165:
 865 0000 F0B4     		push	{r4, r5, r6, r7}
 866              	.LCFI5:
 867              		.cfi_def_cfa_offset 16
 868              		.cfi_offset 4, -16
 869              		.cfi_offset 5, -12
 870              		.cfi_offset 6, -8
 871              		.cfi_offset 7, -4
 872              	.LVL166:
  73:src/modbus.c  **** 
  74:src/modbus.c  **** 	/*//CRC 16
  75:src/modbus.c  **** 	uint32_t CRC16(uint32_t *qPacket, uint32_t usDataLen) {*/
  76:src/modbus.c  **** 
  77:src/modbus.c  **** 		uint32_t ucrcHi = 0xFF;
  78:src/modbus.c  **** 		uint32_t ucrcLo = 0xFF;
 873              		.loc 1 78 0
 874 0002 FF24     		movs	r4, #255
  77:src/modbus.c  **** 		uint32_t ucrcLo = 0xFF;
 875              		.loc 1 77 0
 876 0004 2546     		mov	r5, r4
  79:src/modbus.c  **** 		uint32_t iIndex;
  80:src/modbus.c  **** 
  81:src/modbus.c  **** 		while(usDataLen--){
  82:src/modbus.c  **** 			iIndex = ucrcLo ^ *(qPacket++);
  83:src/modbus.c  **** 			ucrcLo = ucrcHi ^ crcHi[iIndex];
 877              		.loc 1 83 0
 878 0006 40F2000C 		movw	ip, #:lower16:.LANCHOR2
 879 000a C0F2000C 		movt	ip, #:upper16:.LANCHOR2
  84:src/modbus.c  **** 			ucrcHi = crcLo[iIndex];
 880              		.loc 1 84 0
 881 000e 40F20007 		movw	r7, #:lower16:.LANCHOR3
 882 0012 C0F20007 		movt	r7, #:upper16:.LANCHOR3
  81:src/modbus.c  **** 			iIndex = ucrcLo ^ *(qPacket++);
 883              		.loc 1 81 0
 884 0016 08E0     		b	.L47
 885              	.LVL167:
 886              	.L48:
  82:src/modbus.c  **** 			ucrcLo = ucrcHi ^ crcHi[iIndex];
 887              		.loc 1 82 0
 888 0018 0368     		ldr	r3, [r0]
 889 001a 6340     		eors	r3, r3, r4
 890              	.LVL168:
  83:src/modbus.c  **** 			ucrcHi = crcLo[iIndex];
 891              		.loc 1 83 0
 892 001c 5CF82340 		ldr	r4, [ip, r3, lsl #2]
 893              	.LVL169:
 894 0020 6C40     		eors	r4, r4, r5
 895              	.LVL170:
 896              		.loc 1 84 0
 897 0022 57F82350 		ldr	r5, [r7, r3, lsl #2]
 898              	.LVL171:
  81:src/modbus.c  **** 			iIndex = ucrcLo ^ *(qPacket++);
 899              		.loc 1 81 0
 900 0026 3146     		mov	r1, r6
  82:src/modbus.c  **** 			ucrcLo = ucrcHi ^ crcHi[iIndex];
 901              		.loc 1 82 0
 902 0028 0430     		adds	r0, r0, #4
 903              	.LVL172:
 904              	.L47:
  81:src/modbus.c  **** 			iIndex = ucrcLo ^ *(qPacket++);
 905              		.loc 1 81 0 discriminator 1
 906 002a 4E1E     		subs	r6, r1, #1
 907              	.LVL173:
 908 002c 0029     		cmp	r1, #0
 909 002e F3D1     		bne	.L48
 910              	.LVL174:
  85:src/modbus.c  **** 		}
  86:src/modbus.c  **** 		//ucrcHi = ucrcHi << 8 | ucrcLo;
  87:src/modbus.c  **** 
  88:src/modbus.c  **** 		if (ucrcLo == *tempCRC++){
 911              		.loc 1 88 0
 912 0030 1368     		ldr	r3, [r2]
 913 0032 A342     		cmp	r3, r4
  89:src/modbus.c  **** 			if(ucrcHi ==*tempCRC){
  90:src/modbus.c  **** 				return 1;
  91:src/modbus.c  **** 			}
  92:src/modbus.c  **** 		}
  93:src/modbus.c  **** 		return 0;
 914              		.loc 1 93 0
 915 0034 18BF     		it	ne
 916 0036 0020     		movne	r0, #0
 917              	.LVL175:
  88:src/modbus.c  **** 			if(ucrcHi ==*tempCRC){
 918              		.loc 1 88 0
 919 0038 05D1     		bne	.L49
  89:src/modbus.c  **** 			if(ucrcHi ==*tempCRC){
 920              		.loc 1 89 0
 921 003a 5068     		ldr	r0, [r2, #4]
 922              		.loc 1 93 0
 923 003c A842     		cmp	r0, r5
 924 003e 14BF     		ite	ne
 925 0040 0020     		movne	r0, #0
 926 0042 0120     		moveq	r0, #1
 927 0044 FFE7     		b	.L49
 928              	.L49:
  94:src/modbus.c  **** }
 929              		.loc 1 94 0
 930 0046 F0BC     		pop	{r4, r5, r6, r7}
 931              	.LVL176:
 932 0048 7047     		bx	lr
 933              		.cfi_endproc
 934              	.LFE4:
 936 004a 00BF     		.section	.text.calculateOutputCrc,"ax",%progbits
 937              		.align	2
 938              		.global	calculateOutputCrc
 939              		.thumb
 940              		.thumb_func
 942              	calculateOutputCrc:
 943              	.LFB5:
  95:src/modbus.c  **** 
  96:src/modbus.c  **** uint32_t calculateOutputCrc(uint32_t *tempRpacket,uint32_t rPacketLen){
 944              		.loc 1 96 0
 945              		.cfi_startproc
 946              		@ args = 0, pretend = 0, frame = 0
 947              		@ frame_needed = 0, uses_anonymous_args = 0
 948              		@ link register save eliminated.
 949              	.LVL177:
 950 0000 F0B4     		push	{r4, r5, r6, r7}
 951              	.LCFI6:
 952              		.cfi_def_cfa_offset 16
 953              		.cfi_offset 4, -16
 954              		.cfi_offset 5, -12
 955              		.cfi_offset 6, -8
 956              		.cfi_offset 7, -4
 957              	.LVL178:
  97:src/modbus.c  **** 	
  98:src/modbus.c  **** 	uint32_t ucrcHi = 0xFF;
  99:src/modbus.c  **** 	uint32_t ucrcLo = 0xFF;
 958              		.loc 1 99 0
 959 0002 FF22     		movs	r2, #255
  98:src/modbus.c  **** 	uint32_t ucrcLo = 0xFF;
 960              		.loc 1 98 0
 961 0004 1446     		mov	r4, r2
 100:src/modbus.c  **** 	uint32_t iIndex;
 101:src/modbus.c  **** 
 102:src/modbus.c  **** 	while(rPacketLen--){
 103:src/modbus.c  **** 		iIndex = ucrcLo ^ *(tempRpacket++);
 104:src/modbus.c  **** 		ucrcLo = ucrcHi ^ crcHi[iIndex];
 962              		.loc 1 104 0
 963 0006 40F20007 		movw	r7, #:lower16:.LANCHOR2
 964 000a C0F20007 		movt	r7, #:upper16:.LANCHOR2
 105:src/modbus.c  **** 		ucrcHi = crcLo[iIndex];
 965              		.loc 1 105 0
 966 000e 40F20006 		movw	r6, #:lower16:.LANCHOR3
 967 0012 C0F20006 		movt	r6, #:upper16:.LANCHOR3
 102:src/modbus.c  **** 		iIndex = ucrcLo ^ *(tempRpacket++);
 968              		.loc 1 102 0
 969 0016 08E0     		b	.L53
 970              	.LVL179:
 971              	.L54:
 103:src/modbus.c  **** 		ucrcLo = ucrcHi ^ crcHi[iIndex];
 972              		.loc 1 103 0
 973 0018 0368     		ldr	r3, [r0]
 974 001a 5340     		eors	r3, r3, r2
 975              	.LVL180:
 104:src/modbus.c  **** 		ucrcHi = crcLo[iIndex];
 976              		.loc 1 104 0
 977 001c 57F82320 		ldr	r2, [r7, r3, lsl #2]
 978              	.LVL181:
 979 0020 6240     		eors	r2, r2, r4
 980              	.LVL182:
 981              		.loc 1 105 0
 982 0022 56F82340 		ldr	r4, [r6, r3, lsl #2]
 983              	.LVL183:
 102:src/modbus.c  **** 		iIndex = ucrcLo ^ *(tempRpacket++);
 984              		.loc 1 102 0
 985 0026 2946     		mov	r1, r5
 103:src/modbus.c  **** 		ucrcLo = ucrcHi ^ crcHi[iIndex];
 986              		.loc 1 103 0
 987 0028 0430     		adds	r0, r0, #4
 988              	.LVL184:
 989              	.L53:
 102:src/modbus.c  **** 		iIndex = ucrcLo ^ *(tempRpacket++);
 990              		.loc 1 102 0 discriminator 1
 991 002a 4D1E     		subs	r5, r1, #1
 992              	.LVL185:
 993 002c 0029     		cmp	r1, #0
 994 002e F3D1     		bne	.L54
 106:src/modbus.c  **** 	}
 107:src/modbus.c  **** 	*rPacket++ = ucrcHi;
 995              		.loc 1 107 0
 996 0030 40F20003 		movw	r3, #:lower16:.LANCHOR1
 997 0034 C0F20003 		movt	r3, #:upper16:.LANCHOR1
 998 0038 1968     		ldr	r1, [r3]
 999 003a 081D     		adds	r0, r1, #4
 1000              	.LVL186:
 1001 003c 1860     		str	r0, [r3]
 1002 003e 0C60     		str	r4, [r1]
 108:src/modbus.c  **** 	*rPacket++ = ucrcLo;
 1003              		.loc 1 108 0
 1004 0040 1968     		ldr	r1, [r3]
 1005 0042 081D     		adds	r0, r1, #4
 1006 0044 1860     		str	r0, [r3]
 1007 0046 0A60     		str	r2, [r1]
 109:src/modbus.c  **** 	return 0;		
 110:src/modbus.c  **** }
 1008              		.loc 1 110 0
 1009 0048 0020     		movs	r0, #0
 1010 004a F0BC     		pop	{r4, r5, r6, r7}
 1011              	.LVL187:
 1012 004c 7047     		bx	lr
 1013              		.cfi_endproc
 1014              	.LFE5:
 1016 004e 00BF     		.section	.text.readExceptionStatus,"ax",%progbits
 1017              		.align	2
 1018              		.global	readExceptionStatus
 1019              		.thumb
 1020              		.thumb_func
 1022              	readExceptionStatus:
 1023              	.LFB9:
 111:src/modbus.c  **** 
 112:src/modbus.c  **** //Validate the function
 113:src/modbus.c  **** uint32_t validateFunction(uint32_t *qPacket) {
 114:src/modbus.c  **** 
 115:src/modbus.c  **** 	qPacket++;
 116:src/modbus.c  **** 
 117:src/modbus.c  **** 	//Copy function address in to respose packet
 118:src/modbus.c  **** 	*rPacket = *qPacket;
 119:src/modbus.c  **** 	//printf("%d\n",*rPacket);
 120:src/modbus.c  **** 	rPacket++;
 121:src/modbus.c  **** 
 122:src/modbus.c  **** 	switch (*qPacket) {
 123:src/modbus.c  **** 	case READ_COIL:
 124:src/modbus.c  **** 		readCoil(qPacket);
 125:src/modbus.c  **** 		return 1;
 126:src/modbus.c  **** 		break;
 127:src/modbus.c  **** 	case READ_DISCRETE_INPUTS:
 128:src/modbus.c  **** 		readDiscreteInputs(qPacket);
 129:src/modbus.c  **** 		return 1;
 130:src/modbus.c  **** 		break;
 131:src/modbus.c  **** 	case READ_HOLDING_REGISTERS:
 132:src/modbus.c  **** 		readHoldingRegisters(qPacket);
 133:src/modbus.c  **** 		return 1;
 134:src/modbus.c  **** 		break;
 135:src/modbus.c  **** 	case READ_INPUT_REGISTERS:
 136:src/modbus.c  **** 		readInputRegisters(qPacket);
 137:src/modbus.c  **** 		return 1;
 138:src/modbus.c  **** 		break;
 139:src/modbus.c  **** 	case WRITE_SINGLE_COIL:
 140:src/modbus.c  **** 		writeSingleCoil(qPacket);
 141:src/modbus.c  **** 		return 1;
 142:src/modbus.c  **** 		break;
 143:src/modbus.c  **** 	case WRITE_SINGLE_REGISTER:
 144:src/modbus.c  **** 		writeSingleRegister(qPacket);
 145:src/modbus.c  **** 		return 1;
 146:src/modbus.c  **** 		break;
 147:src/modbus.c  **** 	case WRITE_MULTIPLE_COILS:
 148:src/modbus.c  **** 		writeMultipleCoils(qPacket);
 149:src/modbus.c  **** 		return 1;
 150:src/modbus.c  **** 		break;
 151:src/modbus.c  **** 	case WRITE_MULTIPLE_REGISTERS:
 152:src/modbus.c  **** 		writeMultipleRegisters(qPacket);
 153:src/modbus.c  **** 		return 1;
 154:src/modbus.c  **** 		break;
 155:src/modbus.c  **** 	case READ_EXCEPTION_STATUS:
 156:src/modbus.c  **** 		readExceptionStatus(qPacket);
 157:src/modbus.c  **** 		return 1;
 158:src/modbus.c  **** 		break;
 159:src/modbus.c  **** 	default:
 160:src/modbus.c  **** 		return 0;
 161:src/modbus.c  **** 	}
 162:src/modbus.c  **** }
 163:src/modbus.c  **** 
 164:src/modbus.c  **** 
 165:src/modbus.c  **** //TODO : Code to be checked for Multiple Register Writing
 166:src/modbus.c  **** uint32_t writeMultipleRegisters(uint32_t *qPacket) {
 167:src/modbus.c  **** 
 168:src/modbus.c  **** 	//Point qPacket to first address from where data is to be fetched.
 169:src/modbus.c  **** 	qPacket++;
 170:src/modbus.c  **** 
 171:src/modbus.c  **** 	//Assign first address to firstRequest from qPacket
 172:src/modbus.c  **** 	firstRequest = 0x9c40 + *qPacket++;
 173:src/modbus.c  **** 
 174:src/modbus.c  **** 	//Data address of first coil
 175:src/modbus.c  **** 	*rPacket = (unsigned int) firstRequest;
 176:src/modbus.c  **** 	//printf("%d\n",*rPacket);
 177:src/modbus.c  **** 	rPacket++;
 178:src/modbus.c  **** 
 179:src/modbus.c  **** 	//move the number of registers to be written.
 180:src/modbus.c  **** 	totalRequest = *qPacket++;
 181:src/modbus.c  **** 
 182:src/modbus.c  **** 	//Number of registers to be written
 183:src/modbus.c  **** 	*rPacket = (unsigned int) totalRequest;
 184:src/modbus.c  **** 	rPacket++;
 185:src/modbus.c  **** 
 186:src/modbus.c  **** 	//Number of bytes to be sent to slave by master
 187:src/modbus.c  **** 	unsigned int byteStream = (unsigned int) *qPacket++;
 188:src/modbus.c  **** 
 189:src/modbus.c  **** 	//Fetch first address data.
 190:src/modbus.c  **** 	s = getData(firstRequest++);
 191:src/modbus.c  **** 
 192:src/modbus.c  **** 	//For WRITE_MULTIPLE_REGISTERS
 193:src/modbus.c  **** 	uint32_t *tempWriteData = qPacket;
 194:src/modbus.c  **** 
 195:src/modbus.c  **** 	int dataToBeWritten = *tempWriteData++;
 196:src/modbus.c  **** 
 197:src/modbus.c  **** 	int tempWriteRequest = (int) dataToBeWritten;
 198:src/modbus.c  **** 	int count = byteStream;
 199:src/modbus.c  **** 	int fromBit = 0;
 200:src/modbus.c  **** 	int toBit = 7;
 201:src/modbus.c  **** 	int shiftRight;
 202:src/modbus.c  **** 	//int d;
 203:src/modbus.c  **** 
 204:src/modbus.c  **** 	again: while (count != 0) {
 205:src/modbus.c  **** 
 206:src/modbus.c  **** 		//Call masking function and store value in r.
 207:src/modbus.c  **** 		unsigned int r = getMask(fromBit, toBit);
 208:src/modbus.c  **** 
 209:src/modbus.c  **** 		//Get masking done on data from hash and store in result.
 210:src/modbus.c  **** 		unsigned int result = r & s->value;
 211:src/modbus.c  **** 
 212:src/modbus.c  **** 		tempWriteRequest = r & tempWriteRequest;
 213:src/modbus.c  **** 
 214:src/modbus.c  **** 		//Else shift right.
 215:src/modbus.c  **** 		for (shiftRight = fromBit; shiftRight > 0; shiftRight--) {
 216:src/modbus.c  **** 			result = result >> 1;
 217:src/modbus.c  **** 			tempWriteRequest = tempWriteRequest >> 1;
 218:src/modbus.c  **** 		}
 219:src/modbus.c  **** 
 220:src/modbus.c  **** 		result = result | tempWriteRequest;
 221:src/modbus.c  **** 
 222:src/modbus.c  **** 		//Store the data to be sent in response packet one by one till requested bits reached.
 223:src/modbus.c  **** 		*rPacket = result;
 224:src/modbus.c  **** 		rPacket++;
 225:src/modbus.c  **** //		printf("Data: 0x%x\n", result);
 226:src/modbus.c  **** 
 227:src/modbus.c  **** 		//Decrease the count for number of bytes to be written
 228:src/modbus.c  **** 		count--;
 229:src/modbus.c  **** 		fromBit = fromBit + 8;
 230:src/modbus.c  **** 		toBit = toBit + 8;
 231:src/modbus.c  **** 		tempWriteRequest = (int) dataToBeWritten;
 232:src/modbus.c  **** 
 233:src/modbus.c  **** 		// If two bytes written then move on to next register
 234:src/modbus.c  **** 		if (count == 2) {
 235:src/modbus.c  **** 			s = getData(firstRequest++);
 236:src/modbus.c  **** 			int dataToBeWritten = *tempWriteData;
 237:src/modbus.c  **** 			fromBit = 0;
 238:src/modbus.c  **** 			toBit = 7;
 239:src/modbus.c  **** 			goto again;
 240:src/modbus.c  **** 		}
 241:src/modbus.c  **** 	}
 242:src/modbus.c  **** /*
 243:src/modbus.c  **** 	for (d = 0; d < 5; d++) {
 244:src/modbus.c  **** 		printf("\n0x%x", arrayResponsePacket[d]);
 245:src/modbus.c  **** 	}
 246:src/modbus.c  **** */
 247:src/modbus.c  **** 	return 0;
 248:src/modbus.c  **** 
 249:src/modbus.c  **** }
 250:src/modbus.c  **** 
 251:src/modbus.c  **** //TODO : Code to be checked for Multiple Coils Writing
 252:src/modbus.c  **** uint32_t writeMultipleCoils(uint32_t *qPacket) {
 253:src/modbus.c  **** 
 254:src/modbus.c  **** 	//Point qPacket to first address from where data is to be fetched.
 255:src/modbus.c  **** 	qPacket++;
 256:src/modbus.c  **** 
 257:src/modbus.c  **** 	//Assign first address to firstRequest from qPacket
 258:src/modbus.c  **** 	firstRequest = 0x0000 + *qPacket++;
 259:src/modbus.c  **** 
 260:src/modbus.c  **** 	//Data address of first coil
 261:src/modbus.c  **** 	*rPacket = (unsigned int) firstRequest;
 262:src/modbus.c  **** 	//printf("%d\n",*rPacket);
 263:src/modbus.c  **** 	rPacket++;
 264:src/modbus.c  **** 
 265:src/modbus.c  **** 	//move the number of coils to be written.
 266:src/modbus.c  **** 	totalRequest = *qPacket++;
 267:src/modbus.c  **** 
 268:src/modbus.c  **** 	//Number of coils to be written
 269:src/modbus.c  **** 	*rPacket = (unsigned int) totalRequest;
 270:src/modbus.c  **** 	rPacket++;
 271:src/modbus.c  **** 
 272:src/modbus.c  **** 	//Number of bytes to be sent to slave by master
 273:src/modbus.c  **** 	unsigned int byteStream = (unsigned int) *qPacket++;
 274:src/modbus.c  **** 
 275:src/modbus.c  **** 	//Fetch first address data.
 276:src/modbus.c  **** 	s = getData(firstRequest++);
 277:src/modbus.c  **** 
 278:src/modbus.c  **** 	uint32_t *dataToBeWritten;
 279:src/modbus.c  **** 	dataToBeWritten = qPacket;
 280:src/modbus.c  **** 	qPacket++;
 281:src/modbus.c  **** 
 282:src/modbus.c  **** 	int tempWriteRequest = *dataToBeWritten++;
 283:src/modbus.c  **** 	int count = byteStream;
 284:src/modbus.c  **** 	int fromBit = 0;
 285:src/modbus.c  **** 	int toBit = 7;
 286:src/modbus.c  **** 	int shiftRight;
 287:src/modbus.c  **** 	int d;
 288:src/modbus.c  **** 
 289:src/modbus.c  **** 	while (count != 0) {
 290:src/modbus.c  **** 
 291:src/modbus.c  **** 		//Call masking function and store value in r.
 292:src/modbus.c  **** 		unsigned int r = getMask(fromBit, toBit);
 293:src/modbus.c  **** 
 294:src/modbus.c  **** 		//Get masking done on data from hash and store in result.
 295:src/modbus.c  **** 		unsigned int result = r & s->value;
 296:src/modbus.c  **** 
 297:src/modbus.c  **** 		//tempWriteRequest = r & tempWriteRequest;
 298:src/modbus.c  **** 
 299:src/modbus.c  **** 		//Else shift right.
 300:src/modbus.c  **** 		for (shiftRight = fromBit; shiftRight > 0; shiftRight--) {
 301:src/modbus.c  **** 			result = result >> 1;
 302:src/modbus.c  **** 			//tempWriteRequest = tempWriteRequest << 1;
 303:src/modbus.c  **** 		}
 304:src/modbus.c  **** 
 305:src/modbus.c  **** 		result = result | tempWriteRequest;
 306:src/modbus.c  **** 
 307:src/modbus.c  **** 		//Store the data to be sent in response packet one by one till requested bits reached.
 308:src/modbus.c  **** //		*rPacket = result;
 309:src/modbus.c  **** //		rPacket++;
 310:src/modbus.c  **** 		printf("Data: 0x%x\n", result);
 311:src/modbus.c  **** 
 312:src/modbus.c  **** 		//Decrease the count for number of bytes to be written
 313:src/modbus.c  **** 		count--;
 314:src/modbus.c  **** 		fromBit = fromBit + 8;
 315:src/modbus.c  **** 		toBit = toBit + 8;
 316:src/modbus.c  **** 		tempWriteRequest = *dataToBeWritten++;
 317:src/modbus.c  **** 	}
 318:src/modbus.c  **** 
 319:src/modbus.c  **** //	for (d = 0; d < 5; d++) {
 320:src/modbus.c  **** //		printf("\n0x%x", arrayResponsePacket[d]);
 321:src/modbus.c  **** //	}
 322:src/modbus.c  **** 
 323:src/modbus.c  **** 	return 0;
 324:src/modbus.c  **** }
 325:src/modbus.c  **** 
 326:src/modbus.c  **** uint32_t readExceptionStatus(uint32_t *qPacket) {
 1024              		.loc 1 326 0
 1025              		.cfi_startproc
 1026              		@ args = 0, pretend = 0, frame = 0
 1027              		@ frame_needed = 0, uses_anonymous_args = 0
 1028              		@ link register save eliminated.
 1029              	.LVL188:
 327:src/modbus.c  **** 	return 0;
 328:src/modbus.c  **** }
 1030              		.loc 1 328 0
 1031 0000 0020     		movs	r0, #0
 1032              	.LVL189:
 1033 0002 7047     		bx	lr
 1034              		.cfi_endproc
 1035              	.LFE9:
 1037              		.section	.text.getMask,"ax",%progbits
 1038              		.align	2
 1039              		.global	getMask
 1040              		.thumb
 1041              		.thumb_func
 1043              	getMask:
 1044              	.LFB16:
 329:src/modbus.c  **** 
 330:src/modbus.c  **** uint32_t writeSingleRegister(uint32_t *qPacket) {
 331:src/modbus.c  **** 
 332:src/modbus.c  **** 	//Point qPacket to first address from where data is to be fetched.
 333:src/modbus.c  **** 	qPacket++;
 334:src/modbus.c  **** 
 335:src/modbus.c  **** 	//Store the address requested and move it to response packet
 336:src/modbus.c  **** 	uint32_t tempWriteAddress = *qPacket;
 337:src/modbus.c  **** 	*rPacket = (unsigned int) tempWriteAddress;
 338:src/modbus.c  **** 	rPacket++;
 339:src/modbus.c  **** 
 340:src/modbus.c  **** 	//Assign first address to firstRequest from qPacket and
 341:src/modbus.c  **** 	//qPacket's next value i.e total bit requested to totalRequest.
 342:src/modbus.c  **** 	firstRequest = 0x9c40 + *qPacket++;
 343:src/modbus.c  **** 
 344:src/modbus.c  **** 	//move the data to be written
 345:src/modbus.c  **** 	writeRequest = *qPacket;
 346:src/modbus.c  **** 
 347:src/modbus.c  **** 	//stream to be sent back to response packet
 348:src/modbus.c  **** 	//*rPacket = (unsigned int) firstRequest;
 349:src/modbus.c  **** 	//printf("%d\n",*rPacket);
 350:src/modbus.c  **** 	//rPacket++;
 351:src/modbus.c  **** 
 352:src/modbus.c  **** 	//Fetch first address data.
 353:src/modbus.c  **** 	s = getData(firstRequest++);
 354:src/modbus.c  **** 
 355:src/modbus.c  **** 	int tempWriteRequest = (int) writeRequest;
 356:src/modbus.c  **** 	int fromBit = 0;
 357:src/modbus.c  **** 	int toBit = 32;
 358:src/modbus.c  **** 	int shiftRight;
 359:src/modbus.c  **** 	int d;
 360:src/modbus.c  **** 
 361:src/modbus.c  **** 	//Call masking function and store value in r.
 362:src/modbus.c  **** 	unsigned int r = getMask(fromBit, toBit);
 363:src/modbus.c  **** 
 364:src/modbus.c  **** 	//Get masking done on data from hash and store in result.
 365:src/modbus.c  **** 	unsigned int result = r & s->value;
 366:src/modbus.c  **** 
 367:src/modbus.c  **** 	//Else shift right.
 368:src/modbus.c  **** 	for (shiftRight = fromBit; shiftRight > 0; shiftRight--) {
 369:src/modbus.c  **** 		result = result >> 1;
 370:src/modbus.c  **** 	}
 371:src/modbus.c  **** 
 372:src/modbus.c  **** 	//printf("Data: 0x%x\n", result);
 373:src/modbus.c  **** 
 374:src/modbus.c  **** 	result = result | tempWriteRequest;
 375:src/modbus.c  **** 
 376:src/modbus.c  **** 	//Store the data to be sent in response packet one by one till requested bits reached.
 377:src/modbus.c  **** 	//*rPacket = result;
 378:src/modbus.c  **** 	//rPacket++;
 379:src/modbus.c  **** 	*rPacket = tempWriteRequest;
 380:src/modbus.c  **** 	rPacket++;
 381:src/modbus.c  **** 
 382:src/modbus.c  **** //	for (d = 0; d < (1 + 5); d++) {
 383:src/modbus.c  **** //		printf("\n0x%x", arrayResponsePacket[d]);
 384:src/modbus.c  **** //	}
 385:src/modbus.c  **** 
 386:src/modbus.c  **** 	return 0;
 387:src/modbus.c  **** 
 388:src/modbus.c  **** }
 389:src/modbus.c  **** 
 390:src/modbus.c  **** 
 391:src/modbus.c  **** //TODO : Check what to use for writing ON (0xffff0000 or 0xff00) and OFF (0x00000000 or 0x0000)
 392:src/modbus.c  **** uint32_t writeSingleCoil(uint32_t *qPacket) {
 393:src/modbus.c  **** 
 394:src/modbus.c  **** 	//Point qPacket to first address from where data is to be fetched.
 395:src/modbus.c  **** 	qPacket++;
 396:src/modbus.c  **** 
 397:src/modbus.c  **** 	//Assign first address to firstRequest from qPacket and
 398:src/modbus.c  **** 	//qPacket's next value i.e total bit requested to totalRequest.
 399:src/modbus.c  **** 	firstRequest = 0x0000 + *qPacket++;
 400:src/modbus.c  **** 
 401:src/modbus.c  **** 	//move the data to be written
 402:src/modbus.c  **** 	uint32_t *writeRequest = qPacket;
 403:src/modbus.c  **** //	writeRequest+=3;
 404:src/modbus.c  **** 
 405:src/modbus.c  **** 	//stream to be sent back to response packet
 406:src/modbus.c  **** 	*rPacket = (unsigned int) firstRequest;
 407:src/modbus.c  **** 	//printf("%d\n",*rPacket);
 408:src/modbus.c  **** 	rPacket++;
 409:src/modbus.c  **** 
 410:src/modbus.c  **** 	//Fetch first address data.
 411:src/modbus.c  **** 	s = getData(firstRequest++);
 412:src/modbus.c  **** 
 413:src/modbus.c  **** 	//int tempWriteRequest = (int) writeRequest;
 414:src/modbus.c  **** 	int fromBit = 0;
 415:src/modbus.c  **** 	int toBit = 7;
 416:src/modbus.c  **** 	int shiftRight;
 417:src/modbus.c  **** 	int d;
 418:src/modbus.c  **** 	int count = 0;
 419:src/modbus.c  **** 	unsigned int result;
 420:src/modbus.c  **** 
 421:src/modbus.c  **** 	while(count < 2){
 422:src/modbus.c  **** 		//Call masking function and store value in r.
 423:src/modbus.c  **** 		unsigned int r = getMask(fromBit, toBit);
 424:src/modbus.c  **** 
 425:src/modbus.c  **** 		//Get masking done on data from hash and store in result.
 426:src/modbus.c  **** 		result = r & s->value;
 427:src/modbus.c  **** 
 428:src/modbus.c  **** 		//Else shift right.
 429:src/modbus.c  **** 		for (shiftRight = fromBit; shiftRight > 0; shiftRight--) {
 430:src/modbus.c  **** 			result = result >> 1;
 431:src/modbus.c  **** 		}
 432:src/modbus.c  **** 
 433:src/modbus.c  **** 		*rPacket = *writeRequest;
 434:src/modbus.c  **** 		rPacket++;
 435:src/modbus.c  **** 
 436:src/modbus.c  **** 		result = result | *writeRequest++;
 437:src/modbus.c  **** 
 438:src/modbus.c  **** 		fromBit = fromBit + 8;
 439:src/modbus.c  **** 		toBit = toBit + 8;
 440:src/modbus.c  **** 
 441:src/modbus.c  **** 		count++;
 442:src/modbus.c  **** 	}
 443:src/modbus.c  **** //		//Store the data to be sent in response packet one by one till requested bits reached.
 444:src/modbus.c  **** //		*rPacket = result;
 445:src/modbus.c  **** //		rPacket++;
 446:src/modbus.c  **** //		//printf("Data: 0x%x\n", result);
 447:src/modbus.c  **** 
 448:src/modbus.c  **** 
 449:src/modbus.c  **** //	for (d = 0; d < (1 + 3); d++) {
 450:src/modbus.c  **** //		printf("\n0x%x", arrayResponsePacket[d]);
 451:src/modbus.c  **** //	}
 452:src/modbus.c  **** 
 453:src/modbus.c  **** 	return 0;
 454:src/modbus.c  **** 
 455:src/modbus.c  **** }
 456:src/modbus.c  **** 
 457:src/modbus.c  **** uint32_t readInputRegisters(uint32_t *qPacket) {
 458:src/modbus.c  **** 
 459:src/modbus.c  **** 	//Point qPacket to first address from where data is to be fetched.
 460:src/modbus.c  **** 	qPacket++;
 461:src/modbus.c  **** 
 462:src/modbus.c  **** 	//Assign first address to firstRequest from qPacket and
 463:src/modbus.c  **** 	//qPacket's next value i.e total bit requested to totalRequest.
 464:src/modbus.c  **** 	firstRequest = 0x7530 + *qPacket++;
 465:src/modbus.c  **** 	totalRequest = *qPacket;
 466:src/modbus.c  **** 
 467:src/modbus.c  **** 	//Calculate no. of byte and assign it to rPacket
 468:src/modbus.c  **** 	unsigned int byteStream = ((totalRequest / 8) + 1);
 469:src/modbus.c  **** 
 470:src/modbus.c  **** 	//Copy no. of byte stream to be sent back to reponse packet
 471:src/modbus.c  **** 	*rPacket = (unsigned int) byteStream;
 472:src/modbus.c  **** 	//printf("%d\n",*rPacket);
 473:src/modbus.c  **** 	rPacket++;
 474:src/modbus.c  **** 
 475:src/modbus.c  **** 	//Fetch first address data.
 476:src/modbus.c  **** 	s = getData(firstRequest++);
 477:src/modbus.c  **** 
 478:src/modbus.c  **** 	int tempTotalRequest = (int) totalRequest;
 479:src/modbus.c  **** 	int count = 0;
 480:src/modbus.c  **** 	int fromBit = 0;
 481:src/modbus.c  **** 	int toBit = 7;
 482:src/modbus.c  **** 	int shiftRight;
 483:src/modbus.c  **** 	int flag = 0;
 484:src/modbus.c  **** 	int maxCount = 0;
 485:src/modbus.c  **** 	//int d;
 486:src/modbus.c  **** 
 487:src/modbus.c  **** 	again: while (tempTotalRequest > 0) {
 488:src/modbus.c  **** 
 489:src/modbus.c  **** 		if (totalRequest < 8) {
 490:src/modbus.c  **** 			toBit = totalRequest - 1;
 491:src/modbus.c  **** 		}
 492:src/modbus.c  **** 
 493:src/modbus.c  **** 		//Check if temp (having totalRequest) has modulus value of totalRequest.
 494:src/modbus.c  **** 		if (tempTotalRequest == (totalRequest % 8) && flag == 1) {
 495:src/modbus.c  **** 			toBit = (totalRequest % 8) - 1; //if true the set toBit to modules minus-1.
 496:src/modbus.c  **** 		}
 497:src/modbus.c  **** 
 498:src/modbus.c  **** 		//Call masking function and store value in r.
 499:src/modbus.c  **** 		unsigned int r = getMask(fromBit, toBit);
 500:src/modbus.c  **** 
 501:src/modbus.c  **** 		//Get masking done on data from hash and store in result.
 502:src/modbus.c  **** 		unsigned int result = r & s->value;
 503:src/modbus.c  **** 
 504:src/modbus.c  **** 		//Check if first 8 Bit then go to "next" label.
 505:src/modbus.c  **** 		if (toBit == 7) {
 506:src/modbus.c  **** 			goto next;
 507:src/modbus.c  **** 		}
 508:src/modbus.c  **** 
 509:src/modbus.c  **** 		//Else shift right.
 510:src/modbus.c  **** 		else {
 511:src/modbus.c  **** 			for (shiftRight = fromBit; shiftRight > 0; shiftRight--) {
 512:src/modbus.c  **** 				result = result >> 1;
 513:src/modbus.c  **** 			}
 514:src/modbus.c  **** 		}
 515:src/modbus.c  **** 
 516:src/modbus.c  **** 		//Label
 517:src/modbus.c  **** 		next:
 518:src/modbus.c  **** 
 519:src/modbus.c  **** 		//Store the data to be sent in response packet one by one till requested bits reached.
 520:src/modbus.c  **** 		*rPacket = result;
 521:src/modbus.c  **** 		rPacket++;
 522:src/modbus.c  **** //		printf("Data: 0x%x\n", result);
 523:src/modbus.c  **** 
 524:src/modbus.c  **** 		//Increase the countbuffer to check if 32 bit data sent or not
 525:src/modbus.c  **** 		count++;
 526:src/modbus.c  **** 
 527:src/modbus.c  **** 		//Decrement the totalReqeust (assigned to temp) by 8 after sending 8 bit.
 528:src/modbus.c  **** 		tempTotalRequest = tempTotalRequest - 8;
 529:src/modbus.c  **** 
 530:src/modbus.c  **** 		//Check if totalRequest is more than 32 bit or not.
 531:src/modbus.c  **** 		if (totalRequest >= 32) {
 532:src/modbus.c  **** 			maxCount = 4;
 533:src/modbus.c  **** 		}
 534:src/modbus.c  **** 
 535:src/modbus.c  **** 		//If not then set
 536:src/modbus.c  **** 		/*else{
 537:src/modbus.c  **** 		 count = 0;
 538:src/modbus.c  **** 		 fromBit = 0;
 539:src/modbus.c  **** 		 toBit = 7;
 540:src/modbus.c  **** 		 flag = 1;
 541:src/modbus.c  **** 		 goto again;
 542:src/modbus.c  **** 		 }*/
 543:src/modbus.c  **** 
 544:src/modbus.c  **** 		//If count reached b i.e. total 4*8 Bit sent (32 bit) then get next value from hash.
 545:src/modbus.c  **** 		if (count == maxCount) {
 546:src/modbus.c  **** 			s = getData(firstRequest++);
 547:src/modbus.c  **** 			count = 0;
 548:src/modbus.c  **** 			fromBit = 0;
 549:src/modbus.c  **** 			toBit = 7;
 550:src/modbus.c  **** 			flag = 1;
 551:src/modbus.c  **** 			goto again;
 552:src/modbus.c  **** 		}
 553:src/modbus.c  **** 
 554:src/modbus.c  **** 		//Increase fromBit and toBit to fetch next 8 bit.
 555:src/modbus.c  **** 		fromBit = fromBit + 8;
 556:src/modbus.c  **** 		toBit = toBit + 8;
 557:src/modbus.c  **** 	}
 558:src/modbus.c  **** /*
 559:src/modbus.c  **** 	for (d = 0; d < (byteStream + 3); d++) {
 560:src/modbus.c  **** 		printf("\n0x%x", arrayResponsePacket[d]);
 561:src/modbus.c  **** 	}
 562:src/modbus.c  **** 
 563:src/modbus.c  **** */
 564:src/modbus.c  **** 	return 0;
 565:src/modbus.c  **** 
 566:src/modbus.c  **** }
 567:src/modbus.c  **** 
 568:src/modbus.c  **** uint32_t readHoldingRegisters(uint32_t *qPacket) {
 569:src/modbus.c  **** 
 570:src/modbus.c  **** 	//Point qPacket to first address from where data is to be fetched.
 571:src/modbus.c  **** 	qPacket++;
 572:src/modbus.c  **** 
 573:src/modbus.c  **** 	//Assign first address to firstRequest from qPacket and
 574:src/modbus.c  **** 	//qPacket's next value i.e total bit requested to totalRequest.
 575:src/modbus.c  **** 	firstRequest = 0x9C40 | *qPacket++;
 576:src/modbus.c  **** 	totalRequest = *qPacket;
 577:src/modbus.c  **** 
 578:src/modbus.c  **** 	//Calculate no. of byte and assign it to rPacket
 579:src/modbus.c  **** 	unsigned int byteStream = totalRequest * 2;
 580:src/modbus.c  **** 
 581:src/modbus.c  **** 	//Copy no. of byte stream to be sent back to response packet
 582:src/modbus.c  **** 	*rPacket = (unsigned int) byteStream;
 583:src/modbus.c  **** 	//printf("%d\n",*rPacket);
 584:src/modbus.c  **** 	rPacket++;
 585:src/modbus.c  **** 
 586:src/modbus.c  **** 	//Fetch first address data.
 587:src/modbus.c  **** 	s = getData(firstRequest++);
 588:src/modbus.c  **** 
 589:src/modbus.c  **** 	int tempTotalRequest = (int) totalRequest;
 590:src/modbus.c  **** 	int fromBit = 0;
 591:src/modbus.c  **** 	int toBit = 15;
 592:src/modbus.c  **** 	int shiftRight;
 593:src/modbus.c  **** 	//int d;
 594:src/modbus.c  **** 
 595:src/modbus.c  **** 	while (tempTotalRequest > 0) {
 596:src/modbus.c  **** 
 597:src/modbus.c  **** 		int fromBit = 0;
 598:src/modbus.c  **** 		int toBit = 7;
 599:src/modbus.c  **** 
 600:src/modbus.c  **** 		while(fromBit <= 8){
 601:src/modbus.c  **** 				//Call masking function and store value in r.
 602:src/modbus.c  **** 				unsigned int r = getMask(fromBit, toBit);
 603:src/modbus.c  **** 
 604:src/modbus.c  **** 				//Get masking done on data from hash and store in result.
 605:src/modbus.c  **** 				unsigned int result = r & s->value;
 606:src/modbus.c  **** 
 607:src/modbus.c  **** 				for (shiftRight = fromBit; shiftRight > 0; shiftRight--) {
 608:src/modbus.c  **** 					result = result >> 1;
 609:src/modbus.c  **** 				}
 610:src/modbus.c  **** 
 611:src/modbus.c  **** 				//Store the data to be sent in response packet one by one till requested bits reached.
 612:src/modbus.c  **** 				*rPacket = result;
 613:src/modbus.c  **** 				rPacket++;
 614:src/modbus.c  **** 				//printf("Data: 0x%x\n", result);
 615:src/modbus.c  **** 
 616:src/modbus.c  **** 
 617:src/modbus.c  **** 				//Increase from and to bit
 618:src/modbus.c  **** 				fromBit = fromBit + 8;
 619:src/modbus.c  **** 				toBit = toBit + 8;
 620:src/modbus.c  **** 		}
 621:src/modbus.c  **** 
 622:src/modbus.c  **** 		//Decrement request count
 623:src/modbus.c  **** 		tempTotalRequest = tempTotalRequest - 1;
 624:src/modbus.c  **** 
 625:src/modbus.c  **** 		//Fetch next data .
 626:src/modbus.c  **** 		s = getData(firstRequest++);
 627:src/modbus.c  **** 	}
 628:src/modbus.c  **** 
 629:src/modbus.c  **** /*	for (d = 0; d < ((byteStream / 2) + 3); d++) {
 630:src/modbus.c  **** 		printf("\n0x%x", arrayResponsePacket[d]);
 631:src/modbus.c  **** 	}
 632:src/modbus.c  **** */
 633:src/modbus.c  **** 	return 0;
 634:src/modbus.c  **** }
 635:src/modbus.c  **** 
 636:src/modbus.c  **** uint32_t readDiscreteInputs(uint32_t *qPacket) {
 637:src/modbus.c  **** 
 638:src/modbus.c  **** 	//Point qPacket to first address from where data is to be fetched.
 639:src/modbus.c  **** 	qPacket++;
 640:src/modbus.c  **** 
 641:src/modbus.c  **** 	//Assign first address to firstRequest from qPacket and
 642:src/modbus.c  **** 	//qPacket's next value i.e total bit requested to totalRequest.
 643:src/modbus.c  **** 	firstRequest = 0x2710 | *qPacket++;
 644:src/modbus.c  **** 	totalRequest = *qPacket;
 645:src/modbus.c  **** 
 646:src/modbus.c  **** 	//Calculate no. of byte and assign it to rPacket
 647:src/modbus.c  **** 	unsigned int byteStream = ((totalRequest / 8) + 1);
 648:src/modbus.c  **** 
 649:src/modbus.c  **** 	//Copy no. of byte stream to be sent back to reponse packet
 650:src/modbus.c  **** 	*rPacket = (unsigned int) byteStream;
 651:src/modbus.c  **** 	//printf("%d\n",*rPacket);
 652:src/modbus.c  **** 	rPacket++;
 653:src/modbus.c  **** 
 654:src/modbus.c  **** 	//Fetch first address data.
 655:src/modbus.c  **** 	s = getData(firstRequest++);
 656:src/modbus.c  **** 
 657:src/modbus.c  **** 	int tempTotalRequest = (int) totalRequest;
 658:src/modbus.c  **** 	int count = 0;
 659:src/modbus.c  **** 	int fromBit = 0;
 660:src/modbus.c  **** 	int toBit = 7;
 661:src/modbus.c  **** 	int shiftRight;
 662:src/modbus.c  **** 	int flag = 0;
 663:src/modbus.c  **** 	int maxCount = 0;
 664:src/modbus.c  **** 	//int d;
 665:src/modbus.c  **** 
 666:src/modbus.c  **** 	again: while (tempTotalRequest > 0) {
 667:src/modbus.c  **** 
 668:src/modbus.c  **** 		if (totalRequest < 8) {
 669:src/modbus.c  **** 			toBit = totalRequest - 1;
 670:src/modbus.c  **** 		}
 671:src/modbus.c  **** 
 672:src/modbus.c  **** 		//Check if temp (having totalRequest) has modulus value of totalRequest.
 673:src/modbus.c  **** 		if (tempTotalRequest == (totalRequest % 8) && flag == 1) {
 674:src/modbus.c  **** 			toBit = (totalRequest % 8) - 1; //if true the set toBit to modules minus-1.
 675:src/modbus.c  **** 		}
 676:src/modbus.c  **** 
 677:src/modbus.c  **** 		//Call masking function and store value in r.
 678:src/modbus.c  **** 		unsigned int r = getMask(fromBit, toBit);
 679:src/modbus.c  **** 
 680:src/modbus.c  **** 		//Get masking done on data from hash and store in result.
 681:src/modbus.c  **** 		unsigned int result = r & s->value;
 682:src/modbus.c  **** 
 683:src/modbus.c  **** 		//Check if first 8 Bit then go to "next" label.
 684:src/modbus.c  **** 		if (toBit == 7) {
 685:src/modbus.c  **** 			goto next;
 686:src/modbus.c  **** 		}
 687:src/modbus.c  **** 
 688:src/modbus.c  **** 		//Else shift right.
 689:src/modbus.c  **** 		else {
 690:src/modbus.c  **** 			for (shiftRight = fromBit; shiftRight > 0; shiftRight--) {
 691:src/modbus.c  **** 				result = result >> 1;
 692:src/modbus.c  **** 			}
 693:src/modbus.c  **** 		}
 694:src/modbus.c  **** 
 695:src/modbus.c  **** 		//Label
 696:src/modbus.c  **** 		next:
 697:src/modbus.c  **** 
 698:src/modbus.c  **** 		//Store the data to be sent in response packet one by one till requested bits reached.
 699:src/modbus.c  **** 		*rPacket = result;
 700:src/modbus.c  **** 		rPacket++;
 701:src/modbus.c  **** //		printf("Data: 0x%x\n", result);
 702:src/modbus.c  **** 
 703:src/modbus.c  **** 		//Increase the countbuffer to check if 32 bit data sent or not
 704:src/modbus.c  **** 		count++;
 705:src/modbus.c  **** 
 706:src/modbus.c  **** 		//Decrement the totalReqeust (assigned to temp) by 8 after sending 8 bit.
 707:src/modbus.c  **** 		tempTotalRequest = tempTotalRequest - 8;
 708:src/modbus.c  **** 
 709:src/modbus.c  **** 		//Check if totalRequest is more than 32 bit or not.
 710:src/modbus.c  **** 		if (totalRequest >= 32) {
 711:src/modbus.c  **** 			maxCount = 4;
 712:src/modbus.c  **** 		}
 713:src/modbus.c  **** 
 714:src/modbus.c  **** 		//If not then set
 715:src/modbus.c  **** 		/*else{
 716:src/modbus.c  **** 		 count = 0;
 717:src/modbus.c  **** 		 fromBit = 0;
 718:src/modbus.c  **** 		 toBit = 7;
 719:src/modbus.c  **** 		 flag = 1;
 720:src/modbus.c  **** 		 goto again;
 721:src/modbus.c  **** 		 }*/
 722:src/modbus.c  **** 
 723:src/modbus.c  **** 		//If count reached b i.e. total 4*8 Bit sent (32 bit) then get next value from hash.
 724:src/modbus.c  **** 		if (count == maxCount) {
 725:src/modbus.c  **** 			s = getData(firstRequest++);
 726:src/modbus.c  **** 			count = 0;
 727:src/modbus.c  **** 			fromBit = 0;
 728:src/modbus.c  **** 			toBit = 7;
 729:src/modbus.c  **** 			flag = 1;
 730:src/modbus.c  **** 			goto again;
 731:src/modbus.c  **** 		}
 732:src/modbus.c  **** 
 733:src/modbus.c  **** 		//Increase fromBit and toBit to fetch next 8 bit.
 734:src/modbus.c  **** 		fromBit = fromBit + 8;
 735:src/modbus.c  **** 		toBit = toBit + 8;
 736:src/modbus.c  **** 	}
 737:src/modbus.c  **** /*
 738:src/modbus.c  **** 	for (d = 0; d < (byteStream + 3); d++) {
 739:src/modbus.c  **** 		printf("\n0x%x", arrayResponsePacket[d]);
 740:src/modbus.c  **** 	}
 741:src/modbus.c  **** */
 742:src/modbus.c  **** 	return 0;
 743:src/modbus.c  **** 
 744:src/modbus.c  **** }
 745:src/modbus.c  **** 
 746:src/modbus.c  **** uint32_t readCoil(uint32_t *qPacket) {
 747:src/modbus.c  **** 
 748:src/modbus.c  **** 	//Point qPacket to first address from where data is to be fetched.
 749:src/modbus.c  **** 	qPacket++;
 750:src/modbus.c  **** 
 751:src/modbus.c  **** 	//Assign first address to firstRequest from qPacket and
 752:src/modbus.c  **** 	//qPacket's next value i.e total bit requested to totalRequest.
 753:src/modbus.c  **** 	firstRequest = 0x0000 + *qPacket++;
 754:src/modbus.c  **** 	totalRequest = *qPacket;
 755:src/modbus.c  **** 
 756:src/modbus.c  **** 	//Calculate no. of byte and assign it to rPacket
 757:src/modbus.c  **** 	unsigned int byteStream = ((totalRequest / 8) + 1);
 758:src/modbus.c  **** 
 759:src/modbus.c  **** 	//Copy no. of byte stream to be sent back to reponse packet
 760:src/modbus.c  **** 	*rPacket = (unsigned int) byteStream;
 761:src/modbus.c  **** 	//printf("%d\n",*rPacket);
 762:src/modbus.c  **** 	rPacket++;
 763:src/modbus.c  **** 
 764:src/modbus.c  **** 	//Fetch first address data.
 765:src/modbus.c  **** 	s = getData(firstRequest++);
 766:src/modbus.c  **** 
 767:src/modbus.c  **** 	int tempTotalRequest = (int) totalRequest;
 768:src/modbus.c  **** 	int count = 0;
 769:src/modbus.c  **** 	int fromBit = 0;
 770:src/modbus.c  **** 	int toBit = 7;
 771:src/modbus.c  **** 	int shiftRight;
 772:src/modbus.c  **** 	int flag = 0;
 773:src/modbus.c  **** 	int maxCount = 0;
 774:src/modbus.c  **** 	//int d;
 775:src/modbus.c  **** 
 776:src/modbus.c  **** 	again: while (tempTotalRequest > 0) {
 777:src/modbus.c  **** 
 778:src/modbus.c  **** 		if (totalRequest < 8) {
 779:src/modbus.c  **** 			toBit = totalRequest - 1;
 780:src/modbus.c  **** 		}
 781:src/modbus.c  **** 
 782:src/modbus.c  **** 		//Check if temp (having totalRequest) has modulus value of totalRequest.
 783:src/modbus.c  **** 		if (tempTotalRequest == (totalRequest % 8) && flag == 1) {
 784:src/modbus.c  **** 			toBit = (totalRequest % 8) - 1; //if true the set toBit to modules minus-1.
 785:src/modbus.c  **** 		}
 786:src/modbus.c  **** 
 787:src/modbus.c  **** 		//Call masking function and store value in r.
 788:src/modbus.c  **** 		unsigned int r = getMask(fromBit, toBit);
 789:src/modbus.c  **** 
 790:src/modbus.c  **** 		//Get masking done on data from hash and store in result.
 791:src/modbus.c  **** 		unsigned int result = r & s->value;
 792:src/modbus.c  **** 
 793:src/modbus.c  **** 		//Check if first 8 Bit then go to "next" label.
 794:src/modbus.c  **** 		if (toBit == 7) {
 795:src/modbus.c  **** 			goto next;
 796:src/modbus.c  **** 		}
 797:src/modbus.c  **** 
 798:src/modbus.c  **** 		//Else shift right.
 799:src/modbus.c  **** 		else {
 800:src/modbus.c  **** 			for (shiftRight = fromBit; shiftRight > 0; shiftRight--) {
 801:src/modbus.c  **** 				result = result >> 1;
 802:src/modbus.c  **** 			}
 803:src/modbus.c  **** 		}
 804:src/modbus.c  **** 
 805:src/modbus.c  **** 		//Label
 806:src/modbus.c  **** 		next:
 807:src/modbus.c  **** 
 808:src/modbus.c  **** 		//Store the data to be sent in response packet one by one till requested bits reached.
 809:src/modbus.c  **** 		*rPacket = result;
 810:src/modbus.c  **** 		rPacket++;
 811:src/modbus.c  **** //		printf("Data: 0x%x\n", result);
 812:src/modbus.c  **** 
 813:src/modbus.c  **** 		//Increase the countbuffer to check if 32 bit data sent or not
 814:src/modbus.c  **** 		count++;
 815:src/modbus.c  **** 
 816:src/modbus.c  **** 		//Decrement the totalReqeust (assigned to temp) by 8 after sending 8 bit.
 817:src/modbus.c  **** 		tempTotalRequest = tempTotalRequest - 8;
 818:src/modbus.c  **** 
 819:src/modbus.c  **** 		//Check if totalRequest is more than 32 bit or not.
 820:src/modbus.c  **** 		if (totalRequest >= 32) {
 821:src/modbus.c  **** 			maxCount = 4;
 822:src/modbus.c  **** 		}
 823:src/modbus.c  **** 
 824:src/modbus.c  **** 		//If not then set
 825:src/modbus.c  **** 		/*else{
 826:src/modbus.c  **** 		 count = 0;
 827:src/modbus.c  **** 		 fromBit = 0;
 828:src/modbus.c  **** 		 toBit = 7;
 829:src/modbus.c  **** 		 flag = 1;
 830:src/modbus.c  **** 		 goto again;
 831:src/modbus.c  **** 		 }*/
 832:src/modbus.c  **** 
 833:src/modbus.c  **** 		//If count reached b i.e. total 4*8 Bit sent (32 bit) then get next value from hash.
 834:src/modbus.c  **** 		if (count == maxCount) {
 835:src/modbus.c  **** 			s = getData(firstRequest++);
 836:src/modbus.c  **** 			count = 0;
 837:src/modbus.c  **** 			fromBit = 0;
 838:src/modbus.c  **** 			toBit = 7;
 839:src/modbus.c  **** 			flag = 1;
 840:src/modbus.c  **** 			goto again;
 841:src/modbus.c  **** 		}
 842:src/modbus.c  **** 
 843:src/modbus.c  **** 		//Increase fromBit and toBit to fetch next 8 bit.
 844:src/modbus.c  **** 		fromBit = fromBit + 8;
 845:src/modbus.c  **** 		toBit = toBit + 8;
 846:src/modbus.c  **** 	}
 847:src/modbus.c  **** 
 848:src/modbus.c  **** /*	for (d = 0; d < (byteStream + 3); d++) {
 849:src/modbus.c  **** 		printf("\n0x%x", arrayResponsePacket[d]);
 850:src/modbus.c  **** 	}
 851:src/modbus.c  **** */
 852:src/modbus.c  **** 	return 0;
 853:src/modbus.c  **** }
 854:src/modbus.c  **** 
 855:src/modbus.c  **** unsigned int getMask(int a, int b) {
 1045              		.loc 1 855 0
 1046              		.cfi_startproc
 1047              		@ args = 0, pretend = 0, frame = 0
 1048              		@ frame_needed = 0, uses_anonymous_args = 0
 1049              		@ link register save eliminated.
 1050              	.LVL190:
 1051 0000 10B4     		push	{r4}
 1052              	.LCFI7:
 1053              		.cfi_def_cfa_offset 4
 1054              		.cfi_offset 4, -4
 1055              	.LVL191:
 856:src/modbus.c  **** 	unsigned int i;
 857:src/modbus.c  **** 	unsigned int r = 0;
 858:src/modbus.c  **** 	for (i = a; i <= b; i++) {
 1056              		.loc 1 858 0
 1057 0002 0346     		mov	r3, r0
 1058              	.LVL192:
 857:src/modbus.c  **** 	for (i = a; i <= b; i++) {
 1059              		.loc 1 857 0
 1060 0004 0020     		movs	r0, #0
 1061              	.LVL193:
 859:src/modbus.c  **** 		r |= 1 << i;
 1062              		.loc 1 859 0
 1063 0006 0124     		movs	r4, #1
 858:src/modbus.c  **** 		r |= 1 << i;
 1064              		.loc 1 858 0
 1065 0008 03E0     		b	.L57
 1066              	.LVL194:
 1067              	.L58:
 1068              		.loc 1 859 0 discriminator 2
 1069 000a 04FA03F2 		lsl	r2, r4, r3
 1070 000e 1043     		orrs	r0, r0, r2
 1071              	.LVL195:
 858:src/modbus.c  **** 		r |= 1 << i;
 1072              		.loc 1 858 0 discriminator 2
 1073 0010 0133     		adds	r3, r3, #1
 1074              	.LVL196:
 1075              	.L57:
 858:src/modbus.c  **** 		r |= 1 << i;
 1076              		.loc 1 858 0 is_stmt 0 discriminator 1
 1077 0012 9942     		cmp	r1, r3
 1078 0014 F9D2     		bcs	.L58
 860:src/modbus.c  **** 	}
 861:src/modbus.c  **** 	return r;
 862:src/modbus.c  **** }
 1079              		.loc 1 862 0 is_stmt 1
 1080 0016 5DF8044B 		ldr	r4, [sp], #4
 1081 001a 7047     		bx	lr
 1082              		.cfi_endproc
 1083              	.LFE16:
 1085              		.section	.text.writeMultipleRegisters,"ax",%progbits
 1086              		.align	2
 1087              		.global	writeMultipleRegisters
 1088              		.thumb
 1089              		.thumb_func
 1091              	writeMultipleRegisters:
 1092              	.LFB7:
 166:src/modbus.c  **** 
 1093              		.loc 1 166 0
 1094              		.cfi_startproc
 1095              		@ args = 0, pretend = 0, frame = 0
 1096              		@ frame_needed = 0, uses_anonymous_args = 0
 1097              	.LVL197:
 1098 0000 2DE9F84F 		push	{r3, r4, r5, r6, r7, r8, r9, r10, fp, lr}
 1099              	.LCFI8:
 1100              		.cfi_def_cfa_offset 40
 1101              		.cfi_offset 3, -40
 1102              		.cfi_offset 4, -36
 1103              		.cfi_offset 5, -32
 1104              		.cfi_offset 6, -28
 1105              		.cfi_offset 7, -24
 1106              		.cfi_offset 8, -20
 1107              		.cfi_offset 9, -16
 1108              		.cfi_offset 10, -12
 1109              		.cfi_offset 11, -8
 1110              		.cfi_offset 14, -4
 1111 0004 0546     		mov	r5, r0
 1112              	.LVL198:
 172:src/modbus.c  **** 
 1113              		.loc 1 172 0
 1114 0006 4168     		ldr	r1, [r0, #4]
 1115 0008 01F51C41 		add	r1, r1, #39936
 1116 000c 4031     		adds	r1, r1, #64
 1117 000e 40F20003 		movw	r3, #:lower16:.LANCHOR4
 1118 0012 C0F20003 		movt	r3, #:upper16:.LANCHOR4
 1119 0016 1960     		str	r1, [r3]
 175:src/modbus.c  **** 	//printf("%d\n",*rPacket);
 1120              		.loc 1 175 0
 1121 0018 40F20002 		movw	r2, #:lower16:.LANCHOR1
 1122 001c C0F20002 		movt	r2, #:upper16:.LANCHOR1
 1123 0020 1068     		ldr	r0, [r2]
 1124              	.LVL199:
 1125 0022 0160     		str	r1, [r0]
 177:src/modbus.c  **** 
 1126              		.loc 1 177 0
 1127 0024 1068     		ldr	r0, [r2]
 1128              	.LVL200:
 180:src/modbus.c  **** 
 1129              		.loc 1 180 0
 1130 0026 AC68     		ldr	r4, [r5, #8]
 1131 0028 40F20001 		movw	r1, #:lower16:.LANCHOR5
 1132 002c C0F20001 		movt	r1, #:upper16:.LANCHOR5
 1133 0030 0C60     		str	r4, [r1]
 183:src/modbus.c  **** 	rPacket++;
 1134              		.loc 1 183 0
 1135 0032 4460     		str	r4, [r0, #4]
 184:src/modbus.c  **** 
 1136              		.loc 1 184 0
 1137 0034 0830     		adds	r0, r0, #8
 1138 0036 1060     		str	r0, [r2]
 1139              	.LVL201:
 187:src/modbus.c  **** 
 1140              		.loc 1 187 0
 1141 0038 EC68     		ldr	r4, [r5, #12]
 1142              	.LVL202:
 190:src/modbus.c  **** 
 1143              		.loc 1 190 0
 1144 003a 1868     		ldr	r0, [r3]
 1145 003c 421C     		adds	r2, r0, #1
 1146 003e 1A60     		str	r2, [r3]
 1147 0040 FFF7FEFF 		bl	getData
 1148              	.LVL203:
 1149 0044 40F20003 		movw	r3, #:lower16:s
 1150 0048 C0F20003 		movt	r3, #:upper16:s
 1151 004c 1860     		str	r0, [r3]
 1152              	.LVL204:
 195:src/modbus.c  **** 
 1153              		.loc 1 195 0
 1154 004e D5F81090 		ldr	r9, [r5, #16]
 1155              	.LVL205:
 200:src/modbus.c  **** 	int shiftRight;
 1156              		.loc 1 200 0
 1157 0052 0727     		movs	r7, #7
 199:src/modbus.c  **** 	int toBit = 7;
 1158              		.loc 1 199 0
 1159 0054 0025     		movs	r5, #0
 1160              	.LVL206:
 1161              	.LBB9:
 210:src/modbus.c  **** 
 1162              		.loc 1 210 0
 1163 0056 9846     		mov	r8, r3
 223:src/modbus.c  **** 		rPacket++;
 1164              		.loc 1 223 0
 1165 0058 40F20006 		movw	r6, #:lower16:.LANCHOR1
 1166 005c C0F20006 		movt	r6, #:upper16:.LANCHOR1
 1167              	.LBB10:
 235:src/modbus.c  **** 			int dataToBeWritten = *tempWriteData;
 1168              		.loc 1 235 0
 1169 0060 40F2000A 		movw	r10, #:lower16:.LANCHOR4
 1170 0064 C0F2000A 		movt	r10, #:upper16:.LANCHOR4
 238:src/modbus.c  **** 			goto again;
 1171              		.loc 1 238 0
 1172 0068 BB46     		mov	fp, r7
 1173 006a 26E0     		b	.L65
 1174              	.LVL207:
 1175              	.L64:
 1176              	.LBE10:
 207:src/modbus.c  **** 
 1177              		.loc 1 207 0
 1178 006c 2846     		mov	r0, r5
 1179 006e 3946     		mov	r1, r7
 1180 0070 FFF7FEFF 		bl	getMask
 1181              	.LVL208:
 210:src/modbus.c  **** 
 1182              		.loc 1 210 0
 1183 0074 D8F80030 		ldr	r3, [r8]
 1184 0078 5A68     		ldr	r2, [r3, #4]
 1185 007a 0240     		ands	r2, r2, r0
 1186              	.LVL209:
 212:src/modbus.c  **** 
 1187              		.loc 1 212 0
 1188 007c 09EA0000 		and	r0, r9, r0
 1189              	.LVL210:
 215:src/modbus.c  **** 			result = result >> 1;
 1190              		.loc 1 215 0
 1191 0080 2B46     		mov	r3, r5
 1192 0082 02E0     		b	.L61
 1193              	.LVL211:
 1194              	.L62:
 216:src/modbus.c  **** 			tempWriteRequest = tempWriteRequest >> 1;
 1195              		.loc 1 216 0 discriminator 2
 1196 0084 5208     		lsrs	r2, r2, #1
 1197              	.LVL212:
 217:src/modbus.c  **** 		}
 1198              		.loc 1 217 0 discriminator 2
 1199 0086 4010     		asrs	r0, r0, #1
 1200              	.LVL213:
 215:src/modbus.c  **** 			result = result >> 1;
 1201              		.loc 1 215 0 discriminator 2
 1202 0088 013B     		subs	r3, r3, #1
 1203              	.LVL214:
 1204              	.L61:
 215:src/modbus.c  **** 			result = result >> 1;
 1205              		.loc 1 215 0 is_stmt 0 discriminator 1
 1206 008a 002B     		cmp	r3, #0
 1207 008c FADC     		bgt	.L62
 220:src/modbus.c  **** 
 1208              		.loc 1 220 0 is_stmt 1
 1209 008e 1043     		orrs	r0, r0, r2
 1210              	.LVL215:
 223:src/modbus.c  **** 		rPacket++;
 1211              		.loc 1 223 0
 1212 0090 3368     		ldr	r3, [r6]
 1213              	.LVL216:
 1214 0092 1860     		str	r0, [r3]
 224:src/modbus.c  **** //		printf("Data: 0x%x\n", result);
 1215              		.loc 1 224 0
 1216 0094 3368     		ldr	r3, [r6]
 1217 0096 0433     		adds	r3, r3, #4
 1218 0098 3360     		str	r3, [r6]
 228:src/modbus.c  **** 		fromBit = fromBit + 8;
 1219              		.loc 1 228 0
 1220 009a 013C     		subs	r4, r4, #1
 1221              	.LVL217:
 229:src/modbus.c  **** 		toBit = toBit + 8;
 1222              		.loc 1 229 0
 1223 009c 0835     		adds	r5, r5, #8
 1224              	.LVL218:
 230:src/modbus.c  **** 		tempWriteRequest = (int) dataToBeWritten;
 1225              		.loc 1 230 0
 1226 009e 0837     		adds	r7, r7, #8
 1227              	.LVL219:
 234:src/modbus.c  **** 			s = getData(firstRequest++);
 1228              		.loc 1 234 0
 1229 00a0 022C     		cmp	r4, #2
 1230 00a2 0AD1     		bne	.L65
 1231              	.LBB11:
 235:src/modbus.c  **** 			int dataToBeWritten = *tempWriteData;
 1232              		.loc 1 235 0
 1233 00a4 DAF80000 		ldr	r0, [r10]
 1234              	.LVL220:
 1235 00a8 431C     		adds	r3, r0, #1
 1236 00aa CAF80030 		str	r3, [r10]
 1237 00ae FFF7FEFF 		bl	getData
 1238              	.LVL221:
 1239 00b2 C8F80000 		str	r0, [r8]
 1240              	.LVL222:
 238:src/modbus.c  **** 			goto again;
 1241              		.loc 1 238 0
 1242 00b6 5F46     		mov	r7, fp
 237:src/modbus.c  **** 			toBit = 7;
 1243              		.loc 1 237 0
 1244 00b8 0025     		movs	r5, #0
 1245              	.L63:
 1246              	.LVL223:
 1247              	.L65:
 1248              	.LBE11:
 1249              	.LBE9:
 204:src/modbus.c  **** 
 1250              		.loc 1 204 0 discriminator 1
 1251 00ba 002C     		cmp	r4, #0
 1252 00bc D6D1     		bne	.L64
 249:src/modbus.c  **** 
 1253              		.loc 1 249 0
 1254 00be 0020     		movs	r0, #0
 1255 00c0 BDE8F88F 		pop	{r3, r4, r5, r6, r7, r8, r9, r10, fp, pc}
 1256              		.cfi_endproc
 1257              	.LFE7:
 1259              		.section	.text.writeMultipleCoils,"ax",%progbits
 1260              		.align	2
 1261              		.global	writeMultipleCoils
 1262              		.thumb
 1263              		.thumb_func
 1265              	writeMultipleCoils:
 1266              	.LFB8:
 252:src/modbus.c  **** 
 1267              		.loc 1 252 0
 1268              		.cfi_startproc
 1269              		@ args = 0, pretend = 0, frame = 0
 1270              		@ frame_needed = 0, uses_anonymous_args = 0
 1271              	.LVL224:
 1272 0000 2DE9F047 		push	{r4, r5, r6, r7, r8, r9, r10, lr}
 1273              	.LCFI9:
 1274              		.cfi_def_cfa_offset 32
 1275              		.cfi_offset 4, -32
 1276              		.cfi_offset 5, -28
 1277              		.cfi_offset 6, -24
 1278              		.cfi_offset 7, -20
 1279              		.cfi_offset 8, -16
 1280              		.cfi_offset 9, -12
 1281              		.cfi_offset 10, -8
 1282              		.cfi_offset 14, -4
 1283 0004 0446     		mov	r4, r0
 1284              	.LVL225:
 258:src/modbus.c  **** 
 1285              		.loc 1 258 0
 1286 0006 4168     		ldr	r1, [r0, #4]
 1287 0008 40F20003 		movw	r3, #:lower16:.LANCHOR4
 1288 000c C0F20003 		movt	r3, #:upper16:.LANCHOR4
 1289 0010 1960     		str	r1, [r3]
 261:src/modbus.c  **** 	//printf("%d\n",*rPacket);
 1290              		.loc 1 261 0
 1291 0012 40F20002 		movw	r2, #:lower16:.LANCHOR1
 1292 0016 C0F20002 		movt	r2, #:upper16:.LANCHOR1
 1293 001a 1068     		ldr	r0, [r2]
 1294              	.LVL226:
 1295 001c 0160     		str	r1, [r0]
 263:src/modbus.c  **** 
 1296              		.loc 1 263 0
 1297 001e 1068     		ldr	r0, [r2]
 1298              	.LVL227:
 266:src/modbus.c  **** 
 1299              		.loc 1 266 0
 1300 0020 A568     		ldr	r5, [r4, #8]
 1301 0022 40F20001 		movw	r1, #:lower16:.LANCHOR5
 1302 0026 C0F20001 		movt	r1, #:upper16:.LANCHOR5
 1303 002a 0D60     		str	r5, [r1]
 269:src/modbus.c  **** 	rPacket++;
 1304              		.loc 1 269 0
 1305 002c 4560     		str	r5, [r0, #4]
 270:src/modbus.c  **** 
 1306              		.loc 1 270 0
 1307 002e 0830     		adds	r0, r0, #8
 1308 0030 1060     		str	r0, [r2]
 1309              	.LVL228:
 273:src/modbus.c  **** 
 1310              		.loc 1 273 0
 1311 0032 E568     		ldr	r5, [r4, #12]
 1312              	.LVL229:
 276:src/modbus.c  **** 
 1313              		.loc 1 276 0
 1314 0034 1868     		ldr	r0, [r3]
 1315 0036 421C     		adds	r2, r0, #1
 1316 0038 1A60     		str	r2, [r3]
 1317 003a FFF7FEFF 		bl	getData
 1318              	.LVL230:
 1319 003e 40F20003 		movw	r3, #:lower16:s
 1320 0042 C0F20003 		movt	r3, #:upper16:s
 1321 0046 1860     		str	r0, [r3]
 1322              	.LVL231:
 282:src/modbus.c  **** 	int count = byteStream;
 1323              		.loc 1 282 0
 1324 0048 04F11407 		add	r7, r4, #20
 1325              	.LVL232:
 1326 004c D4F81080 		ldr	r8, [r4, #16]
 1327              	.LVL233:
 285:src/modbus.c  **** 	int shiftRight;
 1328              		.loc 1 285 0
 1329 0050 0726     		movs	r6, #7
 284:src/modbus.c  **** 	int toBit = 7;
 1330              		.loc 1 284 0
 1331 0052 0024     		movs	r4, #0
 1332              	.LVL234:
 1333              	.LBB12:
 295:src/modbus.c  **** 
 1334              		.loc 1 295 0
 1335 0054 9A46     		mov	r10, r3
 310:src/modbus.c  **** 
 1336              		.loc 1 310 0
 1337 0056 40F20009 		movw	r9, #:lower16:.LC1
 1338 005a C0F20009 		movt	r9, #:upper16:.LC1
 1339              	.LBE12:
 289:src/modbus.c  **** 
 1340              		.loc 1 289 0
 1341 005e 18E0     		b	.L67
 1342              	.LVL235:
 1343              	.L70:
 1344              	.LBB13:
 292:src/modbus.c  **** 
 1345              		.loc 1 292 0
 1346 0060 2046     		mov	r0, r4
 1347 0062 3146     		mov	r1, r6
 1348 0064 FFF7FEFF 		bl	getMask
 1349              	.LVL236:
 295:src/modbus.c  **** 
 1350              		.loc 1 295 0
 1351 0068 DAF80030 		ldr	r3, [r10]
 1352 006c 5968     		ldr	r1, [r3, #4]
 1353 006e 0140     		ands	r1, r1, r0
 1354              	.LVL237:
 300:src/modbus.c  **** 			result = result >> 1;
 1355              		.loc 1 300 0
 1356 0070 2346     		mov	r3, r4
 1357 0072 01E0     		b	.L68
 1358              	.LVL238:
 1359              	.L69:
 301:src/modbus.c  **** 			//tempWriteRequest = tempWriteRequest << 1;
 1360              		.loc 1 301 0 discriminator 2
 1361 0074 4908     		lsrs	r1, r1, #1
 1362              	.LVL239:
 300:src/modbus.c  **** 			result = result >> 1;
 1363              		.loc 1 300 0 discriminator 2
 1364 0076 013B     		subs	r3, r3, #1
 1365              	.LVL240:
 1366              	.L68:
 300:src/modbus.c  **** 			result = result >> 1;
 1367              		.loc 1 300 0 is_stmt 0 discriminator 1
 1368 0078 002B     		cmp	r3, #0
 1369 007a FBDC     		bgt	.L69
 1370              	.LVL241:
 310:src/modbus.c  **** 
 1371              		.loc 1 310 0 is_stmt 1
 1372 007c 4846     		mov	r0, r9
 1373              	.LVL242:
 1374 007e 41EA0801 		orr	r1, r1, r8
 1375              	.LVL243:
 1376 0082 FFF7FEFF 		bl	printf
 1377              	.LVL244:
 313:src/modbus.c  **** 		fromBit = fromBit + 8;
 1378              		.loc 1 313 0
 1379 0086 013D     		subs	r5, r5, #1
 1380              	.LVL245:
 314:src/modbus.c  **** 		toBit = toBit + 8;
 1381              		.loc 1 314 0
 1382 0088 0834     		adds	r4, r4, #8
 1383              	.LVL246:
 315:src/modbus.c  **** 		tempWriteRequest = *dataToBeWritten++;
 1384              		.loc 1 315 0
 1385 008a 0836     		adds	r6, r6, #8
 1386              	.LVL247:
 316:src/modbus.c  **** 	}
 1387              		.loc 1 316 0
 1388 008c D7F80080 		ldr	r8, [r7]
 1389              	.LVL248:
 1390 0090 0437     		adds	r7, r7, #4
 1391              	.LVL249:
 1392              	.L67:
 1393              	.LBE13:
 289:src/modbus.c  **** 
 1394              		.loc 1 289 0 discriminator 1
 1395 0092 002D     		cmp	r5, #0
 1396 0094 E4D1     		bne	.L70
 324:src/modbus.c  **** 
 1397              		.loc 1 324 0
 1398 0096 0020     		movs	r0, #0
 1399 0098 BDE8F087 		pop	{r4, r5, r6, r7, r8, r9, r10, pc}
 1400              		.cfi_endproc
 1401              	.LFE8:
 1403              		.section	.text.writeSingleRegister,"ax",%progbits
 1404              		.align	2
 1405              		.global	writeSingleRegister
 1406              		.thumb
 1407              		.thumb_func
 1409              	writeSingleRegister:
 1410              	.LFB10:
 330:src/modbus.c  **** 
 1411              		.loc 1 330 0
 1412              		.cfi_startproc
 1413              		@ args = 0, pretend = 0, frame = 0
 1414              		@ frame_needed = 0, uses_anonymous_args = 0
 1415              	.LVL250:
 1416 0000 F8B5     		push	{r3, r4, r5, r6, r7, lr}
 1417              	.LCFI10:
 1418              		.cfi_def_cfa_offset 24
 1419              		.cfi_offset 3, -24
 1420              		.cfi_offset 4, -20
 1421              		.cfi_offset 5, -16
 1422              		.cfi_offset 6, -12
 1423              		.cfi_offset 7, -8
 1424              		.cfi_offset 14, -4
 1425              	.LVL251:
 336:src/modbus.c  **** 	*rPacket = (unsigned int) tempWriteAddress;
 1426              		.loc 1 336 0
 1427 0002 4268     		ldr	r2, [r0, #4]
 1428              	.LVL252:
 337:src/modbus.c  **** 	rPacket++;
 1429              		.loc 1 337 0
 1430 0004 40F20004 		movw	r4, #:lower16:.LANCHOR1
 1431 0008 C0F20004 		movt	r4, #:upper16:.LANCHOR1
 1432 000c 2368     		ldr	r3, [r4]
 1433 000e 1A60     		str	r2, [r3]
 338:src/modbus.c  **** 
 1434              		.loc 1 338 0
 1435 0010 2668     		ldr	r6, [r4]
 1436 0012 351D     		adds	r5, r6, #4
 1437 0014 2560     		str	r5, [r4]
 1438              	.LVL253:
 342:src/modbus.c  **** 
 1439              		.loc 1 342 0
 1440 0016 4168     		ldr	r1, [r0, #4]
 1441 0018 01F51C41 		add	r1, r1, #39936
 1442 001c 40F20003 		movw	r3, #:lower16:.LANCHOR4
 1443 0020 C0F20003 		movt	r3, #:upper16:.LANCHOR4
 345:src/modbus.c  **** 
 1444              		.loc 1 345 0
 1445 0024 8768     		ldr	r7, [r0, #8]
 1446 0026 40F20002 		movw	r2, #:lower16:.LANCHOR6
 1447              	.LVL254:
 1448 002a C0F20002 		movt	r2, #:upper16:.LANCHOR6
 1449 002e 1760     		str	r7, [r2]
 353:src/modbus.c  **** 
 1450              		.loc 1 353 0
 1451 0030 01F14102 		add	r2, r1, #65
 1452 0034 1A60     		str	r2, [r3]
 1453 0036 01F14000 		add	r0, r1, #64
 1454              	.LVL255:
 1455 003a FFF7FEFF 		bl	getData
 1456              	.LVL256:
 1457 003e 40F20003 		movw	r3, #:lower16:s
 1458 0042 C0F20003 		movt	r3, #:upper16:s
 1459 0046 1860     		str	r0, [r3]
 1460              	.LVL257:
 362:src/modbus.c  **** 
 1461              		.loc 1 362 0
 1462 0048 0020     		movs	r0, #0
 1463 004a 2021     		movs	r1, #32
 1464 004c FFF7FEFF 		bl	getMask
 1465              	.LVL258:
 379:src/modbus.c  **** 	rPacket++;
 1466              		.loc 1 379 0
 1467 0050 7760     		str	r7, [r6, #4]
 380:src/modbus.c  **** 
 1468              		.loc 1 380 0
 1469 0052 06F10805 		add	r5, r6, #8
 1470 0056 2560     		str	r5, [r4]
 388:src/modbus.c  **** 
 1471              		.loc 1 388 0
 1472 0058 0020     		movs	r0, #0
 1473 005a F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 1474              		.cfi_endproc
 1475              	.LFE10:
 1477              		.section	.text.writeSingleCoil,"ax",%progbits
 1478              		.align	2
 1479              		.global	writeSingleCoil
 1480              		.thumb
 1481              		.thumb_func
 1483              	writeSingleCoil:
 1484              	.LFB11:
 392:src/modbus.c  **** 
 1485              		.loc 1 392 0
 1486              		.cfi_startproc
 1487              		@ args = 0, pretend = 0, frame = 0
 1488              		@ frame_needed = 0, uses_anonymous_args = 0
 1489              	.LVL259:
 1490 0000 2DE9F041 		push	{r4, r5, r6, r7, r8, lr}
 1491              	.LCFI11:
 1492              		.cfi_def_cfa_offset 24
 1493              		.cfi_offset 4, -24
 1494              		.cfi_offset 5, -20
 1495              		.cfi_offset 6, -16
 1496              		.cfi_offset 7, -12
 1497              		.cfi_offset 8, -8
 1498              		.cfi_offset 14, -4
 1499              	.LVL260:
 399:src/modbus.c  **** 
 1500              		.loc 1 399 0
 1501 0004 4168     		ldr	r1, [r0, #4]
 1502 0006 40F20003 		movw	r3, #:lower16:.LANCHOR4
 1503 000a C0F20003 		movt	r3, #:upper16:.LANCHOR4
 1504 000e 1960     		str	r1, [r3]
 402:src/modbus.c  **** //	writeRequest+=3;
 1505              		.loc 1 402 0
 1506 0010 00F10808 		add	r8, r0, #8
 1507              	.LVL261:
 406:src/modbus.c  **** 	//printf("%d\n",*rPacket);
 1508              		.loc 1 406 0
 1509 0014 40F20002 		movw	r2, #:lower16:.LANCHOR1
 1510 0018 C0F20002 		movt	r2, #:upper16:.LANCHOR1
 1511 001c 1068     		ldr	r0, [r2]
 1512              	.LVL262:
 1513 001e 0160     		str	r1, [r0]
 408:src/modbus.c  **** 
 1514              		.loc 1 408 0
 1515 0020 1168     		ldr	r1, [r2]
 1516 0022 0431     		adds	r1, r1, #4
 1517 0024 1160     		str	r1, [r2]
 411:src/modbus.c  **** 
 1518              		.loc 1 411 0
 1519 0026 1868     		ldr	r0, [r3]
 1520 0028 421C     		adds	r2, r0, #1
 1521 002a 1A60     		str	r2, [r3]
 1522 002c FFF7FEFF 		bl	getData
 1523              	.LVL263:
 1524 0030 40F20003 		movw	r3, #:lower16:s
 1525 0034 C0F20003 		movt	r3, #:upper16:s
 1526 0038 1860     		str	r0, [r3]
 1527              	.LVL264:
 418:src/modbus.c  **** 	unsigned int result;
 1528              		.loc 1 418 0
 1529 003a 0026     		movs	r6, #0
 415:src/modbus.c  **** 	int shiftRight;
 1530              		.loc 1 415 0
 1531 003c 0727     		movs	r7, #7
 414:src/modbus.c  **** 	int toBit = 7;
 1532              		.loc 1 414 0
 1533 003e 3546     		mov	r5, r6
 1534              	.LBB14:
 433:src/modbus.c  **** 		rPacket++;
 1535              		.loc 1 433 0
 1536 0040 40F20004 		movw	r4, #:lower16:.LANCHOR1
 1537 0044 C0F20004 		movt	r4, #:upper16:.LANCHOR1
 1538              	.LBE14:
 421:src/modbus.c  **** 		//Call masking function and store value in r.
 1539              		.loc 1 421 0
 1540 0048 12E0     		b	.L73
 1541              	.LVL265:
 1542              	.L76:
 1543              	.LBB15:
 423:src/modbus.c  **** 
 1544              		.loc 1 423 0
 1545 004a 2846     		mov	r0, r5
 1546 004c 3946     		mov	r1, r7
 1547 004e FFF7FEFF 		bl	getMask
 1548              	.LVL266:
 429:src/modbus.c  **** 			result = result >> 1;
 1549              		.loc 1 429 0
 1550 0052 2B46     		mov	r3, r5
 1551 0054 00E0     		b	.L74
 1552              	.LVL267:
 1553              	.L75:
 429:src/modbus.c  **** 			result = result >> 1;
 1554              		.loc 1 429 0 is_stmt 0 discriminator 2
 1555 0056 013B     		subs	r3, r3, #1
 1556              	.LVL268:
 1557              	.L74:
 429:src/modbus.c  **** 			result = result >> 1;
 1558              		.loc 1 429 0 discriminator 1
 1559 0058 002B     		cmp	r3, #0
 1560 005a FCDC     		bgt	.L75
 433:src/modbus.c  **** 		rPacket++;
 1561              		.loc 1 433 0 is_stmt 1
 1562 005c 2368     		ldr	r3, [r4]
 1563              	.LVL269:
 1564 005e 58F8042B 		ldr	r2, [r8], #4
 1565              	.LVL270:
 1566 0062 1A60     		str	r2, [r3]
 434:src/modbus.c  **** 
 1567              		.loc 1 434 0
 1568 0064 2368     		ldr	r3, [r4]
 1569 0066 0433     		adds	r3, r3, #4
 1570 0068 2360     		str	r3, [r4]
 1571              	.LVL271:
 438:src/modbus.c  **** 		toBit = toBit + 8;
 1572              		.loc 1 438 0
 1573 006a 0835     		adds	r5, r5, #8
 1574              	.LVL272:
 439:src/modbus.c  **** 
 1575              		.loc 1 439 0
 1576 006c 0837     		adds	r7, r7, #8
 1577              	.LVL273:
 441:src/modbus.c  **** 	}
 1578              		.loc 1 441 0
 1579 006e 0136     		adds	r6, r6, #1
 1580              	.LVL274:
 1581              	.L73:
 1582              	.LBE15:
 421:src/modbus.c  **** 		//Call masking function and store value in r.
 1583              		.loc 1 421 0 discriminator 1
 1584 0070 012E     		cmp	r6, #1
 1585 0072 EADD     		ble	.L76
 455:src/modbus.c  **** 
 1586              		.loc 1 455 0
 1587 0074 0020     		movs	r0, #0
 1588 0076 BDE8F081 		pop	{r4, r5, r6, r7, r8, pc}
 1589              		.cfi_endproc
 1590              	.LFE11:
 1592 007a 00BF     		.section	.text.readInputRegisters,"ax",%progbits
 1593              		.align	2
 1594              		.global	readInputRegisters
 1595              		.thumb
 1596              		.thumb_func
 1598              	readInputRegisters:
 1599              	.LFB12:
 457:src/modbus.c  **** 
 1600              		.loc 1 457 0
 1601              		.cfi_startproc
 1602              		@ args = 0, pretend = 0, frame = 8
 1603              		@ frame_needed = 0, uses_anonymous_args = 0
 1604              	.LVL275:
 1605 0000 2DE9F04F 		push	{r4, r5, r6, r7, r8, r9, r10, fp, lr}
 1606              	.LCFI12:
 1607              		.cfi_def_cfa_offset 36
 1608              		.cfi_offset 4, -36
 1609              		.cfi_offset 5, -32
 1610              		.cfi_offset 6, -28
 1611              		.cfi_offset 7, -24
 1612              		.cfi_offset 8, -20
 1613              		.cfi_offset 9, -16
 1614              		.cfi_offset 10, -12
 1615              		.cfi_offset 11, -8
 1616              		.cfi_offset 14, -4
 1617 0004 83B0     		sub	sp, sp, #12
 1618              	.LCFI13:
 1619              		.cfi_def_cfa_offset 48
 1620              	.LVL276:
 464:src/modbus.c  **** 	totalRequest = *qPacket;
 1621              		.loc 1 464 0
 1622 0006 4268     		ldr	r2, [r0, #4]
 1623 0008 02F5EA42 		add	r2, r2, #29952
 1624 000c 3032     		adds	r2, r2, #48
 1625 000e 40F20003 		movw	r3, #:lower16:.LANCHOR4
 1626 0012 C0F20003 		movt	r3, #:upper16:.LANCHOR4
 1627 0016 1A60     		str	r2, [r3]
 465:src/modbus.c  **** 
 1628              		.loc 1 465 0
 1629 0018 8268     		ldr	r2, [r0, #8]
 1630 001a 40F20004 		movw	r4, #:lower16:.LANCHOR5
 1631 001e C0F20004 		movt	r4, #:upper16:.LANCHOR5
 1632 0022 2260     		str	r2, [r4]
 468:src/modbus.c  **** 
 1633              		.loc 1 468 0
 1634 0024 D208     		lsrs	r2, r2, #3
 1635 0026 501C     		adds	r0, r2, #1
 1636              	.LVL277:
 471:src/modbus.c  **** 	//printf("%d\n",*rPacket);
 1637              		.loc 1 471 0
 1638 0028 40F20002 		movw	r2, #:lower16:.LANCHOR1
 1639 002c C0F20002 		movt	r2, #:upper16:.LANCHOR1
 1640 0030 1168     		ldr	r1, [r2]
 1641 0032 0860     		str	r0, [r1]
 473:src/modbus.c  **** 
 1642              		.loc 1 473 0
 1643 0034 1168     		ldr	r1, [r2]
 1644 0036 0431     		adds	r1, r1, #4
 1645 0038 1160     		str	r1, [r2]
 476:src/modbus.c  **** 
 1646              		.loc 1 476 0
 1647 003a 1868     		ldr	r0, [r3]
 1648              	.LVL278:
 1649 003c 421C     		adds	r2, r0, #1
 1650 003e 1A60     		str	r2, [r3]
 1651 0040 FFF7FEFF 		bl	getData
 1652              	.LVL279:
 1653 0044 40F20003 		movw	r3, #:lower16:s
 1654 0048 C0F20003 		movt	r3, #:upper16:s
 1655 004c 1860     		str	r0, [r3]
 478:src/modbus.c  **** 	int count = 0;
 1656              		.loc 1 478 0
 1657 004e 2568     		ldr	r5, [r4]
 1658              	.LVL280:
 484:src/modbus.c  **** 	//int d;
 1659              		.loc 1 484 0
 1660 0050 0027     		movs	r7, #0
 483:src/modbus.c  **** 	int maxCount = 0;
 1661              		.loc 1 483 0
 1662 0052 0197     		str	r7, [sp, #4]
 481:src/modbus.c  **** 	int shiftRight;
 1663              		.loc 1 481 0
 1664 0054 0724     		movs	r4, #7
 480:src/modbus.c  **** 	int toBit = 7;
 1665              		.loc 1 480 0
 1666 0056 3E46     		mov	r6, r7
 479:src/modbus.c  **** 	int fromBit = 0;
 1667              		.loc 1 479 0
 1668 0058 B946     		mov	r9, r7
 1669              	.LBB16:
 489:src/modbus.c  **** 			toBit = totalRequest - 1;
 1670              		.loc 1 489 0
 1671 005a 40F2000A 		movw	r10, #:lower16:.LANCHOR5
 1672 005e C0F2000A 		movt	r10, #:upper16:.LANCHOR5
 502:src/modbus.c  **** 
 1673              		.loc 1 502 0
 1674 0062 9B46     		mov	fp, r3
 520:src/modbus.c  **** 		rPacket++;
 1675              		.loc 1 520 0
 1676 0064 40F20008 		movw	r8, #:lower16:.LANCHOR1
 1677 0068 C0F20008 		movt	r8, #:upper16:.LANCHOR1
 546:src/modbus.c  **** 			count = 0;
 1678              		.loc 1 546 0
 1679 006c 40F20002 		movw	r2, #:lower16:.LANCHOR4
 1680 0070 C0F20002 		movt	r2, #:upper16:.LANCHOR4
 1681 0074 0092     		str	r2, [sp]
 1682 0076 41E0     		b	.L89
 1683              	.LVL281:
 1684              	.L87:
 489:src/modbus.c  **** 			toBit = totalRequest - 1;
 1685              		.loc 1 489 0
 1686 0078 DAF80030 		ldr	r3, [r10]
 1687 007c 072B     		cmp	r3, #7
 490:src/modbus.c  **** 		}
 1688              		.loc 1 490 0
 1689 007e 98BF     		it	ls
 1690 0080 03F1FF34 		addls	r4, r3, #-1
 1691              	.LVL282:
 494:src/modbus.c  **** 			toBit = (totalRequest % 8) - 1; //if true the set toBit to modules minus-1.
 1692              		.loc 1 494 0
 1693 0084 03F00703 		and	r3, r3, #7
 1694 0088 9D42     		cmp	r5, r3
 1695 008a 02D1     		bne	.L80
 494:src/modbus.c  **** 			toBit = (totalRequest % 8) - 1; //if true the set toBit to modules minus-1.
 1696              		.loc 1 494 0 is_stmt 0 discriminator 1
 1697 008c 019A     		ldr	r2, [sp, #4]
 1698 008e 02B1     		cbz	r2, .L80
 495:src/modbus.c  **** 		}
 1699              		.loc 1 495 0 is_stmt 1
 1700 0090 5C1E     		subs	r4, r3, #1
 1701              	.LVL283:
 1702              	.L80:
 499:src/modbus.c  **** 
 1703              		.loc 1 499 0
 1704 0092 3046     		mov	r0, r6
 1705 0094 2146     		mov	r1, r4
 1706 0096 FFF7FEFF 		bl	getMask
 1707              	.LVL284:
 502:src/modbus.c  **** 
 1708              		.loc 1 502 0
 1709 009a DBF80030 		ldr	r3, [fp]
 1710 009e 5B68     		ldr	r3, [r3, #4]
 1711 00a0 1840     		ands	r0, r0, r3
 1712              	.LVL285:
 505:src/modbus.c  **** 			goto next;
 1713              		.loc 1 505 0
 1714 00a2 072C     		cmp	r4, #7
 1715 00a4 18BF     		it	ne
 1716 00a6 3346     		movne	r3, r6
 1717 00a8 02D1     		bne	.L82
 1718 00aa 03E0     		b	.L81
 1719              	.LVL286:
 1720              	.L83:
 512:src/modbus.c  **** 			}
 1721              		.loc 1 512 0 discriminator 2
 1722 00ac 4008     		lsrs	r0, r0, #1
 1723              	.LVL287:
 511:src/modbus.c  **** 				result = result >> 1;
 1724              		.loc 1 511 0 discriminator 2
 1725 00ae 013B     		subs	r3, r3, #1
 1726              	.LVL288:
 1727              	.L82:
 511:src/modbus.c  **** 				result = result >> 1;
 1728              		.loc 1 511 0 is_stmt 0 discriminator 1
 1729 00b0 002B     		cmp	r3, #0
 1730 00b2 FBDC     		bgt	.L83
 1731              	.LVL289:
 1732              	.L81:
 520:src/modbus.c  **** 		rPacket++;
 1733              		.loc 1 520 0 is_stmt 1
 1734 00b4 D8F80030 		ldr	r3, [r8]
 1735 00b8 1860     		str	r0, [r3]
 521:src/modbus.c  **** //		printf("Data: 0x%x\n", result);
 1736              		.loc 1 521 0
 1737 00ba D8F80030 		ldr	r3, [r8]
 1738 00be 0433     		adds	r3, r3, #4
 1739 00c0 C8F80030 		str	r3, [r8]
 525:src/modbus.c  **** 
 1740              		.loc 1 525 0
 1741 00c4 09F10109 		add	r9, r9, #1
 1742              	.LVL290:
 528:src/modbus.c  **** 
 1743              		.loc 1 528 0
 1744 00c8 083D     		subs	r5, r5, #8
 1745              	.LVL291:
 531:src/modbus.c  **** 			maxCount = 4;
 1746              		.loc 1 531 0
 1747 00ca DAF80030 		ldr	r3, [r10]
 532:src/modbus.c  **** 		}
 1748              		.loc 1 532 0
 1749 00ce 1F2B     		cmp	r3, #31
 1750 00d0 88BF     		it	hi
 1751 00d2 0427     		movhi	r7, #4
 1752              	.LVL292:
 545:src/modbus.c  **** 			s = getData(firstRequest++);
 1753              		.loc 1 545 0
 1754 00d4 B945     		cmp	r9, r7
 555:src/modbus.c  **** 		toBit = toBit + 8;
 1755              		.loc 1 555 0
 1756 00d6 1CBF     		itt	ne
 1757 00d8 0836     		addne	r6, r6, #8
 1758              	.LVL293:
 556:src/modbus.c  **** 	}
 1759              		.loc 1 556 0
 1760 00da 0834     		addne	r4, r4, #8
 1761              	.LVL294:
 1762              	.L86:
 545:src/modbus.c  **** 			s = getData(firstRequest++);
 1763              		.loc 1 545 0
 1764 00dc 0ED1     		bne	.L89
 546:src/modbus.c  **** 			count = 0;
 1765              		.loc 1 546 0
 1766 00de 009B     		ldr	r3, [sp]
 1767 00e0 1868     		ldr	r0, [r3]
 1768              	.LVL295:
 1769 00e2 431C     		adds	r3, r0, #1
 1770 00e4 009A     		ldr	r2, [sp]
 1771 00e6 1360     		str	r3, [r2]
 1772 00e8 FFF7FEFF 		bl	getData
 1773              	.LVL296:
 1774 00ec CBF80000 		str	r0, [fp]
 1775              	.LVL297:
 550:src/modbus.c  **** 			goto again;
 1776              		.loc 1 550 0
 1777 00f0 0123     		movs	r3, #1
 1778 00f2 0193     		str	r3, [sp, #4]
 549:src/modbus.c  **** 			flag = 1;
 1779              		.loc 1 549 0
 1780 00f4 0724     		movs	r4, #7
 548:src/modbus.c  **** 			toBit = 7;
 1781              		.loc 1 548 0
 1782 00f6 0026     		movs	r6, #0
 547:src/modbus.c  **** 			fromBit = 0;
 1783              		.loc 1 547 0
 1784 00f8 B146     		mov	r9, r6
 551:src/modbus.c  **** 		}
 1785              		.loc 1 551 0
 1786 00fa FFE7     		b	.L89
 1787              	.LVL298:
 1788              	.L89:
 1789              	.LBE16:
 487:src/modbus.c  **** 
 1790              		.loc 1 487 0 discriminator 1
 1791 00fc 002D     		cmp	r5, #0
 1792 00fe BBDC     		bgt	.L87
 566:src/modbus.c  **** 
 1793              		.loc 1 566 0
 1794 0100 0020     		movs	r0, #0
 1795 0102 03B0     		add	sp, sp, #12
 1796              		@ sp needed
 1797 0104 BDE8F08F 		pop	{r4, r5, r6, r7, r8, r9, r10, fp, pc}
 1798              		.cfi_endproc
 1799              	.LFE12:
 1801              		.section	.text.readHoldingRegisters,"ax",%progbits
 1802              		.align	2
 1803              		.global	readHoldingRegisters
 1804              		.thumb
 1805              		.thumb_func
 1807              	readHoldingRegisters:
 1808              	.LFB13:
 568:src/modbus.c  **** 
 1809              		.loc 1 568 0
 1810              		.cfi_startproc
 1811              		@ args = 0, pretend = 0, frame = 0
 1812              		@ frame_needed = 0, uses_anonymous_args = 0
 1813              	.LVL299:
 1814 0000 2DE9F84F 		push	{r3, r4, r5, r6, r7, r8, r9, r10, fp, lr}
 1815              	.LCFI14:
 1816              		.cfi_def_cfa_offset 40
 1817              		.cfi_offset 3, -40
 1818              		.cfi_offset 4, -36
 1819              		.cfi_offset 5, -32
 1820              		.cfi_offset 6, -28
 1821              		.cfi_offset 7, -24
 1822              		.cfi_offset 8, -20
 1823              		.cfi_offset 9, -16
 1824              		.cfi_offset 10, -12
 1825              		.cfi_offset 11, -8
 1826              		.cfi_offset 14, -4
 1827              	.LVL300:
 575:src/modbus.c  **** 	totalRequest = *qPacket;
 1828              		.loc 1 575 0
 1829 0004 4268     		ldr	r2, [r0, #4]
 1830 0006 42F41C42 		orr	r2, r2, #39936
 1831 000a 42F04002 		orr	r2, r2, #64
 1832 000e 40F20003 		movw	r3, #:lower16:.LANCHOR4
 1833 0012 C0F20003 		movt	r3, #:upper16:.LANCHOR4
 1834 0016 1A60     		str	r2, [r3]
 576:src/modbus.c  **** 
 1835              		.loc 1 576 0
 1836 0018 8268     		ldr	r2, [r0, #8]
 1837 001a 40F20004 		movw	r4, #:lower16:.LANCHOR5
 1838 001e C0F20004 		movt	r4, #:upper16:.LANCHOR5
 1839 0022 2260     		str	r2, [r4]
 579:src/modbus.c  **** 
 1840              		.loc 1 579 0
 1841 0024 5000     		lsls	r0, r2, #1
 1842              	.LVL301:
 582:src/modbus.c  **** 	//printf("%d\n",*rPacket);
 1843              		.loc 1 582 0
 1844 0026 40F20002 		movw	r2, #:lower16:.LANCHOR1
 1845 002a C0F20002 		movt	r2, #:upper16:.LANCHOR1
 1846 002e 1168     		ldr	r1, [r2]
 1847 0030 0860     		str	r0, [r1]
 584:src/modbus.c  **** 
 1848              		.loc 1 584 0
 1849 0032 1168     		ldr	r1, [r2]
 1850 0034 0431     		adds	r1, r1, #4
 1851 0036 1160     		str	r1, [r2]
 587:src/modbus.c  **** 
 1852              		.loc 1 587 0
 1853 0038 1868     		ldr	r0, [r3]
 1854              	.LVL302:
 1855 003a 421C     		adds	r2, r0, #1
 1856 003c 1A60     		str	r2, [r3]
 1857 003e FFF7FEFF 		bl	getData
 1858              	.LVL303:
 1859 0042 40F20003 		movw	r3, #:lower16:s
 1860 0046 C0F20003 		movt	r3, #:upper16:s
 1861 004a 1860     		str	r0, [r3]
 589:src/modbus.c  **** 	int fromBit = 0;
 1862              		.loc 1 589 0
 1863 004c D4F80080 		ldr	r8, [r4]
 1864              	.LVL304:
 1865 0050 4FF0070B 		mov	fp, #7
 1866 0054 4FF0000A 		mov	r10, #0
 1867              	.LBB17:
 1868              	.LBB18:
 605:src/modbus.c  **** 
 1869              		.loc 1 605 0
 1870 0058 1F46     		mov	r7, r3
 612:src/modbus.c  **** 				rPacket++;
 1871              		.loc 1 612 0
 1872 005a 40F20006 		movw	r6, #:lower16:.LANCHOR1
 1873 005e C0F20006 		movt	r6, #:upper16:.LANCHOR1
 1874              	.LBE18:
 626:src/modbus.c  **** 	}
 1875              		.loc 1 626 0
 1876 0062 40F20009 		movw	r9, #:lower16:.LANCHOR4
 1877 0066 C0F20009 		movt	r9, #:upper16:.LANCHOR4
 1878              	.LBE17:
 595:src/modbus.c  **** 
 1879              		.loc 1 595 0
 1880 006a 22E0     		b	.L91
 1881              	.LVL305:
 1882              	.L94:
 1883              	.LBB20:
 1884              	.LBB19:
 602:src/modbus.c  **** 
 1885              		.loc 1 602 0
 1886 006c 2046     		mov	r0, r4
 1887 006e 2946     		mov	r1, r5
 1888 0070 FFF7FEFF 		bl	getMask
 1889              	.LVL306:
 605:src/modbus.c  **** 
 1890              		.loc 1 605 0
 1891 0074 3B68     		ldr	r3, [r7]
 1892 0076 5B68     		ldr	r3, [r3, #4]
 1893 0078 1840     		ands	r0, r0, r3
 1894              	.LVL307:
 607:src/modbus.c  **** 					result = result >> 1;
 1895              		.loc 1 607 0
 1896 007a 2346     		mov	r3, r4
 1897 007c 01E0     		b	.L92
 1898              	.LVL308:
 1899              	.L93:
 608:src/modbus.c  **** 				}
 1900              		.loc 1 608 0 discriminator 2
 1901 007e 4008     		lsrs	r0, r0, #1
 1902              	.LVL309:
 607:src/modbus.c  **** 					result = result >> 1;
 1903              		.loc 1 607 0 discriminator 2
 1904 0080 013B     		subs	r3, r3, #1
 1905              	.LVL310:
 1906              	.L92:
 607:src/modbus.c  **** 					result = result >> 1;
 1907              		.loc 1 607 0 is_stmt 0 discriminator 1
 1908 0082 002B     		cmp	r3, #0
 1909 0084 FBDC     		bgt	.L93
 612:src/modbus.c  **** 				rPacket++;
 1910              		.loc 1 612 0 is_stmt 1
 1911 0086 3368     		ldr	r3, [r6]
 1912              	.LVL311:
 1913 0088 1860     		str	r0, [r3]
 613:src/modbus.c  **** 				//printf("Data: 0x%x\n", result);
 1914              		.loc 1 613 0
 1915 008a 3368     		ldr	r3, [r6]
 1916 008c 0433     		adds	r3, r3, #4
 1917 008e 3360     		str	r3, [r6]
 618:src/modbus.c  **** 				toBit = toBit + 8;
 1918              		.loc 1 618 0
 1919 0090 0834     		adds	r4, r4, #8
 1920              	.LVL312:
 619:src/modbus.c  **** 		}
 1921              		.loc 1 619 0
 1922 0092 0835     		adds	r5, r5, #8
 1923              	.LVL313:
 1924 0094 01E0     		b	.L95
 1925              	.LVL314:
 1926              	.L96:
 1927              	.LBE19:
 1928              	.LBE20:
 1929 0096 5D46     		mov	r5, fp
 1930 0098 5446     		mov	r4, r10
 1931              	.L95:
 1932              	.LVL315:
 1933              	.LBB21:
 600:src/modbus.c  **** 				//Call masking function and store value in r.
 1934              		.loc 1 600 0 discriminator 1
 1935 009a 082C     		cmp	r4, #8
 1936 009c E6DD     		ble	.L94
 623:src/modbus.c  **** 
 1937              		.loc 1 623 0
 1938 009e 08F1FF38 		add	r8, r8, #-1
 1939              	.LVL316:
 626:src/modbus.c  **** 	}
 1940              		.loc 1 626 0
 1941 00a2 D9F80000 		ldr	r0, [r9]
 1942 00a6 431C     		adds	r3, r0, #1
 1943 00a8 C9F80030 		str	r3, [r9]
 1944 00ac FFF7FEFF 		bl	getData
 1945              	.LVL317:
 1946 00b0 3860     		str	r0, [r7]
 1947              	.LVL318:
 1948              	.L91:
 1949              	.LBE21:
 595:src/modbus.c  **** 
 1950              		.loc 1 595 0 discriminator 1
 1951 00b2 B8F1000F 		cmp	r8, #0
 1952 00b6 EEDC     		bgt	.L96
 634:src/modbus.c  **** 
 1953              		.loc 1 634 0
 1954 00b8 0020     		movs	r0, #0
 1955 00ba BDE8F88F 		pop	{r3, r4, r5, r6, r7, r8, r9, r10, fp, pc}
 1956              		.cfi_endproc
 1957              	.LFE13:
 1959 00be 00BF     		.section	.text.readDiscreteInputs,"ax",%progbits
 1960              		.align	2
 1961              		.global	readDiscreteInputs
 1962              		.thumb
 1963              		.thumb_func
 1965              	readDiscreteInputs:
 1966              	.LFB14:
 636:src/modbus.c  **** 
 1967              		.loc 1 636 0
 1968              		.cfi_startproc
 1969              		@ args = 0, pretend = 0, frame = 8
 1970              		@ frame_needed = 0, uses_anonymous_args = 0
 1971              	.LVL319:
 1972 0000 2DE9F04F 		push	{r4, r5, r6, r7, r8, r9, r10, fp, lr}
 1973              	.LCFI15:
 1974              		.cfi_def_cfa_offset 36
 1975              		.cfi_offset 4, -36
 1976              		.cfi_offset 5, -32
 1977              		.cfi_offset 6, -28
 1978              		.cfi_offset 7, -24
 1979              		.cfi_offset 8, -20
 1980              		.cfi_offset 9, -16
 1981              		.cfi_offset 10, -12
 1982              		.cfi_offset 11, -8
 1983              		.cfi_offset 14, -4
 1984 0004 83B0     		sub	sp, sp, #12
 1985              	.LCFI16:
 1986              		.cfi_def_cfa_offset 48
 1987              	.LVL320:
 643:src/modbus.c  **** 	totalRequest = *qPacket;
 1988              		.loc 1 643 0
 1989 0006 4268     		ldr	r2, [r0, #4]
 1990 0008 42F41C52 		orr	r2, r2, #9984
 1991 000c 42F01002 		orr	r2, r2, #16
 1992 0010 40F20003 		movw	r3, #:lower16:.LANCHOR4
 1993 0014 C0F20003 		movt	r3, #:upper16:.LANCHOR4
 1994 0018 1A60     		str	r2, [r3]
 644:src/modbus.c  **** 
 1995              		.loc 1 644 0
 1996 001a 8268     		ldr	r2, [r0, #8]
 1997 001c 40F20004 		movw	r4, #:lower16:.LANCHOR5
 1998 0020 C0F20004 		movt	r4, #:upper16:.LANCHOR5
 1999 0024 2260     		str	r2, [r4]
 647:src/modbus.c  **** 
 2000              		.loc 1 647 0
 2001 0026 D208     		lsrs	r2, r2, #3
 2002 0028 501C     		adds	r0, r2, #1
 2003              	.LVL321:
 650:src/modbus.c  **** 	//printf("%d\n",*rPacket);
 2004              		.loc 1 650 0
 2005 002a 40F20002 		movw	r2, #:lower16:.LANCHOR1
 2006 002e C0F20002 		movt	r2, #:upper16:.LANCHOR1
 2007 0032 1168     		ldr	r1, [r2]
 2008 0034 0860     		str	r0, [r1]
 652:src/modbus.c  **** 
 2009              		.loc 1 652 0
 2010 0036 1168     		ldr	r1, [r2]
 2011 0038 0431     		adds	r1, r1, #4
 2012 003a 1160     		str	r1, [r2]
 655:src/modbus.c  **** 
 2013              		.loc 1 655 0
 2014 003c 1868     		ldr	r0, [r3]
 2015              	.LVL322:
 2016 003e 421C     		adds	r2, r0, #1
 2017 0040 1A60     		str	r2, [r3]
 2018 0042 FFF7FEFF 		bl	getData
 2019              	.LVL323:
 2020 0046 40F20003 		movw	r3, #:lower16:s
 2021 004a C0F20003 		movt	r3, #:upper16:s
 2022 004e 1860     		str	r0, [r3]
 657:src/modbus.c  **** 	int count = 0;
 2023              		.loc 1 657 0
 2024 0050 2568     		ldr	r5, [r4]
 2025              	.LVL324:
 663:src/modbus.c  **** 	//int d;
 2026              		.loc 1 663 0
 2027 0052 0027     		movs	r7, #0
 662:src/modbus.c  **** 	int maxCount = 0;
 2028              		.loc 1 662 0
 2029 0054 0197     		str	r7, [sp, #4]
 660:src/modbus.c  **** 	int shiftRight;
 2030              		.loc 1 660 0
 2031 0056 0724     		movs	r4, #7
 659:src/modbus.c  **** 	int toBit = 7;
 2032              		.loc 1 659 0
 2033 0058 3E46     		mov	r6, r7
 658:src/modbus.c  **** 	int fromBit = 0;
 2034              		.loc 1 658 0
 2035 005a B946     		mov	r9, r7
 2036              	.LBB22:
 668:src/modbus.c  **** 			toBit = totalRequest - 1;
 2037              		.loc 1 668 0
 2038 005c 40F2000A 		movw	r10, #:lower16:.LANCHOR5
 2039 0060 C0F2000A 		movt	r10, #:upper16:.LANCHOR5
 681:src/modbus.c  **** 
 2040              		.loc 1 681 0
 2041 0064 9B46     		mov	fp, r3
 699:src/modbus.c  **** 		rPacket++;
 2042              		.loc 1 699 0
 2043 0066 40F20008 		movw	r8, #:lower16:.LANCHOR1
 2044 006a C0F20008 		movt	r8, #:upper16:.LANCHOR1
 725:src/modbus.c  **** 			count = 0;
 2045              		.loc 1 725 0
 2046 006e 40F20002 		movw	r2, #:lower16:.LANCHOR4
 2047 0072 C0F20002 		movt	r2, #:upper16:.LANCHOR4
 2048 0076 0092     		str	r2, [sp]
 2049 0078 41E0     		b	.L109
 2050              	.LVL325:
 2051              	.L107:
 668:src/modbus.c  **** 			toBit = totalRequest - 1;
 2052              		.loc 1 668 0
 2053 007a DAF80030 		ldr	r3, [r10]
 2054 007e 072B     		cmp	r3, #7
 669:src/modbus.c  **** 		}
 2055              		.loc 1 669 0
 2056 0080 98BF     		it	ls
 2057 0082 03F1FF34 		addls	r4, r3, #-1
 2058              	.LVL326:
 673:src/modbus.c  **** 			toBit = (totalRequest % 8) - 1; //if true the set toBit to modules minus-1.
 2059              		.loc 1 673 0
 2060 0086 03F00703 		and	r3, r3, #7
 2061 008a 9D42     		cmp	r5, r3
 2062 008c 02D1     		bne	.L100
 673:src/modbus.c  **** 			toBit = (totalRequest % 8) - 1; //if true the set toBit to modules minus-1.
 2063              		.loc 1 673 0 is_stmt 0 discriminator 1
 2064 008e 019A     		ldr	r2, [sp, #4]
 2065 0090 02B1     		cbz	r2, .L100
 674:src/modbus.c  **** 		}
 2066              		.loc 1 674 0 is_stmt 1
 2067 0092 5C1E     		subs	r4, r3, #1
 2068              	.LVL327:
 2069              	.L100:
 678:src/modbus.c  **** 
 2070              		.loc 1 678 0
 2071 0094 3046     		mov	r0, r6
 2072 0096 2146     		mov	r1, r4
 2073 0098 FFF7FEFF 		bl	getMask
 2074              	.LVL328:
 681:src/modbus.c  **** 
 2075              		.loc 1 681 0
 2076 009c DBF80030 		ldr	r3, [fp]
 2077 00a0 5B68     		ldr	r3, [r3, #4]
 2078 00a2 1840     		ands	r0, r0, r3
 2079              	.LVL329:
 684:src/modbus.c  **** 			goto next;
 2080              		.loc 1 684 0
 2081 00a4 072C     		cmp	r4, #7
 2082 00a6 18BF     		it	ne
 2083 00a8 3346     		movne	r3, r6
 2084 00aa 02D1     		bne	.L102
 2085 00ac 03E0     		b	.L101
 2086              	.LVL330:
 2087              	.L103:
 691:src/modbus.c  **** 			}
 2088              		.loc 1 691 0 discriminator 2
 2089 00ae 4008     		lsrs	r0, r0, #1
 2090              	.LVL331:
 690:src/modbus.c  **** 				result = result >> 1;
 2091              		.loc 1 690 0 discriminator 2
 2092 00b0 013B     		subs	r3, r3, #1
 2093              	.LVL332:
 2094              	.L102:
 690:src/modbus.c  **** 				result = result >> 1;
 2095              		.loc 1 690 0 is_stmt 0 discriminator 1
 2096 00b2 002B     		cmp	r3, #0
 2097 00b4 FBDC     		bgt	.L103
 2098              	.LVL333:
 2099              	.L101:
 699:src/modbus.c  **** 		rPacket++;
 2100              		.loc 1 699 0 is_stmt 1
 2101 00b6 D8F80030 		ldr	r3, [r8]
 2102 00ba 1860     		str	r0, [r3]
 700:src/modbus.c  **** //		printf("Data: 0x%x\n", result);
 2103              		.loc 1 700 0
 2104 00bc D8F80030 		ldr	r3, [r8]
 2105 00c0 0433     		adds	r3, r3, #4
 2106 00c2 C8F80030 		str	r3, [r8]
 704:src/modbus.c  **** 
 2107              		.loc 1 704 0
 2108 00c6 09F10109 		add	r9, r9, #1
 2109              	.LVL334:
 707:src/modbus.c  **** 
 2110              		.loc 1 707 0
 2111 00ca 083D     		subs	r5, r5, #8
 2112              	.LVL335:
 710:src/modbus.c  **** 			maxCount = 4;
 2113              		.loc 1 710 0
 2114 00cc DAF80030 		ldr	r3, [r10]
 711:src/modbus.c  **** 		}
 2115              		.loc 1 711 0
 2116 00d0 1F2B     		cmp	r3, #31
 2117 00d2 88BF     		it	hi
 2118 00d4 0427     		movhi	r7, #4
 2119              	.LVL336:
 724:src/modbus.c  **** 			s = getData(firstRequest++);
 2120              		.loc 1 724 0
 2121 00d6 B945     		cmp	r9, r7
 734:src/modbus.c  **** 		toBit = toBit + 8;
 2122              		.loc 1 734 0
 2123 00d8 1CBF     		itt	ne
 2124 00da 0836     		addne	r6, r6, #8
 2125              	.LVL337:
 735:src/modbus.c  **** 	}
 2126              		.loc 1 735 0
 2127 00dc 0834     		addne	r4, r4, #8
 2128              	.LVL338:
 2129              	.L106:
 724:src/modbus.c  **** 			s = getData(firstRequest++);
 2130              		.loc 1 724 0
 2131 00de 0ED1     		bne	.L109
 725:src/modbus.c  **** 			count = 0;
 2132              		.loc 1 725 0
 2133 00e0 009B     		ldr	r3, [sp]
 2134 00e2 1868     		ldr	r0, [r3]
 2135              	.LVL339:
 2136 00e4 431C     		adds	r3, r0, #1
 2137 00e6 009A     		ldr	r2, [sp]
 2138 00e8 1360     		str	r3, [r2]
 2139 00ea FFF7FEFF 		bl	getData
 2140              	.LVL340:
 2141 00ee CBF80000 		str	r0, [fp]
 2142              	.LVL341:
 729:src/modbus.c  **** 			goto again;
 2143              		.loc 1 729 0
 2144 00f2 0123     		movs	r3, #1
 2145 00f4 0193     		str	r3, [sp, #4]
 728:src/modbus.c  **** 			flag = 1;
 2146              		.loc 1 728 0
 2147 00f6 0724     		movs	r4, #7
 727:src/modbus.c  **** 			toBit = 7;
 2148              		.loc 1 727 0
 2149 00f8 0026     		movs	r6, #0
 726:src/modbus.c  **** 			fromBit = 0;
 2150              		.loc 1 726 0
 2151 00fa B146     		mov	r9, r6
 730:src/modbus.c  **** 		}
 2152              		.loc 1 730 0
 2153 00fc FFE7     		b	.L109
 2154              	.LVL342:
 2155              	.L109:
 2156              	.LBE22:
 666:src/modbus.c  **** 
 2157              		.loc 1 666 0 discriminator 1
 2158 00fe 002D     		cmp	r5, #0
 2159 0100 BBDC     		bgt	.L107
 744:src/modbus.c  **** 
 2160              		.loc 1 744 0
 2161 0102 0020     		movs	r0, #0
 2162 0104 03B0     		add	sp, sp, #12
 2163              		@ sp needed
 2164 0106 BDE8F08F 		pop	{r4, r5, r6, r7, r8, r9, r10, fp, pc}
 2165              		.cfi_endproc
 2166              	.LFE14:
 2168 010a 00BF     		.section	.text.readCoil,"ax",%progbits
 2169              		.align	2
 2170              		.global	readCoil
 2171              		.thumb
 2172              		.thumb_func
 2174              	readCoil:
 2175              	.LFB15:
 746:src/modbus.c  **** 
 2176              		.loc 1 746 0
 2177              		.cfi_startproc
 2178              		@ args = 0, pretend = 0, frame = 8
 2179              		@ frame_needed = 0, uses_anonymous_args = 0
 2180              	.LVL343:
 2181 0000 2DE9F04F 		push	{r4, r5, r6, r7, r8, r9, r10, fp, lr}
 2182              	.LCFI17:
 2183              		.cfi_def_cfa_offset 36
 2184              		.cfi_offset 4, -36
 2185              		.cfi_offset 5, -32
 2186              		.cfi_offset 6, -28
 2187              		.cfi_offset 7, -24
 2188              		.cfi_offset 8, -20
 2189              		.cfi_offset 9, -16
 2190              		.cfi_offset 10, -12
 2191              		.cfi_offset 11, -8
 2192              		.cfi_offset 14, -4
 2193 0004 83B0     		sub	sp, sp, #12
 2194              	.LCFI18:
 2195              		.cfi_def_cfa_offset 48
 2196              	.LVL344:
 753:src/modbus.c  **** 	totalRequest = *qPacket;
 2197              		.loc 1 753 0
 2198 0006 4268     		ldr	r2, [r0, #4]
 2199 0008 40F20003 		movw	r3, #:lower16:.LANCHOR4
 2200 000c C0F20003 		movt	r3, #:upper16:.LANCHOR4
 2201 0010 1A60     		str	r2, [r3]
 754:src/modbus.c  **** 
 2202              		.loc 1 754 0
 2203 0012 8268     		ldr	r2, [r0, #8]
 2204 0014 40F20004 		movw	r4, #:lower16:.LANCHOR5
 2205 0018 C0F20004 		movt	r4, #:upper16:.LANCHOR5
 2206 001c 2260     		str	r2, [r4]
 757:src/modbus.c  **** 
 2207              		.loc 1 757 0
 2208 001e D208     		lsrs	r2, r2, #3
 2209 0020 501C     		adds	r0, r2, #1
 2210              	.LVL345:
 760:src/modbus.c  **** 	//printf("%d\n",*rPacket);
 2211              		.loc 1 760 0
 2212 0022 40F20002 		movw	r2, #:lower16:.LANCHOR1
 2213 0026 C0F20002 		movt	r2, #:upper16:.LANCHOR1
 2214 002a 1168     		ldr	r1, [r2]
 2215 002c 0860     		str	r0, [r1]
 762:src/modbus.c  **** 
 2216              		.loc 1 762 0
 2217 002e 1168     		ldr	r1, [r2]
 2218 0030 0431     		adds	r1, r1, #4
 2219 0032 1160     		str	r1, [r2]
 765:src/modbus.c  **** 
 2220              		.loc 1 765 0
 2221 0034 1868     		ldr	r0, [r3]
 2222              	.LVL346:
 2223 0036 421C     		adds	r2, r0, #1
 2224 0038 1A60     		str	r2, [r3]
 2225 003a FFF7FEFF 		bl	getData
 2226              	.LVL347:
 2227 003e 40F20003 		movw	r3, #:lower16:s
 2228 0042 C0F20003 		movt	r3, #:upper16:s
 2229 0046 1860     		str	r0, [r3]
 767:src/modbus.c  **** 	int count = 0;
 2230              		.loc 1 767 0
 2231 0048 2568     		ldr	r5, [r4]
 2232              	.LVL348:
 773:src/modbus.c  **** 	//int d;
 2233              		.loc 1 773 0
 2234 004a 0027     		movs	r7, #0
 772:src/modbus.c  **** 	int maxCount = 0;
 2235              		.loc 1 772 0
 2236 004c 0197     		str	r7, [sp, #4]
 770:src/modbus.c  **** 	int shiftRight;
 2237              		.loc 1 770 0
 2238 004e 0724     		movs	r4, #7
 769:src/modbus.c  **** 	int toBit = 7;
 2239              		.loc 1 769 0
 2240 0050 3E46     		mov	r6, r7
 768:src/modbus.c  **** 	int fromBit = 0;
 2241              		.loc 1 768 0
 2242 0052 B946     		mov	r9, r7
 2243              	.LBB23:
 778:src/modbus.c  **** 			toBit = totalRequest - 1;
 2244              		.loc 1 778 0
 2245 0054 40F2000A 		movw	r10, #:lower16:.LANCHOR5
 2246 0058 C0F2000A 		movt	r10, #:upper16:.LANCHOR5
 791:src/modbus.c  **** 
 2247              		.loc 1 791 0
 2248 005c 9B46     		mov	fp, r3
 809:src/modbus.c  **** 		rPacket++;
 2249              		.loc 1 809 0
 2250 005e 40F20008 		movw	r8, #:lower16:.LANCHOR1
 2251 0062 C0F20008 		movt	r8, #:upper16:.LANCHOR1
 835:src/modbus.c  **** 			count = 0;
 2252              		.loc 1 835 0
 2253 0066 40F20002 		movw	r2, #:lower16:.LANCHOR4
 2254 006a C0F20002 		movt	r2, #:upper16:.LANCHOR4
 2255 006e 0092     		str	r2, [sp]
 2256 0070 41E0     		b	.L122
 2257              	.LVL349:
 2258              	.L120:
 778:src/modbus.c  **** 			toBit = totalRequest - 1;
 2259              		.loc 1 778 0
 2260 0072 DAF80030 		ldr	r3, [r10]
 2261 0076 072B     		cmp	r3, #7
 779:src/modbus.c  **** 		}
 2262              		.loc 1 779 0
 2263 0078 98BF     		it	ls
 2264 007a 03F1FF34 		addls	r4, r3, #-1
 2265              	.LVL350:
 783:src/modbus.c  **** 			toBit = (totalRequest % 8) - 1; //if true the set toBit to modules minus-1.
 2266              		.loc 1 783 0
 2267 007e 03F00703 		and	r3, r3, #7
 2268 0082 9D42     		cmp	r5, r3
 2269 0084 02D1     		bne	.L113
 783:src/modbus.c  **** 			toBit = (totalRequest % 8) - 1; //if true the set toBit to modules minus-1.
 2270              		.loc 1 783 0 is_stmt 0 discriminator 1
 2271 0086 019A     		ldr	r2, [sp, #4]
 2272 0088 02B1     		cbz	r2, .L113
 784:src/modbus.c  **** 		}
 2273              		.loc 1 784 0 is_stmt 1
 2274 008a 5C1E     		subs	r4, r3, #1
 2275              	.LVL351:
 2276              	.L113:
 788:src/modbus.c  **** 
 2277              		.loc 1 788 0
 2278 008c 3046     		mov	r0, r6
 2279 008e 2146     		mov	r1, r4
 2280 0090 FFF7FEFF 		bl	getMask
 2281              	.LVL352:
 791:src/modbus.c  **** 
 2282              		.loc 1 791 0
 2283 0094 DBF80030 		ldr	r3, [fp]
 2284 0098 5B68     		ldr	r3, [r3, #4]
 2285 009a 1840     		ands	r0, r0, r3
 2286              	.LVL353:
 794:src/modbus.c  **** 			goto next;
 2287              		.loc 1 794 0
 2288 009c 072C     		cmp	r4, #7
 2289 009e 18BF     		it	ne
 2290 00a0 3346     		movne	r3, r6
 2291 00a2 02D1     		bne	.L115
 2292 00a4 03E0     		b	.L114
 2293              	.LVL354:
 2294              	.L116:
 801:src/modbus.c  **** 			}
 2295              		.loc 1 801 0 discriminator 2
 2296 00a6 4008     		lsrs	r0, r0, #1
 2297              	.LVL355:
 800:src/modbus.c  **** 				result = result >> 1;
 2298              		.loc 1 800 0 discriminator 2
 2299 00a8 013B     		subs	r3, r3, #1
 2300              	.LVL356:
 2301              	.L115:
 800:src/modbus.c  **** 				result = result >> 1;
 2302              		.loc 1 800 0 is_stmt 0 discriminator 1
 2303 00aa 002B     		cmp	r3, #0
 2304 00ac FBDC     		bgt	.L116
 2305              	.LVL357:
 2306              	.L114:
 809:src/modbus.c  **** 		rPacket++;
 2307              		.loc 1 809 0 is_stmt 1
 2308 00ae D8F80030 		ldr	r3, [r8]
 2309 00b2 1860     		str	r0, [r3]
 810:src/modbus.c  **** //		printf("Data: 0x%x\n", result);
 2310              		.loc 1 810 0
 2311 00b4 D8F80030 		ldr	r3, [r8]
 2312 00b8 0433     		adds	r3, r3, #4
 2313 00ba C8F80030 		str	r3, [r8]
 814:src/modbus.c  **** 
 2314              		.loc 1 814 0
 2315 00be 09F10109 		add	r9, r9, #1
 2316              	.LVL358:
 817:src/modbus.c  **** 
 2317              		.loc 1 817 0
 2318 00c2 083D     		subs	r5, r5, #8
 2319              	.LVL359:
 820:src/modbus.c  **** 			maxCount = 4;
 2320              		.loc 1 820 0
 2321 00c4 DAF80030 		ldr	r3, [r10]
 821:src/modbus.c  **** 		}
 2322              		.loc 1 821 0
 2323 00c8 1F2B     		cmp	r3, #31
 2324 00ca 88BF     		it	hi
 2325 00cc 0427     		movhi	r7, #4
 2326              	.LVL360:
 834:src/modbus.c  **** 			s = getData(firstRequest++);
 2327              		.loc 1 834 0
 2328 00ce B945     		cmp	r9, r7
 844:src/modbus.c  **** 		toBit = toBit + 8;
 2329              		.loc 1 844 0
 2330 00d0 1CBF     		itt	ne
 2331 00d2 0836     		addne	r6, r6, #8
 2332              	.LVL361:
 845:src/modbus.c  **** 	}
 2333              		.loc 1 845 0
 2334 00d4 0834     		addne	r4, r4, #8
 2335              	.LVL362:
 2336              	.L119:
 834:src/modbus.c  **** 			s = getData(firstRequest++);
 2337              		.loc 1 834 0
 2338 00d6 0ED1     		bne	.L122
 835:src/modbus.c  **** 			count = 0;
 2339              		.loc 1 835 0
 2340 00d8 009B     		ldr	r3, [sp]
 2341 00da 1868     		ldr	r0, [r3]
 2342              	.LVL363:
 2343 00dc 431C     		adds	r3, r0, #1
 2344 00de 009A     		ldr	r2, [sp]
 2345 00e0 1360     		str	r3, [r2]
 2346 00e2 FFF7FEFF 		bl	getData
 2347              	.LVL364:
 2348 00e6 CBF80000 		str	r0, [fp]
 2349              	.LVL365:
 839:src/modbus.c  **** 			goto again;
 2350              		.loc 1 839 0
 2351 00ea 0123     		movs	r3, #1
 2352 00ec 0193     		str	r3, [sp, #4]
 838:src/modbus.c  **** 			flag = 1;
 2353              		.loc 1 838 0
 2354 00ee 0724     		movs	r4, #7
 837:src/modbus.c  **** 			toBit = 7;
 2355              		.loc 1 837 0
 2356 00f0 0026     		movs	r6, #0
 836:src/modbus.c  **** 			fromBit = 0;
 2357              		.loc 1 836 0
 2358 00f2 B146     		mov	r9, r6
 840:src/modbus.c  **** 		}
 2359              		.loc 1 840 0
 2360 00f4 FFE7     		b	.L122
 2361              	.LVL366:
 2362              	.L122:
 2363              	.LBE23:
 776:src/modbus.c  **** 
 2364              		.loc 1 776 0 discriminator 1
 2365 00f6 002D     		cmp	r5, #0
 2366 00f8 BBDC     		bgt	.L120
 853:src/modbus.c  **** 
 2367              		.loc 1 853 0
 2368 00fa 0020     		movs	r0, #0
 2369 00fc 03B0     		add	sp, sp, #12
 2370              		@ sp needed
 2371 00fe BDE8F08F 		pop	{r4, r5, r6, r7, r8, r9, r10, fp, pc}
 2372              		.cfi_endproc
 2373              	.LFE15:
 2375 0102 00BF     		.section	.text.validateFunction,"ax",%progbits
 2376              		.align	2
 2377              		.global	validateFunction
 2378              		.thumb
 2379              		.thumb_func
 2381              	validateFunction:
 2382              	.LFB6:
 113:src/modbus.c  **** 
 2383              		.loc 1 113 0
 2384              		.cfi_startproc
 2385              		@ args = 0, pretend = 0, frame = 0
 2386              		@ frame_needed = 0, uses_anonymous_args = 0
 2387              	.LVL367:
 2388 0000 10B5     		push	{r4, lr}
 2389              	.LCFI19:
 2390              		.cfi_def_cfa_offset 8
 2391              		.cfi_offset 4, -8
 2392              		.cfi_offset 14, -4
 115:src/modbus.c  **** 
 2393              		.loc 1 115 0
 2394 0002 041D     		adds	r4, r0, #4
 2395              	.LVL368:
 118:src/modbus.c  **** 	//printf("%d\n",*rPacket);
 2396              		.loc 1 118 0
 2397 0004 40F20003 		movw	r3, #:lower16:.LANCHOR1
 2398 0008 C0F20003 		movt	r3, #:upper16:.LANCHOR1
 2399 000c 1A68     		ldr	r2, [r3]
 2400 000e 4168     		ldr	r1, [r0, #4]
 2401 0010 1160     		str	r1, [r2]
 120:src/modbus.c  **** 
 2402              		.loc 1 120 0
 2403 0012 1A68     		ldr	r2, [r3]
 2404 0014 0432     		adds	r2, r2, #4
 2405 0016 1A60     		str	r2, [r3]
 122:src/modbus.c  **** 	case READ_COIL:
 2406              		.loc 1 122 0
 2407 0018 4368     		ldr	r3, [r0, #4]
 2408 001a 013B     		subs	r3, r3, #1
 2409 001c 0F2B     		cmp	r3, #15
 2410 001e 09D8     		bhi	.L124
 2411 0020 DFE803F0 		tbb	[pc, r3]
 2412              	.L126:
 2413 0024 0A       		.byte	(.L125-.L126)/2
 2414 0025 0F       		.byte	(.L127-.L126)/2
 2415 0026 14       		.byte	(.L128-.L126)/2
 2416 0027 19       		.byte	(.L129-.L126)/2
 2417 0028 1E       		.byte	(.L130-.L126)/2
 2418 0029 23       		.byte	(.L131-.L126)/2
 2419 002a 32       		.byte	(.L135-.L126)/2
 2420 002b 08       		.byte	(.L124-.L126)/2
 2421 002c 08       		.byte	(.L124-.L126)/2
 2422 002d 08       		.byte	(.L124-.L126)/2
 2423 002e 08       		.byte	(.L124-.L126)/2
 2424 002f 08       		.byte	(.L124-.L126)/2
 2425 0030 08       		.byte	(.L124-.L126)/2
 2426 0031 08       		.byte	(.L124-.L126)/2
 2427 0032 28       		.byte	(.L133-.L126)/2
 2428 0033 2D       		.byte	(.L134-.L126)/2
 2429              		.align	1
 2430              	.L124:
 160:src/modbus.c  **** 	}
 2431              		.loc 1 160 0
 2432 0034 0020     		movs	r0, #0
 2433 0036 10BD     		pop	{r4, pc}
 2434              	.LVL369:
 2435              	.L125:
 124:src/modbus.c  **** 		return 1;
 2436              		.loc 1 124 0
 2437 0038 2046     		mov	r0, r4
 2438 003a FFF7FEFF 		bl	readCoil
 2439              	.LVL370:
 125:src/modbus.c  **** 		break;
 2440              		.loc 1 125 0
 2441 003e 0120     		movs	r0, #1
 2442 0040 10BD     		pop	{r4, pc}
 2443              	.LVL371:
 2444              	.L127:
 128:src/modbus.c  **** 		return 1;
 2445              		.loc 1 128 0
 2446 0042 2046     		mov	r0, r4
 2447 0044 FFF7FEFF 		bl	readDiscreteInputs
 2448              	.LVL372:
 129:src/modbus.c  **** 		break;
 2449              		.loc 1 129 0
 2450 0048 0120     		movs	r0, #1
 2451 004a 10BD     		pop	{r4, pc}
 2452              	.LVL373:
 2453              	.L128:
 132:src/modbus.c  **** 		return 1;
 2454              		.loc 1 132 0
 2455 004c 2046     		mov	r0, r4
 2456 004e FFF7FEFF 		bl	readHoldingRegisters
 2457              	.LVL374:
 133:src/modbus.c  **** 		break;
 2458              		.loc 1 133 0
 2459 0052 0120     		movs	r0, #1
 2460 0054 10BD     		pop	{r4, pc}
 2461              	.LVL375:
 2462              	.L129:
 136:src/modbus.c  **** 		return 1;
 2463              		.loc 1 136 0
 2464 0056 2046     		mov	r0, r4
 2465 0058 FFF7FEFF 		bl	readInputRegisters
 2466              	.LVL376:
 137:src/modbus.c  **** 		break;
 2467              		.loc 1 137 0
 2468 005c 0120     		movs	r0, #1
 2469 005e 10BD     		pop	{r4, pc}
 2470              	.LVL377:
 2471              	.L130:
 140:src/modbus.c  **** 		return 1;
 2472              		.loc 1 140 0
 2473 0060 2046     		mov	r0, r4
 2474 0062 FFF7FEFF 		bl	writeSingleCoil
 2475              	.LVL378:
 141:src/modbus.c  **** 		break;
 2476              		.loc 1 141 0
 2477 0066 0120     		movs	r0, #1
 2478 0068 10BD     		pop	{r4, pc}
 2479              	.LVL379:
 2480              	.L131:
 144:src/modbus.c  **** 		return 1;
 2481              		.loc 1 144 0
 2482 006a 2046     		mov	r0, r4
 2483 006c FFF7FEFF 		bl	writeSingleRegister
 2484              	.LVL380:
 145:src/modbus.c  **** 		break;
 2485              		.loc 1 145 0
 2486 0070 0120     		movs	r0, #1
 2487 0072 10BD     		pop	{r4, pc}
 2488              	.LVL381:
 2489              	.L133:
 148:src/modbus.c  **** 		return 1;
 2490              		.loc 1 148 0
 2491 0074 2046     		mov	r0, r4
 2492 0076 FFF7FEFF 		bl	writeMultipleCoils
 2493              	.LVL382:
 149:src/modbus.c  **** 		break;
 2494              		.loc 1 149 0
 2495 007a 0120     		movs	r0, #1
 2496 007c 10BD     		pop	{r4, pc}
 2497              	.LVL383:
 2498              	.L134:
 152:src/modbus.c  **** 		return 1;
 2499              		.loc 1 152 0
 2500 007e 2046     		mov	r0, r4
 2501 0080 FFF7FEFF 		bl	writeMultipleRegisters
 2502              	.LVL384:
 153:src/modbus.c  **** 		break;
 2503              		.loc 1 153 0
 2504 0084 0120     		movs	r0, #1
 2505 0086 10BD     		pop	{r4, pc}
 2506              	.LVL385:
 2507              	.L135:
 157:src/modbus.c  **** 		break;
 2508              		.loc 1 157 0
 2509 0088 0120     		movs	r0, #1
 162:src/modbus.c  **** 
 2510              		.loc 1 162 0
 2511 008a 10BD     		pop	{r4, pc}
 2512              		.cfi_endproc
 2513              	.LFE6:
 2515              		.comm	s,4,4
 2516              		.global	users
 2517              		.global	rPacket
 2518              		.global	arrayResponsePacket
 2519              		.global	writeRequest
 2520              		.global	totalRequest
 2521              		.global	firstRequest
 2522              		.section	.bss.totalRequest,"aw",%nobits
 2523              		.align	2
 2524              		.set	.LANCHOR5,. + 0
 2527              	totalRequest:
 2528 0000 00000000 		.space	4
 2529              		.section	.rodata.crcLo,"a",%progbits
 2530              		.align	2
 2531              		.set	.LANCHOR3,. + 0
 2534              	crcLo:
 2535 0000 00000000 		.word	0
 2536 0004 C0000000 		.word	192
 2537 0008 C1000000 		.word	193
 2538 000c 01000000 		.word	1
 2539 0010 C3000000 		.word	195
 2540 0014 03000000 		.word	3
 2541 0018 02000000 		.word	2
 2542 001c C2000000 		.word	194
 2543 0020 C6000000 		.word	198
 2544 0024 06000000 		.word	6
 2545 0028 07000000 		.word	7
 2546 002c C7000000 		.word	199
 2547 0030 05000000 		.word	5
 2548 0034 C5000000 		.word	197
 2549 0038 C4000000 		.word	196
 2550 003c 04000000 		.word	4
 2551 0040 CC000000 		.word	204
 2552 0044 0C000000 		.word	12
 2553 0048 0D000000 		.word	13
 2554 004c CD000000 		.word	205
 2555 0050 0F000000 		.word	15
 2556 0054 CF000000 		.word	207
 2557 0058 CE000000 		.word	206
 2558 005c 0E000000 		.word	14
 2559 0060 0A000000 		.word	10
 2560 0064 CA000000 		.word	202
 2561 0068 CB000000 		.word	203
 2562 006c 0B000000 		.word	11
 2563 0070 C9000000 		.word	201
 2564 0074 09000000 		.word	9
 2565 0078 08000000 		.word	8
 2566 007c C8000000 		.word	200
 2567 0080 D8000000 		.word	216
 2568 0084 18000000 		.word	24
 2569 0088 19000000 		.word	25
 2570 008c D9000000 		.word	217
 2571 0090 1B000000 		.word	27
 2572 0094 DB000000 		.word	219
 2573 0098 DA000000 		.word	218
 2574 009c 1A000000 		.word	26
 2575 00a0 1E000000 		.word	30
 2576 00a4 DE000000 		.word	222
 2577 00a8 DF000000 		.word	223
 2578 00ac 1F000000 		.word	31
 2579 00b0 DD000000 		.word	221
 2580 00b4 1D000000 		.word	29
 2581 00b8 1C000000 		.word	28
 2582 00bc DC000000 		.word	220
 2583 00c0 14000000 		.word	20
 2584 00c4 D4000000 		.word	212
 2585 00c8 D5000000 		.word	213
 2586 00cc 15000000 		.word	21
 2587 00d0 D7000000 		.word	215
 2588 00d4 17000000 		.word	23
 2589 00d8 16000000 		.word	22
 2590 00dc D6000000 		.word	214
 2591 00e0 D2000000 		.word	210
 2592 00e4 12000000 		.word	18
 2593 00e8 13000000 		.word	19
 2594 00ec D3000000 		.word	211
 2595 00f0 11000000 		.word	17
 2596 00f4 D1000000 		.word	209
 2597 00f8 D0000000 		.word	208
 2598 00fc 10000000 		.word	16
 2599 0100 F0000000 		.word	240
 2600 0104 30000000 		.word	48
 2601 0108 31000000 		.word	49
 2602 010c F1000000 		.word	241
 2603 0110 33000000 		.word	51
 2604 0114 F3000000 		.word	243
 2605 0118 F2000000 		.word	242
 2606 011c 32000000 		.word	50
 2607 0120 36000000 		.word	54
 2608 0124 F6000000 		.word	246
 2609 0128 F7000000 		.word	247
 2610 012c 37000000 		.word	55
 2611 0130 F5000000 		.word	245
 2612 0134 35000000 		.word	53
 2613 0138 34000000 		.word	52
 2614 013c F4000000 		.word	244
 2615 0140 3C000000 		.word	60
 2616 0144 FC000000 		.word	252
 2617 0148 FD000000 		.word	253
 2618 014c 3D000000 		.word	61
 2619 0150 FF000000 		.word	255
 2620 0154 3F000000 		.word	63
 2621 0158 3E000000 		.word	62
 2622 015c FE000000 		.word	254
 2623 0160 FA000000 		.word	250
 2624 0164 3A000000 		.word	58
 2625 0168 3B000000 		.word	59
 2626 016c FB000000 		.word	251
 2627 0170 39000000 		.word	57
 2628 0174 F9000000 		.word	249
 2629 0178 F8000000 		.word	248
 2630 017c 38000000 		.word	56
 2631 0180 28000000 		.word	40
 2632 0184 E8000000 		.word	232
 2633 0188 E9000000 		.word	233
 2634 018c 29000000 		.word	41
 2635 0190 EB000000 		.word	235
 2636 0194 2B000000 		.word	43
 2637 0198 2A000000 		.word	42
 2638 019c EA000000 		.word	234
 2639 01a0 EE000000 		.word	238
 2640 01a4 2E000000 		.word	46
 2641 01a8 2F000000 		.word	47
 2642 01ac EF000000 		.word	239
 2643 01b0 2D000000 		.word	45
 2644 01b4 ED000000 		.word	237
 2645 01b8 EC000000 		.word	236
 2646 01bc 2C000000 		.word	44
 2647 01c0 E4000000 		.word	228
 2648 01c4 24000000 		.word	36
 2649 01c8 25000000 		.word	37
 2650 01cc E5000000 		.word	229
 2651 01d0 27000000 		.word	39
 2652 01d4 E7000000 		.word	231
 2653 01d8 E6000000 		.word	230
 2654 01dc 26000000 		.word	38
 2655 01e0 22000000 		.word	34
 2656 01e4 E2000000 		.word	226
 2657 01e8 E3000000 		.word	227
 2658 01ec 23000000 		.word	35
 2659 01f0 E1000000 		.word	225
 2660 01f4 21000000 		.word	33
 2661 01f8 20000000 		.word	32
 2662 01fc E0000000 		.word	224
 2663 0200 A0000000 		.word	160
 2664 0204 60000000 		.word	96
 2665 0208 61000000 		.word	97
 2666 020c A1000000 		.word	161
 2667 0210 63000000 		.word	99
 2668 0214 A3000000 		.word	163
 2669 0218 A2000000 		.word	162
 2670 021c 62000000 		.word	98
 2671 0220 66000000 		.word	102
 2672 0224 A6000000 		.word	166
 2673 0228 A7000000 		.word	167
 2674 022c 67000000 		.word	103
 2675 0230 A5000000 		.word	165
 2676 0234 65000000 		.word	101
 2677 0238 64000000 		.word	100
 2678 023c A4000000 		.word	164
 2679 0240 6C000000 		.word	108
 2680 0244 AC000000 		.word	172
 2681 0248 AD000000 		.word	173
 2682 024c 6D000000 		.word	109
 2683 0250 AF000000 		.word	175
 2684 0254 6F000000 		.word	111
 2685 0258 6E000000 		.word	110
 2686 025c AE000000 		.word	174
 2687 0260 AA000000 		.word	170
 2688 0264 6A000000 		.word	106
 2689 0268 6B000000 		.word	107
 2690 026c AB000000 		.word	171
 2691 0270 69000000 		.word	105
 2692 0274 A9000000 		.word	169
 2693 0278 A8000000 		.word	168
 2694 027c 68000000 		.word	104
 2695 0280 78000000 		.word	120
 2696 0284 B8000000 		.word	184
 2697 0288 B9000000 		.word	185
 2698 028c 79000000 		.word	121
 2699 0290 BB000000 		.word	187
 2700 0294 7B000000 		.word	123
 2701 0298 7A000000 		.word	122
 2702 029c BA000000 		.word	186
 2703 02a0 BE000000 		.word	190
 2704 02a4 7E000000 		.word	126
 2705 02a8 7F000000 		.word	127
 2706 02ac BF000000 		.word	191
 2707 02b0 7D000000 		.word	125
 2708 02b4 BD000000 		.word	189
 2709 02b8 BC000000 		.word	188
 2710 02bc 7C000000 		.word	124
 2711 02c0 B4000000 		.word	180
 2712 02c4 74000000 		.word	116
 2713 02c8 75000000 		.word	117
 2714 02cc B5000000 		.word	181
 2715 02d0 77000000 		.word	119
 2716 02d4 B7000000 		.word	183
 2717 02d8 B6000000 		.word	182
 2718 02dc 76000000 		.word	118
 2719 02e0 72000000 		.word	114
 2720 02e4 B2000000 		.word	178
 2721 02e8 B3000000 		.word	179
 2722 02ec 73000000 		.word	115
 2723 02f0 B1000000 		.word	177
 2724 02f4 71000000 		.word	113
 2725 02f8 70000000 		.word	112
 2726 02fc B0000000 		.word	176
 2727 0300 50000000 		.word	80
 2728 0304 90000000 		.word	144
 2729 0308 91000000 		.word	145
 2730 030c 51000000 		.word	81
 2731 0310 93000000 		.word	147
 2732 0314 53000000 		.word	83
 2733 0318 52000000 		.word	82
 2734 031c 92000000 		.word	146
 2735 0320 96000000 		.word	150
 2736 0324 56000000 		.word	86
 2737 0328 57000000 		.word	87
 2738 032c 97000000 		.word	151
 2739 0330 55000000 		.word	85
 2740 0334 95000000 		.word	149
 2741 0338 94000000 		.word	148
 2742 033c 54000000 		.word	84
 2743 0340 9C000000 		.word	156
 2744 0344 5C000000 		.word	92
 2745 0348 5D000000 		.word	93
 2746 034c 9D000000 		.word	157
 2747 0350 5F000000 		.word	95
 2748 0354 9F000000 		.word	159
 2749 0358 9E000000 		.word	158
 2750 035c 5E000000 		.word	94
 2751 0360 5A000000 		.word	90
 2752 0364 9A000000 		.word	154
 2753 0368 9B000000 		.word	155
 2754 036c 5B000000 		.word	91
 2755 0370 99000000 		.word	153
 2756 0374 59000000 		.word	89
 2757 0378 58000000 		.word	88
 2758 037c 98000000 		.word	152
 2759 0380 88000000 		.word	136
 2760 0384 48000000 		.word	72
 2761 0388 49000000 		.word	73
 2762 038c 89000000 		.word	137
 2763 0390 4B000000 		.word	75
 2764 0394 8B000000 		.word	139
 2765 0398 8A000000 		.word	138
 2766 039c 4A000000 		.word	74
 2767 03a0 4E000000 		.word	78
 2768 03a4 8E000000 		.word	142
 2769 03a8 8F000000 		.word	143
 2770 03ac 4F000000 		.word	79
 2771 03b0 8D000000 		.word	141
 2772 03b4 4D000000 		.word	77
 2773 03b8 4C000000 		.word	76
 2774 03bc 8C000000 		.word	140
 2775 03c0 44000000 		.word	68
 2776 03c4 84000000 		.word	132
 2777 03c8 85000000 		.word	133
 2778 03cc 45000000 		.word	69
 2779 03d0 87000000 		.word	135
 2780 03d4 47000000 		.word	71
 2781 03d8 46000000 		.word	70
 2782 03dc 86000000 		.word	134
 2783 03e0 82000000 		.word	130
 2784 03e4 42000000 		.word	66
 2785 03e8 43000000 		.word	67
 2786 03ec 83000000 		.word	131
 2787 03f0 41000000 		.word	65
 2788 03f4 81000000 		.word	129
 2789 03f8 80000000 		.word	128
 2790 03fc 40000000 		.word	64
 2791              		.section	.bss.writeRequest,"aw",%nobits
 2792              		.align	2
 2793              		.set	.LANCHOR6,. + 0
 2796              	writeRequest:
 2797 0000 00000000 		.space	4
 2798              		.section	.bss.firstRequest,"aw",%nobits
 2799              		.align	2
 2800              		.set	.LANCHOR4,. + 0
 2803              	firstRequest:
 2804 0000 00000000 		.space	4
 2805              		.section	.rodata.crcHi,"a",%progbits
 2806              		.align	2
 2807              		.set	.LANCHOR2,. + 0
 2810              	crcHi:
 2811 0000 00000000 		.word	0
 2812 0004 C1000000 		.word	193
 2813 0008 81000000 		.word	129
 2814 000c 40000000 		.word	64
 2815 0010 01000000 		.word	1
 2816 0014 C0000000 		.word	192
 2817 0018 80000000 		.word	128
 2818 001c 41000000 		.word	65
 2819 0020 01000000 		.word	1
 2820 0024 C0000000 		.word	192
 2821 0028 80000000 		.word	128
 2822 002c 41000000 		.word	65
 2823 0030 00000000 		.word	0
 2824 0034 C1000000 		.word	193
 2825 0038 81000000 		.word	129
 2826 003c 40000000 		.word	64
 2827 0040 01000000 		.word	1
 2828 0044 C0000000 		.word	192
 2829 0048 80000000 		.word	128
 2830 004c 41000000 		.word	65
 2831 0050 00000000 		.word	0
 2832 0054 C1000000 		.word	193
 2833 0058 81000000 		.word	129
 2834 005c 40000000 		.word	64
 2835 0060 00000000 		.word	0
 2836 0064 C1000000 		.word	193
 2837 0068 81000000 		.word	129
 2838 006c 40000000 		.word	64
 2839 0070 01000000 		.word	1
 2840 0074 C0000000 		.word	192
 2841 0078 80000000 		.word	128
 2842 007c 41000000 		.word	65
 2843 0080 01000000 		.word	1
 2844 0084 C0000000 		.word	192
 2845 0088 80000000 		.word	128
 2846 008c 41000000 		.word	65
 2847 0090 00000000 		.word	0
 2848 0094 C1000000 		.word	193
 2849 0098 81000000 		.word	129
 2850 009c 40000000 		.word	64
 2851 00a0 00000000 		.word	0
 2852 00a4 C1000000 		.word	193
 2853 00a8 81000000 		.word	129
 2854 00ac 40000000 		.word	64
 2855 00b0 01000000 		.word	1
 2856 00b4 C0000000 		.word	192
 2857 00b8 80000000 		.word	128
 2858 00bc 41000000 		.word	65
 2859 00c0 00000000 		.word	0
 2860 00c4 C1000000 		.word	193
 2861 00c8 81000000 		.word	129
 2862 00cc 40000000 		.word	64
 2863 00d0 01000000 		.word	1
 2864 00d4 C0000000 		.word	192
 2865 00d8 80000000 		.word	128
 2866 00dc 41000000 		.word	65
 2867 00e0 01000000 		.word	1
 2868 00e4 C0000000 		.word	192
 2869 00e8 80000000 		.word	128
 2870 00ec 41000000 		.word	65
 2871 00f0 00000000 		.word	0
 2872 00f4 C1000000 		.word	193
 2873 00f8 81000000 		.word	129
 2874 00fc 40000000 		.word	64
 2875 0100 01000000 		.word	1
 2876 0104 C0000000 		.word	192
 2877 0108 80000000 		.word	128
 2878 010c 41000000 		.word	65
 2879 0110 00000000 		.word	0
 2880 0114 C1000000 		.word	193
 2881 0118 81000000 		.word	129
 2882 011c 40000000 		.word	64
 2883 0120 00000000 		.word	0
 2884 0124 C1000000 		.word	193
 2885 0128 81000000 		.word	129
 2886 012c 40000000 		.word	64
 2887 0130 01000000 		.word	1
 2888 0134 C0000000 		.word	192
 2889 0138 80000000 		.word	128
 2890 013c 41000000 		.word	65
 2891 0140 00000000 		.word	0
 2892 0144 C1000000 		.word	193
 2893 0148 81000000 		.word	129
 2894 014c 40000000 		.word	64
 2895 0150 01000000 		.word	1
 2896 0154 C0000000 		.word	192
 2897 0158 80000000 		.word	128
 2898 015c 41000000 		.word	65
 2899 0160 01000000 		.word	1
 2900 0164 C0000000 		.word	192
 2901 0168 80000000 		.word	128
 2902 016c 41000000 		.word	65
 2903 0170 00000000 		.word	0
 2904 0174 C1000000 		.word	193
 2905 0178 81000000 		.word	129
 2906 017c 40000000 		.word	64
 2907 0180 00000000 		.word	0
 2908 0184 C1000000 		.word	193
 2909 0188 81000000 		.word	129
 2910 018c 40000000 		.word	64
 2911 0190 01000000 		.word	1
 2912 0194 C0000000 		.word	192
 2913 0198 80000000 		.word	128
 2914 019c 41000000 		.word	65
 2915 01a0 01000000 		.word	1
 2916 01a4 C0000000 		.word	192
 2917 01a8 80000000 		.word	128
 2918 01ac 41000000 		.word	65
 2919 01b0 00000000 		.word	0
 2920 01b4 C1000000 		.word	193
 2921 01b8 81000000 		.word	129
 2922 01bc 40000000 		.word	64
 2923 01c0 01000000 		.word	1
 2924 01c4 C0000000 		.word	192
 2925 01c8 80000000 		.word	128
 2926 01cc 41000000 		.word	65
 2927 01d0 00000000 		.word	0
 2928 01d4 C1000000 		.word	193
 2929 01d8 81000000 		.word	129
 2930 01dc 40000000 		.word	64
 2931 01e0 00000000 		.word	0
 2932 01e4 C1000000 		.word	193
 2933 01e8 81000000 		.word	129
 2934 01ec 40000000 		.word	64
 2935 01f0 01000000 		.word	1
 2936 01f4 C0000000 		.word	192
 2937 01f8 80000000 		.word	128
 2938 01fc 41000000 		.word	65
 2939 0200 01000000 		.word	1
 2940 0204 C0000000 		.word	192
 2941 0208 80000000 		.word	128
 2942 020c 41000000 		.word	65
 2943 0210 00000000 		.word	0
 2944 0214 C1000000 		.word	193
 2945 0218 81000000 		.word	129
 2946 021c 40000000 		.word	64
 2947 0220 00000000 		.word	0
 2948 0224 C1000000 		.word	193
 2949 0228 81000000 		.word	129
 2950 022c 40000000 		.word	64
 2951 0230 01000000 		.word	1
 2952 0234 C0000000 		.word	192
 2953 0238 80000000 		.word	128
 2954 023c 41000000 		.word	65
 2955 0240 00000000 		.word	0
 2956 0244 C1000000 		.word	193
 2957 0248 81000000 		.word	129
 2958 024c 40000000 		.word	64
 2959 0250 01000000 		.word	1
 2960 0254 C0000000 		.word	192
 2961 0258 80000000 		.word	128
 2962 025c 41000000 		.word	65
 2963 0260 01000000 		.word	1
 2964 0264 C0000000 		.word	192
 2965 0268 80000000 		.word	128
 2966 026c 41000000 		.word	65
 2967 0270 00000000 		.word	0
 2968 0274 C1000000 		.word	193
 2969 0278 81000000 		.word	129
 2970 027c 40000000 		.word	64
 2971 0280 00000000 		.word	0
 2972 0284 C1000000 		.word	193
 2973 0288 81000000 		.word	129
 2974 028c 40000000 		.word	64
 2975 0290 01000000 		.word	1
 2976 0294 C0000000 		.word	192
 2977 0298 80000000 		.word	128
 2978 029c 41000000 		.word	65
 2979 02a0 01000000 		.word	1
 2980 02a4 C0000000 		.word	192
 2981 02a8 80000000 		.word	128
 2982 02ac 41000000 		.word	65
 2983 02b0 00000000 		.word	0
 2984 02b4 C1000000 		.word	193
 2985 02b8 81000000 		.word	129
 2986 02bc 40000000 		.word	64
 2987 02c0 01000000 		.word	1
 2988 02c4 C0000000 		.word	192
 2989 02c8 80000000 		.word	128
 2990 02cc 41000000 		.word	65
 2991 02d0 00000000 		.word	0
 2992 02d4 C1000000 		.word	193
 2993 02d8 81000000 		.word	129
 2994 02dc 40000000 		.word	64
 2995 02e0 00000000 		.word	0
 2996 02e4 C1000000 		.word	193
 2997 02e8 81000000 		.word	129
 2998 02ec 40000000 		.word	64
 2999 02f0 01000000 		.word	1
 3000 02f4 C0000000 		.word	192
 3001 02f8 80000000 		.word	128
 3002 02fc 41000000 		.word	65
 3003 0300 00000000 		.word	0
 3004 0304 C1000000 		.word	193
 3005 0308 81000000 		.word	129
 3006 030c 40000000 		.word	64
 3007 0310 01000000 		.word	1
 3008 0314 C0000000 		.word	192
 3009 0318 80000000 		.word	128
 3010 031c 41000000 		.word	65
 3011 0320 01000000 		.word	1
 3012 0324 C0000000 		.word	192
 3013 0328 80000000 		.word	128
 3014 032c 41000000 		.word	65
 3015 0330 00000000 		.word	0
 3016 0334 C1000000 		.word	193
 3017 0338 81000000 		.word	129
 3018 033c 40000000 		.word	64
 3019 0340 01000000 		.word	1
 3020 0344 C0000000 		.word	192
 3021 0348 80000000 		.word	128
 3022 034c 41000000 		.word	65
 3023 0350 00000000 		.word	0
 3024 0354 C1000000 		.word	193
 3025 0358 81000000 		.word	129
 3026 035c 40000000 		.word	64
 3027 0360 00000000 		.word	0
 3028 0364 C1000000 		.word	193
 3029 0368 81000000 		.word	129
 3030 036c 40000000 		.word	64
 3031 0370 01000000 		.word	1
 3032 0374 C0000000 		.word	192
 3033 0378 80000000 		.word	128
 3034 037c 41000000 		.word	65
 3035 0380 01000000 		.word	1
 3036 0384 C0000000 		.word	192
 3037 0388 80000000 		.word	128
 3038 038c 41000000 		.word	65
 3039 0390 00000000 		.word	0
 3040 0394 C1000000 		.word	193
 3041 0398 81000000 		.word	129
 3042 039c 40000000 		.word	64
 3043 03a0 00000000 		.word	0
 3044 03a4 C1000000 		.word	193
 3045 03a8 81000000 		.word	129
 3046 03ac 40000000 		.word	64
 3047 03b0 01000000 		.word	1
 3048 03b4 C0000000 		.word	192
 3049 03b8 80000000 		.word	128
 3050 03bc 41000000 		.word	65
 3051 03c0 00000000 		.word	0
 3052 03c4 C1000000 		.word	193
 3053 03c8 81000000 		.word	129
 3054 03cc 40000000 		.word	64
 3055 03d0 01000000 		.word	1
 3056 03d4 C0000000 		.word	192
 3057 03d8 80000000 		.word	128
 3058 03dc 41000000 		.word	65
 3059 03e0 01000000 		.word	1
 3060 03e4 C0000000 		.word	192
 3061 03e8 80000000 		.word	128
 3062 03ec 41000000 		.word	65
 3063 03f0 00000000 		.word	0
 3064 03f4 C1000000 		.word	193
 3065 03f8 81000000 		.word	129
 3066 03fc 40000000 		.word	64
 3067              		.section	.data.rPacket,"aw",%progbits
 3068              		.align	2
 3069              		.set	.LANCHOR1,. + 0
 3072              	rPacket:
 3073 0000 00000000 		.word	arrayResponsePacket
 3074              		.section	.rodata.str1.4,"aMS",%progbits,1
 3075              		.align	2
 3076              	.LC0:
 3077 0000 4B657920 		.ascii	"Key 0x%x --> Data 0x%x\012\000"
 3077      30782578 
 3077      202D2D3E 
 3077      20446174 
 3077      61203078 
 3078              	.LC1:
 3079 0018 44617461 		.ascii	"Data: 0x%x\012\000"
 3079      3A203078 
 3079      25780A00 
 3080              		.section	.bss.arrayResponsePacket,"aw",%nobits
 3081              		.align	2
 3084              	arrayResponsePacket:
 3085 0000 00000000 		.space	200
 3085      00000000 
 3085      00000000 
 3085      00000000 
 3085      00000000 
 3086              		.section	.bss.users,"aw",%nobits
 3087              		.align	2
 3088              		.set	.LANCHOR0,. + 0
 3091              	users:
 3092 0000 00000000 		.space	4
 3093              		.text
 3094              	.Letext0:
 3095              		.file 2 "/usr/lib/gcc/arm-none-eabi/4.8.2/include/stddef.h"
 3096              		.file 3 "/usr/include/newlib/machine/_default_types.h"
 3097              		.file 4 "/usr/include/newlib/stdint.h"
 3098              		.file 5 "src/uthash.h"
 3099              		.file 6 "src/modbus.h"
 3100              		.file 7 "/usr/include/newlib/string.h"
 3101              		.file 8 "/usr/include/newlib/stdlib.h"
 3102              		.file 9 "/usr/include/newlib/stdio.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 modbus.c
     /tmp/cc0JBjmR.s:20     .text.addData:0000000000000000 $t
     /tmp/cc0JBjmR.s:25     .text.addData:0000000000000000 addData
     /tmp/cc0JBjmR.s:3088   .bss.users:0000000000000000 .LANCHOR0
     /tmp/cc0JBjmR.s:583    .text.putData:0000000000000000 $t
     /tmp/cc0JBjmR.s:588    .text.putData:0000000000000000 putData
     /tmp/cc0JBjmR.s:3076   .rodata.str1.4:0000000000000000 .LC0
     /tmp/cc0JBjmR.s:631    .text.getData:0000000000000000 $t
     /tmp/cc0JBjmR.s:636    .text.getData:0000000000000000 getData
     /tmp/cc0JBjmR.s:810    .text.validateSlaveID:0000000000000000 $t
     /tmp/cc0JBjmR.s:815    .text.validateSlaveID:0000000000000000 validateSlaveID
     /tmp/cc0JBjmR.s:3069   .data.rPacket:0000000000000000 .LANCHOR1
     /tmp/cc0JBjmR.s:852    .text.validateCrc:0000000000000000 $t
     /tmp/cc0JBjmR.s:857    .text.validateCrc:0000000000000000 validateCrc
     /tmp/cc0JBjmR.s:2807   .rodata.crcHi:0000000000000000 .LANCHOR2
     /tmp/cc0JBjmR.s:2531   .rodata.crcLo:0000000000000000 .LANCHOR3
     /tmp/cc0JBjmR.s:937    .text.calculateOutputCrc:0000000000000000 $t
     /tmp/cc0JBjmR.s:942    .text.calculateOutputCrc:0000000000000000 calculateOutputCrc
     /tmp/cc0JBjmR.s:1017   .text.readExceptionStatus:0000000000000000 $t
     /tmp/cc0JBjmR.s:1022   .text.readExceptionStatus:0000000000000000 readExceptionStatus
     /tmp/cc0JBjmR.s:1038   .text.getMask:0000000000000000 $t
     /tmp/cc0JBjmR.s:1043   .text.getMask:0000000000000000 getMask
     /tmp/cc0JBjmR.s:1086   .text.writeMultipleRegisters:0000000000000000 $t
     /tmp/cc0JBjmR.s:1091   .text.writeMultipleRegisters:0000000000000000 writeMultipleRegisters
     /tmp/cc0JBjmR.s:2800   .bss.firstRequest:0000000000000000 .LANCHOR4
     /tmp/cc0JBjmR.s:2524   .bss.totalRequest:0000000000000000 .LANCHOR5
                            *COM*:0000000000000004 s
     /tmp/cc0JBjmR.s:1260   .text.writeMultipleCoils:0000000000000000 $t
     /tmp/cc0JBjmR.s:1265   .text.writeMultipleCoils:0000000000000000 writeMultipleCoils
     /tmp/cc0JBjmR.s:3078   .rodata.str1.4:0000000000000018 .LC1
     /tmp/cc0JBjmR.s:1404   .text.writeSingleRegister:0000000000000000 $t
     /tmp/cc0JBjmR.s:1409   .text.writeSingleRegister:0000000000000000 writeSingleRegister
     /tmp/cc0JBjmR.s:2793   .bss.writeRequest:0000000000000000 .LANCHOR6
     /tmp/cc0JBjmR.s:1478   .text.writeSingleCoil:0000000000000000 $t
     /tmp/cc0JBjmR.s:1483   .text.writeSingleCoil:0000000000000000 writeSingleCoil
     /tmp/cc0JBjmR.s:1593   .text.readInputRegisters:0000000000000000 $t
     /tmp/cc0JBjmR.s:1598   .text.readInputRegisters:0000000000000000 readInputRegisters
     /tmp/cc0JBjmR.s:1802   .text.readHoldingRegisters:0000000000000000 $t
     /tmp/cc0JBjmR.s:1807   .text.readHoldingRegisters:0000000000000000 readHoldingRegisters
     /tmp/cc0JBjmR.s:1960   .text.readDiscreteInputs:0000000000000000 $t
     /tmp/cc0JBjmR.s:1965   .text.readDiscreteInputs:0000000000000000 readDiscreteInputs
     /tmp/cc0JBjmR.s:2169   .text.readCoil:0000000000000000 $t
     /tmp/cc0JBjmR.s:2174   .text.readCoil:0000000000000000 readCoil
     /tmp/cc0JBjmR.s:2376   .text.validateFunction:0000000000000000 $t
     /tmp/cc0JBjmR.s:2381   .text.validateFunction:0000000000000000 validateFunction
     /tmp/cc0JBjmR.s:2413   .text.validateFunction:0000000000000024 $d
     /tmp/cc0JBjmR.s:2429   .text.validateFunction:0000000000000034 $t
     /tmp/cc0JBjmR.s:3091   .bss.users:0000000000000000 users
     /tmp/cc0JBjmR.s:3072   .data.rPacket:0000000000000000 rPacket
     /tmp/cc0JBjmR.s:3084   .bss.arrayResponsePacket:0000000000000000 arrayResponsePacket
     /tmp/cc0JBjmR.s:2796   .bss.writeRequest:0000000000000000 writeRequest
     /tmp/cc0JBjmR.s:2527   .bss.totalRequest:0000000000000000 totalRequest
     /tmp/cc0JBjmR.s:2803   .bss.firstRequest:0000000000000000 firstRequest
     /tmp/cc0JBjmR.s:2523   .bss.totalRequest:0000000000000000 $d
     /tmp/cc0JBjmR.s:2530   .rodata.crcLo:0000000000000000 $d
     /tmp/cc0JBjmR.s:2534   .rodata.crcLo:0000000000000000 crcLo
     /tmp/cc0JBjmR.s:2792   .bss.writeRequest:0000000000000000 $d
     /tmp/cc0JBjmR.s:2799   .bss.firstRequest:0000000000000000 $d
     /tmp/cc0JBjmR.s:2806   .rodata.crcHi:0000000000000000 $d
     /tmp/cc0JBjmR.s:2810   .rodata.crcHi:0000000000000000 crcHi
     /tmp/cc0JBjmR.s:3068   .data.rPacket:0000000000000000 $d
     /tmp/cc0JBjmR.s:3075   .rodata.str1.4:0000000000000000 $d
     /tmp/cc0JBjmR.s:3081   .bss.arrayResponsePacket:0000000000000000 $d
     /tmp/cc0JBjmR.s:3087   .bss.users:0000000000000000 $d
                     .debug_frame:0000000000000010 $d
                           .group:0000000000000000 wm4.1.7402b5479d3fa4780665141f585fc0ee
                           .group:0000000000000000 wm4.newlib.h.8.fec018e441fee7bfa1923812ad010f97
                           .group:0000000000000000 wm4.features.h.22.6a4ca7cd053637cc1d0db6c16f39b2d7
                           .group:0000000000000000 wm4.config.h.212.4163ef2871a828c674038d036b081cfd
                           .group:0000000000000000 wm4._ansi.h.23.2147fde150631f5584b9dc29b914d1b8
                           .group:0000000000000000 wm4.stdio.h.31.7c0e28c411445f3f9c5b11accf882760
                           .group:0000000000000000 wm4.stddef.h.184.159df79b4ca79c76561572a55985524c
                           .group:0000000000000000 wm4.stdarg.h.34.3a23a216c0c293b3d2ea2e89281481e6
                           .group:0000000000000000 wm4.stddef.h.39.7e3d906ac58942e0b374c527445f5de5
                           .group:0000000000000000 wm4._default_types.h.6.9e4229723f5523536bc8f574589d6a99
                           .group:0000000000000000 wm4.lock.h.2.9bc98482741e5e2a9450b12934a684ea
                           .group:0000000000000000 wm4._types.h.54.d3d34a3b7f3cc230cd159baf022b4b08
                           .group:0000000000000000 wm4.stddef.h.158.61317cdbfb4026324507d123a50b0fd6
                           .group:0000000000000000 wm4.reent.h.17.8bd9e4098e0428508c282cad794fae43
                           .group:0000000000000000 wm4.types.h.23.0d949686bbcadd1621462d4fa1f884f9
                           .group:0000000000000000 wm4.types.h.2.e9cec8c90ab35f77d9f499e06ae02400
                           .group:0000000000000000 wm4.types.h.80.56707660962b21991903f1fee7c13bb3
                           .group:0000000000000000 wm4.stdio.h.2.4aa87247282eca6c8f36f9de33d8df1a
                           .group:0000000000000000 wm4.stdio.h.64.0f05fa42cfe2db7fc44729a52d3ba948
                           .group:0000000000000000 wm4.stdlib.h.13.4ed386f5c1a80d71e72172885d946ef2
                           .group:0000000000000000 wm4.stddef.h.158.a7efb00f6cbc6f43213b50e183c9830c
                           .group:0000000000000000 wm4.alloca.h.8.dfc0c703c47ec3e69746825b17d9e66d
                           .group:0000000000000000 wm4.stdlib.h.53.1a82a3cc35cb0a04319c41bcf41d2a02
                           .group:0000000000000000 wm4.cdefs.h.47.62f534e9f325912d9007cf852ba0bf0d
                           .group:0000000000000000 wm4.string.h.15.dab3980bf35408a4c507182805e2de3a
                           .group:0000000000000000 wm4.string.h.126.6ff3aa59129e7f66b2c273baf353e066
                           .group:0000000000000000 wm4.uthash.h.43.1fc79745d9a41d0170507d27cd8856dc
                           .group:0000000000000000 wm4.stdint.h.10.d0f8e374834fcfc2e296d5d5fe82f02a
                           .group:0000000000000000 wm4.inttypes.h.24.4db40689d622c4d3b547b5801303bdae
                           .group:0000000000000000 wm4.uthash.h.67.1f07c20d9d9dfd82ae163222519c47ad

UNDEFINED SYMBOLS
memcmp
malloc
exit
memset
free
printf
