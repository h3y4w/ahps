   1              		.syntax unified
   2              		.cpu cortex-m4
   3              		.eabi_attribute 27, 3
   4              		.fpu fpv4-sp-d16
   5              		.eabi_attribute 20, 1
   6              		.eabi_attribute 21, 1
   7              		.eabi_attribute 23, 3
   8              		.eabi_attribute 24, 1
   9              		.eabi_attribute 25, 1
  10              		.eabi_attribute 26, 1
  11              		.eabi_attribute 30, 1
  12              		.eabi_attribute 34, 1
  13              		.eabi_attribute 18, 4
  14              		.thumb
  15              		.file	"command_parser.c"
  16              		.text
  17              	.Ltext0:
  18              		.cfi_sections	.debug_frame
  19              		.section	.text.setup_output,"ax",%progbits
  20              		.align	2
  21              		.global	setup_output
  22              		.thumb
  23              		.thumb_func
  25              	setup_output:
  26              	.LFB110:
  27              		.file 1 "src/command_parser.c"
   1:src/command_parser.c **** #include "command_parser.h"
   2:src/command_parser.c **** 
   3:src/command_parser.c **** USART_rtos *USARTOutput_rtos; 
   4:src/command_parser.c **** 
   5:src/command_parser.c **** void setup_output(USART_rtos *USARTx_rtos) {
  28              		.loc 1 5 0
  29              		.cfi_startproc
  30              		@ args = 0, pretend = 0, frame = 0
  31              		@ frame_needed = 0, uses_anonymous_args = 0
  32              		@ link register save eliminated.
  33              	.LVL0:
   6:src/command_parser.c ****     USARTOutput_rtos = USARTx_rtos;
  34              		.loc 1 6 0
  35 0000 40F20003 		movw	r3, #:lower16:USARTOutput_rtos
  36 0004 C0F20003 		movt	r3, #:upper16:USARTOutput_rtos
  37 0008 1860     		str	r0, [r3]
  38 000a 7047     		bx	lr
  39              		.cfi_endproc
  40              	.LFE110:
  42              		.section	.text.replace_char,"ax",%progbits
  43              		.align	2
  44              		.global	replace_char
  45              		.thumb
  46              		.thumb_func
  48              	replace_char:
  49              	.LFB111:
   7:src/command_parser.c **** }
   8:src/command_parser.c **** 
   9:src/command_parser.c **** void replace_char(char *msg, char find, char replace) {
  50              		.loc 1 9 0
  51              		.cfi_startproc
  52              		@ args = 0, pretend = 0, frame = 0
  53              		@ frame_needed = 0, uses_anonymous_args = 0
  54              		@ link register save eliminated.
  55              	.LVL1:
  10:src/command_parser.c ****     while(*msg!='\r') {
  56              		.loc 1 10 0
  57 0000 03E0     		b	.L3
  58              	.L5:
  11:src/command_parser.c ****         if (*msg == find) *msg = replace;
  59              		.loc 1 11 0
  60 0002 8B42     		cmp	r3, r1
  61 0004 08BF     		it	eq
  62 0006 0270     		strbeq	r2, [r0]
  12:src/command_parser.c ****         msg++;
  63              		.loc 1 12 0
  64 0008 0130     		adds	r0, r0, #1
  65              	.LVL2:
  66              	.L3:
  10:src/command_parser.c ****     while(*msg!='\r') {
  67              		.loc 1 10 0 discriminator 1
  68 000a 0378     		ldrb	r3, [r0]	@ zero_extendqisi2
  69 000c 0D2B     		cmp	r3, #13
  70 000e F8D1     		bne	.L5
  13:src/command_parser.c ****     }
  14:src/command_parser.c **** }
  71              		.loc 1 14 0
  72 0010 7047     		bx	lr
  73              		.cfi_endproc
  74              	.LFE111:
  76 0012 00BF     		.section	.text.str_compare,"ax",%progbits
  77              		.align	2
  78              		.global	str_compare
  79              		.thumb
  80              		.thumb_func
  82              	str_compare:
  83              	.LFB112:
  15:src/command_parser.c **** 
  16:src/command_parser.c **** int str_compare(char *str1, char *str2, const char terminator) {
  84              		.loc 1 16 0
  85              		.cfi_startproc
  86              		@ args = 0, pretend = 0, frame = 0
  87              		@ frame_needed = 0, uses_anonymous_args = 0
  88              		@ link register save eliminated.
  89              	.LVL3:
  90 0000 30B4     		push	{r4, r5}
  91              	.LCFI0:
  92              		.cfi_def_cfa_offset 8
  93              		.cfi_offset 4, -8
  94              		.cfi_offset 5, -4
  95              	.LVL4:
  17:src/command_parser.c ****     int i;
  18:src/command_parser.c ****     for(i=0;; i++) {
  96              		.loc 1 18 0
  97 0002 0023     		movs	r3, #0
  98              	.LVL5:
  99              	.L8:
  19:src/command_parser.c **** 
  20:src/command_parser.c ****         if (str1[i] == str2[i]) {
 100              		.loc 1 20 0
 101 0004 C45C     		ldrb	r4, [r0, r3]	@ zero_extendqisi2
 102 0006 CD5C     		ldrb	r5, [r1, r3]	@ zero_extendqisi2
 103 0008 AC42     		cmp	r4, r5
 104 000a 03D1     		bne	.L9
  21:src/command_parser.c ****             if (str1[i] == terminator) return 1; // strs match
 105              		.loc 1 21 0
 106 000c 9442     		cmp	r4, r2
 107 000e 03D0     		beq	.L10
  18:src/command_parser.c **** 
 108              		.loc 1 18 0
 109 0010 0133     		adds	r3, r3, #1
 110              	.LVL6:
  22:src/command_parser.c ****         }
  23:src/command_parser.c **** 
  24:src/command_parser.c ****         else {
  25:src/command_parser.c ****             return 0;
  26:src/command_parser.c ****         }
  27:src/command_parser.c ****     }
 111              		.loc 1 27 0
 112 0012 F7E7     		b	.L8
 113              	.L9:
  25:src/command_parser.c ****         }
 114              		.loc 1 25 0
 115 0014 0020     		movs	r0, #0
 116              	.LVL7:
 117 0016 00E0     		b	.L7
 118              	.LVL8:
 119              	.L10:
  21:src/command_parser.c ****         }
 120              		.loc 1 21 0
 121 0018 0120     		movs	r0, #1
 122              	.LVL9:
 123              	.L7:
  28:src/command_parser.c **** }
 124              		.loc 1 28 0
 125 001a 30BC     		pop	{r4, r5}
 126 001c 7047     		bx	lr
 127              		.cfi_endproc
 128              	.LFE112:
 130 001e 00BF     		.section	.text.find_next_char,"ax",%progbits
 131              		.align	2
 132              		.global	find_next_char
 133              		.thumb
 134              		.thumb_func
 136              	find_next_char:
 137              	.LFB113:
  29:src/command_parser.c **** 
  30:src/command_parser.c **** 
  31:src/command_parser.c **** int find_next_char(char *msg, int offset, char find) {
 138              		.loc 1 31 0
 139              		.cfi_startproc
 140              		@ args = 0, pretend = 0, frame = 0
 141              		@ frame_needed = 0, uses_anonymous_args = 0
 142              		@ link register save eliminated.
 143              	.LVL10:
  32:src/command_parser.c ****     int i=0;
 144              		.loc 1 32 0
 145 0000 0023     		movs	r3, #0
 146              	.LVL11:
 147              	.L13:
  33:src/command_parser.c ****     while (1) {
  34:src/command_parser.c ****         if (msg[i] == find) break;
 148              		.loc 1 34 0
 149 0002 C15C     		ldrb	r1, [r0, r3]	@ zero_extendqisi2
 150 0004 9142     		cmp	r1, r2
 151 0006 02D0     		beq	.L14
  35:src/command_parser.c ****         else if (msg[i] == '\0') {
 152              		.loc 1 35 0
 153 0008 19B1     		cbz	r1, .L15
  36:src/command_parser.c ****             return -1;
  37:src/command_parser.c ****             break;
  38:src/command_parser.c ****         }
  39:src/command_parser.c ****         i++;
 154              		.loc 1 39 0
 155 000a 0133     		adds	r3, r3, #1
 156              	.LVL12:
  40:src/command_parser.c ****     }
 157              		.loc 1 40 0
 158 000c F9E7     		b	.L13
 159              	.L14:
  41:src/command_parser.c **** 
  42:src/command_parser.c ****     return i;
 160              		.loc 1 42 0
 161 000e 1846     		mov	r0, r3
 162              	.LVL13:
 163 0010 7047     		bx	lr
 164              	.LVL14:
 165              	.L15:
  36:src/command_parser.c ****             break;
 166              		.loc 1 36 0
 167 0012 4FF0FF30 		mov	r0, #-1
 168              	.LVL15:
  43:src/command_parser.c **** }
 169              		.loc 1 43 0
 170 0016 7047     		bx	lr
 171              		.cfi_endproc
 172              	.LFE113:
 174              		.section	.text.str_to_int,"ax",%progbits
 175              		.align	2
 176              		.global	str_to_int
 177              		.thumb
 178              		.thumb_func
 180              	str_to_int:
 181              	.LFB114:
  44:src/command_parser.c **** 
  45:src/command_parser.c **** 
  46:src/command_parser.c **** int str_to_int(char *buffer, char terminator) {
 182              		.loc 1 46 0
 183              		.cfi_startproc
 184              		@ args = 0, pretend = 0, frame = 0
 185              		@ frame_needed = 0, uses_anonymous_args = 0
 186              		@ link register save eliminated.
 187              	.LVL16:
 188 0000 70B4     		push	{r4, r5, r6}
 189              	.LCFI1:
 190              		.cfi_def_cfa_offset 12
 191              		.cfi_offset 4, -12
 192              		.cfi_offset 5, -8
 193              		.cfi_offset 6, -4
 194 0002 0546     		mov	r5, r0
 195              	.LVL17:
  47:src/command_parser.c ****     int num = 0;
  48:src/command_parser.c ****     int i=0;
  49:src/command_parser.c ****     int neg=0;
  50:src/command_parser.c **** 
  51:src/command_parser.c ****     if (buffer[i] == '-') {
 196              		.loc 1 51 0
 197 0004 0378     		ldrb	r3, [r0]	@ zero_extendqisi2
 198 0006 2D2B     		cmp	r3, #45
  49:src/command_parser.c **** 
 199              		.loc 1 49 0
 200 0008 14BF     		ite	ne
 201 000a 0026     		movne	r6, #0
  52:src/command_parser.c ****         i++;
  53:src/command_parser.c ****         neg = 1;
 202              		.loc 1 53 0
 203 000c 0126     		moveq	r6, #1
  52:src/command_parser.c ****         i++;
 204              		.loc 1 52 0
 205 000e 3246     		mov	r2, r6
  48:src/command_parser.c ****     int neg=0;
 206              		.loc 1 48 0
 207 0010 0020     		movs	r0, #0
 208              	.LVL18:
 209 0012 0AE0     		b	.L18
 210              	.LVL19:
 211              	.L20:
  54:src/command_parser.c ****     }
  55:src/command_parser.c **** 
  56:src/command_parser.c ****     for(i; buffer[i]!=terminator; i++) {
  57:src/command_parser.c ****         if (buffer[i] >= '0' && buffer[i]<='9'){
 212              		.loc 1 57 0
 213 0014 A3F13004 		sub	r4, r3, #48
 214 0018 E4B2     		uxtb	r4, r4
 215 001a 092C     		cmp	r4, #9
 216 001c 08D8     		bhi	.L19
  58:src/command_parser.c ****             num *= 10; 
 217              		.loc 1 58 0
 218 001e 00EB8000 		add	r0, r0, r0, lsl #2
 219              	.LVL20:
  59:src/command_parser.c ****             num += buffer[i]-'0';
 220              		.loc 1 59 0
 221 0022 303B     		subs	r3, r3, #48
 222 0024 03EB4000 		add	r0, r3, r0, lsl #1
 223              	.LVL21:
  56:src/command_parser.c ****         if (buffer[i] >= '0' && buffer[i]<='9'){
 224              		.loc 1 56 0
 225 0028 0132     		adds	r2, r2, #1
 226              	.LVL22:
 227              	.L18:
  56:src/command_parser.c ****         if (buffer[i] >= '0' && buffer[i]<='9'){
 228              		.loc 1 56 0 is_stmt 0 discriminator 1
 229 002a AB5C     		ldrb	r3, [r5, r2]	@ zero_extendqisi2
 230 002c 8B42     		cmp	r3, r1
 231 002e F1D1     		bne	.L20
 232              	.L19:
  60:src/command_parser.c ****         }
  61:src/command_parser.c **** 
  62:src/command_parser.c ****         else {
  63:src/command_parser.c ****             break;
  64:src/command_parser.c ****         }    
  65:src/command_parser.c ****     }
  66:src/command_parser.c **** 
  67:src/command_parser.c ****     if (neg) {
 233              		.loc 1 67 0 is_stmt 1
 234 0030 06B1     		cbz	r6, .L21
  68:src/command_parser.c ****         num *= -1;
 235              		.loc 1 68 0
 236 0032 4042     		negs	r0, r0
 237              	.LVL23:
 238              	.L21:
  69:src/command_parser.c ****     }
  70:src/command_parser.c ****     return num;
  71:src/command_parser.c **** 
  72:src/command_parser.c **** }
 239              		.loc 1 72 0
 240 0034 70BC     		pop	{r4, r5, r6}
 241              	.LVL24:
 242 0036 7047     		bx	lr
 243              		.cfi_endproc
 244              	.LFE114:
 246              		.section	.text.command_set_regime_ph,"ax",%progbits
 247              		.align	2
 248              		.global	command_set_regime_ph
 249              		.thumb
 250              		.thumb_func
 252              	command_set_regime_ph:
 253              	.LFB115:
  73:src/command_parser.c **** 
  74:src/command_parser.c **** 
  75:src/command_parser.c **** 
  76:src/command_parser.c **** 
  77:src/command_parser.c **** Stage stages[MAX_STAGES];
  78:src/command_parser.c **** int REGIME_PH[MAX_REGIME_PH][2] = {
  79:src/command_parser.c ****                                     {-1, -1}, 
  80:src/command_parser.c ****                                     {-1, -1}, 
  81:src/command_parser.c ****                                     {-1, -1}, 
  82:src/command_parser.c ****                                     {-1, -1}, 
  83:src/command_parser.c ****                                     {-1, -1}, 
  84:src/command_parser.c ****                                     {-1, -1},
  85:src/command_parser.c ****                                     {-1, -1}, 
  86:src/command_parser.c ****                                     {-1, -1}, 
  87:src/command_parser.c ****                                     {-1, -1},
  88:src/command_parser.c ****                                     {-1, -1}
  89:src/command_parser.c ****                                   }; //ph, delay
  90:src/command_parser.c **** int REGIME_LIGHTING[MAX_REGIME_LIGHTING][2] ={{-1, -1}}; //distance, hours_on
  91:src/command_parser.c **** 
  92:src/command_parser.c **** void command_set_regime_ph(char *pos, char term) {
 254              		.loc 1 92 0
 255              		.cfi_startproc
 256              		@ args = 0, pretend = 0, frame = 176
 257              		@ frame_needed = 0, uses_anonymous_args = 0
 258              	.LVL25:
 259 0000 2DE9F04F 		push	{r4, r5, r6, r7, r8, r9, r10, fp, lr}
 260              	.LCFI2:
 261              		.cfi_def_cfa_offset 36
 262              		.cfi_offset 4, -36
 263              		.cfi_offset 5, -32
 264              		.cfi_offset 6, -28
 265              		.cfi_offset 7, -24
 266              		.cfi_offset 8, -20
 267              		.cfi_offset 9, -16
 268              		.cfi_offset 10, -12
 269              		.cfi_offset 11, -8
 270              		.cfi_offset 14, -4
 271 0004 ADB0     		sub	sp, sp, #180
 272              	.LCFI3:
 273              		.cfi_def_cfa_offset 216
 274 0006 0446     		mov	r4, r0
 275 0008 0F46     		mov	r7, r1
  93:src/command_parser.c ****     USART_rtos_packet packet;
  94:src/command_parser.c ****     char buffer[80];
  95:src/command_parser.c ****     char msg[] = "{'object_type': 'REGIME_PH', 'method': 'set', 'error':%d, 'object_id':%d}\r\n";
 276              		.loc 1 95 0
 277 000a 01A8     		add	r0, sp, #4
 278              	.LVL26:
 279 000c 40F20001 		movw	r1, #:lower16:.LC0
 280              	.LVL27:
 281 0010 C0F20001 		movt	r1, #:upper16:.LC0
 282 0014 4C22     		movs	r2, #76
 283 0016 FFF7FEFF 		bl	memcpy
 284              	.LVL28:
  96:src/command_parser.c ****     packet.msg = buffer;
 285              		.loc 1 96 0
 286 001a 14AB     		add	r3, sp, #80
 287 001c 2993     		str	r3, [sp, #164]
  97:src/command_parser.c **** 
  98:src/command_parser.c ****     packet.USARTx_rtos = USARTOutput_rtos; 
 288              		.loc 1 98 0
 289 001e 40F20003 		movw	r3, #:lower16:USARTOutput_rtos
 290 0022 C0F20003 		movt	r3, #:upper16:USARTOutput_rtos
 291 0026 1B68     		ldr	r3, [r3]
 292 0028 2893     		str	r3, [sp, #160]
 293              	.LVL29:
  99:src/command_parser.c **** 
 100:src/command_parser.c **** 
 101:src/command_parser.c ****     int NEW_ITEM = 0;
 102:src/command_parser.c **** 
 103:src/command_parser.c ****     int idx = find_next_char(pos, 0, term);
 294              		.loc 1 103 0
 295 002a 2046     		mov	r0, r4
 296 002c 0021     		movs	r1, #0
 297 002e 3A46     		mov	r2, r7
 298 0030 FFF7FEFF 		bl	find_next_char
 299              	.LVL30:
 104:src/command_parser.c ****     pos+=idx+1;
 300              		.loc 1 104 0
 301 0034 0130     		adds	r0, r0, #1
 302              	.LVL31:
 303 0036 0444     		add	r4, r4, r0
 304              	.LVL32:
 105:src/command_parser.c **** 
 106:src/command_parser.c ****     int regime_id = str_to_int(pos, '\003')-1;
 305              		.loc 1 106 0
 306 0038 2046     		mov	r0, r4
 307              	.LVL33:
 308 003a 0321     		movs	r1, #3
 309 003c FFF7FEFF 		bl	str_to_int
 310              	.LVL34:
 311 0040 461E     		subs	r6, r0, #1
 312              	.LVL35:
 107:src/command_parser.c ****     if (!(regime_id >= -1 && regime_id <MAX_REGIME_PH)){
 313              		.loc 1 107 0
 314 0042 0A28     		cmp	r0, #10
 315 0044 0AD9     		bls	.L24
 108:src/command_parser.c ****         USART_rtos_sputs(&packet, msg, 100, -1); // error 100: incorrect id
 316              		.loc 1 108 0
 317 0046 28A8     		add	r0, sp, #160
 318 0048 01A9     		add	r1, sp, #4
 319 004a 6422     		movs	r2, #100
 320 004c 4FF0FF33 		mov	r3, #-1
 321 0050 FFF7FEFF 		bl	USART_rtos_sputs
 322              	.LVL36:
 109:src/command_parser.c ****         USART_rtos_wait_send(&packet);
 323              		.loc 1 109 0
 324 0054 28A8     		add	r0, sp, #160
 325 0056 FFF7FEFF 		bl	USART_rtos_wait_send
 326              	.LVL37:
 110:src/command_parser.c ****         return;
 327              		.loc 1 110 0
 328 005a 82E0     		b	.L23
 329              	.L24:
 111:src/command_parser.c ****     }
 112:src/command_parser.c **** 
 113:src/command_parser.c ****     else if (regime_id == -1) {
 330              		.loc 1 113 0
 331 005c B6F1FF3F 		cmp	r6, #-1
 101:src/command_parser.c **** 
 332              		.loc 1 101 0
 333 0060 18BF     		it	ne
 334 0062 4FF0000B 		movne	fp, #0
 335              		.loc 1 113 0
 336 0066 23D1     		bne	.L27
 337 0068 0CE0     		b	.L39
 338              	.LVL38:
 339              	.L30:
 340              	.LBB2:
 114:src/command_parser.c ****         int i;
 115:src/command_parser.c ****         for(i=0; i<MAX_REGIME_PH; i++) if (REGIME_PH[i][1]  == -1 && REGIME_PH[i][0] == -1) break;
 341              		.loc 1 115 0 discriminator 2
 342 006a 02EBC603 		add	r3, r2, r6, lsl #3
 343 006e 5B68     		ldr	r3, [r3, #4]
 344 0070 B3F1FF3F 		cmp	r3, #-1
 345 0074 04D1     		bne	.L28
 346              		.loc 1 115 0 is_stmt 0 discriminator 1
 347 0076 52F83630 		ldr	r3, [r2, r6, lsl #3]
 348 007a B3F1FF3F 		cmp	r3, #-1
 349 007e 08D0     		beq	.L29
 350              	.L28:
 351              		.loc 1 115 0 discriminator 2
 352 0080 0136     		adds	r6, r6, #1
 353              	.LVL39:
 354 0082 04E0     		b	.L26
 355              	.LVL40:
 356              	.L39:
 357              	.LBE2:
 358 0084 0026     		movs	r6, #0
 359              	.LVL41:
 360              	.LBB3:
 361              		.loc 1 115 0
 362 0086 40F20002 		movw	r2, #:lower16:.LANCHOR0
 363 008a C0F20002 		movt	r2, #:upper16:.LANCHOR0
 364              	.L26:
 365              	.LVL42:
 366              		.loc 1 115 0 discriminator 1
 367 008e 092E     		cmp	r6, #9
 368 0090 EBDD     		ble	.L30
 369              	.L29:
 116:src/command_parser.c **** 
 117:src/command_parser.c ****         if (i == MAX_REGIME_PH) {
 370              		.loc 1 117 0 is_stmt 1
 371 0092 0A2E     		cmp	r6, #10
 372 0094 0AD1     		bne	.L40
 118:src/command_parser.c **** 
 119:src/command_parser.c ****             USART_rtos_sputs(&packet, msg, 101, -1); //error 101: need to overwrite existing rows
 373              		.loc 1 119 0
 374 0096 28A8     		add	r0, sp, #160
 375              	.LVL43:
 376 0098 01A9     		add	r1, sp, #4
 377 009a 6522     		movs	r2, #101
 378 009c 4FF0FF33 		mov	r3, #-1
 379 00a0 FFF7FEFF 		bl	USART_rtos_sputs
 380              	.LVL44:
 120:src/command_parser.c ****             USART_rtos_wait_send(&packet);
 381              		.loc 1 120 0
 382 00a4 28A8     		add	r0, sp, #160
 383 00a6 FFF7FEFF 		bl	USART_rtos_wait_send
 384              	.LVL45:
 121:src/command_parser.c ****             return;
 385              		.loc 1 121 0
 386 00aa 5AE0     		b	.L23
 387              	.LVL46:
 388              	.L40:
 122:src/command_parser.c ****         }
 123:src/command_parser.c **** 
 124:src/command_parser.c ****         regime_id = i;
 125:src/command_parser.c ****         NEW_ITEM = 1;
 389              		.loc 1 125 0
 390 00ac 4FF0010B 		mov	fp, #1
 391              	.LVL47:
 392              	.L27:
 393              	.LBE3:
 126:src/command_parser.c ****     }
 127:src/command_parser.c **** 
 128:src/command_parser.c **** 
 129:src/command_parser.c ****     idx = find_next_char(pos, 0, term);
 394              		.loc 1 129 0
 395 00b0 2046     		mov	r0, r4
 396 00b2 0021     		movs	r1, #0
 397 00b4 3A46     		mov	r2, r7
 398 00b6 FFF7FEFF 		bl	find_next_char
 399              	.LVL48:
 130:src/command_parser.c ****     pos+=idx+1;
 400              		.loc 1 130 0
 401 00ba 431C     		adds	r3, r0, #1
 402 00bc 1C44     		add	r4, r4, r3
 403              	.LVL49:
 131:src/command_parser.c **** 
 132:src/command_parser.c ****     //break this up into smaller functions for each task
 133:src/command_parser.c **** 
 134:src/command_parser.c ****     int i;
 135:src/command_parser.c ****     for(i=0; i<2 && idx!=0; i++) {
 404              		.loc 1 135 0
 405 00be 0025     		movs	r5, #0
 406              	.LBB4:
 136:src/command_parser.c ****         switch (*pos) {
 137:src/command_parser.c ****             int v;
 138:src/command_parser.c ****             char buffer[30];
 139:src/command_parser.c **** 
 140:src/command_parser.c ****             case 'p':
 141:src/command_parser.c ****                 pos++;
 142:src/command_parser.c ****                 v = str_to_int(pos, '\003');
 143:src/command_parser.c ****                 //printf("p=%d\n", v);
 144:src/command_parser.c ****                 REGIME_PH[regime_id][0] = v;
 145:src/command_parser.c ****                 break;
 146:src/command_parser.c **** 
 147:src/command_parser.c ****             case 'd': 
 148:src/command_parser.c ****                pos++;
 149:src/command_parser.c ****                v = str_to_int(pos, '\003'); 
 407              		.loc 1 149 0
 408 00c0 4FF00308 		mov	r8, #3
 150:src/command_parser.c ****                //printf("d=%d\n", v);
 151:src/command_parser.c ****                REGIME_PH[regime_id][1] = v;
 409              		.loc 1 151 0
 410 00c4 40F20009 		movw	r9, #:lower16:.LANCHOR0
 411 00c8 C0F20009 		movt	r9, #:upper16:.LANCHOR0
 412 00cc 09EBC60A 		add	r10, r9, r6, lsl #3
 413              	.LBE4:
 135:src/command_parser.c ****         switch (*pos) {
 414              		.loc 1 135 0
 415 00d0 38E0     		b	.L31
 416              	.LVL50:
 417              	.L37:
 136:src/command_parser.c ****         switch (*pos) {
 418              		.loc 1 136 0
 419 00d2 2378     		ldrb	r3, [r4]	@ zero_extendqisi2
 420 00d4 642B     		cmp	r3, #100
 421 00d6 09D0     		beq	.L33
 422 00d8 702B     		cmp	r3, #112
 423 00da 0FD1     		bne	.L41
 424              	.LBB5:
 141:src/command_parser.c ****                 v = str_to_int(pos, '\003');
 425              		.loc 1 141 0
 426 00dc 0134     		adds	r4, r4, #1
 427              	.LVL51:
 142:src/command_parser.c ****                 //printf("p=%d\n", v);
 428              		.loc 1 142 0
 429 00de 2046     		mov	r0, r4
 430              	.LVL52:
 431 00e0 4146     		mov	r1, r8
 432 00e2 FFF7FEFF 		bl	str_to_int
 433              	.LVL53:
 144:src/command_parser.c ****                 break;
 434              		.loc 1 144 0
 435 00e6 49F83600 		str	r0, [r9, r6, lsl #3]
 145:src/command_parser.c **** 
 436              		.loc 1 145 0
 437 00ea 20E0     		b	.L35
 438              	.LVL54:
 439              	.L33:
 148:src/command_parser.c ****                v = str_to_int(pos, '\003'); 
 440              		.loc 1 148 0
 441 00ec 0134     		adds	r4, r4, #1
 442              	.LVL55:
 149:src/command_parser.c ****                //printf("d=%d\n", v);
 443              		.loc 1 149 0
 444 00ee 2046     		mov	r0, r4
 445              	.LVL56:
 446 00f0 4146     		mov	r1, r8
 447 00f2 FFF7FEFF 		bl	str_to_int
 448              	.LVL57:
 449              		.loc 1 151 0
 450 00f6 CAF80400 		str	r0, [r10, #4]
 152:src/command_parser.c ****                break;
 451              		.loc 1 152 0
 452 00fa 18E0     		b	.L35
 453              	.LVL58:
 454              	.L41:
 153:src/command_parser.c **** 
 154:src/command_parser.c ****             default:
 155:src/command_parser.c ****                USART_rtos_sputs(&packet, msg, 102, -1); //error 102: incorrect variable
 455              		.loc 1 155 0
 456 00fc 28A8     		add	r0, sp, #160
 457              	.LVL59:
 458 00fe 01A9     		add	r1, sp, #4
 459 0100 6622     		movs	r2, #102
 460 0102 4FF0FF33 		mov	r3, #-1
 461 0106 FFF7FEFF 		bl	USART_rtos_sputs
 462              	.LVL60:
 156:src/command_parser.c ****                USART_rtos_wait_send(&packet);
 463              		.loc 1 156 0
 464 010a 28A8     		add	r0, sp, #160
 465 010c FFF7FEFF 		bl	USART_rtos_wait_send
 466              	.LVL61:
 157:src/command_parser.c ****                if (NEW_ITEM) {
 467              		.loc 1 157 0
 468 0110 BBF1000F 		cmp	fp, #0
 469 0114 0BD0     		beq	.L35
 158:src/command_parser.c ****                    REGIME_PH[regime_id][0] = -1; //PH setting
 470              		.loc 1 158 0
 471 0116 40F20003 		movw	r3, #:lower16:.LANCHOR0
 472 011a C0F20003 		movt	r3, #:upper16:.LANCHOR0
 473 011e 4FF0FF32 		mov	r2, #-1
 474 0122 43F83620 		str	r2, [r3, r6, lsl #3]
 159:src/command_parser.c ****                    REGIME_PH[regime_id][1] = -1; // delay
 475              		.loc 1 159 0
 476 0126 03EBC603 		add	r3, r3, r6, lsl #3
 477 012a 5A60     		str	r2, [r3, #4]
 478 012c 19E0     		b	.L23
 479              	.L35:
 480              	.LBE5:
 160:src/command_parser.c ****                    return;
 161:src/command_parser.c ****                }
 162:src/command_parser.c **** 
 163:src/command_parser.c ****         }
 164:src/command_parser.c ****         idx = find_next_char(pos, 0, term);
 481              		.loc 1 164 0
 482 012e 2046     		mov	r0, r4
 483 0130 0021     		movs	r1, #0
 484 0132 3A46     		mov	r2, r7
 485 0134 FFF7FEFF 		bl	find_next_char
 486              	.LVL62:
 165:src/command_parser.c ****         if (idx == -1) break;
 487              		.loc 1 165 0
 488 0138 B0F1FF3F 		cmp	r0, #-1
 489 013c 0BD0     		beq	.L36
 166:src/command_parser.c ****         pos+=idx+1;
 490              		.loc 1 166 0
 491 013e 431C     		adds	r3, r0, #1
 492 0140 1C44     		add	r4, r4, r3
 493              	.LVL63:
 135:src/command_parser.c ****         switch (*pos) {
 494              		.loc 1 135 0
 495 0142 0135     		adds	r5, r5, #1
 496              	.LVL64:
 497              	.L31:
 135:src/command_parser.c ****         switch (*pos) {
 498              		.loc 1 135 0 is_stmt 0 discriminator 1
 499 0144 012D     		cmp	r5, #1
 500 0146 CCBF     		ite	gt
 501 0148 0023     		movgt	r3, #0
 502 014a 0123     		movle	r3, #1
 503 014c 0028     		cmp	r0, #0
 504 014e 08BF     		it	eq
 505 0150 0023     		moveq	r3, #0
 506 0152 002B     		cmp	r3, #0
 507 0154 BDD1     		bne	.L37
 508              	.L36:
 167:src/command_parser.c ****     }
 168:src/command_parser.c ****     USART_rtos_sputs(&packet, msg, 0, regime_id+1);
 509              		.loc 1 168 0 is_stmt 1
 510 0156 28A8     		add	r0, sp, #160
 511              	.LVL65:
 512 0158 01A9     		add	r1, sp, #4
 513 015a 0022     		movs	r2, #0
 514 015c 731C     		adds	r3, r6, #1
 515 015e FFF7FEFF 		bl	USART_rtos_sputs
 516              	.LVL66:
 517              	.L23:
 169:src/command_parser.c **** 
 170:src/command_parser.c **** 
 171:src/command_parser.c **** }
 518              		.loc 1 171 0
 519 0162 2DB0     		add	sp, sp, #180
 520              		@ sp needed
 521 0164 BDE8F08F 		pop	{r4, r5, r6, r7, r8, r9, r10, fp, pc}
 522              		.cfi_endproc
 523              	.LFE115:
 525              		.section	.text.command_set_stage,"ax",%progbits
 526              		.align	2
 527              		.global	command_set_stage
 528              		.thumb
 529              		.thumb_func
 531              	command_set_stage:
 532              	.LFB116:
 172:src/command_parser.c **** 
 173:src/command_parser.c **** void command_set_stage(char *pos, char term) {
 533              		.loc 1 173 0
 534              		.cfi_startproc
 535              		@ args = 0, pretend = 0, frame = 176
 536              		@ frame_needed = 0, uses_anonymous_args = 0
 537              	.LVL67:
 538 0000 2DE9F04F 		push	{r4, r5, r6, r7, r8, r9, r10, fp, lr}
 539              	.LCFI4:
 540              		.cfi_def_cfa_offset 36
 541              		.cfi_offset 4, -36
 542              		.cfi_offset 5, -32
 543              		.cfi_offset 6, -28
 544              		.cfi_offset 7, -24
 545              		.cfi_offset 8, -20
 546              		.cfi_offset 9, -16
 547              		.cfi_offset 10, -12
 548              		.cfi_offset 11, -8
 549              		.cfi_offset 14, -4
 550 0004 ADB0     		sub	sp, sp, #180
 551              	.LCFI5:
 552              		.cfi_def_cfa_offset 216
 553 0006 0446     		mov	r4, r0
 554 0008 0F46     		mov	r7, r1
 174:src/command_parser.c ****     USART_rtos_packet packet;
 175:src/command_parser.c ****     char buffer[80];
 176:src/command_parser.c ****     char msg[] = "{'object_type': 'STAGE', 'method': 'set', 'error':%d, 'object_id':%d}\r\n";
 555              		.loc 1 176 0
 556 000a 02A8     		add	r0, sp, #8
 557              	.LVL68:
 558 000c 40F20001 		movw	r1, #:lower16:.LC1
 559              	.LVL69:
 560 0010 C0F20001 		movt	r1, #:upper16:.LC1
 561 0014 4822     		movs	r2, #72
 562 0016 FFF7FEFF 		bl	memcpy
 563              	.LVL70:
 177:src/command_parser.c ****     packet.msg = buffer;
 564              		.loc 1 177 0
 565 001a 14AB     		add	r3, sp, #80
 566 001c 2993     		str	r3, [sp, #164]
 178:src/command_parser.c ****     packet.USARTx_rtos = USARTOutput_rtos;
 567              		.loc 1 178 0
 568 001e 40F20003 		movw	r3, #:lower16:USARTOutput_rtos
 569 0022 C0F20003 		movt	r3, #:upper16:USARTOutput_rtos
 570 0026 1B68     		ldr	r3, [r3]
 571 0028 2893     		str	r3, [sp, #160]
 572              	.LVL71:
 179:src/command_parser.c **** 
 180:src/command_parser.c ****     int NEW_ITEM = 0;
 181:src/command_parser.c **** 
 182:src/command_parser.c ****     int idx = find_next_char(pos, 0, term);
 573              		.loc 1 182 0
 574 002a 2046     		mov	r0, r4
 575 002c 0021     		movs	r1, #0
 576 002e 3A46     		mov	r2, r7
 577 0030 FFF7FEFF 		bl	find_next_char
 578              	.LVL72:
 183:src/command_parser.c ****     pos+=idx+1;
 579              		.loc 1 183 0
 580 0034 0130     		adds	r0, r0, #1
 581              	.LVL73:
 582 0036 2518     		adds	r5, r4, r0
 583              	.LVL74:
 184:src/command_parser.c **** 
 185:src/command_parser.c ****     int stage_id = str_to_int(pos, '\003')-1;
 584              		.loc 1 185 0
 585 0038 2846     		mov	r0, r5
 586              	.LVL75:
 587 003a 0321     		movs	r1, #3
 588 003c FFF7FEFF 		bl	str_to_int
 589              	.LVL76:
 590 0040 441E     		subs	r4, r0, #1
 591              	.LVL77:
 186:src/command_parser.c **** 
 187:src/command_parser.c ****     if (!(stage_id >= -1 && stage_id <MAX_STAGES)) {
 592              		.loc 1 187 0
 593 0042 0A28     		cmp	r0, #10
 594 0044 0AD9     		bls	.L43
 188:src/command_parser.c ****         USART_rtos_sputs(&packet, msg, 100, -1); // error 100: incorrect id
 595              		.loc 1 188 0
 596 0046 28A8     		add	r0, sp, #160
 597 0048 02A9     		add	r1, sp, #8
 598 004a 6422     		movs	r2, #100
 599 004c 4FF0FF33 		mov	r3, #-1
 600 0050 FFF7FEFF 		bl	USART_rtos_sputs
 601              	.LVL78:
 189:src/command_parser.c ****         USART_rtos_wait_send(&packet);
 602              		.loc 1 189 0
 603 0054 28A8     		add	r0, sp, #160
 604 0056 FFF7FEFF 		bl	USART_rtos_wait_send
 605              	.LVL79:
 190:src/command_parser.c ****         return;
 606              		.loc 1 190 0
 607 005a A9E0     		b	.L42
 608              	.L43:
 191:src/command_parser.c ****     }
 192:src/command_parser.c **** 
 193:src/command_parser.c ****     else if (stage_id == -1) {
 609              		.loc 1 193 0
 610 005c B4F1FF3F 		cmp	r4, #-1
 611 0060 0AD0     		beq	.L62
 180:src/command_parser.c **** 
 612              		.loc 1 180 0
 613 0062 0022     		movs	r2, #0
 614 0064 0192     		str	r2, [sp, #4]
 615 0066 26E0     		b	.L46
 616              	.LVL80:
 617              	.L48:
 618              	.LBB6:
 194:src/command_parser.c ****         int i;
 195:src/command_parser.c ****         for(i=0; i<MAX_STAGES; i++) {
 196:src/command_parser.c ****             if (stages[i].using == 0) break;
 619              		.loc 1 196 0
 620 0068 04EB4403 		add	r3, r4, r4, lsl #1
 621 006c 02EBC303 		add	r3, r2, r3, lsl #3
 622 0070 5B69     		ldr	r3, [r3, #20]
 623 0072 43B1     		cbz	r3, .L47
 195:src/command_parser.c ****             if (stages[i].using == 0) break;
 624              		.loc 1 195 0
 625 0074 0134     		adds	r4, r4, #1
 626              	.LVL81:
 627 0076 04E0     		b	.L45
 628              	.LVL82:
 629              	.L62:
 630              	.LBE6:
 631 0078 0024     		movs	r4, #0
 632              	.LVL83:
 633              	.LBB7:
 634              		.loc 1 196 0
 635 007a 40F20002 		movw	r2, #:lower16:stages
 636 007e C0F20002 		movt	r2, #:upper16:stages
 637              	.L45:
 638              	.LVL84:
 195:src/command_parser.c ****             if (stages[i].using == 0) break;
 639              		.loc 1 195 0 discriminator 1
 640 0082 092C     		cmp	r4, #9
 641 0084 F0DD     		ble	.L48
 642              	.L47:
 197:src/command_parser.c ****         }
 198:src/command_parser.c **** 
 199:src/command_parser.c ****         if (i == MAX_STAGES) {
 643              		.loc 1 199 0
 644 0086 0A2C     		cmp	r4, #10
 645 0088 0AD1     		bne	.L49
 200:src/command_parser.c ****             USART_rtos_sputs(&packet, msg, 101, -1); //error 101: need to overwrite existing rows
 646              		.loc 1 200 0
 647 008a 28A8     		add	r0, sp, #160
 648              	.LVL85:
 649 008c 02A9     		add	r1, sp, #8
 650 008e 6522     		movs	r2, #101
 651 0090 4FF0FF33 		mov	r3, #-1
 652 0094 FFF7FEFF 		bl	USART_rtos_sputs
 653              	.LVL86:
 201:src/command_parser.c ****             USART_rtos_wait_send(&packet);
 654              		.loc 1 201 0
 655 0098 28A8     		add	r0, sp, #160
 656 009a FFF7FEFF 		bl	USART_rtos_wait_send
 657              	.LVL87:
 202:src/command_parser.c ****             return;
 658              		.loc 1 202 0
 659 009e 87E0     		b	.L42
 660              	.LVL88:
 661              	.L49:
 203:src/command_parser.c ****         }
 204:src/command_parser.c **** 
 205:src/command_parser.c ****         stage_id = i;
 206:src/command_parser.c ****         stages[stage_id].using = 1;
 662              		.loc 1 206 0
 663 00a0 40F20003 		movw	r3, #:lower16:stages
 664 00a4 C0F20003 		movt	r3, #:upper16:stages
 665 00a8 04EB4402 		add	r2, r4, r4, lsl #1
 666 00ac 03EBC203 		add	r3, r3, r2, lsl #3
 667 00b0 0122     		movs	r2, #1
 668 00b2 5A61     		str	r2, [r3, #20]
 669              	.LVL89:
 207:src/command_parser.c ****         NEW_ITEM = 1;
 670              		.loc 1 207 0
 671 00b4 0192     		str	r2, [sp, #4]
 672              	.LVL90:
 673              	.L46:
 674              	.LBE7:
 208:src/command_parser.c ****     }
 209:src/command_parser.c **** 
 210:src/command_parser.c ****     idx = find_next_char(pos, 0, term);
 675              		.loc 1 210 0
 676 00b6 2846     		mov	r0, r5
 677 00b8 0021     		movs	r1, #0
 678 00ba 3A46     		mov	r2, r7
 679 00bc FFF7FEFF 		bl	find_next_char
 680              	.LVL91:
 211:src/command_parser.c ****     pos+=idx+1;
 681              		.loc 1 211 0
 682 00c0 431C     		adds	r3, r0, #1
 683 00c2 1D44     		add	r5, r5, r3
 684              	.LVL92:
 212:src/command_parser.c **** 
 213:src/command_parser.c ****     int i;
 214:src/command_parser.c **** 
 215:src/command_parser.c ****     stages[stage_id].id = stage_id+1;
 685              		.loc 1 215 0
 686 00c4 04F1010B 		add	fp, r4, #1
 687 00c8 40F20003 		movw	r3, #:lower16:stages
 688 00cc C0F20003 		movt	r3, #:upper16:stages
 689 00d0 04EB4402 		add	r2, r4, r4, lsl #1
 690 00d4 43F832B0 		str	fp, [r3, r2, lsl #3]
 691              	.LVL93:
 216:src/command_parser.c **** 
 217:src/command_parser.c ****     for(i=0; i<5 && idx!=0; i++) {
 692              		.loc 1 217 0
 693 00d8 0026     		movs	r6, #0
 694              	.LBB8:
 218:src/command_parser.c ****         int v;
 219:src/command_parser.c ****         //pos++;
 220:src/command_parser.c ****         switch (/**(pos-1)*/*pos) {
 221:src/command_parser.c ****             case 'l': //length in days
 222:src/command_parser.c ****                pos++;
 223:src/command_parser.c ****                v = str_to_int(pos, '\003'); 
 224:src/command_parser.c ****                stages[stage_id].length = v;
 225:src/command_parser.c ****                break;
 226:src/command_parser.c **** 
 227:src/command_parser.c ****             case 'p': //regime_ph_id 
 228:src/command_parser.c ****                pos++;
 229:src/command_parser.c ****                v = str_to_int(pos, '\003'); 
 230:src/command_parser.c ****   //             printf("p=%d\n", v);
 231:src/command_parser.c ****                stages[stage_id].regime_ph_id = v;
 232:src/command_parser.c ****                break;
 233:src/command_parser.c **** 
 234:src/command_parser.c ****             case 'i': //regime_lighting_id 
 235:src/command_parser.c ****                pos++;
 236:src/command_parser.c ****                v = str_to_int(pos, '\003'); 
 237:src/command_parser.c **** //               printf("g=%d\n", v);
 238:src/command_parser.c ****                stages[stage_id].regime_lighting_id = v;
 239:src/command_parser.c ****                break;
 240:src/command_parser.c **** 
 241:src/command_parser.c ****             case 'o': //order 
 242:src/command_parser.c ****                pos++;
 243:src/command_parser.c ****                v = str_to_int(pos, '\003'); 
 695              		.loc 1 243 0
 696 00da 4FF0030A 		mov	r10, #3
 244:src/command_parser.c **** //               printf("g=%d\n", v);
 245:src/command_parser.c ****                stages[stage_id].order = v;
 697              		.loc 1 245 0
 698 00de 40F20003 		movw	r3, #:lower16:stages
 699 00e2 C0F20003 		movt	r3, #:upper16:stages
 700 00e6 03EBC209 		add	r9, r3, r2, lsl #3
 246:src/command_parser.c ****                break;
 247:src/command_parser.c ****             
 248:src/command_parser.c **** 
 249:src/command_parser.c ****             default:
 250:src/command_parser.c ****                USART_rtos_sputs(&packet, msg, 102, stage_id+1); // error 102: incorrect variable
 251:src/command_parser.c ****                if (NEW_ITEM) {
 252:src/command_parser.c ****                    stages[stage_id].using = 0;
 253:src/command_parser.c ****                    stages[stage_id].order = 0;
 254:src/command_parser.c ****                    stages[stage_id].regime_lighting_id = 0;
 255:src/command_parser.c ****                    stages[stage_id].regime_ph_id = 0;
 256:src/command_parser.c ****                    stages[stage_id].length = 0;
 257:src/command_parser.c **** 
 258:src/command_parser.c ****                }
 259:src/command_parser.c ****                USART_rtos_wait_send(&packet);
 260:src/command_parser.c ****                return;
 261:src/command_parser.c ****         }
 262:src/command_parser.c ****         idx = find_next_char(pos, 0, term);
 701              		.loc 1 262 0
 702 00ea B046     		mov	r8, r6
 703              	.LBE8:
 217:src/command_parser.c ****         int v;
 704              		.loc 1 217 0
 705 00ec 4EE0     		b	.L50
 706              	.LVL94:
 707              	.L60:
 708              	.LBB9:
 220:src/command_parser.c ****             case 'l': //length in days
 709              		.loc 1 220 0
 710 00ee 2B78     		ldrb	r3, [r5]	@ zero_extendqisi2
 711 00f0 693B     		subs	r3, r3, #105
 712 00f2 072B     		cmp	r3, #7
 713 00f4 25D8     		bhi	.L51
 714 00f6 DFE803F0 		tbb	[pc, r3]
 715              	.L53:
 716 00fa 14       		.byte	(.L52-.L53)/2
 717 00fb 24       		.byte	(.L51-.L53)/2
 718 00fc 24       		.byte	(.L51-.L53)/2
 719 00fd 04       		.byte	(.L54-.L53)/2
 720 00fe 24       		.byte	(.L51-.L53)/2
 721 00ff 24       		.byte	(.L51-.L53)/2
 722 0100 1C       		.byte	(.L55-.L53)/2
 723 0101 0C       		.byte	(.L56-.L53)/2
 724              		.align	1
 725              	.L54:
 222:src/command_parser.c ****                v = str_to_int(pos, '\003'); 
 726              		.loc 1 222 0
 727 0102 0135     		adds	r5, r5, #1
 728              	.LVL95:
 223:src/command_parser.c ****                stages[stage_id].length = v;
 729              		.loc 1 223 0
 730 0104 2846     		mov	r0, r5
 731              	.LVL96:
 732 0106 5146     		mov	r1, r10
 733 0108 FFF7FEFF 		bl	str_to_int
 734              	.LVL97:
 224:src/command_parser.c ****                break;
 735              		.loc 1 224 0
 736 010c C9F80400 		str	r0, [r9, #4]
 225:src/command_parser.c **** 
 737              		.loc 1 225 0
 738 0110 31E0     		b	.L57
 739              	.LVL98:
 740              	.L56:
 228:src/command_parser.c ****                v = str_to_int(pos, '\003'); 
 741              		.loc 1 228 0
 742 0112 0135     		adds	r5, r5, #1
 743              	.LVL99:
 229:src/command_parser.c ****   //             printf("p=%d\n", v);
 744              		.loc 1 229 0
 745 0114 2846     		mov	r0, r5
 746              	.LVL100:
 747 0116 5146     		mov	r1, r10
 748 0118 FFF7FEFF 		bl	str_to_int
 749              	.LVL101:
 231:src/command_parser.c ****                break;
 750              		.loc 1 231 0
 751 011c C9F80C00 		str	r0, [r9, #12]
 232:src/command_parser.c **** 
 752              		.loc 1 232 0
 753 0120 29E0     		b	.L57
 754              	.LVL102:
 755              	.L52:
 235:src/command_parser.c ****                v = str_to_int(pos, '\003'); 
 756              		.loc 1 235 0
 757 0122 0135     		adds	r5, r5, #1
 758              	.LVL103:
 236:src/command_parser.c **** //               printf("g=%d\n", v);
 759              		.loc 1 236 0
 760 0124 2846     		mov	r0, r5
 761              	.LVL104:
 762 0126 5146     		mov	r1, r10
 763 0128 FFF7FEFF 		bl	str_to_int
 764              	.LVL105:
 238:src/command_parser.c ****                break;
 765              		.loc 1 238 0
 766 012c C9F81000 		str	r0, [r9, #16]
 239:src/command_parser.c **** 
 767              		.loc 1 239 0
 768 0130 21E0     		b	.L57
 769              	.LVL106:
 770              	.L55:
 242:src/command_parser.c ****                v = str_to_int(pos, '\003'); 
 771              		.loc 1 242 0
 772 0132 0135     		adds	r5, r5, #1
 773              	.LVL107:
 243:src/command_parser.c **** //               printf("g=%d\n", v);
 774              		.loc 1 243 0
 775 0134 2846     		mov	r0, r5
 776              	.LVL108:
 777 0136 5146     		mov	r1, r10
 778 0138 FFF7FEFF 		bl	str_to_int
 779              	.LVL109:
 245:src/command_parser.c ****                break;
 780              		.loc 1 245 0
 781 013c C9F80800 		str	r0, [r9, #8]
 246:src/command_parser.c ****             
 782              		.loc 1 246 0
 783 0140 19E0     		b	.L57
 784              	.LVL110:
 785              	.L51:
 250:src/command_parser.c ****                if (NEW_ITEM) {
 786              		.loc 1 250 0
 787 0142 28A8     		add	r0, sp, #160
 788              	.LVL111:
 789 0144 02A9     		add	r1, sp, #8
 790 0146 6622     		movs	r2, #102
 791 0148 5B46     		mov	r3, fp
 792 014a FFF7FEFF 		bl	USART_rtos_sputs
 793              	.LVL112:
 251:src/command_parser.c ****                    stages[stage_id].using = 0;
 794              		.loc 1 251 0
 795 014e 019B     		ldr	r3, [sp, #4]
 796 0150 6BB1     		cbz	r3, .L58
 252:src/command_parser.c ****                    stages[stage_id].order = 0;
 797              		.loc 1 252 0
 798 0152 40F20002 		movw	r2, #:lower16:stages
 799 0156 C0F20002 		movt	r2, #:upper16:stages
 800 015a 6000     		lsls	r0, r4, #1
 801 015c 0119     		adds	r1, r0, r4
 802 015e 02EBC101 		add	r1, r2, r1, lsl #3
 803 0162 0023     		movs	r3, #0
 804 0164 4B61     		str	r3, [r1, #20]
 253:src/command_parser.c ****                    stages[stage_id].regime_lighting_id = 0;
 805              		.loc 1 253 0
 806 0166 8B60     		str	r3, [r1, #8]
 254:src/command_parser.c ****                    stages[stage_id].regime_ph_id = 0;
 807              		.loc 1 254 0
 808 0168 0B61     		str	r3, [r1, #16]
 255:src/command_parser.c ****                    stages[stage_id].length = 0;
 809              		.loc 1 255 0
 810 016a CB60     		str	r3, [r1, #12]
 256:src/command_parser.c **** 
 811              		.loc 1 256 0
 812 016c 4B60     		str	r3, [r1, #4]
 813              	.L58:
 259:src/command_parser.c ****                return;
 814              		.loc 1 259 0
 815 016e 28A8     		add	r0, sp, #160
 816 0170 FFF7FEFF 		bl	USART_rtos_wait_send
 817              	.LVL113:
 260:src/command_parser.c ****         }
 818              		.loc 1 260 0
 819 0174 1CE0     		b	.L42
 820              	.LVL114:
 821              	.L57:
 822              		.loc 1 262 0
 823 0176 2846     		mov	r0, r5
 824              	.LVL115:
 825 0178 4146     		mov	r1, r8
 826 017a 3A46     		mov	r2, r7
 827 017c FFF7FEFF 		bl	find_next_char
 828              	.LVL116:
 263:src/command_parser.c ****         if (idx == -1) break;
 829              		.loc 1 263 0
 830 0180 B0F1FF3F 		cmp	r0, #-1
 831 0184 0BD0     		beq	.L59
 264:src/command_parser.c ****         pos+=idx+1;
 832              		.loc 1 264 0
 833 0186 431C     		adds	r3, r0, #1
 834 0188 1D44     		add	r5, r5, r3
 835              	.LVL117:
 836              	.LBE9:
 217:src/command_parser.c ****         int v;
 837              		.loc 1 217 0
 838 018a 0136     		adds	r6, r6, #1
 839              	.LVL118:
 840              	.L50:
 217:src/command_parser.c ****         int v;
 841              		.loc 1 217 0 is_stmt 0 discriminator 1
 842 018c 042E     		cmp	r6, #4
 843 018e CCBF     		ite	gt
 844 0190 0023     		movgt	r3, #0
 845 0192 0123     		movle	r3, #1
 846 0194 0028     		cmp	r0, #0
 847 0196 08BF     		it	eq
 848 0198 0023     		moveq	r3, #0
 849 019a 002B     		cmp	r3, #0
 850 019c A7D1     		bne	.L60
 851              	.L59:
 265:src/command_parser.c ****     }
 266:src/command_parser.c ****     USART_rtos_sputs(&packet, msg, 0, stage_id+1);
 852              		.loc 1 266 0 is_stmt 1
 853 019e 28A8     		add	r0, sp, #160
 854              	.LVL119:
 855 01a0 02A9     		add	r1, sp, #8
 856 01a2 0022     		movs	r2, #0
 857 01a4 5B46     		mov	r3, fp
 858 01a6 FFF7FEFF 		bl	USART_rtos_sputs
 859              	.LVL120:
 267:src/command_parser.c ****     USART_rtos_wait_send(&packet);
 860              		.loc 1 267 0
 861 01aa 28A8     		add	r0, sp, #160
 862 01ac FFF7FEFF 		bl	USART_rtos_wait_send
 863              	.LVL121:
 864              	.L42:
 268:src/command_parser.c **** }
 865              		.loc 1 268 0
 866 01b0 2DB0     		add	sp, sp, #180
 867              		@ sp needed
 868 01b2 BDE8F08F 		pop	{r4, r5, r6, r7, r8, r9, r10, fp, pc}
 869              		.cfi_endproc
 870              	.LFE116:
 872 01b6 00BF     		.section	.text.command_set,"ax",%progbits
 873              		.align	2
 874              		.global	command_set
 875              		.thumb
 876              		.thumb_func
 878              	command_set:
 879              	.LFB117:
 269:src/command_parser.c **** 
 270:src/command_parser.c **** void command_set(char *pos, char term) {
 880              		.loc 1 270 0
 881              		.cfi_startproc
 882              		@ args = 0, pretend = 0, frame = 16
 883              		@ frame_needed = 0, uses_anonymous_args = 0
 884              	.LVL122:
 885 0000 30B5     		push	{r4, r5, lr}
 886              	.LCFI6:
 887              		.cfi_def_cfa_offset 12
 888              		.cfi_offset 4, -12
 889              		.cfi_offset 5, -8
 890              		.cfi_offset 14, -4
 891 0002 85B0     		sub	sp, sp, #20
 892              	.LCFI7:
 893              		.cfi_def_cfa_offset 32
 894 0004 0C46     		mov	r4, r1
 271:src/command_parser.c ****     USART_rtos_packet packet;
 272:src/command_parser.c ****     packet.USARTx_rtos = USARTOutput_rtos;
 895              		.loc 1 272 0
 896 0006 40F20003 		movw	r3, #:lower16:USARTOutput_rtos
 897 000a C0F20003 		movt	r3, #:upper16:USARTOutput_rtos
 898 000e 1B68     		ldr	r3, [r3]
 899 0010 0093     		str	r3, [sp]
 273:src/command_parser.c ****     pos+=4;
 900              		.loc 1 273 0
 901 0012 051D     		adds	r5, r0, #4
 902              	.LVL123:
 274:src/command_parser.c **** 
 275:src/command_parser.c ****     if (str_compare(pos, "REGIME_PH\003", term)) {
 903              		.loc 1 275 0
 904 0014 2846     		mov	r0, r5
 905 0016 40F20001 		movw	r1, #:lower16:.LC2
 906              	.LVL124:
 907 001a C0F20001 		movt	r1, #:upper16:.LC2
 908 001e 2246     		mov	r2, r4
 909 0020 FFF7FEFF 		bl	str_compare
 910              	.LVL125:
 911 0024 20B1     		cbz	r0, .L64
 276:src/command_parser.c ****         command_set_regime_ph(pos, term);
 912              		.loc 1 276 0
 913 0026 2846     		mov	r0, r5
 914 0028 2146     		mov	r1, r4
 915 002a FFF7FEFF 		bl	command_set_regime_ph
 916              	.LVL126:
 917 002e 20E0     		b	.L63
 918              	.L64:
 277:src/command_parser.c ****     }
 278:src/command_parser.c **** 
 279:src/command_parser.c ****     else if (str_compare(pos, "STAGE\003", term)) {
 919              		.loc 1 279 0
 920 0030 2846     		mov	r0, r5
 921 0032 40F20001 		movw	r1, #:lower16:.LC3
 922 0036 C0F20001 		movt	r1, #:upper16:.LC3
 923 003a 2246     		mov	r2, r4
 924 003c FFF7FEFF 		bl	str_compare
 925              	.LVL127:
 926 0040 20B1     		cbz	r0, .L66
 280:src/command_parser.c ****         command_set_stage(pos, term);
 927              		.loc 1 280 0
 928 0042 2846     		mov	r0, r5
 929 0044 2146     		mov	r1, r4
 930 0046 FFF7FEFF 		bl	command_set_stage
 931              	.LVL128:
 932 004a 12E0     		b	.L63
 933              	.L66:
 281:src/command_parser.c ****     }
 282:src/command_parser.c **** 
 283:src/command_parser.c ****     else if (str_compare(pos, "REGIME_LIGHTING\003", term)) {
 934              		.loc 1 283 0
 935 004c 2846     		mov	r0, r5
 936 004e 40F20001 		movw	r1, #:lower16:.LC4
 937 0052 C0F20001 		movt	r1, #:upper16:.LC4
 938 0056 2246     		mov	r2, r4
 939 0058 FFF7FEFF 		bl	str_compare
 940              	.LVL129:
 941 005c 48B9     		cbnz	r0, .L63
 284:src/command_parser.c ****     }
 285:src/command_parser.c **** 
 286:src/command_parser.c ****     else {
 287:src/command_parser.c ****         USART_rtos_puts(&packet, "{'object_type': '', method: 'set', error: 10, 'object_id': -1}\r\
 942              		.loc 1 287 0
 943 005e 6846     		mov	r0, sp
 944 0060 40F20001 		movw	r1, #:lower16:.LC5
 945 0064 C0F20001 		movt	r1, #:upper16:.LC5
 946 0068 FFF7FEFF 		bl	USART_rtos_puts
 947              	.LVL130:
 288:src/command_parser.c ****         USART_rtos_wait_send(&packet);
 948              		.loc 1 288 0
 949 006c 6846     		mov	r0, sp
 950 006e FFF7FEFF 		bl	USART_rtos_wait_send
 951              	.LVL131:
 952              	.L63:
 289:src/command_parser.c ****         return;
 290:src/command_parser.c ****     }
 291:src/command_parser.c **** 
 292:src/command_parser.c **** }
 953              		.loc 1 292 0
 954 0072 05B0     		add	sp, sp, #20
 955              		@ sp needed
 956 0074 30BD     		pop	{r4, r5, pc}
 957              		.cfi_endproc
 958              	.LFE117:
 960 0076 00BF     		.section	.text.command_del_regime_ph,"ax",%progbits
 961              		.align	2
 962              		.global	command_del_regime_ph
 963              		.thumb
 964              		.thumb_func
 966              	command_del_regime_ph:
 967              	.LFB118:
 293:src/command_parser.c **** 
 294:src/command_parser.c **** void command_del_regime_ph (char *pos, char term) {
 968              		.loc 1 294 0
 969              		.cfi_startproc
 970              		@ args = 0, pretend = 0, frame = 16
 971              		@ frame_needed = 0, uses_anonymous_args = 0
 972              	.LVL132:
 973 0000 10B5     		push	{r4, lr}
 974              	.LCFI8:
 975              		.cfi_def_cfa_offset 8
 976              		.cfi_offset 4, -8
 977              		.cfi_offset 14, -4
 978 0002 84B0     		sub	sp, sp, #16
 979              	.LCFI9:
 980              		.cfi_def_cfa_offset 24
 981 0004 0446     		mov	r4, r0
 982 0006 0A46     		mov	r2, r1
 295:src/command_parser.c ****     USART_rtos_packet packet;
 296:src/command_parser.c ****     packet.USARTx_rtos = USARTOutput_rtos;
 983              		.loc 1 296 0
 984 0008 40F20003 		movw	r3, #:lower16:USARTOutput_rtos
 985 000c C0F20003 		movt	r3, #:upper16:USARTOutput_rtos
 986 0010 1B68     		ldr	r3, [r3]
 987 0012 0093     		str	r3, [sp]
 297:src/command_parser.c **** 
 298:src/command_parser.c ****     int idx = find_next_char(pos, 0, term);
 988              		.loc 1 298 0
 989 0014 0021     		movs	r1, #0
 990              	.LVL133:
 991 0016 FFF7FEFF 		bl	find_next_char
 992              	.LVL134:
 299:src/command_parser.c ****     pos+=idx+1;
 993              		.loc 1 299 0
 994 001a 0130     		adds	r0, r0, #1
 995              	.LVL135:
 300:src/command_parser.c ****     int regime_id = str_to_int(pos, '\003')-1;
 996              		.loc 1 300 0
 997 001c 2044     		add	r0, r0, r4
 998              	.LVL136:
 999 001e 0321     		movs	r1, #3
 1000 0020 FFF7FEFF 		bl	str_to_int
 1001              	.LVL137:
 1002 0024 441E     		subs	r4, r0, #1
 1003              	.LVL138:
 301:src/command_parser.c ****     if (!(regime_id>=0 && regime_id < MAX_REGIME_PH)) {
 1004              		.loc 1 301 0
 1005 0026 092C     		cmp	r4, #9
 1006 0028 07D9     		bls	.L69
 302:src/command_parser.c ****         USART_rtos_puts(&packet, "Error: Incorrect REGIME_PH id\r\n");
 1007              		.loc 1 302 0
 1008 002a 6846     		mov	r0, sp
 1009 002c 40F20001 		movw	r1, #:lower16:.LC6
 1010 0030 C0F20001 		movt	r1, #:upper16:.LC6
 1011 0034 FFF7FEFF 		bl	USART_rtos_puts
 1012              	.LVL139:
 1013 0038 12E0     		b	.L68
 1014              	.L69:
 303:src/command_parser.c ****         return;
 304:src/command_parser.c ****     }
 305:src/command_parser.c **** 
 306:src/command_parser.c ****     USART_rtos_sputs(&packet, "DEBUG: DELETING REGIME_ID %d\r\n", regime_id);
 1015              		.loc 1 306 0
 1016 003a 6846     		mov	r0, sp
 1017 003c 40F20001 		movw	r1, #:lower16:.LC7
 1018 0040 C0F20001 		movt	r1, #:upper16:.LC7
 1019 0044 2246     		mov	r2, r4
 1020 0046 FFF7FEFF 		bl	USART_rtos_sputs
 1021              	.LVL140:
 307:src/command_parser.c ****     REGIME_PH[regime_id][0] = -1;
 1022              		.loc 1 307 0
 1023 004a 40F20003 		movw	r3, #:lower16:.LANCHOR0
 1024 004e C0F20003 		movt	r3, #:upper16:.LANCHOR0
 1025 0052 4FF0FF32 		mov	r2, #-1
 1026 0056 43F83420 		str	r2, [r3, r4, lsl #3]
 308:src/command_parser.c ****     REGIME_PH[regime_id][1] = -1;
 1027              		.loc 1 308 0
 1028 005a 03EBC404 		add	r4, r3, r4, lsl #3
 1029              	.LVL141:
 1030 005e 6260     		str	r2, [r4, #4]
 1031              	.L68:
 309:src/command_parser.c **** }
 1032              		.loc 1 309 0
 1033 0060 04B0     		add	sp, sp, #16
 1034              		@ sp needed
 1035 0062 10BD     		pop	{r4, pc}
 1036              		.cfi_endproc
 1037              	.LFE118:
 1039              		.section	.text.command_del_stage,"ax",%progbits
 1040              		.align	2
 1041              		.global	command_del_stage
 1042              		.thumb
 1043              		.thumb_func
 1045              	command_del_stage:
 1046              	.LFB119:
 310:src/command_parser.c **** 
 311:src/command_parser.c **** void command_del_stage (char *pos, char term) {
 1047              		.loc 1 311 0
 1048              		.cfi_startproc
 1049              		@ args = 0, pretend = 0, frame = 16
 1050              		@ frame_needed = 0, uses_anonymous_args = 0
 1051              	.LVL142:
 1052 0000 30B5     		push	{r4, r5, lr}
 1053              	.LCFI10:
 1054              		.cfi_def_cfa_offset 12
 1055              		.cfi_offset 4, -12
 1056              		.cfi_offset 5, -8
 1057              		.cfi_offset 14, -4
 1058 0002 85B0     		sub	sp, sp, #20
 1059              	.LCFI11:
 1060              		.cfi_def_cfa_offset 32
 1061 0004 0446     		mov	r4, r0
 1062 0006 0A46     		mov	r2, r1
 312:src/command_parser.c ****     USART_rtos_packet packet;
 313:src/command_parser.c ****     packet.USARTx_rtos = USARTOutput_rtos;
 1063              		.loc 1 313 0
 1064 0008 40F20003 		movw	r3, #:lower16:USARTOutput_rtos
 1065 000c C0F20003 		movt	r3, #:upper16:USARTOutput_rtos
 1066 0010 1B68     		ldr	r3, [r3]
 1067 0012 0093     		str	r3, [sp]
 314:src/command_parser.c **** 
 315:src/command_parser.c ****     int idx = find_next_char(pos, 0, term);
 1068              		.loc 1 315 0
 1069 0014 0021     		movs	r1, #0
 1070              	.LVL143:
 1071 0016 FFF7FEFF 		bl	find_next_char
 1072              	.LVL144:
 316:src/command_parser.c ****     pos+=idx+1;
 1073              		.loc 1 316 0
 1074 001a 0130     		adds	r0, r0, #1
 1075              	.LVL145:
 317:src/command_parser.c **** 
 318:src/command_parser.c ****     int stage_id = str_to_int(pos, '\003')-1;
 1076              		.loc 1 318 0
 1077 001c 2044     		add	r0, r0, r4
 1078              	.LVL146:
 1079 001e 0321     		movs	r1, #3
 1080 0020 FFF7FEFF 		bl	str_to_int
 1081              	.LVL147:
 1082 0024 0246     		mov	r2, r0
 1083 0026 431E     		subs	r3, r0, #1
 1084              	.LVL148:
 319:src/command_parser.c **** 
 320:src/command_parser.c ****     if (!(stage_id >= 0 && stage_id <MAX_STAGES)) {
 1085              		.loc 1 320 0
 1086 0028 092B     		cmp	r3, #9
 1087 002a 07D9     		bls	.L72
 321:src/command_parser.c **** 
 322:src/command_parser.c ****         USART_rtos_puts(&packet, "Error: Incorrect stage id\r\n");
 1088              		.loc 1 322 0
 1089 002c 6846     		mov	r0, sp
 1090 002e 40F20001 		movw	r1, #:lower16:.LC8
 1091 0032 C0F20001 		movt	r1, #:upper16:.LC8
 1092 0036 FFF7FEFF 		bl	USART_rtos_puts
 1093              	.LVL149:
 1094 003a 14E0     		b	.L71
 1095              	.LVL150:
 1096              	.L72:
 323:src/command_parser.c ****         return;
 324:src/command_parser.c ****     }
 325:src/command_parser.c **** 
 326:src/command_parser.c ****     stages[stage_id].using = 0;
 1097              		.loc 1 326 0
 1098 003c 40F20004 		movw	r4, #:lower16:stages
 1099 0040 C0F20004 		movt	r4, #:upper16:stages
 1100 0044 5800     		lsls	r0, r3, #1
 1101 0046 C518     		adds	r5, r0, r3
 1102 0048 04EBC505 		add	r5, r4, r5, lsl #3
 1103 004c 0021     		movs	r1, #0
 1104 004e 6961     		str	r1, [r5, #20]
 327:src/command_parser.c ****     stages[stage_id].order = 0;
 1105              		.loc 1 327 0
 1106 0050 A960     		str	r1, [r5, #8]
 328:src/command_parser.c ****     stages[stage_id].regime_lighting_id = 0;
 1107              		.loc 1 328 0
 1108 0052 2961     		str	r1, [r5, #16]
 329:src/command_parser.c ****     stages[stage_id].regime_ph_id = 0;
 1109              		.loc 1 329 0
 1110 0054 E960     		str	r1, [r5, #12]
 330:src/command_parser.c ****     stages[stage_id].length = 0;
 1111              		.loc 1 330 0
 1112 0056 6960     		str	r1, [r5, #4]
 331:src/command_parser.c **** 
 332:src/command_parser.c ****     USART_rtos_sputs(&packet, "Succesfully deleted stage id: %d\r\n", stage_id+1);
 1113              		.loc 1 332 0
 1114 0058 6846     		mov	r0, sp
 1115 005a 40F20001 		movw	r1, #:lower16:.LC9
 1116 005e C0F20001 		movt	r1, #:upper16:.LC9
 1117 0062 FFF7FEFF 		bl	USART_rtos_sputs
 1118              	.LVL151:
 1119              	.L71:
 333:src/command_parser.c **** }
 1120              		.loc 1 333 0
 1121 0066 05B0     		add	sp, sp, #20
 1122              		@ sp needed
 1123 0068 30BD     		pop	{r4, r5, pc}
 1124              		.cfi_endproc
 1125              	.LFE119:
 1127 006a 00BF     		.section	.text.command_del,"ax",%progbits
 1128              		.align	2
 1129              		.global	command_del
 1130              		.thumb
 1131              		.thumb_func
 1133              	command_del:
 1134              	.LFB120:
 334:src/command_parser.c **** 
 335:src/command_parser.c **** void command_del(char *pos, char term) {
 1135              		.loc 1 335 0
 1136              		.cfi_startproc
 1137              		@ args = 0, pretend = 0, frame = 16
 1138              		@ frame_needed = 0, uses_anonymous_args = 0
 1139              	.LVL152:
 1140 0000 30B5     		push	{r4, r5, lr}
 1141              	.LCFI12:
 1142              		.cfi_def_cfa_offset 12
 1143              		.cfi_offset 4, -12
 1144              		.cfi_offset 5, -8
 1145              		.cfi_offset 14, -4
 1146 0002 85B0     		sub	sp, sp, #20
 1147              	.LCFI13:
 1148              		.cfi_def_cfa_offset 32
 1149 0004 0D46     		mov	r5, r1
 336:src/command_parser.c ****     USART_rtos_packet packet;
 337:src/command_parser.c ****     packet.USARTx_rtos = USARTOutput_rtos;
 1150              		.loc 1 337 0
 1151 0006 40F20003 		movw	r3, #:lower16:USARTOutput_rtos
 1152 000a C0F20003 		movt	r3, #:upper16:USARTOutput_rtos
 1153 000e 1B68     		ldr	r3, [r3]
 1154 0010 0093     		str	r3, [sp]
 338:src/command_parser.c ****     pos+=4;
 1155              		.loc 1 338 0
 1156 0012 041D     		adds	r4, r0, #4
 1157              	.LVL153:
 339:src/command_parser.c ****     if (str_compare(pos, "REGIME_PH\003", term)) {
 1158              		.loc 1 339 0
 1159 0014 2046     		mov	r0, r4
 1160 0016 40F20001 		movw	r1, #:lower16:.LC2
 1161              	.LVL154:
 1162 001a C0F20001 		movt	r1, #:upper16:.LC2
 1163 001e 2A46     		mov	r2, r5
 1164 0020 FFF7FEFF 		bl	str_compare
 1165              	.LVL155:
 1166 0024 20B1     		cbz	r0, .L75
 340:src/command_parser.c ****         command_del_regime_ph(pos, term);
 1167              		.loc 1 340 0
 1168 0026 2046     		mov	r0, r4
 1169 0028 2946     		mov	r1, r5
 1170 002a FFF7FEFF 		bl	command_del_regime_ph
 1171              	.LVL156:
 1172 002e 21E0     		b	.L74
 1173              	.L75:
 341:src/command_parser.c ****     }
 342:src/command_parser.c **** 
 343:src/command_parser.c ****     else if (str_compare(pos, "STAGE\003", term)) {
 1174              		.loc 1 343 0
 1175 0030 2046     		mov	r0, r4
 1176 0032 40F20001 		movw	r1, #:lower16:.LC3
 1177 0036 C0F20001 		movt	r1, #:upper16:.LC3
 1178 003a 2A46     		mov	r2, r5
 1179 003c FFF7FEFF 		bl	str_compare
 1180              	.LVL157:
 1181 0040 20B1     		cbz	r0, .L77
 344:src/command_parser.c ****         command_del_stage(pos, term);
 1182              		.loc 1 344 0
 1183 0042 2046     		mov	r0, r4
 1184 0044 2946     		mov	r1, r5
 1185 0046 FFF7FEFF 		bl	command_del_stage
 1186              	.LVL158:
 1187 004a 13E0     		b	.L74
 1188              	.L77:
 345:src/command_parser.c ****     }
 346:src/command_parser.c **** 
 347:src/command_parser.c ****     else if (str_compare(pos, "REGIME_LIGHTING\003", term)) {
 1189              		.loc 1 347 0
 1190 004c 2046     		mov	r0, r4
 1191 004e 40F20001 		movw	r1, #:lower16:.LC4
 1192 0052 C0F20001 		movt	r1, #:upper16:.LC4
 1193 0056 2A46     		mov	r2, r5
 1194 0058 FFF7FEFF 		bl	str_compare
 1195              	.LVL159:
 1196 005c 50B9     		cbnz	r0, .L74
 348:src/command_parser.c **** //        printf("OK LIGHTING SHIT\n");
 349:src/command_parser.c ****     }
 350:src/command_parser.c **** 
 351:src/command_parser.c ****     else {
 352:src/command_parser.c ****         USART_rtos_sputs(&packet, "Error: Unknown Object '%s'\r\n", pos);
 1197              		.loc 1 352 0
 1198 005e 6846     		mov	r0, sp
 1199 0060 40F20001 		movw	r1, #:lower16:.LC10
 1200 0064 C0F20001 		movt	r1, #:upper16:.LC10
 1201 0068 2246     		mov	r2, r4
 1202 006a FFF7FEFF 		bl	USART_rtos_sputs
 1203              	.LVL160:
 353:src/command_parser.c ****         USART_rtos_wait_send(&packet);
 1204              		.loc 1 353 0
 1205 006e 6846     		mov	r0, sp
 1206 0070 FFF7FEFF 		bl	USART_rtos_wait_send
 1207              	.LVL161:
 1208              	.L74:
 354:src/command_parser.c ****     }
 355:src/command_parser.c **** }
 1209              		.loc 1 355 0
 1210 0074 05B0     		add	sp, sp, #20
 1211              		@ sp needed
 1212 0076 30BD     		pop	{r4, r5, pc}
 1213              		.cfi_endproc
 1214              	.LFE120:
 1216              		.section	.text.stage_print,"ax",%progbits
 1217              		.align	2
 1218              		.global	stage_print
 1219              		.thumb
 1220              		.thumb_func
 1222              	stage_print:
 1223              	.LFB121:
 356:src/command_parser.c **** 
 357:src/command_parser.c **** void stage_print(Stage *stage) {
 1224              		.loc 1 357 0
 1225              		.cfi_startproc
 1226              		@ args = 0, pretend = 0, frame = 120
 1227              		@ frame_needed = 0, uses_anonymous_args = 0
 1228              	.LVL162:
 1229 0000 00B5     		push	{lr}
 1230              	.LCFI14:
 1231              		.cfi_def_cfa_offset 4
 1232              		.cfi_offset 14, -4
 1233 0002 A3B0     		sub	sp, sp, #140
 1234              	.LCFI15:
 1235              		.cfi_def_cfa_offset 144
 358:src/command_parser.c ****     USART_rtos_packet packet;
 359:src/command_parser.c ****     packet.USARTx_rtos = USARTOutput_rtos;
 1236              		.loc 1 359 0
 1237 0004 40F20003 		movw	r3, #:lower16:USARTOutput_rtos
 1238 0008 C0F20003 		movt	r3, #:upper16:USARTOutput_rtos
 1239 000c 1B68     		ldr	r3, [r3]
 1240 000e 1E93     		str	r3, [sp, #120]
 360:src/command_parser.c ****     char buffer[100];
 361:src/command_parser.c ****     packet.msg = buffer;
 1241              		.loc 1 361 0
 1242 0010 05AB     		add	r3, sp, #20
 1243 0012 1F93     		str	r3, [sp, #124]
 362:src/command_parser.c **** 
 363:src/command_parser.c ****     USART_rtos_sputs(
 1244              		.loc 1 363 0
 1245 0014 0268     		ldr	r2, [r0]
 1246 0016 4368     		ldr	r3, [r0, #4]
 1247 0018 8168     		ldr	r1, [r0, #8]
 1248 001a 0091     		str	r1, [sp]
 1249 001c C168     		ldr	r1, [r0, #12]
 1250 001e 0191     		str	r1, [sp, #4]
 1251 0020 0169     		ldr	r1, [r0, #16]
 1252 0022 0291     		str	r1, [sp, #8]
 1253 0024 4169     		ldr	r1, [r0, #20]
 1254 0026 0391     		str	r1, [sp, #12]
 1255 0028 1EA8     		add	r0, sp, #120
 1256              	.LVL163:
 1257 002a 40F20001 		movw	r1, #:lower16:.LC11
 1258 002e C0F20001 		movt	r1, #:upper16:.LC11
 1259 0032 FFF7FEFF 		bl	USART_rtos_sputs
 1260              	.LVL164:
 364:src/command_parser.c ****             &packet,
 365:src/command_parser.c ****             "{'id': %d, 'length': %d, 'order':%d, 'ph_id': %d, 'lighting_id':%d, 'using':%d}\r\n", 
 366:src/command_parser.c ****             stage->id,
 367:src/command_parser.c ****             stage->length,
 368:src/command_parser.c ****             stage->order,
 369:src/command_parser.c ****             stage->regime_ph_id,
 370:src/command_parser.c ****             stage->regime_lighting_id,
 371:src/command_parser.c ****             stage->using
 372:src/command_parser.c ****     );
 373:src/command_parser.c ****     USART_rtos_wait_send(&packet);
 1261              		.loc 1 373 0
 1262 0036 1EA8     		add	r0, sp, #120
 1263 0038 FFF7FEFF 		bl	USART_rtos_wait_send
 1264              	.LVL165:
 374:src/command_parser.c **** 
 375:src/command_parser.c **** }
 1265              		.loc 1 375 0
 1266 003c 23B0     		add	sp, sp, #140
 1267              		@ sp needed
 1268 003e 5DF804FB 		ldr	pc, [sp], #4
 1269              		.cfi_endproc
 1270              	.LFE121:
 1272 0042 00BF     		.section	.text.regime_ph_print,"ax",%progbits
 1273              		.align	2
 1274              		.global	regime_ph_print
 1275              		.thumb
 1276              		.thumb_func
 1278              	regime_ph_print:
 1279              	.LFB122:
 376:src/command_parser.c **** 
 377:src/command_parser.c **** void regime_ph_print(int *regime_ph, int regime_id) {
 1280              		.loc 1 377 0
 1281              		.cfi_startproc
 1282              		@ args = 0, pretend = 0, frame = 72
 1283              		@ frame_needed = 0, uses_anonymous_args = 0
 1284              	.LVL166:
 1285 0000 00B5     		push	{lr}
 1286              	.LCFI16:
 1287              		.cfi_def_cfa_offset 4
 1288              		.cfi_offset 14, -4
 1289 0002 95B0     		sub	sp, sp, #84
 1290              	.LCFI17:
 1291              		.cfi_def_cfa_offset 88
 378:src/command_parser.c ****     USART_rtos_packet packet;
 379:src/command_parser.c ****     packet.USARTx_rtos = USARTOutput_rtos;
 1292              		.loc 1 379 0
 1293 0004 40F20003 		movw	r3, #:lower16:USARTOutput_rtos
 1294 0008 C0F20003 		movt	r3, #:upper16:USARTOutput_rtos
 1295 000c 1B68     		ldr	r3, [r3]
 1296 000e 1093     		str	r3, [sp, #64]
 380:src/command_parser.c ****     char buffer[50];
 381:src/command_parser.c ****     packet.msg = buffer;
 1297              		.loc 1 381 0
 1298 0010 03AB     		add	r3, sp, #12
 1299 0012 1193     		str	r3, [sp, #68]
 382:src/command_parser.c **** 
 383:src/command_parser.c ****     USART_rtos_sputs(&packet, "{'id': %d, 'ph': %d, 'delay': %d}\r\n", regime_id+1, regime_ph[0], r
 1300              		.loc 1 383 0
 1301 0014 4A1C     		adds	r2, r1, #1
 1302 0016 0368     		ldr	r3, [r0]
 1303 0018 4068     		ldr	r0, [r0, #4]
 1304              	.LVL167:
 1305 001a 0090     		str	r0, [sp]
 1306 001c 10A8     		add	r0, sp, #64
 1307 001e 40F20001 		movw	r1, #:lower16:.LC12
 1308              	.LVL168:
 1309 0022 C0F20001 		movt	r1, #:upper16:.LC12
 1310 0026 FFF7FEFF 		bl	USART_rtos_sputs
 1311              	.LVL169:
 384:src/command_parser.c ****     USART_rtos_wait_send(&packet);
 1312              		.loc 1 384 0
 1313 002a 10A8     		add	r0, sp, #64
 1314 002c FFF7FEFF 		bl	USART_rtos_wait_send
 1315              	.LVL170:
 385:src/command_parser.c **** 
 386:src/command_parser.c **** }
 1316              		.loc 1 386 0
 1317 0030 15B0     		add	sp, sp, #84
 1318              		@ sp needed
 1319 0032 5DF804FB 		ldr	pc, [sp], #4
 1320              		.cfi_endproc
 1321              	.LFE122:
 1323 0036 00BF     		.section	.text.command_get,"ax",%progbits
 1324              		.align	2
 1325              		.global	command_get
 1326              		.thumb
 1327              		.thumb_func
 1329              	command_get:
 1330              	.LFB123:
 387:src/command_parser.c **** 
 388:src/command_parser.c **** void command_get(char *pos, char term) {
 1331              		.loc 1 388 0
 1332              		.cfi_startproc
 1333              		@ args = 0, pretend = 0, frame = 16
 1334              		@ frame_needed = 0, uses_anonymous_args = 0
 1335              	.LVL171:
 1336 0000 F0B5     		push	{r4, r5, r6, r7, lr}
 1337              	.LCFI18:
 1338              		.cfi_def_cfa_offset 20
 1339              		.cfi_offset 4, -20
 1340              		.cfi_offset 5, -16
 1341              		.cfi_offset 6, -12
 1342              		.cfi_offset 7, -8
 1343              		.cfi_offset 14, -4
 1344 0002 85B0     		sub	sp, sp, #20
 1345              	.LCFI19:
 1346              		.cfi_def_cfa_offset 40
 1347 0004 0E46     		mov	r6, r1
 389:src/command_parser.c **** 
 390:src/command_parser.c ****     USART_rtos_packet packet;
 391:src/command_parser.c ****     packet.USARTx_rtos = USARTOutput_rtos;
 1348              		.loc 1 391 0
 1349 0006 40F20003 		movw	r3, #:lower16:USARTOutput_rtos
 1350 000a C0F20003 		movt	r3, #:upper16:USARTOutput_rtos
 1351 000e 1B68     		ldr	r3, [r3]
 1352 0010 0093     		str	r3, [sp]
 392:src/command_parser.c **** 
 393:src/command_parser.c ****     pos+=4;
 1353              		.loc 1 393 0
 1354 0012 051D     		adds	r5, r0, #4
 1355              	.LVL172:
 394:src/command_parser.c **** 
 395:src/command_parser.c ****     if (str_compare(pos, "REGIME_PH\003", term)) {
 1356              		.loc 1 395 0
 1357 0014 2846     		mov	r0, r5
 1358 0016 40F20001 		movw	r1, #:lower16:.LC2
 1359              	.LVL173:
 1360 001a C0F20001 		movt	r1, #:upper16:.LC2
 1361 001e 3246     		mov	r2, r6
 1362 0020 FFF7FEFF 		bl	str_compare
 1363              	.LVL174:
 1364 0024 A0B3     		cbz	r0, .L81
 1365              	.LBB10:
 396:src/command_parser.c **** 
 397:src/command_parser.c ****         int idx = find_next_char(pos, 0, term);
 1366              		.loc 1 397 0
 1367 0026 2846     		mov	r0, r5
 1368 0028 0021     		movs	r1, #0
 1369 002a 3246     		mov	r2, r6
 1370 002c FFF7FEFF 		bl	find_next_char
 1371              	.LVL175:
 398:src/command_parser.c ****         pos+=idx+1;
 1372              		.loc 1 398 0
 1373 0030 0130     		adds	r0, r0, #1
 1374              	.LVL176:
 1375 0032 0544     		add	r5, r5, r0
 1376              	.LVL177:
 399:src/command_parser.c ****         int regime_id = str_to_int(pos, '\003')-1;
 1377              		.loc 1 399 0
 1378 0034 2846     		mov	r0, r5
 1379              	.LVL178:
 1380 0036 0321     		movs	r1, #3
 1381 0038 FFF7FEFF 		bl	str_to_int
 1382              	.LVL179:
 1383 003c 411E     		subs	r1, r0, #1
 1384              	.LVL180:
 400:src/command_parser.c **** 
 401:src/command_parser.c ****         if (regime_id >= 0 && regime_id <MAX_REGIME_PH) {
 1385              		.loc 1 401 0
 1386 003e 0929     		cmp	r1, #9
 1387 0040 08D8     		bhi	.L82
 402:src/command_parser.c ****             regime_ph_print(REGIME_PH[regime_id], regime_id);
 1388              		.loc 1 402 0
 1389 0042 40F20000 		movw	r0, #:lower16:.LANCHOR0
 1390 0046 C0F20000 		movt	r0, #:upper16:.LANCHOR0
 1391 004a 00EBC100 		add	r0, r0, r1, lsl #3
 1392 004e FFF7FEFF 		bl	regime_ph_print
 1393              	.LVL181:
 1394 0052 1DE0     		b	.L81
 1395              	.LVL182:
 1396              	.L82:
 403:src/command_parser.c **** 
 404:src/command_parser.c ****         }
 405:src/command_parser.c ****         else if(regime_id == -1) {
 1397              		.loc 1 405 0
 1398 0054 B1F1FF3F 		cmp	r1, #-1
 1399 0058 0FD1     		bne	.L95
 1400 005a 06E0     		b	.L93
 1401              	.LVL183:
 1402              	.L85:
 1403              	.LBB11:
 406:src/command_parser.c ****             int i;
 407:src/command_parser.c ****             for(i=0; i<MAX_REGIME_PH; i++) {
 408:src/command_parser.c ****                 regime_ph_print(REGIME_PH[i], i);
 1404              		.loc 1 408 0 discriminator 2
 1405 005c 07EBC400 		add	r0, r7, r4, lsl #3
 1406 0060 2146     		mov	r1, r4
 1407 0062 FFF7FEFF 		bl	regime_ph_print
 1408              	.LVL184:
 407:src/command_parser.c ****                 regime_ph_print(REGIME_PH[i], i);
 1409              		.loc 1 407 0 discriminator 2
 1410 0066 0134     		adds	r4, r4, #1
 1411              	.LVL185:
 1412 0068 04E0     		b	.L83
 1413              	.LVL186:
 1414              	.L93:
 1415              	.LBE11:
 1416 006a 0024     		movs	r4, #0
 1417              	.LBB12:
 1418              		.loc 1 408 0
 1419 006c 40F20007 		movw	r7, #:lower16:.LANCHOR0
 1420 0070 C0F20007 		movt	r7, #:upper16:.LANCHOR0
 1421              	.LVL187:
 1422              	.L83:
 407:src/command_parser.c ****                 regime_ph_print(REGIME_PH[i], i);
 1423              		.loc 1 407 0 discriminator 1
 1424 0074 092C     		cmp	r4, #9
 1425 0076 F1DD     		ble	.L85
 1426 0078 0AE0     		b	.L81
 1427              	.LVL188:
 1428              	.L95:
 1429              	.LBE12:
 409:src/command_parser.c ****             }
 410:src/command_parser.c ****         }
 411:src/command_parser.c **** 
 412:src/command_parser.c ****         else {
 413:src/command_parser.c **** 
 414:src/command_parser.c ****             USART_rtos_puts(&packet, "Error: Invalid regime_ph_id\r\n");
 1430              		.loc 1 414 0
 1431 007a 6846     		mov	r0, sp
 1432 007c 40F20001 		movw	r1, #:lower16:.LC13
 1433              	.LVL189:
 1434 0080 C0F20001 		movt	r1, #:upper16:.LC13
 1435 0084 FFF7FEFF 		bl	USART_rtos_puts
 1436              	.LVL190:
 415:src/command_parser.c ****             USART_rtos_wait_send(&packet);
 1437              		.loc 1 415 0
 1438 0088 6846     		mov	r0, sp
 1439 008a FFF7FEFF 		bl	USART_rtos_wait_send
 1440              	.LVL191:
 416:src/command_parser.c ****             return;
 1441              		.loc 1 416 0
 1442 008e 3CE0     		b	.L80
 1443              	.L81:
 1444              	.LBE10:
 417:src/command_parser.c ****         }
 418:src/command_parser.c **** 
 419:src/command_parser.c ****     }
 420:src/command_parser.c **** 
 421:src/command_parser.c ****     if (str_compare(pos, "STAGE\003", term)) {
 1445              		.loc 1 421 0
 1446 0090 2846     		mov	r0, r5
 1447 0092 40F20001 		movw	r1, #:lower16:.LC3
 1448 0096 C0F20001 		movt	r1, #:upper16:.LC3
 1449 009a 3246     		mov	r2, r6
 1450 009c FFF7FEFF 		bl	str_compare
 1451              	.LVL192:
 1452 00a0 98B3     		cbz	r0, .L80
 1453              	.LBB13:
 422:src/command_parser.c **** 
 423:src/command_parser.c ****         int idx = find_next_char(pos, 0, term);
 1454              		.loc 1 423 0
 1455 00a2 2846     		mov	r0, r5
 1456 00a4 0021     		movs	r1, #0
 1457 00a6 3246     		mov	r2, r6
 1458 00a8 FFF7FEFF 		bl	find_next_char
 1459              	.LVL193:
 424:src/command_parser.c ****         pos+=idx+1;
 1460              		.loc 1 424 0
 1461 00ac 0130     		adds	r0, r0, #1
 1462              	.LVL194:
 425:src/command_parser.c ****         int stage_id = str_to_int(pos, '\003')-1;
 1463              		.loc 1 425 0
 1464 00ae 2844     		add	r0, r0, r5
 1465              	.LVL195:
 1466 00b0 0321     		movs	r1, #3
 1467 00b2 FFF7FEFF 		bl	str_to_int
 1468              	.LVL196:
 426:src/command_parser.c ****         if (stage_id == -1) {
 1469              		.loc 1 426 0
 1470 00b6 431E     		subs	r3, r0, #1
 1471              	.LVL197:
 1472 00b8 80B9     		cbnz	r0, .L96
 1473 00ba 07E0     		b	.L94
 1474              	.LVL198:
 1475              	.L90:
 1476              	.LBB14:
 427:src/command_parser.c ****             int i;
 428:src/command_parser.c ****             for(i=0; i<MAX_STAGES; i++) {
 429:src/command_parser.c ****                 stage_print(&stages[i]);
 1477              		.loc 1 429 0 discriminator 2
 1478 00bc 04EB4400 		add	r0, r4, r4, lsl #1
 1479 00c0 05EBC000 		add	r0, r5, r0, lsl #3
 1480 00c4 FFF7FEFF 		bl	stage_print
 1481              	.LVL199:
 428:src/command_parser.c ****                 stage_print(&stages[i]);
 1482              		.loc 1 428 0 discriminator 2
 1483 00c8 0134     		adds	r4, r4, #1
 1484              	.LVL200:
 1485 00ca 04E0     		b	.L88
 1486              	.LVL201:
 1487              	.L94:
 1488              	.LBE14:
 1489 00cc 0024     		movs	r4, #0
 1490              	.LBB15:
 1491              		.loc 1 429 0
 1492 00ce 40F20005 		movw	r5, #:lower16:stages
 1493 00d2 C0F20005 		movt	r5, #:upper16:stages
 1494              	.LVL202:
 1495              	.L88:
 428:src/command_parser.c ****                 stage_print(&stages[i]);
 1496              		.loc 1 428 0 discriminator 1
 1497 00d6 092C     		cmp	r4, #9
 1498 00d8 F0DD     		ble	.L90
 1499 00da 16E0     		b	.L80
 1500              	.LVL203:
 1501              	.L96:
 1502              	.LBE15:
 430:src/command_parser.c ****             }
 431:src/command_parser.c ****         }
 432:src/command_parser.c ****         else if (stage_id >= 0 && stage_id <MAX_STAGES) {
 1503              		.loc 1 432 0
 1504 00dc 092B     		cmp	r3, #9
 1505 00de 0AD8     		bhi	.L91
 433:src/command_parser.c ****             stage_print(stages+stage_id);
 1506              		.loc 1 433 0
 1507 00e0 03EB4303 		add	r3, r3, r3, lsl #1
 1508              	.LVL204:
 1509 00e4 40F20000 		movw	r0, #:lower16:stages
 1510              	.LVL205:
 1511 00e8 C0F20000 		movt	r0, #:upper16:stages
 1512 00ec 00EBC300 		add	r0, r0, r3, lsl #3
 1513 00f0 FFF7FEFF 		bl	stage_print
 1514              	.LVL206:
 1515 00f4 09E0     		b	.L80
 1516              	.LVL207:
 1517              	.L91:
 434:src/command_parser.c **** 
 435:src/command_parser.c ****         }
 436:src/command_parser.c ****         else {
 437:src/command_parser.c ****             USART_rtos_puts(&packet, "Error: Invalid stage_id\r\n");
 1518              		.loc 1 437 0
 1519 00f6 6846     		mov	r0, sp
 1520 00f8 40F20001 		movw	r1, #:lower16:.LC14
 1521 00fc C0F20001 		movt	r1, #:upper16:.LC14
 1522 0100 FFF7FEFF 		bl	USART_rtos_puts
 1523              	.LVL208:
 438:src/command_parser.c ****             USART_rtos_wait_send(&packet);
 1524              		.loc 1 438 0
 1525 0104 6846     		mov	r0, sp
 1526 0106 FFF7FEFF 		bl	USART_rtos_wait_send
 1527              	.LVL209:
 1528              	.L80:
 1529              	.LBE13:
 439:src/command_parser.c ****             return;
 440:src/command_parser.c ****         }
 441:src/command_parser.c **** 
 442:src/command_parser.c ****     }
 443:src/command_parser.c **** 
 444:src/command_parser.c ****     else {
 445:src/command_parser.c ****         //USART_rtos_sputs(&packet, "Error: Unknown Object '%s'\r\n", pos);
 446:src/command_parser.c ****         //USART_rtos_wait_send(&packet);
 447:src/command_parser.c **** 
 448:src/command_parser.c ****     }
 449:src/command_parser.c **** }
 1530              		.loc 1 449 0
 1531 010a 05B0     		add	sp, sp, #20
 1532              		@ sp needed
 1533 010c F0BD     		pop	{r4, r5, r6, r7, pc}
 1534              		.cfi_endproc
 1535              	.LFE123:
 1537 010e 00BF     		.section	.text.command_routing,"ax",%progbits
 1538              		.align	2
 1539              		.global	command_routing
 1540              		.thumb
 1541              		.thumb_func
 1543              	command_routing:
 1544              	.LFB124:
 450:src/command_parser.c **** 
 451:src/command_parser.c **** 
 452:src/command_parser.c **** 
 453:src/command_parser.c **** int command_routing(char *pos, char term) {
 1545              		.loc 1 453 0
 1546              		.cfi_startproc
 1547              		@ args = 0, pretend = 0, frame = 16
 1548              		@ frame_needed = 0, uses_anonymous_args = 0
 1549              	.LVL210:
 1550 0000 30B5     		push	{r4, r5, lr}
 1551              	.LCFI20:
 1552              		.cfi_def_cfa_offset 12
 1553              		.cfi_offset 4, -12
 1554              		.cfi_offset 5, -8
 1555              		.cfi_offset 14, -4
 1556 0002 85B0     		sub	sp, sp, #20
 1557              	.LCFI21:
 1558              		.cfi_def_cfa_offset 32
 1559 0004 0546     		mov	r5, r0
 1560 0006 0C46     		mov	r4, r1
 454:src/command_parser.c ****     USART_rtos_packet packet;
 455:src/command_parser.c ****     packet.USARTx_rtos = USARTOutput_rtos;
 1561              		.loc 1 455 0
 1562 0008 40F20003 		movw	r3, #:lower16:USARTOutput_rtos
 1563 000c C0F20003 		movt	r3, #:upper16:USARTOutput_rtos
 1564 0010 1B68     		ldr	r3, [r3]
 1565 0012 0093     		str	r3, [sp]
 1566              	.LVL211:
 456:src/command_parser.c ****     int r = 0;
 457:src/command_parser.c ****     
 458:src/command_parser.c ****     if (str_compare(pos, "get\003", term)) {
 1567              		.loc 1 458 0
 1568 0014 40F20001 		movw	r1, #:lower16:.LC15
 1569              	.LVL212:
 1570 0018 C0F20001 		movt	r1, #:upper16:.LC15
 1571 001c 2246     		mov	r2, r4
 1572 001e FFF7FEFF 		bl	str_compare
 1573              	.LVL213:
 1574 0022 28B1     		cbz	r0, .L98
 459:src/command_parser.c ****         command_get(pos, term);
 1575              		.loc 1 459 0
 1576 0024 2846     		mov	r0, r5
 1577 0026 2146     		mov	r1, r4
 1578 0028 FFF7FEFF 		bl	command_get
 1579              	.LVL214:
 456:src/command_parser.c ****     int r = 0;
 1580              		.loc 1 456 0
 1581 002c 0020     		movs	r0, #0
 1582 002e 2EE0     		b	.L99
 1583              	.L98:
 460:src/command_parser.c ****     }
 461:src/command_parser.c **** 
 462:src/command_parser.c ****     else if (str_compare(pos, "set\003", term)) {
 1584              		.loc 1 462 0
 1585 0030 2846     		mov	r0, r5
 1586 0032 40F20001 		movw	r1, #:lower16:.LC16
 1587 0036 C0F20001 		movt	r1, #:upper16:.LC16
 1588 003a 2246     		mov	r2, r4
 1589 003c FFF7FEFF 		bl	str_compare
 1590              	.LVL215:
 1591 0040 28B1     		cbz	r0, .L100
 463:src/command_parser.c ****         command_set(pos, term);
 1592              		.loc 1 463 0
 1593 0042 2846     		mov	r0, r5
 1594 0044 2146     		mov	r1, r4
 1595 0046 FFF7FEFF 		bl	command_set
 1596              	.LVL216:
 456:src/command_parser.c ****     
 1597              		.loc 1 456 0
 1598 004a 0020     		movs	r0, #0
 1599 004c 1FE0     		b	.L99
 1600              	.L100:
 464:src/command_parser.c ****     }
 465:src/command_parser.c **** 
 466:src/command_parser.c ****     else if (str_compare(pos, "del\003", term)) {
 1601              		.loc 1 466 0
 1602 004e 2846     		mov	r0, r5
 1603 0050 40F20001 		movw	r1, #:lower16:.LC17
 1604 0054 C0F20001 		movt	r1, #:upper16:.LC17
 1605 0058 2246     		mov	r2, r4
 1606 005a FFF7FEFF 		bl	str_compare
 1607              	.LVL217:
 1608 005e 28B1     		cbz	r0, .L101
 467:src/command_parser.c ****         command_del(pos, term);
 1609              		.loc 1 467 0
 1610 0060 2846     		mov	r0, r5
 1611 0062 2146     		mov	r1, r4
 1612 0064 FFF7FEFF 		bl	command_del
 1613              	.LVL218:
 456:src/command_parser.c ****     
 1614              		.loc 1 456 0
 1615 0068 0020     		movs	r0, #0
 1616 006a 10E0     		b	.L99
 1617              	.L101:
 468:src/command_parser.c ****     }
 469:src/command_parser.c **** 
 470:src/command_parser.c ****     else if (*pos != term){
 1618              		.loc 1 470 0
 1619 006c 2B78     		ldrb	r3, [r5]	@ zero_extendqisi2
 1620 006e A342     		cmp	r3, r4
 456:src/command_parser.c ****     
 1621              		.loc 1 456 0
 1622 0070 08BF     		it	eq
 1623 0072 0020     		moveq	r0, #0
 1624              		.loc 1 470 0
 1625 0074 0BD0     		beq	.L99
 471:src/command_parser.c ****         USART_rtos_puts(&packet, "{'method': '', 'error': 9}\r\n"); //error 9: Unknown start comman
 1626              		.loc 1 471 0
 1627 0076 6846     		mov	r0, sp
 1628 0078 40F20001 		movw	r1, #:lower16:.LC18
 1629 007c C0F20001 		movt	r1, #:upper16:.LC18
 1630 0080 FFF7FEFF 		bl	USART_rtos_puts
 1631              	.LVL219:
 472:src/command_parser.c ****         USART_rtos_wait_send(&packet);
 1632              		.loc 1 472 0
 1633 0084 6846     		mov	r0, sp
 1634 0086 FFF7FEFF 		bl	USART_rtos_wait_send
 1635              	.LVL220:
 473:src/command_parser.c ****         r = 1;
 1636              		.loc 1 473 0
 1637 008a 0120     		movs	r0, #1
 1638 008c FFE7     		b	.L99
 1639              	.LVL221:
 1640              	.L99:
 474:src/command_parser.c ****     }
 475:src/command_parser.c ****     return r; //1 = Error
 476:src/command_parser.c **** }
 1641              		.loc 1 476 0
 1642 008e 05B0     		add	sp, sp, #20
 1643              		@ sp needed
 1644 0090 30BD     		pop	{r4, r5, pc}
 1645              		.cfi_endproc
 1646              	.LFE124:
 1648              		.global	REGIME_LIGHTING
 1649              		.global	REGIME_PH
 1650              		.comm	stages,240,4
 1651              		.comm	USARTOutput_rtos,4,4
 1652 0092 00BF     		.section	.rodata.str1.4,"aMS",%progbits,1
 1653              		.align	2
 1654              	.LC0:
 1655 0000 7B276F62 		.ascii	"{'object_type': 'REGIME_PH', 'method': 'set', 'erro"
 1655      6A656374 
 1655      5F747970 
 1655      65273A20 
 1655      27524547 
 1656 0033 72273A25 		.ascii	"r':%d, 'object_id':%d}\015\012\000"
 1656      642C2027 
 1656      6F626A65 
 1656      63745F69 
 1656      64273A25 
 1657              	.LC1:
 1658 004c 7B276F62 		.ascii	"{'object_type': 'STAGE', 'method': 'set', 'error':%"
 1658      6A656374 
 1658      5F747970 
 1658      65273A20 
 1658      27535441 
 1659 007f 642C2027 		.ascii	"d, 'object_id':%d}\015\012\000"
 1659      6F626A65 
 1659      63745F69 
 1659      64273A25 
 1659      647D0D0A 
 1660              	.LC2:
 1661 0094 52454749 		.ascii	"REGIME_PH\003\000"
 1661      4D455F50 
 1661      480300
 1662 009f 00       		.space	1
 1663              	.LC3:
 1664 00a0 53544147 		.ascii	"STAGE\003\000"
 1664      450300
 1665 00a7 00       		.space	1
 1666              	.LC4:
 1667 00a8 52454749 		.ascii	"REGIME_LIGHTING\003\000"
 1667      4D455F4C 
 1667      49474854 
 1667      494E4703 
 1667      00
 1668 00b9 000000   		.space	3
 1669              	.LC5:
 1670 00bc 7B276F62 		.ascii	"{'object_type': '', method: 'set', error: 10, 'obje"
 1670      6A656374 
 1670      5F747970 
 1670      65273A20 
 1670      27272C20 
 1671 00ef 63745F69 		.ascii	"ct_id': -1}\015\012\000"
 1671      64273A20 
 1671      2D317D0D 
 1671      0A00
 1672 00fd 000000   		.space	3
 1673              	.LC6:
 1674 0100 4572726F 		.ascii	"Error: Incorrect REGIME_PH id\015\012\000"
 1674      723A2049 
 1674      6E636F72 
 1674      72656374 
 1674      20524547 
 1675              	.LC7:
 1676 0120 44454255 		.ascii	"DEBUG: DELETING REGIME_ID %d\015\012\000"
 1676      473A2044 
 1676      454C4554 
 1676      494E4720 
 1676      52454749 
 1677 013f 00       		.space	1
 1678              	.LC8:
 1679 0140 4572726F 		.ascii	"Error: Incorrect stage id\015\012\000"
 1679      723A2049 
 1679      6E636F72 
 1679      72656374 
 1679      20737461 
 1680              	.LC9:
 1681 015c 53756363 		.ascii	"Succesfully deleted stage id: %d\015\012\000"
 1681      65736675 
 1681      6C6C7920 
 1681      64656C65 
 1681      74656420 
 1682 017f 00       		.space	1
 1683              	.LC10:
 1684 0180 4572726F 		.ascii	"Error: Unknown Object '%s'\015\012\000"
 1684      723A2055 
 1684      6E6B6E6F 
 1684      776E204F 
 1684      626A6563 
 1685 019d 000000   		.space	3
 1686              	.LC11:
 1687 01a0 7B276964 		.ascii	"{'id': %d, 'length': %d, 'order':%d, 'ph_id': %d, '"
 1687      273A2025 
 1687      642C2027 
 1687      6C656E67 
 1687      7468273A 
 1688 01d3 6C696768 		.ascii	"lighting_id':%d, 'using':%d}\015\012\000"
 1688      74696E67 
 1688      5F696427 
 1688      3A25642C 
 1688      20277573 
 1689 01f2 0000     		.space	2
 1690              	.LC12:
 1691 01f4 7B276964 		.ascii	"{'id': %d, 'ph': %d, 'delay': %d}\015\012\000"
 1691      273A2025 
 1691      642C2027 
 1691      7068273A 
 1691      2025642C 
 1692              	.LC13:
 1693 0218 4572726F 		.ascii	"Error: Invalid regime_ph_id\015\012\000"
 1693      723A2049 
 1693      6E76616C 
 1693      69642072 
 1693      6567696D 
 1694 0236 0000     		.space	2
 1695              	.LC14:
 1696 0238 4572726F 		.ascii	"Error: Invalid stage_id\015\012\000"
 1696      723A2049 
 1696      6E76616C 
 1696      69642073 
 1696      74616765 
 1697 0252 0000     		.space	2
 1698              	.LC15:
 1699 0254 67657403 		.ascii	"get\003\000"
 1699      00
 1700 0259 000000   		.space	3
 1701              	.LC16:
 1702 025c 73657403 		.ascii	"set\003\000"
 1702      00
 1703 0261 000000   		.space	3
 1704              	.LC17:
 1705 0264 64656C03 		.ascii	"del\003\000"
 1705      00
 1706 0269 000000   		.space	3
 1707              	.LC18:
 1708 026c 7B276D65 		.ascii	"{'method': '', 'error': 9}\015\012\000"
 1708      74686F64 
 1708      273A2027 
 1708      272C2027 
 1708      6572726F 
 1709 0289 000000   		.section	.data.REGIME_LIGHTING,"aw",%progbits
 1710              		.align	2
 1713              	REGIME_LIGHTING:
 1714 0000 FFFFFFFF 		.word	-1
 1715 0004 FFFFFFFF 		.word	-1
 1716 0008 00000000 		.space	72
 1716      00000000 
 1716      00000000 
 1716      00000000 
 1716      00000000 
 1717              		.section	.data.REGIME_PH,"aw",%progbits
 1718              		.align	2
 1719              		.set	.LANCHOR0,. + 0
 1722              	REGIME_PH:
 1723 0000 FFFFFFFF 		.word	-1
 1724 0004 FFFFFFFF 		.word	-1
 1725 0008 FFFFFFFF 		.word	-1
 1726 000c FFFFFFFF 		.word	-1
 1727 0010 FFFFFFFF 		.word	-1
 1728 0014 FFFFFFFF 		.word	-1
 1729 0018 FFFFFFFF 		.word	-1
 1730 001c FFFFFFFF 		.word	-1
 1731 0020 FFFFFFFF 		.word	-1
 1732 0024 FFFFFFFF 		.word	-1
 1733 0028 FFFFFFFF 		.word	-1
 1734 002c FFFFFFFF 		.word	-1
 1735 0030 FFFFFFFF 		.word	-1
 1736 0034 FFFFFFFF 		.word	-1
 1737 0038 FFFFFFFF 		.word	-1
 1738 003c FFFFFFFF 		.word	-1
 1739 0040 FFFFFFFF 		.word	-1
 1740 0044 FFFFFFFF 		.word	-1
 1741 0048 FFFFFFFF 		.word	-1
 1742 004c FFFFFFFF 		.word	-1
 1743              		.text
 1744              	.Letext0:
 1745              		.file 2 "/usr/include/newlib/machine/_default_types.h"
 1746              		.file 3 "/usr/include/newlib/stdint.h"
 1747              		.file 4 "libs/Device/STM32F4xx/Include/stm32f4xx.h"
 1748              		.file 5 "FreeRTOS/Source/include/../../Source/portable/GCC/ARM_CM4F/portmacro.h"
 1749              		.file 6 "FreeRTOS/Source/include/queue.h"
 1750              		.file 7 "FreeRTOS/Source/include/semphr.h"
 1751              		.file 8 "src/usart_rtos.h"
 1752              		.file 9 "src/command_parser.h"
 1753              		.file 10 "libs/CMSIS/Include/core_cm4.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 command_parser.c
     /tmp/cc3wkEEX.s:20     .text.setup_output:0000000000000000 $t
     /tmp/cc3wkEEX.s:25     .text.setup_output:0000000000000000 setup_output
                            *COM*:0000000000000004 USARTOutput_rtos
     /tmp/cc3wkEEX.s:43     .text.replace_char:0000000000000000 $t
     /tmp/cc3wkEEX.s:48     .text.replace_char:0000000000000000 replace_char
     /tmp/cc3wkEEX.s:77     .text.str_compare:0000000000000000 $t
     /tmp/cc3wkEEX.s:82     .text.str_compare:0000000000000000 str_compare
     /tmp/cc3wkEEX.s:131    .text.find_next_char:0000000000000000 $t
     /tmp/cc3wkEEX.s:136    .text.find_next_char:0000000000000000 find_next_char
     /tmp/cc3wkEEX.s:175    .text.str_to_int:0000000000000000 $t
     /tmp/cc3wkEEX.s:180    .text.str_to_int:0000000000000000 str_to_int
     /tmp/cc3wkEEX.s:247    .text.command_set_regime_ph:0000000000000000 $t
     /tmp/cc3wkEEX.s:252    .text.command_set_regime_ph:0000000000000000 command_set_regime_ph
     /tmp/cc3wkEEX.s:1654   .rodata.str1.4:0000000000000000 .LC0
     /tmp/cc3wkEEX.s:1719   .data.REGIME_PH:0000000000000000 .LANCHOR0
     /tmp/cc3wkEEX.s:526    .text.command_set_stage:0000000000000000 $t
     /tmp/cc3wkEEX.s:531    .text.command_set_stage:0000000000000000 command_set_stage
     /tmp/cc3wkEEX.s:1657   .rodata.str1.4:000000000000004c .LC1
                            *COM*:00000000000000f0 stages
     /tmp/cc3wkEEX.s:716    .text.command_set_stage:00000000000000fa $d
     /tmp/cc3wkEEX.s:724    .text.command_set_stage:0000000000000102 $t
     /tmp/cc3wkEEX.s:873    .text.command_set:0000000000000000 $t
     /tmp/cc3wkEEX.s:878    .text.command_set:0000000000000000 command_set
     /tmp/cc3wkEEX.s:1660   .rodata.str1.4:0000000000000094 .LC2
     /tmp/cc3wkEEX.s:1663   .rodata.str1.4:00000000000000a0 .LC3
     /tmp/cc3wkEEX.s:1666   .rodata.str1.4:00000000000000a8 .LC4
     /tmp/cc3wkEEX.s:1669   .rodata.str1.4:00000000000000bc .LC5
     /tmp/cc3wkEEX.s:961    .text.command_del_regime_ph:0000000000000000 $t
     /tmp/cc3wkEEX.s:966    .text.command_del_regime_ph:0000000000000000 command_del_regime_ph
     /tmp/cc3wkEEX.s:1673   .rodata.str1.4:0000000000000100 .LC6
     /tmp/cc3wkEEX.s:1675   .rodata.str1.4:0000000000000120 .LC7
     /tmp/cc3wkEEX.s:1040   .text.command_del_stage:0000000000000000 $t
     /tmp/cc3wkEEX.s:1045   .text.command_del_stage:0000000000000000 command_del_stage
     /tmp/cc3wkEEX.s:1678   .rodata.str1.4:0000000000000140 .LC8
     /tmp/cc3wkEEX.s:1680   .rodata.str1.4:000000000000015c .LC9
     /tmp/cc3wkEEX.s:1128   .text.command_del:0000000000000000 $t
     /tmp/cc3wkEEX.s:1133   .text.command_del:0000000000000000 command_del
     /tmp/cc3wkEEX.s:1683   .rodata.str1.4:0000000000000180 .LC10
     /tmp/cc3wkEEX.s:1217   .text.stage_print:0000000000000000 $t
     /tmp/cc3wkEEX.s:1222   .text.stage_print:0000000000000000 stage_print
     /tmp/cc3wkEEX.s:1686   .rodata.str1.4:00000000000001a0 .LC11
     /tmp/cc3wkEEX.s:1273   .text.regime_ph_print:0000000000000000 $t
     /tmp/cc3wkEEX.s:1278   .text.regime_ph_print:0000000000000000 regime_ph_print
     /tmp/cc3wkEEX.s:1690   .rodata.str1.4:00000000000001f4 .LC12
     /tmp/cc3wkEEX.s:1324   .text.command_get:0000000000000000 $t
     /tmp/cc3wkEEX.s:1329   .text.command_get:0000000000000000 command_get
     /tmp/cc3wkEEX.s:1692   .rodata.str1.4:0000000000000218 .LC13
     /tmp/cc3wkEEX.s:1695   .rodata.str1.4:0000000000000238 .LC14
     /tmp/cc3wkEEX.s:1538   .text.command_routing:0000000000000000 $t
     /tmp/cc3wkEEX.s:1543   .text.command_routing:0000000000000000 command_routing
     /tmp/cc3wkEEX.s:1698   .rodata.str1.4:0000000000000254 .LC15
     /tmp/cc3wkEEX.s:1701   .rodata.str1.4:000000000000025c .LC16
     /tmp/cc3wkEEX.s:1704   .rodata.str1.4:0000000000000264 .LC17
     /tmp/cc3wkEEX.s:1707   .rodata.str1.4:000000000000026c .LC18
     /tmp/cc3wkEEX.s:1713   .data.REGIME_LIGHTING:0000000000000000 REGIME_LIGHTING
     /tmp/cc3wkEEX.s:1722   .data.REGIME_PH:0000000000000000 REGIME_PH
     /tmp/cc3wkEEX.s:1653   .rodata.str1.4:0000000000000000 $d
     /tmp/cc3wkEEX.s:1710   .data.REGIME_LIGHTING:0000000000000000 $d
     /tmp/cc3wkEEX.s:1718   .data.REGIME_PH:0000000000000000 $d
                     .debug_frame:0000000000000010 $d
                           .group:0000000000000000 wm4.1.7402b5479d3fa4780665141f585fc0ee
                           .group:0000000000000000 wm4.stddef.h.39.daafd3d79fe2f3a84d2d73d7d4e706f8
                           .group:0000000000000000 wm4.projdefs.h.55.cdae9ead80b5a2ac004f41bb277aad45
                           .group:0000000000000000 wm4.FreeRTOSConfig.h.55.a343614a17c4367a6359a1f530d6d32b
                           .group:0000000000000000 wm4.stm32f4xx.h.48.a3308e16720c7afc3eb28e585e628ce6
                           .group:0000000000000000 wm4.core_cm4.h.32.5f62939b60122629d60d85d0c4a14709
                           .group:0000000000000000 wm4.features.h.22.6a4ca7cd053637cc1d0db6c16f39b2d7
                           .group:0000000000000000 wm4._default_types.h.15.8b2cb27e528498f8ff711db085d6e489
                           .group:0000000000000000 wm4.stdint.h.20.796e373797e732130a803d4c0338fa1b
                           .group:0000000000000000 wm4.core_cmInstr.h.25.f50f886f2edf670cf199b35fd96f5c91
                           .group:0000000000000000 wm4.core_cm4_simd.h.29.b4a3fdfb606cb3b26119424324d4b963
                           .group:0000000000000000 wm4.core_cm4.h.153.5393ef7e6cebf34dd51ca528f9218ab3
                           .group:0000000000000000 wm4.stm32f4xx.h.282.95bae448a91bccfbf24a6f9d95904bb8
                           .group:0000000000000000 wm4.stm32f4xx_adc.h.102.2061aa73008746f3c2cc6ce8f635cad3
                           .group:0000000000000000 wm4.stm32f4xx_can.h.25.87f18ca48b2692d39f76e87b1f07c953
                           .group:0000000000000000 wm4.stm32f4xx_cryp.h.25.db1951c06ee684df97ea3a11aba6cb51
                           .group:0000000000000000 wm4.stm32f4xx_dac.h.25.c43557a6416ea4dfa986c1209c2558d6
                           .group:0000000000000000 wm4.stm32f4xx_dbgmcu.h.24.7aedfdcf091890b5cb96019bd29a2bfc
                           .group:0000000000000000 wm4.stm32f4xx_dcmi.h.24.64883d9be802a535b1d7770d14da73e0
                           .group:0000000000000000 wm4.stm32f4xx_dma.h.25.c1fa1d44ae0bc9c2b3a0d1d355d8c1e6
                           .group:0000000000000000 wm4.stm32f4xx_exti.h.25.620998268d5d3d9042a8297fbe07d507
                           .group:0000000000000000 wm4.stm32f4xx_flash.h.25.65d4f351b72ee41355279f70305f361a
                           .group:0000000000000000 wm4.stm32f4xx_fsmc.h.25.b907ac7bd9bec46e02d06b137d53cfd8
                           .group:0000000000000000 wm4.stm32f4xx_hash.h.25.633fb84f031cf2ab1bd834e536716dfa
                           .group:0000000000000000 wm4.stm32f4xx_gpio.h.25.5bd1d790d742a307b55aea5fa8fcdae8
                           .group:0000000000000000 wm4.stm32f4xx_i2c.h.25.8fcdb817a00a67d4624d79bab0d9275f
                           .group:0000000000000000 wm4.stm32f4xx_iwdg.h.25.3013e8d2058415cb9d51af77f748a146
                           .group:0000000000000000 wm4.stm32f4xx_pwr.h.25.48b68c1f3a894ab012f9c2a2c222f159
                           .group:0000000000000000 wm4.stm32f4xx_rcc.h.24.c15e7c8dc065bb29146f29591b195c87
                           .group:0000000000000000 wm4.stm32f4xx_rng.h.25.cdb5c5c07de6a48aedfde608da3f447e
                           .group:0000000000000000 wm4.stm32f4xx_rtc.h.25.4809a79ad46ad97b4a01e735a96738eb
                           .group:0000000000000000 wm4.stm32f4xx_sdio.h.25.406302aabae34eada94e5f2cde635a3e
                           .group:0000000000000000 wm4.stm32f4xx_spi.h.25.46c61b79ff8408da93e2e90cf9b717d6
                           .group:0000000000000000 wm4.stm32f4xx_syscfg.h.25.9d5caab5677661b69e959531364e23d7
                           .group:0000000000000000 wm4.stm32f4xx_tim.h.25.948f7fc943f34bd206e29758e77ee0a2
                           .group:0000000000000000 wm4.stm32f4xx_usart.h.25.b64697dad017ba547dd272c2cdb5846a
                           .group:0000000000000000 wm4.stm32f4xx_wwdg.h.25.09d70b7849c6894ddf1e83c8e86b70e1
                           .group:0000000000000000 wm4.misc.h.25.a0cb758c1f091b46f201b19cec9e63a1
                           .group:0000000000000000 wm4.stm32f4xx.h.6913.da011404ccb203790556c86f10c46b18
                           .group:0000000000000000 wm4.FreeRTOSConfig.h.74.fc794e36cd6c91c3b4695c74d78d9ccd
                           .group:0000000000000000 wm4.portmacro.h.69.a7e264ae32accd81a6ffb6f75a8356fe
                           .group:0000000000000000 wm4.portable.h.315.489c085dbd13c768c8594a7d23ef5545
                           .group:0000000000000000 wm4.mpu_wrappers.h.55.46a4a008a193040c38098e9a5f07ff9d
                           .group:0000000000000000 wm4.FreeRTOS.h.136.a1d4f27d190f434afd0502fdd510d30a
                           .group:0000000000000000 wm4.list.h.84.e713c47e239b06424d7c93968625e34d
                           .group:0000000000000000 wm4.task.h.73.ea72fb74b80a9cae261e97c6a9e3f3a7
                           .group:0000000000000000 wm4.queue.h.56.a4282b659085ac883e461fc7ab8aecd1
                           .group:0000000000000000 wm4.semphr.h.65.53591bdf1c84eee2eae05897a780c325
                           .group:0000000000000000 wm4.command_parser.h.2.5e0bdc6818b1caaa7320b37894727a8a

UNDEFINED SYMBOLS
memcpy
USART_rtos_sputs
USART_rtos_wait_send
USART_rtos_puts
