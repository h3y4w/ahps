   1              		.syntax unified
   2              		.cpu cortex-m4
   3              		.eabi_attribute 27, 3
   4              		.fpu fpv4-sp-d16
   5              		.eabi_attribute 20, 1
   6              		.eabi_attribute 21, 1
   7              		.eabi_attribute 23, 3
   8              		.eabi_attribute 24, 1
   9              		.eabi_attribute 25, 1
  10              		.eabi_attribute 26, 1
  11              		.eabi_attribute 30, 1
  12              		.eabi_attribute 34, 1
  13              		.eabi_attribute 18, 4
  14              		.thumb
  15              		.file	"command_parser.c"
  16              		.text
  17              	.Ltext0:
  18              		.cfi_sections	.debug_frame
  19              		.section	.text.setup_output,"ax",%progbits
  20              		.align	2
  21              		.global	setup_output
  22              		.thumb
  23              		.thumb_func
  25              	setup_output:
  26              	.LFB110:
  27              		.file 1 "src/command_parser.c"
   1:src/command_parser.c **** #include "command_parser.h"
   2:src/command_parser.c **** #include "hbfuncs.h" 
   3:src/command_parser.c **** #include "hb_structs.h"
   4:src/command_parser.c **** 
   5:src/command_parser.c **** USART_rtos *USARTOutput_rtos; 
   6:src/command_parser.c **** 
   7:src/command_parser.c **** void setup_output(USART_rtos *USARTx_rtos) {
  28              		.loc 1 7 0
  29              		.cfi_startproc
  30              		@ args = 0, pretend = 0, frame = 0
  31              		@ frame_needed = 0, uses_anonymous_args = 0
  32              		@ link register save eliminated.
  33              	.LVL0:
   8:src/command_parser.c ****     USARTOutput_rtos = USARTx_rtos;
  34              		.loc 1 8 0
  35 0000 40F20003 		movw	r3, #:lower16:USARTOutput_rtos
  36 0004 C0F20003 		movt	r3, #:upper16:USARTOutput_rtos
  37 0008 1860     		str	r0, [r3]
  38 000a 7047     		bx	lr
  39              		.cfi_endproc
  40              	.LFE110:
  42              		.section	.text.replace_char,"ax",%progbits
  43              		.align	2
  44              		.global	replace_char
  45              		.thumb
  46              		.thumb_func
  48              	replace_char:
  49              	.LFB111:
   9:src/command_parser.c **** }
  10:src/command_parser.c **** 
  11:src/command_parser.c **** void replace_char(char *msg, char find, char replace) {
  50              		.loc 1 11 0
  51              		.cfi_startproc
  52              		@ args = 0, pretend = 0, frame = 0
  53              		@ frame_needed = 0, uses_anonymous_args = 0
  54              		@ link register save eliminated.
  55              	.LVL1:
  12:src/command_parser.c ****     while(*msg!='\r') {
  56              		.loc 1 12 0
  57 0000 03E0     		b	.L3
  58              	.L5:
  13:src/command_parser.c ****         if (*msg == find) *msg = replace;
  59              		.loc 1 13 0
  60 0002 8B42     		cmp	r3, r1
  61 0004 08BF     		it	eq
  62 0006 0270     		strbeq	r2, [r0]
  14:src/command_parser.c ****         msg++;
  63              		.loc 1 14 0
  64 0008 0130     		adds	r0, r0, #1
  65              	.LVL2:
  66              	.L3:
  12:src/command_parser.c ****     while(*msg!='\r') {
  67              		.loc 1 12 0 discriminator 1
  68 000a 0378     		ldrb	r3, [r0]	@ zero_extendqisi2
  69 000c 0D2B     		cmp	r3, #13
  70 000e F8D1     		bne	.L5
  15:src/command_parser.c ****     }
  16:src/command_parser.c **** }
  71              		.loc 1 16 0
  72 0010 7047     		bx	lr
  73              		.cfi_endproc
  74              	.LFE111:
  76 0012 00BF     		.section	.text.str_compare,"ax",%progbits
  77              		.align	2
  78              		.global	str_compare
  79              		.thumb
  80              		.thumb_func
  82              	str_compare:
  83              	.LFB112:
  17:src/command_parser.c **** 
  18:src/command_parser.c **** int str_compare(char *str1, char *str2, const char terminator) {
  84              		.loc 1 18 0
  85              		.cfi_startproc
  86              		@ args = 0, pretend = 0, frame = 0
  87              		@ frame_needed = 0, uses_anonymous_args = 0
  88              		@ link register save eliminated.
  89              	.LVL3:
  90 0000 30B4     		push	{r4, r5}
  91              	.LCFI0:
  92              		.cfi_def_cfa_offset 8
  93              		.cfi_offset 4, -8
  94              		.cfi_offset 5, -4
  95              	.LVL4:
  19:src/command_parser.c ****     int i;
  20:src/command_parser.c ****     for(i=0;; i++) {
  96              		.loc 1 20 0
  97 0002 0023     		movs	r3, #0
  98              	.LVL5:
  99              	.L8:
  21:src/command_parser.c **** 
  22:src/command_parser.c ****         if (str1[i] == str2[i]) {
 100              		.loc 1 22 0
 101 0004 C45C     		ldrb	r4, [r0, r3]	@ zero_extendqisi2
 102 0006 CD5C     		ldrb	r5, [r1, r3]	@ zero_extendqisi2
 103 0008 AC42     		cmp	r4, r5
 104 000a 03D1     		bne	.L9
  23:src/command_parser.c ****             if (str1[i] == terminator) return 1; // strs match
 105              		.loc 1 23 0
 106 000c 9442     		cmp	r4, r2
 107 000e 03D0     		beq	.L10
  20:src/command_parser.c **** 
 108              		.loc 1 20 0
 109 0010 0133     		adds	r3, r3, #1
 110              	.LVL6:
  24:src/command_parser.c ****         }
  25:src/command_parser.c **** 
  26:src/command_parser.c ****         else {
  27:src/command_parser.c ****             return 0;
  28:src/command_parser.c ****         }
  29:src/command_parser.c ****     }
 111              		.loc 1 29 0
 112 0012 F7E7     		b	.L8
 113              	.L9:
  27:src/command_parser.c ****         }
 114              		.loc 1 27 0
 115 0014 0020     		movs	r0, #0
 116              	.LVL7:
 117 0016 00E0     		b	.L7
 118              	.LVL8:
 119              	.L10:
  23:src/command_parser.c ****         }
 120              		.loc 1 23 0
 121 0018 0120     		movs	r0, #1
 122              	.LVL9:
 123              	.L7:
  30:src/command_parser.c **** }
 124              		.loc 1 30 0
 125 001a 30BC     		pop	{r4, r5}
 126 001c 7047     		bx	lr
 127              		.cfi_endproc
 128              	.LFE112:
 130 001e 00BF     		.section	.text.find_next_char,"ax",%progbits
 131              		.align	2
 132              		.global	find_next_char
 133              		.thumb
 134              		.thumb_func
 136              	find_next_char:
 137              	.LFB113:
  31:src/command_parser.c **** 
  32:src/command_parser.c **** 
  33:src/command_parser.c **** int find_next_char(char *msg, int offset, char find) {
 138              		.loc 1 33 0
 139              		.cfi_startproc
 140              		@ args = 0, pretend = 0, frame = 0
 141              		@ frame_needed = 0, uses_anonymous_args = 0
 142              		@ link register save eliminated.
 143              	.LVL10:
  34:src/command_parser.c ****     int i=0;
 144              		.loc 1 34 0
 145 0000 0023     		movs	r3, #0
 146              	.LVL11:
 147              	.L13:
  35:src/command_parser.c ****     while (1) {
  36:src/command_parser.c ****         if (msg[i] == find) break;
 148              		.loc 1 36 0
 149 0002 C15C     		ldrb	r1, [r0, r3]	@ zero_extendqisi2
 150 0004 9142     		cmp	r1, r2
 151 0006 02D0     		beq	.L14
  37:src/command_parser.c ****         else if (msg[i] == '\0') {
 152              		.loc 1 37 0
 153 0008 19B1     		cbz	r1, .L15
  38:src/command_parser.c ****             return -1;
  39:src/command_parser.c ****             break;
  40:src/command_parser.c ****         }
  41:src/command_parser.c ****         i++;
 154              		.loc 1 41 0
 155 000a 0133     		adds	r3, r3, #1
 156              	.LVL12:
  42:src/command_parser.c ****     }
 157              		.loc 1 42 0
 158 000c F9E7     		b	.L13
 159              	.L14:
  43:src/command_parser.c **** 
  44:src/command_parser.c ****     return i;
 160              		.loc 1 44 0
 161 000e 1846     		mov	r0, r3
 162              	.LVL13:
 163 0010 7047     		bx	lr
 164              	.LVL14:
 165              	.L15:
  38:src/command_parser.c ****             break;
 166              		.loc 1 38 0
 167 0012 4FF0FF30 		mov	r0, #-1
 168              	.LVL15:
  45:src/command_parser.c **** }
 169              		.loc 1 45 0
 170 0016 7047     		bx	lr
 171              		.cfi_endproc
 172              	.LFE113:
 174              		.section	.text.str_to_int,"ax",%progbits
 175              		.align	2
 176              		.global	str_to_int
 177              		.thumb
 178              		.thumb_func
 180              	str_to_int:
 181              	.LFB114:
  46:src/command_parser.c **** 
  47:src/command_parser.c **** 
  48:src/command_parser.c **** int str_to_int(char *buffer, char terminator) {
 182              		.loc 1 48 0
 183              		.cfi_startproc
 184              		@ args = 0, pretend = 0, frame = 0
 185              		@ frame_needed = 0, uses_anonymous_args = 0
 186              		@ link register save eliminated.
 187              	.LVL16:
 188 0000 70B4     		push	{r4, r5, r6}
 189              	.LCFI1:
 190              		.cfi_def_cfa_offset 12
 191              		.cfi_offset 4, -12
 192              		.cfi_offset 5, -8
 193              		.cfi_offset 6, -4
 194 0002 0546     		mov	r5, r0
 195              	.LVL17:
  49:src/command_parser.c ****     int num = 0;
  50:src/command_parser.c ****     int i=0;
  51:src/command_parser.c ****     int neg=0;
  52:src/command_parser.c **** 
  53:src/command_parser.c ****     if (buffer[i] == '-') {
 196              		.loc 1 53 0
 197 0004 0378     		ldrb	r3, [r0]	@ zero_extendqisi2
 198 0006 2D2B     		cmp	r3, #45
  51:src/command_parser.c **** 
 199              		.loc 1 51 0
 200 0008 14BF     		ite	ne
 201 000a 0026     		movne	r6, #0
  54:src/command_parser.c ****         i++;
  55:src/command_parser.c ****         neg = 1;
 202              		.loc 1 55 0
 203 000c 0126     		moveq	r6, #1
  54:src/command_parser.c ****         i++;
 204              		.loc 1 54 0
 205 000e 3246     		mov	r2, r6
  50:src/command_parser.c ****     int neg=0;
 206              		.loc 1 50 0
 207 0010 0020     		movs	r0, #0
 208              	.LVL18:
 209 0012 0AE0     		b	.L18
 210              	.LVL19:
 211              	.L20:
  56:src/command_parser.c ****     }
  57:src/command_parser.c **** 
  58:src/command_parser.c ****     for(i; buffer[i]!=terminator; i++) {
  59:src/command_parser.c ****         if (buffer[i] >= '0' && buffer[i]<='9'){
 212              		.loc 1 59 0
 213 0014 A3F13004 		sub	r4, r3, #48
 214 0018 E4B2     		uxtb	r4, r4
 215 001a 092C     		cmp	r4, #9
 216 001c 08D8     		bhi	.L19
  60:src/command_parser.c ****             num *= 10; 
 217              		.loc 1 60 0
 218 001e 00EB8000 		add	r0, r0, r0, lsl #2
 219              	.LVL20:
  61:src/command_parser.c ****             num += buffer[i]-'0';
 220              		.loc 1 61 0
 221 0022 303B     		subs	r3, r3, #48
 222 0024 03EB4000 		add	r0, r3, r0, lsl #1
 223              	.LVL21:
  58:src/command_parser.c ****         if (buffer[i] >= '0' && buffer[i]<='9'){
 224              		.loc 1 58 0
 225 0028 0132     		adds	r2, r2, #1
 226              	.LVL22:
 227              	.L18:
  58:src/command_parser.c ****         if (buffer[i] >= '0' && buffer[i]<='9'){
 228              		.loc 1 58 0 is_stmt 0 discriminator 1
 229 002a AB5C     		ldrb	r3, [r5, r2]	@ zero_extendqisi2
 230 002c 8B42     		cmp	r3, r1
 231 002e F1D1     		bne	.L20
 232              	.L19:
  62:src/command_parser.c ****         }
  63:src/command_parser.c **** 
  64:src/command_parser.c ****         else {
  65:src/command_parser.c ****             break;
  66:src/command_parser.c ****         }    
  67:src/command_parser.c ****     }
  68:src/command_parser.c **** 
  69:src/command_parser.c ****     if (neg) {
 233              		.loc 1 69 0 is_stmt 1
 234 0030 06B1     		cbz	r6, .L21
  70:src/command_parser.c ****         num *= -1;
 235              		.loc 1 70 0
 236 0032 4042     		negs	r0, r0
 237              	.LVL23:
 238              	.L21:
  71:src/command_parser.c ****     }
  72:src/command_parser.c ****     return num;
  73:src/command_parser.c **** 
  74:src/command_parser.c **** }
 239              		.loc 1 74 0
 240 0034 70BC     		pop	{r4, r5, r6}
 241              	.LVL24:
 242 0036 7047     		bx	lr
 243              		.cfi_endproc
 244              	.LFE114:
 246              		.section	.text.command_set_regime_ph,"ax",%progbits
 247              		.align	2
 248              		.global	command_set_regime_ph
 249              		.thumb
 250              		.thumb_func
 252              	command_set_regime_ph:
 253              	.LFB115:
  75:src/command_parser.c **** 
  76:src/command_parser.c **** 
  77:src/command_parser.c **** 
  78:src/command_parser.c **** 
  79:src/command_parser.c **** Stage stages[MAX_STAGES];
  80:src/command_parser.c **** int REGIME_PH[MAX_REGIME_PH][2] = {
  81:src/command_parser.c ****                                     {-1, -1}, 
  82:src/command_parser.c ****                                     {-1, -1}, 
  83:src/command_parser.c ****                                     {-1, -1}, 
  84:src/command_parser.c ****                                     {-1, -1}, 
  85:src/command_parser.c ****                                     {-1, -1}, 
  86:src/command_parser.c ****                                     {-1, -1},
  87:src/command_parser.c ****                                     {-1, -1}, 
  88:src/command_parser.c ****                                     {-1, -1}, 
  89:src/command_parser.c ****                                     {-1, -1},
  90:src/command_parser.c ****                                     {-1, -1}
  91:src/command_parser.c ****                                   }; //ph, delay
  92:src/command_parser.c **** 
  93:src/command_parser.c **** int REGIME_LIGHTING[MAX_REGIME_LIGHTING][2] ={{-1, -1}}; //distance, hours_on
  94:src/command_parser.c **** 
  95:src/command_parser.c **** void command_set_regime_ph(char *pos, char term) {
 254              		.loc 1 95 0
 255              		.cfi_startproc
 256              		@ args = 0, pretend = 0, frame = 176
 257              		@ frame_needed = 0, uses_anonymous_args = 0
 258              	.LVL25:
 259 0000 2DE9F04F 		push	{r4, r5, r6, r7, r8, r9, r10, fp, lr}
 260              	.LCFI2:
 261              		.cfi_def_cfa_offset 36
 262              		.cfi_offset 4, -36
 263              		.cfi_offset 5, -32
 264              		.cfi_offset 6, -28
 265              		.cfi_offset 7, -24
 266              		.cfi_offset 8, -20
 267              		.cfi_offset 9, -16
 268              		.cfi_offset 10, -12
 269              		.cfi_offset 11, -8
 270              		.cfi_offset 14, -4
 271 0004 ADB0     		sub	sp, sp, #180
 272              	.LCFI3:
 273              		.cfi_def_cfa_offset 216
 274 0006 0446     		mov	r4, r0
 275 0008 0F46     		mov	r7, r1
  96:src/command_parser.c ****     USART_rtos_packet packet;
  97:src/command_parser.c ****     char buffer[80];
  98:src/command_parser.c ****     char msg[] = "{'object_type': 'REGIME_PH', 'method': 'set', 'error':%d, 'object_id':%d}\r\n";
 276              		.loc 1 98 0
 277 000a 01A8     		add	r0, sp, #4
 278              	.LVL26:
 279 000c 40F20001 		movw	r1, #:lower16:.LC0
 280              	.LVL27:
 281 0010 C0F20001 		movt	r1, #:upper16:.LC0
 282 0014 4C22     		movs	r2, #76
 283 0016 FFF7FEFF 		bl	memcpy
 284              	.LVL28:
  99:src/command_parser.c ****     packet.msg = buffer;
 285              		.loc 1 99 0
 286 001a 14AB     		add	r3, sp, #80
 287 001c 2993     		str	r3, [sp, #164]
 100:src/command_parser.c **** 
 101:src/command_parser.c ****     packet.USARTx_rtos = USARTOutput_rtos; 
 288              		.loc 1 101 0
 289 001e 40F20003 		movw	r3, #:lower16:USARTOutput_rtos
 290 0022 C0F20003 		movt	r3, #:upper16:USARTOutput_rtos
 291 0026 1B68     		ldr	r3, [r3]
 292 0028 2893     		str	r3, [sp, #160]
 293              	.LVL29:
 102:src/command_parser.c **** 
 103:src/command_parser.c **** 
 104:src/command_parser.c ****     int NEW_ITEM = 0;
 105:src/command_parser.c **** 
 106:src/command_parser.c ****     int idx = find_next_char(pos, 0, term);
 294              		.loc 1 106 0
 295 002a 2046     		mov	r0, r4
 296 002c 0021     		movs	r1, #0
 297 002e 3A46     		mov	r2, r7
 298 0030 FFF7FEFF 		bl	find_next_char
 299              	.LVL30:
 107:src/command_parser.c ****     pos+=idx+1;
 300              		.loc 1 107 0
 301 0034 0130     		adds	r0, r0, #1
 302              	.LVL31:
 303 0036 0444     		add	r4, r4, r0
 304              	.LVL32:
 108:src/command_parser.c **** 
 109:src/command_parser.c ****     int regime_id = str_to_int(pos, '\003')-1;
 305              		.loc 1 109 0
 306 0038 2046     		mov	r0, r4
 307              	.LVL33:
 308 003a 0321     		movs	r1, #3
 309 003c FFF7FEFF 		bl	str_to_int
 310              	.LVL34:
 311 0040 461E     		subs	r6, r0, #1
 312              	.LVL35:
 110:src/command_parser.c ****     if (!(regime_id >= -1 && regime_id <MAX_REGIME_PH)){
 313              		.loc 1 110 0
 314 0042 0A28     		cmp	r0, #10
 315 0044 0AD9     		bls	.L24
 111:src/command_parser.c ****         USART_rtos_sputs(&packet, msg, 100, -1); // error 100: incorrect id
 316              		.loc 1 111 0
 317 0046 28A8     		add	r0, sp, #160
 318 0048 01A9     		add	r1, sp, #4
 319 004a 6422     		movs	r2, #100
 320 004c 4FF0FF33 		mov	r3, #-1
 321 0050 FFF7FEFF 		bl	USART_rtos_sputs
 322              	.LVL36:
 112:src/command_parser.c ****         USART_rtos_wait_send(&packet);
 323              		.loc 1 112 0
 324 0054 28A8     		add	r0, sp, #160
 325 0056 FFF7FEFF 		bl	USART_rtos_wait_send
 326              	.LVL37:
 113:src/command_parser.c ****         return;
 327              		.loc 1 113 0
 328 005a 82E0     		b	.L23
 329              	.L24:
 114:src/command_parser.c ****     }
 115:src/command_parser.c **** 
 116:src/command_parser.c ****     else if (regime_id == -1) {
 330              		.loc 1 116 0
 331 005c B6F1FF3F 		cmp	r6, #-1
 104:src/command_parser.c **** 
 332              		.loc 1 104 0
 333 0060 18BF     		it	ne
 334 0062 4FF0000B 		movne	fp, #0
 335              		.loc 1 116 0
 336 0066 23D1     		bne	.L27
 337 0068 0CE0     		b	.L39
 338              	.LVL38:
 339              	.L30:
 340              	.LBB2:
 117:src/command_parser.c ****         int i;
 118:src/command_parser.c ****         for(i=0; i<MAX_REGIME_PH; i++) if (REGIME_PH[i][1]  == -1 && REGIME_PH[i][0] == -1) break;
 341              		.loc 1 118 0 discriminator 2
 342 006a 02EBC603 		add	r3, r2, r6, lsl #3
 343 006e 5B68     		ldr	r3, [r3, #4]
 344 0070 B3F1FF3F 		cmp	r3, #-1
 345 0074 04D1     		bne	.L28
 346              		.loc 1 118 0 is_stmt 0 discriminator 1
 347 0076 52F83630 		ldr	r3, [r2, r6, lsl #3]
 348 007a B3F1FF3F 		cmp	r3, #-1
 349 007e 08D0     		beq	.L29
 350              	.L28:
 351              		.loc 1 118 0 discriminator 2
 352 0080 0136     		adds	r6, r6, #1
 353              	.LVL39:
 354 0082 04E0     		b	.L26
 355              	.LVL40:
 356              	.L39:
 357              	.LBE2:
 358 0084 0026     		movs	r6, #0
 359              	.LVL41:
 360              	.LBB3:
 361              		.loc 1 118 0
 362 0086 40F20002 		movw	r2, #:lower16:.LANCHOR0
 363 008a C0F20002 		movt	r2, #:upper16:.LANCHOR0
 364              	.L26:
 365              	.LVL42:
 366              		.loc 1 118 0 discriminator 1
 367 008e 092E     		cmp	r6, #9
 368 0090 EBDD     		ble	.L30
 369              	.L29:
 119:src/command_parser.c **** 
 120:src/command_parser.c ****         if (i == MAX_REGIME_PH) {
 370              		.loc 1 120 0 is_stmt 1
 371 0092 0A2E     		cmp	r6, #10
 372 0094 0AD1     		bne	.L40
 121:src/command_parser.c **** 
 122:src/command_parser.c ****             USART_rtos_sputs(&packet, msg, 101, -1); //error 101: need to overwrite existing rows
 373              		.loc 1 122 0
 374 0096 28A8     		add	r0, sp, #160
 375              	.LVL43:
 376 0098 01A9     		add	r1, sp, #4
 377 009a 6522     		movs	r2, #101
 378 009c 4FF0FF33 		mov	r3, #-1
 379 00a0 FFF7FEFF 		bl	USART_rtos_sputs
 380              	.LVL44:
 123:src/command_parser.c ****             USART_rtos_wait_send(&packet);
 381              		.loc 1 123 0
 382 00a4 28A8     		add	r0, sp, #160
 383 00a6 FFF7FEFF 		bl	USART_rtos_wait_send
 384              	.LVL45:
 124:src/command_parser.c ****             return;
 385              		.loc 1 124 0
 386 00aa 5AE0     		b	.L23
 387              	.LVL46:
 388              	.L40:
 125:src/command_parser.c ****         }
 126:src/command_parser.c **** 
 127:src/command_parser.c ****         regime_id = i;
 128:src/command_parser.c ****         NEW_ITEM = 1;
 389              		.loc 1 128 0
 390 00ac 4FF0010B 		mov	fp, #1
 391              	.LVL47:
 392              	.L27:
 393              	.LBE3:
 129:src/command_parser.c ****     }
 130:src/command_parser.c **** 
 131:src/command_parser.c **** 
 132:src/command_parser.c ****     idx = find_next_char(pos, 0, term);
 394              		.loc 1 132 0
 395 00b0 2046     		mov	r0, r4
 396 00b2 0021     		movs	r1, #0
 397 00b4 3A46     		mov	r2, r7
 398 00b6 FFF7FEFF 		bl	find_next_char
 399              	.LVL48:
 133:src/command_parser.c ****     pos+=idx+1;
 400              		.loc 1 133 0
 401 00ba 431C     		adds	r3, r0, #1
 402 00bc 1C44     		add	r4, r4, r3
 403              	.LVL49:
 134:src/command_parser.c **** 
 135:src/command_parser.c ****     //break this up into smaller functions for each task
 136:src/command_parser.c **** 
 137:src/command_parser.c ****     int i;
 138:src/command_parser.c ****     for(i=0; i<2 && idx!=0; i++) {
 404              		.loc 1 138 0
 405 00be 0025     		movs	r5, #0
 406              	.LBB4:
 139:src/command_parser.c ****         switch (*pos) {
 140:src/command_parser.c ****             int v;
 141:src/command_parser.c ****             char buffer[30];
 142:src/command_parser.c **** 
 143:src/command_parser.c ****             case 'p':
 144:src/command_parser.c ****                 pos++;
 145:src/command_parser.c ****                 v = str_to_int(pos, '\003');
 146:src/command_parser.c ****                 //printf("p=%d\n", v);
 147:src/command_parser.c ****                 REGIME_PH[regime_id][0] = v;
 148:src/command_parser.c ****                 break;
 149:src/command_parser.c **** 
 150:src/command_parser.c ****             case 'd': 
 151:src/command_parser.c ****                pos++;
 152:src/command_parser.c ****                v = str_to_int(pos, '\003'); 
 407              		.loc 1 152 0
 408 00c0 4FF00308 		mov	r8, #3
 153:src/command_parser.c ****                //printf("d=%d\n", v);
 154:src/command_parser.c ****                REGIME_PH[regime_id][1] = v;
 409              		.loc 1 154 0
 410 00c4 40F20009 		movw	r9, #:lower16:.LANCHOR0
 411 00c8 C0F20009 		movt	r9, #:upper16:.LANCHOR0
 412 00cc 09EBC60A 		add	r10, r9, r6, lsl #3
 413              	.LBE4:
 138:src/command_parser.c ****         switch (*pos) {
 414              		.loc 1 138 0
 415 00d0 38E0     		b	.L31
 416              	.LVL50:
 417              	.L37:
 139:src/command_parser.c ****         switch (*pos) {
 418              		.loc 1 139 0
 419 00d2 2378     		ldrb	r3, [r4]	@ zero_extendqisi2
 420 00d4 642B     		cmp	r3, #100
 421 00d6 09D0     		beq	.L33
 422 00d8 702B     		cmp	r3, #112
 423 00da 0FD1     		bne	.L41
 424              	.LBB5:
 144:src/command_parser.c ****                 v = str_to_int(pos, '\003');
 425              		.loc 1 144 0
 426 00dc 0134     		adds	r4, r4, #1
 427              	.LVL51:
 145:src/command_parser.c ****                 //printf("p=%d\n", v);
 428              		.loc 1 145 0
 429 00de 2046     		mov	r0, r4
 430              	.LVL52:
 431 00e0 4146     		mov	r1, r8
 432 00e2 FFF7FEFF 		bl	str_to_int
 433              	.LVL53:
 147:src/command_parser.c ****                 break;
 434              		.loc 1 147 0
 435 00e6 49F83600 		str	r0, [r9, r6, lsl #3]
 148:src/command_parser.c **** 
 436              		.loc 1 148 0
 437 00ea 20E0     		b	.L35
 438              	.LVL54:
 439              	.L33:
 151:src/command_parser.c ****                v = str_to_int(pos, '\003'); 
 440              		.loc 1 151 0
 441 00ec 0134     		adds	r4, r4, #1
 442              	.LVL55:
 152:src/command_parser.c ****                //printf("d=%d\n", v);
 443              		.loc 1 152 0
 444 00ee 2046     		mov	r0, r4
 445              	.LVL56:
 446 00f0 4146     		mov	r1, r8
 447 00f2 FFF7FEFF 		bl	str_to_int
 448              	.LVL57:
 449              		.loc 1 154 0
 450 00f6 CAF80400 		str	r0, [r10, #4]
 155:src/command_parser.c ****                break;
 451              		.loc 1 155 0
 452 00fa 18E0     		b	.L35
 453              	.LVL58:
 454              	.L41:
 156:src/command_parser.c **** 
 157:src/command_parser.c ****             default:
 158:src/command_parser.c ****                USART_rtos_sputs(&packet, msg, 102, -1); //error 102: incorrect variable
 455              		.loc 1 158 0
 456 00fc 28A8     		add	r0, sp, #160
 457              	.LVL59:
 458 00fe 01A9     		add	r1, sp, #4
 459 0100 6622     		movs	r2, #102
 460 0102 4FF0FF33 		mov	r3, #-1
 461 0106 FFF7FEFF 		bl	USART_rtos_sputs
 462              	.LVL60:
 159:src/command_parser.c ****                USART_rtos_wait_send(&packet);
 463              		.loc 1 159 0
 464 010a 28A8     		add	r0, sp, #160
 465 010c FFF7FEFF 		bl	USART_rtos_wait_send
 466              	.LVL61:
 160:src/command_parser.c ****                if (NEW_ITEM) {
 467              		.loc 1 160 0
 468 0110 BBF1000F 		cmp	fp, #0
 469 0114 0BD0     		beq	.L35
 161:src/command_parser.c ****                    REGIME_PH[regime_id][0] = -1; //PH setting
 470              		.loc 1 161 0
 471 0116 40F20003 		movw	r3, #:lower16:.LANCHOR0
 472 011a C0F20003 		movt	r3, #:upper16:.LANCHOR0
 473 011e 4FF0FF32 		mov	r2, #-1
 474 0122 43F83620 		str	r2, [r3, r6, lsl #3]
 162:src/command_parser.c ****                    REGIME_PH[regime_id][1] = -1; // delay
 475              		.loc 1 162 0
 476 0126 03EBC603 		add	r3, r3, r6, lsl #3
 477 012a 5A60     		str	r2, [r3, #4]
 478 012c 19E0     		b	.L23
 479              	.L35:
 480              	.LBE5:
 163:src/command_parser.c ****                    return;
 164:src/command_parser.c ****                }
 165:src/command_parser.c **** 
 166:src/command_parser.c ****         }
 167:src/command_parser.c ****         idx = find_next_char(pos, 0, term);
 481              		.loc 1 167 0
 482 012e 2046     		mov	r0, r4
 483 0130 0021     		movs	r1, #0
 484 0132 3A46     		mov	r2, r7
 485 0134 FFF7FEFF 		bl	find_next_char
 486              	.LVL62:
 168:src/command_parser.c ****         if (idx == -1) break;
 487              		.loc 1 168 0
 488 0138 B0F1FF3F 		cmp	r0, #-1
 489 013c 0BD0     		beq	.L36
 169:src/command_parser.c ****         pos+=idx+1;
 490              		.loc 1 169 0
 491 013e 431C     		adds	r3, r0, #1
 492 0140 1C44     		add	r4, r4, r3
 493              	.LVL63:
 138:src/command_parser.c ****         switch (*pos) {
 494              		.loc 1 138 0
 495 0142 0135     		adds	r5, r5, #1
 496              	.LVL64:
 497              	.L31:
 138:src/command_parser.c ****         switch (*pos) {
 498              		.loc 1 138 0 is_stmt 0 discriminator 1
 499 0144 012D     		cmp	r5, #1
 500 0146 CCBF     		ite	gt
 501 0148 0023     		movgt	r3, #0
 502 014a 0123     		movle	r3, #1
 503 014c 0028     		cmp	r0, #0
 504 014e 08BF     		it	eq
 505 0150 0023     		moveq	r3, #0
 506 0152 002B     		cmp	r3, #0
 507 0154 BDD1     		bne	.L37
 508              	.L36:
 170:src/command_parser.c ****     }
 171:src/command_parser.c ****     USART_rtos_sputs(&packet, msg, 0, regime_id+1);
 509              		.loc 1 171 0 is_stmt 1
 510 0156 28A8     		add	r0, sp, #160
 511              	.LVL65:
 512 0158 01A9     		add	r1, sp, #4
 513 015a 0022     		movs	r2, #0
 514 015c 731C     		adds	r3, r6, #1
 515 015e FFF7FEFF 		bl	USART_rtos_sputs
 516              	.LVL66:
 517              	.L23:
 172:src/command_parser.c **** 
 173:src/command_parser.c **** 
 174:src/command_parser.c **** }
 518              		.loc 1 174 0
 519 0162 2DB0     		add	sp, sp, #180
 520              		@ sp needed
 521 0164 BDE8F08F 		pop	{r4, r5, r6, r7, r8, r9, r10, fp, pc}
 522              		.cfi_endproc
 523              	.LFE115:
 525              		.section	.text.command_set_stage,"ax",%progbits
 526              		.align	2
 527              		.global	command_set_stage
 528              		.thumb
 529              		.thumb_func
 531              	command_set_stage:
 532              	.LFB116:
 175:src/command_parser.c **** 
 176:src/command_parser.c **** void command_set_stage(char *pos, char term) {
 533              		.loc 1 176 0
 534              		.cfi_startproc
 535              		@ args = 0, pretend = 0, frame = 176
 536              		@ frame_needed = 0, uses_anonymous_args = 0
 537              	.LVL67:
 538 0000 2DE9F04F 		push	{r4, r5, r6, r7, r8, r9, r10, fp, lr}
 539              	.LCFI4:
 540              		.cfi_def_cfa_offset 36
 541              		.cfi_offset 4, -36
 542              		.cfi_offset 5, -32
 543              		.cfi_offset 6, -28
 544              		.cfi_offset 7, -24
 545              		.cfi_offset 8, -20
 546              		.cfi_offset 9, -16
 547              		.cfi_offset 10, -12
 548              		.cfi_offset 11, -8
 549              		.cfi_offset 14, -4
 550 0004 ADB0     		sub	sp, sp, #180
 551              	.LCFI5:
 552              		.cfi_def_cfa_offset 216
 553 0006 0446     		mov	r4, r0
 554 0008 0F46     		mov	r7, r1
 177:src/command_parser.c ****     USART_rtos_packet packet;
 178:src/command_parser.c ****     char buffer[80];
 179:src/command_parser.c ****     char msg[] = "{'object_type': 'STAGE', 'method': 'set', 'error':%d, 'object_id':%d}\r\n";
 555              		.loc 1 179 0
 556 000a 02A8     		add	r0, sp, #8
 557              	.LVL68:
 558 000c 40F20001 		movw	r1, #:lower16:.LC1
 559              	.LVL69:
 560 0010 C0F20001 		movt	r1, #:upper16:.LC1
 561 0014 4822     		movs	r2, #72
 562 0016 FFF7FEFF 		bl	memcpy
 563              	.LVL70:
 180:src/command_parser.c ****     packet.msg = buffer;
 564              		.loc 1 180 0
 565 001a 14AB     		add	r3, sp, #80
 566 001c 2993     		str	r3, [sp, #164]
 181:src/command_parser.c ****     packet.USARTx_rtos = USARTOutput_rtos;
 567              		.loc 1 181 0
 568 001e 40F20003 		movw	r3, #:lower16:USARTOutput_rtos
 569 0022 C0F20003 		movt	r3, #:upper16:USARTOutput_rtos
 570 0026 1B68     		ldr	r3, [r3]
 571 0028 2893     		str	r3, [sp, #160]
 572              	.LVL71:
 182:src/command_parser.c **** 
 183:src/command_parser.c ****     int NEW_ITEM = 0;
 184:src/command_parser.c **** 
 185:src/command_parser.c ****     int idx = find_next_char(pos, 0, term);
 573              		.loc 1 185 0
 574 002a 2046     		mov	r0, r4
 575 002c 0021     		movs	r1, #0
 576 002e 3A46     		mov	r2, r7
 577 0030 FFF7FEFF 		bl	find_next_char
 578              	.LVL72:
 186:src/command_parser.c ****     pos+=idx+1;
 579              		.loc 1 186 0
 580 0034 0130     		adds	r0, r0, #1
 581              	.LVL73:
 582 0036 2518     		adds	r5, r4, r0
 583              	.LVL74:
 187:src/command_parser.c **** 
 188:src/command_parser.c ****     int stage_id = str_to_int(pos, '\003')-1;
 584              		.loc 1 188 0
 585 0038 2846     		mov	r0, r5
 586              	.LVL75:
 587 003a 0321     		movs	r1, #3
 588 003c FFF7FEFF 		bl	str_to_int
 589              	.LVL76:
 590 0040 441E     		subs	r4, r0, #1
 591              	.LVL77:
 189:src/command_parser.c **** 
 190:src/command_parser.c ****     if (!(stage_id >= -1 && stage_id <MAX_STAGES)) {
 592              		.loc 1 190 0
 593 0042 0A28     		cmp	r0, #10
 594 0044 0AD9     		bls	.L43
 191:src/command_parser.c ****         USART_rtos_sputs(&packet, msg, 100, -1); // error 100: incorrect id
 595              		.loc 1 191 0
 596 0046 28A8     		add	r0, sp, #160
 597 0048 02A9     		add	r1, sp, #8
 598 004a 6422     		movs	r2, #100
 599 004c 4FF0FF33 		mov	r3, #-1
 600 0050 FFF7FEFF 		bl	USART_rtos_sputs
 601              	.LVL78:
 192:src/command_parser.c ****         USART_rtos_wait_send(&packet);
 602              		.loc 1 192 0
 603 0054 28A8     		add	r0, sp, #160
 604 0056 FFF7FEFF 		bl	USART_rtos_wait_send
 605              	.LVL79:
 193:src/command_parser.c ****         return;
 606              		.loc 1 193 0
 607 005a A9E0     		b	.L42
 608              	.L43:
 194:src/command_parser.c ****     }
 195:src/command_parser.c **** 
 196:src/command_parser.c ****     else if (stage_id == -1) {
 609              		.loc 1 196 0
 610 005c B4F1FF3F 		cmp	r4, #-1
 611 0060 0AD0     		beq	.L62
 183:src/command_parser.c **** 
 612              		.loc 1 183 0
 613 0062 0022     		movs	r2, #0
 614 0064 0192     		str	r2, [sp, #4]
 615 0066 26E0     		b	.L46
 616              	.LVL80:
 617              	.L48:
 618              	.LBB6:
 197:src/command_parser.c ****         int i;
 198:src/command_parser.c ****         for(i=0; i<MAX_STAGES; i++) {
 199:src/command_parser.c ****             if (stages[i].using == 0) break;
 619              		.loc 1 199 0
 620 0068 04EB4403 		add	r3, r4, r4, lsl #1
 621 006c 02EBC303 		add	r3, r2, r3, lsl #3
 622 0070 5B69     		ldr	r3, [r3, #20]
 623 0072 43B1     		cbz	r3, .L47
 198:src/command_parser.c ****             if (stages[i].using == 0) break;
 624              		.loc 1 198 0
 625 0074 0134     		adds	r4, r4, #1
 626              	.LVL81:
 627 0076 04E0     		b	.L45
 628              	.LVL82:
 629              	.L62:
 630              	.LBE6:
 631 0078 0024     		movs	r4, #0
 632              	.LVL83:
 633              	.LBB7:
 634              		.loc 1 199 0
 635 007a 40F20002 		movw	r2, #:lower16:stages
 636 007e C0F20002 		movt	r2, #:upper16:stages
 637              	.L45:
 638              	.LVL84:
 198:src/command_parser.c ****             if (stages[i].using == 0) break;
 639              		.loc 1 198 0 discriminator 1
 640 0082 092C     		cmp	r4, #9
 641 0084 F0DD     		ble	.L48
 642              	.L47:
 200:src/command_parser.c ****         }
 201:src/command_parser.c **** 
 202:src/command_parser.c ****         if (i == MAX_STAGES) {
 643              		.loc 1 202 0
 644 0086 0A2C     		cmp	r4, #10
 645 0088 0AD1     		bne	.L49
 203:src/command_parser.c ****             USART_rtos_sputs(&packet, msg, 101, -1); //error 101: need to overwrite existing rows
 646              		.loc 1 203 0
 647 008a 28A8     		add	r0, sp, #160
 648              	.LVL85:
 649 008c 02A9     		add	r1, sp, #8
 650 008e 6522     		movs	r2, #101
 651 0090 4FF0FF33 		mov	r3, #-1
 652 0094 FFF7FEFF 		bl	USART_rtos_sputs
 653              	.LVL86:
 204:src/command_parser.c ****             USART_rtos_wait_send(&packet);
 654              		.loc 1 204 0
 655 0098 28A8     		add	r0, sp, #160
 656 009a FFF7FEFF 		bl	USART_rtos_wait_send
 657              	.LVL87:
 205:src/command_parser.c ****             return;
 658              		.loc 1 205 0
 659 009e 87E0     		b	.L42
 660              	.LVL88:
 661              	.L49:
 206:src/command_parser.c ****         }
 207:src/command_parser.c **** 
 208:src/command_parser.c ****         stage_id = i;
 209:src/command_parser.c ****         stages[stage_id].using = 1;
 662              		.loc 1 209 0
 663 00a0 40F20003 		movw	r3, #:lower16:stages
 664 00a4 C0F20003 		movt	r3, #:upper16:stages
 665 00a8 04EB4402 		add	r2, r4, r4, lsl #1
 666 00ac 03EBC203 		add	r3, r3, r2, lsl #3
 667 00b0 0122     		movs	r2, #1
 668 00b2 5A61     		str	r2, [r3, #20]
 669              	.LVL89:
 210:src/command_parser.c ****         NEW_ITEM = 1;
 670              		.loc 1 210 0
 671 00b4 0192     		str	r2, [sp, #4]
 672              	.LVL90:
 673              	.L46:
 674              	.LBE7:
 211:src/command_parser.c ****     }
 212:src/command_parser.c **** 
 213:src/command_parser.c ****     idx = find_next_char(pos, 0, term);
 675              		.loc 1 213 0
 676 00b6 2846     		mov	r0, r5
 677 00b8 0021     		movs	r1, #0
 678 00ba 3A46     		mov	r2, r7
 679 00bc FFF7FEFF 		bl	find_next_char
 680              	.LVL91:
 214:src/command_parser.c ****     pos+=idx+1;
 681              		.loc 1 214 0
 682 00c0 431C     		adds	r3, r0, #1
 683 00c2 1D44     		add	r5, r5, r3
 684              	.LVL92:
 215:src/command_parser.c **** 
 216:src/command_parser.c ****     int i;
 217:src/command_parser.c **** 
 218:src/command_parser.c ****     stages[stage_id].id = stage_id+1;
 685              		.loc 1 218 0
 686 00c4 04F1010B 		add	fp, r4, #1
 687 00c8 40F20003 		movw	r3, #:lower16:stages
 688 00cc C0F20003 		movt	r3, #:upper16:stages
 689 00d0 04EB4402 		add	r2, r4, r4, lsl #1
 690 00d4 43F832B0 		str	fp, [r3, r2, lsl #3]
 691              	.LVL93:
 219:src/command_parser.c **** 
 220:src/command_parser.c ****     for(i=0; i<5 && idx!=0; i++) {
 692              		.loc 1 220 0
 693 00d8 0026     		movs	r6, #0
 694              	.LBB8:
 221:src/command_parser.c ****         int v;
 222:src/command_parser.c ****         //pos++;
 223:src/command_parser.c ****         switch (/**(pos-1)*/*pos) {
 224:src/command_parser.c ****             case 'l': //length in days
 225:src/command_parser.c ****                pos++;
 226:src/command_parser.c ****                v = str_to_int(pos, '\003'); 
 227:src/command_parser.c ****                stages[stage_id].length = v;
 228:src/command_parser.c ****                break;
 229:src/command_parser.c **** 
 230:src/command_parser.c ****             case 'p': //regime_ph_id 
 231:src/command_parser.c ****                pos++;
 232:src/command_parser.c ****                v = str_to_int(pos, '\003'); 
 233:src/command_parser.c ****   //             printf("p=%d\n", v);
 234:src/command_parser.c ****                stages[stage_id].regime_ph_id = v;
 235:src/command_parser.c ****                break;
 236:src/command_parser.c **** 
 237:src/command_parser.c ****             case 'i': //regime_lighting_id 
 238:src/command_parser.c ****                pos++;
 239:src/command_parser.c ****                v = str_to_int(pos, '\003'); 
 240:src/command_parser.c **** //               printf("g=%d\n", v);
 241:src/command_parser.c ****                stages[stage_id].regime_lighting_id = v;
 242:src/command_parser.c ****                break;
 243:src/command_parser.c **** 
 244:src/command_parser.c ****             case 'o': //order 
 245:src/command_parser.c ****                pos++;
 246:src/command_parser.c ****                v = str_to_int(pos, '\003'); 
 695              		.loc 1 246 0
 696 00da 4FF0030A 		mov	r10, #3
 247:src/command_parser.c **** //               printf("g=%d\n", v);
 248:src/command_parser.c ****                stages[stage_id].order = v;
 697              		.loc 1 248 0
 698 00de 40F20003 		movw	r3, #:lower16:stages
 699 00e2 C0F20003 		movt	r3, #:upper16:stages
 700 00e6 03EBC209 		add	r9, r3, r2, lsl #3
 249:src/command_parser.c ****                break;
 250:src/command_parser.c ****             
 251:src/command_parser.c **** 
 252:src/command_parser.c ****             default:
 253:src/command_parser.c ****                USART_rtos_sputs(&packet, msg, 102, stage_id+1); // error 102: incorrect variable
 254:src/command_parser.c ****                if (NEW_ITEM) {
 255:src/command_parser.c ****                    stages[stage_id].using = 0;
 256:src/command_parser.c ****                    stages[stage_id].order = 0;
 257:src/command_parser.c ****                    stages[stage_id].regime_lighting_id = 0;
 258:src/command_parser.c ****                    stages[stage_id].regime_ph_id = 0;
 259:src/command_parser.c ****                    stages[stage_id].length = 0;
 260:src/command_parser.c **** 
 261:src/command_parser.c ****                }
 262:src/command_parser.c ****                USART_rtos_wait_send(&packet);
 263:src/command_parser.c ****                return;
 264:src/command_parser.c ****         }
 265:src/command_parser.c ****         idx = find_next_char(pos, 0, term);
 701              		.loc 1 265 0
 702 00ea B046     		mov	r8, r6
 703              	.LBE8:
 220:src/command_parser.c ****         int v;
 704              		.loc 1 220 0
 705 00ec 4EE0     		b	.L50
 706              	.LVL94:
 707              	.L60:
 708              	.LBB9:
 223:src/command_parser.c ****             case 'l': //length in days
 709              		.loc 1 223 0
 710 00ee 2B78     		ldrb	r3, [r5]	@ zero_extendqisi2
 711 00f0 693B     		subs	r3, r3, #105
 712 00f2 072B     		cmp	r3, #7
 713 00f4 25D8     		bhi	.L51
 714 00f6 DFE803F0 		tbb	[pc, r3]
 715              	.L53:
 716 00fa 14       		.byte	(.L52-.L53)/2
 717 00fb 24       		.byte	(.L51-.L53)/2
 718 00fc 24       		.byte	(.L51-.L53)/2
 719 00fd 04       		.byte	(.L54-.L53)/2
 720 00fe 24       		.byte	(.L51-.L53)/2
 721 00ff 24       		.byte	(.L51-.L53)/2
 722 0100 1C       		.byte	(.L55-.L53)/2
 723 0101 0C       		.byte	(.L56-.L53)/2
 724              		.align	1
 725              	.L54:
 225:src/command_parser.c ****                v = str_to_int(pos, '\003'); 
 726              		.loc 1 225 0
 727 0102 0135     		adds	r5, r5, #1
 728              	.LVL95:
 226:src/command_parser.c ****                stages[stage_id].length = v;
 729              		.loc 1 226 0
 730 0104 2846     		mov	r0, r5
 731              	.LVL96:
 732 0106 5146     		mov	r1, r10
 733 0108 FFF7FEFF 		bl	str_to_int
 734              	.LVL97:
 227:src/command_parser.c ****                break;
 735              		.loc 1 227 0
 736 010c C9F80400 		str	r0, [r9, #4]
 228:src/command_parser.c **** 
 737              		.loc 1 228 0
 738 0110 31E0     		b	.L57
 739              	.LVL98:
 740              	.L56:
 231:src/command_parser.c ****                v = str_to_int(pos, '\003'); 
 741              		.loc 1 231 0
 742 0112 0135     		adds	r5, r5, #1
 743              	.LVL99:
 232:src/command_parser.c ****   //             printf("p=%d\n", v);
 744              		.loc 1 232 0
 745 0114 2846     		mov	r0, r5
 746              	.LVL100:
 747 0116 5146     		mov	r1, r10
 748 0118 FFF7FEFF 		bl	str_to_int
 749              	.LVL101:
 234:src/command_parser.c ****                break;
 750              		.loc 1 234 0
 751 011c C9F80C00 		str	r0, [r9, #12]
 235:src/command_parser.c **** 
 752              		.loc 1 235 0
 753 0120 29E0     		b	.L57
 754              	.LVL102:
 755              	.L52:
 238:src/command_parser.c ****                v = str_to_int(pos, '\003'); 
 756              		.loc 1 238 0
 757 0122 0135     		adds	r5, r5, #1
 758              	.LVL103:
 239:src/command_parser.c **** //               printf("g=%d\n", v);
 759              		.loc 1 239 0
 760 0124 2846     		mov	r0, r5
 761              	.LVL104:
 762 0126 5146     		mov	r1, r10
 763 0128 FFF7FEFF 		bl	str_to_int
 764              	.LVL105:
 241:src/command_parser.c ****                break;
 765              		.loc 1 241 0
 766 012c C9F81000 		str	r0, [r9, #16]
 242:src/command_parser.c **** 
 767              		.loc 1 242 0
 768 0130 21E0     		b	.L57
 769              	.LVL106:
 770              	.L55:
 245:src/command_parser.c ****                v = str_to_int(pos, '\003'); 
 771              		.loc 1 245 0
 772 0132 0135     		adds	r5, r5, #1
 773              	.LVL107:
 246:src/command_parser.c **** //               printf("g=%d\n", v);
 774              		.loc 1 246 0
 775 0134 2846     		mov	r0, r5
 776              	.LVL108:
 777 0136 5146     		mov	r1, r10
 778 0138 FFF7FEFF 		bl	str_to_int
 779              	.LVL109:
 248:src/command_parser.c ****                break;
 780              		.loc 1 248 0
 781 013c C9F80800 		str	r0, [r9, #8]
 249:src/command_parser.c ****             
 782              		.loc 1 249 0
 783 0140 19E0     		b	.L57
 784              	.LVL110:
 785              	.L51:
 253:src/command_parser.c ****                if (NEW_ITEM) {
 786              		.loc 1 253 0
 787 0142 28A8     		add	r0, sp, #160
 788              	.LVL111:
 789 0144 02A9     		add	r1, sp, #8
 790 0146 6622     		movs	r2, #102
 791 0148 5B46     		mov	r3, fp
 792 014a FFF7FEFF 		bl	USART_rtos_sputs
 793              	.LVL112:
 254:src/command_parser.c ****                    stages[stage_id].using = 0;
 794              		.loc 1 254 0
 795 014e 019B     		ldr	r3, [sp, #4]
 796 0150 6BB1     		cbz	r3, .L58
 255:src/command_parser.c ****                    stages[stage_id].order = 0;
 797              		.loc 1 255 0
 798 0152 40F20002 		movw	r2, #:lower16:stages
 799 0156 C0F20002 		movt	r2, #:upper16:stages
 800 015a 6000     		lsls	r0, r4, #1
 801 015c 0119     		adds	r1, r0, r4
 802 015e 02EBC101 		add	r1, r2, r1, lsl #3
 803 0162 0023     		movs	r3, #0
 804 0164 4B61     		str	r3, [r1, #20]
 256:src/command_parser.c ****                    stages[stage_id].regime_lighting_id = 0;
 805              		.loc 1 256 0
 806 0166 8B60     		str	r3, [r1, #8]
 257:src/command_parser.c ****                    stages[stage_id].regime_ph_id = 0;
 807              		.loc 1 257 0
 808 0168 0B61     		str	r3, [r1, #16]
 258:src/command_parser.c ****                    stages[stage_id].length = 0;
 809              		.loc 1 258 0
 810 016a CB60     		str	r3, [r1, #12]
 259:src/command_parser.c **** 
 811              		.loc 1 259 0
 812 016c 4B60     		str	r3, [r1, #4]
 813              	.L58:
 262:src/command_parser.c ****                return;
 814              		.loc 1 262 0
 815 016e 28A8     		add	r0, sp, #160
 816 0170 FFF7FEFF 		bl	USART_rtos_wait_send
 817              	.LVL113:
 263:src/command_parser.c ****         }
 818              		.loc 1 263 0
 819 0174 1CE0     		b	.L42
 820              	.LVL114:
 821              	.L57:
 822              		.loc 1 265 0
 823 0176 2846     		mov	r0, r5
 824              	.LVL115:
 825 0178 4146     		mov	r1, r8
 826 017a 3A46     		mov	r2, r7
 827 017c FFF7FEFF 		bl	find_next_char
 828              	.LVL116:
 266:src/command_parser.c ****         if (idx == -1) break;
 829              		.loc 1 266 0
 830 0180 B0F1FF3F 		cmp	r0, #-1
 831 0184 0BD0     		beq	.L59
 267:src/command_parser.c ****         pos+=idx+1;
 832              		.loc 1 267 0
 833 0186 431C     		adds	r3, r0, #1
 834 0188 1D44     		add	r5, r5, r3
 835              	.LVL117:
 836              	.LBE9:
 220:src/command_parser.c ****         int v;
 837              		.loc 1 220 0
 838 018a 0136     		adds	r6, r6, #1
 839              	.LVL118:
 840              	.L50:
 220:src/command_parser.c ****         int v;
 841              		.loc 1 220 0 is_stmt 0 discriminator 1
 842 018c 042E     		cmp	r6, #4
 843 018e CCBF     		ite	gt
 844 0190 0023     		movgt	r3, #0
 845 0192 0123     		movle	r3, #1
 846 0194 0028     		cmp	r0, #0
 847 0196 08BF     		it	eq
 848 0198 0023     		moveq	r3, #0
 849 019a 002B     		cmp	r3, #0
 850 019c A7D1     		bne	.L60
 851              	.L59:
 268:src/command_parser.c ****     }
 269:src/command_parser.c ****     USART_rtos_sputs(&packet, msg, 0, stage_id+1);
 852              		.loc 1 269 0 is_stmt 1
 853 019e 28A8     		add	r0, sp, #160
 854              	.LVL119:
 855 01a0 02A9     		add	r1, sp, #8
 856 01a2 0022     		movs	r2, #0
 857 01a4 5B46     		mov	r3, fp
 858 01a6 FFF7FEFF 		bl	USART_rtos_sputs
 859              	.LVL120:
 270:src/command_parser.c ****     USART_rtos_wait_send(&packet);
 860              		.loc 1 270 0
 861 01aa 28A8     		add	r0, sp, #160
 862 01ac FFF7FEFF 		bl	USART_rtos_wait_send
 863              	.LVL121:
 864              	.L42:
 271:src/command_parser.c **** }
 865              		.loc 1 271 0
 866 01b0 2DB0     		add	sp, sp, #180
 867              		@ sp needed
 868 01b2 BDE8F08F 		pop	{r4, r5, r6, r7, r8, r9, r10, fp, pc}
 869              		.cfi_endproc
 870              	.LFE116:
 872 01b6 00BF     		.section	.text.command_set,"ax",%progbits
 873              		.align	2
 874              		.global	command_set
 875              		.thumb
 876              		.thumb_func
 878              	command_set:
 879              	.LFB117:
 272:src/command_parser.c **** 
 273:src/command_parser.c **** void command_set(char *pos, char term) {
 880              		.loc 1 273 0
 881              		.cfi_startproc
 882              		@ args = 0, pretend = 0, frame = 16
 883              		@ frame_needed = 0, uses_anonymous_args = 0
 884              	.LVL122:
 885 0000 30B5     		push	{r4, r5, lr}
 886              	.LCFI6:
 887              		.cfi_def_cfa_offset 12
 888              		.cfi_offset 4, -12
 889              		.cfi_offset 5, -8
 890              		.cfi_offset 14, -4
 891 0002 85B0     		sub	sp, sp, #20
 892              	.LCFI7:
 893              		.cfi_def_cfa_offset 32
 894 0004 0C46     		mov	r4, r1
 274:src/command_parser.c ****     USART_rtos_packet packet;
 275:src/command_parser.c ****     packet.USARTx_rtos = USARTOutput_rtos;
 895              		.loc 1 275 0
 896 0006 40F20003 		movw	r3, #:lower16:USARTOutput_rtos
 897 000a C0F20003 		movt	r3, #:upper16:USARTOutput_rtos
 898 000e 1B68     		ldr	r3, [r3]
 899 0010 0093     		str	r3, [sp]
 276:src/command_parser.c ****     pos+=4;
 900              		.loc 1 276 0
 901 0012 051D     		adds	r5, r0, #4
 902              	.LVL123:
 277:src/command_parser.c **** 
 278:src/command_parser.c ****     if (str_compare(pos, "REGIME_PH\003", term)) {
 903              		.loc 1 278 0
 904 0014 2846     		mov	r0, r5
 905 0016 40F20001 		movw	r1, #:lower16:.LC2
 906              	.LVL124:
 907 001a C0F20001 		movt	r1, #:upper16:.LC2
 908 001e 2246     		mov	r2, r4
 909 0020 FFF7FEFF 		bl	str_compare
 910              	.LVL125:
 911 0024 20B1     		cbz	r0, .L64
 279:src/command_parser.c ****         command_set_regime_ph(pos, term);
 912              		.loc 1 279 0
 913 0026 2846     		mov	r0, r5
 914 0028 2146     		mov	r1, r4
 915 002a FFF7FEFF 		bl	command_set_regime_ph
 916              	.LVL126:
 917 002e 20E0     		b	.L63
 918              	.L64:
 280:src/command_parser.c ****     }
 281:src/command_parser.c **** 
 282:src/command_parser.c ****     else if (str_compare(pos, "STAGE\003", term)) {
 919              		.loc 1 282 0
 920 0030 2846     		mov	r0, r5
 921 0032 40F20001 		movw	r1, #:lower16:.LC3
 922 0036 C0F20001 		movt	r1, #:upper16:.LC3
 923 003a 2246     		mov	r2, r4
 924 003c FFF7FEFF 		bl	str_compare
 925              	.LVL127:
 926 0040 20B1     		cbz	r0, .L66
 283:src/command_parser.c ****         command_set_stage(pos, term);
 927              		.loc 1 283 0
 928 0042 2846     		mov	r0, r5
 929 0044 2146     		mov	r1, r4
 930 0046 FFF7FEFF 		bl	command_set_stage
 931              	.LVL128:
 932 004a 12E0     		b	.L63
 933              	.L66:
 284:src/command_parser.c ****     }
 285:src/command_parser.c **** 
 286:src/command_parser.c ****     else if (str_compare(pos, "REGIME_LIGHTING\003", term)) {
 934              		.loc 1 286 0
 935 004c 2846     		mov	r0, r5
 936 004e 40F20001 		movw	r1, #:lower16:.LC4
 937 0052 C0F20001 		movt	r1, #:upper16:.LC4
 938 0056 2246     		mov	r2, r4
 939 0058 FFF7FEFF 		bl	str_compare
 940              	.LVL129:
 941 005c 48B9     		cbnz	r0, .L63
 287:src/command_parser.c ****     }
 288:src/command_parser.c **** 
 289:src/command_parser.c ****     else {
 290:src/command_parser.c ****         USART_rtos_puts(&packet, "{'object_type': '', method: 'set', error: 10, 'object_id': -1}\r\
 942              		.loc 1 290 0
 943 005e 6846     		mov	r0, sp
 944 0060 40F20001 		movw	r1, #:lower16:.LC5
 945 0064 C0F20001 		movt	r1, #:upper16:.LC5
 946 0068 FFF7FEFF 		bl	USART_rtos_puts
 947              	.LVL130:
 291:src/command_parser.c ****         USART_rtos_wait_send(&packet);
 948              		.loc 1 291 0
 949 006c 6846     		mov	r0, sp
 950 006e FFF7FEFF 		bl	USART_rtos_wait_send
 951              	.LVL131:
 952              	.L63:
 292:src/command_parser.c ****         return;
 293:src/command_parser.c ****     }
 294:src/command_parser.c **** 
 295:src/command_parser.c **** }
 953              		.loc 1 295 0
 954 0072 05B0     		add	sp, sp, #20
 955              		@ sp needed
 956 0074 30BD     		pop	{r4, r5, pc}
 957              		.cfi_endproc
 958              	.LFE117:
 960 0076 00BF     		.section	.text.command_del_regime_ph,"ax",%progbits
 961              		.align	2
 962              		.global	command_del_regime_ph
 963              		.thumb
 964              		.thumb_func
 966              	command_del_regime_ph:
 967              	.LFB118:
 296:src/command_parser.c **** 
 297:src/command_parser.c **** void command_del_regime_ph (char *pos, char term) {
 968              		.loc 1 297 0
 969              		.cfi_startproc
 970              		@ args = 0, pretend = 0, frame = 16
 971              		@ frame_needed = 0, uses_anonymous_args = 0
 972              	.LVL132:
 973 0000 10B5     		push	{r4, lr}
 974              	.LCFI8:
 975              		.cfi_def_cfa_offset 8
 976              		.cfi_offset 4, -8
 977              		.cfi_offset 14, -4
 978 0002 84B0     		sub	sp, sp, #16
 979              	.LCFI9:
 980              		.cfi_def_cfa_offset 24
 981 0004 0446     		mov	r4, r0
 982 0006 0A46     		mov	r2, r1
 298:src/command_parser.c ****     USART_rtos_packet packet;
 299:src/command_parser.c ****     packet.USARTx_rtos = USARTOutput_rtos;
 983              		.loc 1 299 0
 984 0008 40F20003 		movw	r3, #:lower16:USARTOutput_rtos
 985 000c C0F20003 		movt	r3, #:upper16:USARTOutput_rtos
 986 0010 1B68     		ldr	r3, [r3]
 987 0012 0093     		str	r3, [sp]
 300:src/command_parser.c **** 
 301:src/command_parser.c ****     int idx = find_next_char(pos, 0, term);
 988              		.loc 1 301 0
 989 0014 0021     		movs	r1, #0
 990              	.LVL133:
 991 0016 FFF7FEFF 		bl	find_next_char
 992              	.LVL134:
 302:src/command_parser.c ****     pos+=idx+1;
 993              		.loc 1 302 0
 994 001a 0130     		adds	r0, r0, #1
 995              	.LVL135:
 303:src/command_parser.c ****     int regime_id = str_to_int(pos, '\003')-1;
 996              		.loc 1 303 0
 997 001c 2044     		add	r0, r0, r4
 998              	.LVL136:
 999 001e 0321     		movs	r1, #3
 1000 0020 FFF7FEFF 		bl	str_to_int
 1001              	.LVL137:
 1002 0024 441E     		subs	r4, r0, #1
 1003              	.LVL138:
 304:src/command_parser.c **** 
 305:src/command_parser.c ****     if (!(regime_id>=0 && regime_id < MAX_REGIME_PH)) {
 1004              		.loc 1 305 0
 1005 0026 092C     		cmp	r4, #9
 1006 0028 07D9     		bls	.L69
 306:src/command_parser.c ****         USART_rtos_puts(&packet, "Error: Incorrect REGIME_PH id\r\n");
 1007              		.loc 1 306 0
 1008 002a 6846     		mov	r0, sp
 1009 002c 40F20001 		movw	r1, #:lower16:.LC6
 1010 0030 C0F20001 		movt	r1, #:upper16:.LC6
 1011 0034 FFF7FEFF 		bl	USART_rtos_puts
 1012              	.LVL139:
 1013 0038 12E0     		b	.L68
 1014              	.L69:
 307:src/command_parser.c ****         return;
 308:src/command_parser.c ****     }
 309:src/command_parser.c **** 
 310:src/command_parser.c ****     USART_rtos_sputs(&packet, "DEBUG: DELETING REGIME_ID %d\r\n", regime_id);
 1015              		.loc 1 310 0
 1016 003a 6846     		mov	r0, sp
 1017 003c 40F20001 		movw	r1, #:lower16:.LC7
 1018 0040 C0F20001 		movt	r1, #:upper16:.LC7
 1019 0044 2246     		mov	r2, r4
 1020 0046 FFF7FEFF 		bl	USART_rtos_sputs
 1021              	.LVL140:
 311:src/command_parser.c ****     REGIME_PH[regime_id][0] = -1;
 1022              		.loc 1 311 0
 1023 004a 40F20003 		movw	r3, #:lower16:.LANCHOR0
 1024 004e C0F20003 		movt	r3, #:upper16:.LANCHOR0
 1025 0052 4FF0FF32 		mov	r2, #-1
 1026 0056 43F83420 		str	r2, [r3, r4, lsl #3]
 312:src/command_parser.c ****     REGIME_PH[regime_id][1] = -1;
 1027              		.loc 1 312 0
 1028 005a 03EBC404 		add	r4, r3, r4, lsl #3
 1029              	.LVL141:
 1030 005e 6260     		str	r2, [r4, #4]
 1031              	.L68:
 313:src/command_parser.c **** }
 1032              		.loc 1 313 0
 1033 0060 04B0     		add	sp, sp, #16
 1034              		@ sp needed
 1035 0062 10BD     		pop	{r4, pc}
 1036              		.cfi_endproc
 1037              	.LFE118:
 1039              		.section	.text.command_del_stage,"ax",%progbits
 1040              		.align	2
 1041              		.global	command_del_stage
 1042              		.thumb
 1043              		.thumb_func
 1045              	command_del_stage:
 1046              	.LFB119:
 314:src/command_parser.c **** 
 315:src/command_parser.c **** void command_del_stage (char *pos, char term) {
 1047              		.loc 1 315 0
 1048              		.cfi_startproc
 1049              		@ args = 0, pretend = 0, frame = 16
 1050              		@ frame_needed = 0, uses_anonymous_args = 0
 1051              	.LVL142:
 1052 0000 30B5     		push	{r4, r5, lr}
 1053              	.LCFI10:
 1054              		.cfi_def_cfa_offset 12
 1055              		.cfi_offset 4, -12
 1056              		.cfi_offset 5, -8
 1057              		.cfi_offset 14, -4
 1058 0002 85B0     		sub	sp, sp, #20
 1059              	.LCFI11:
 1060              		.cfi_def_cfa_offset 32
 1061 0004 0446     		mov	r4, r0
 1062 0006 0A46     		mov	r2, r1
 316:src/command_parser.c ****     USART_rtos_packet packet;
 317:src/command_parser.c ****     packet.USARTx_rtos = USARTOutput_rtos;
 1063              		.loc 1 317 0
 1064 0008 40F20003 		movw	r3, #:lower16:USARTOutput_rtos
 1065 000c C0F20003 		movt	r3, #:upper16:USARTOutput_rtos
 1066 0010 1B68     		ldr	r3, [r3]
 1067 0012 0093     		str	r3, [sp]
 318:src/command_parser.c **** 
 319:src/command_parser.c ****     int idx = find_next_char(pos, 0, term);
 1068              		.loc 1 319 0
 1069 0014 0021     		movs	r1, #0
 1070              	.LVL143:
 1071 0016 FFF7FEFF 		bl	find_next_char
 1072              	.LVL144:
 320:src/command_parser.c ****     pos+=idx+1;
 1073              		.loc 1 320 0
 1074 001a 0130     		adds	r0, r0, #1
 1075              	.LVL145:
 321:src/command_parser.c **** 
 322:src/command_parser.c ****     int stage_id = str_to_int(pos, '\003')-1;
 1076              		.loc 1 322 0
 1077 001c 2044     		add	r0, r0, r4
 1078              	.LVL146:
 1079 001e 0321     		movs	r1, #3
 1080 0020 FFF7FEFF 		bl	str_to_int
 1081              	.LVL147:
 1082 0024 0246     		mov	r2, r0
 1083 0026 431E     		subs	r3, r0, #1
 1084              	.LVL148:
 323:src/command_parser.c **** 
 324:src/command_parser.c ****     if (!(stage_id >= 0 && stage_id <MAX_STAGES)) {
 1085              		.loc 1 324 0
 1086 0028 092B     		cmp	r3, #9
 1087 002a 07D9     		bls	.L72
 325:src/command_parser.c **** 
 326:src/command_parser.c ****         USART_rtos_puts(&packet, "Error: Incorrect stage id\r\n");
 1088              		.loc 1 326 0
 1089 002c 6846     		mov	r0, sp
 1090 002e 40F20001 		movw	r1, #:lower16:.LC8
 1091 0032 C0F20001 		movt	r1, #:upper16:.LC8
 1092 0036 FFF7FEFF 		bl	USART_rtos_puts
 1093              	.LVL149:
 1094 003a 14E0     		b	.L71
 1095              	.LVL150:
 1096              	.L72:
 327:src/command_parser.c ****         return;
 328:src/command_parser.c ****     }
 329:src/command_parser.c **** 
 330:src/command_parser.c ****     stages[stage_id].using = 0;
 1097              		.loc 1 330 0
 1098 003c 40F20004 		movw	r4, #:lower16:stages
 1099 0040 C0F20004 		movt	r4, #:upper16:stages
 1100 0044 5800     		lsls	r0, r3, #1
 1101 0046 C518     		adds	r5, r0, r3
 1102 0048 04EBC505 		add	r5, r4, r5, lsl #3
 1103 004c 0021     		movs	r1, #0
 1104 004e 6961     		str	r1, [r5, #20]
 331:src/command_parser.c ****     stages[stage_id].order = 0;
 1105              		.loc 1 331 0
 1106 0050 A960     		str	r1, [r5, #8]
 332:src/command_parser.c ****     stages[stage_id].regime_lighting_id = 0;
 1107              		.loc 1 332 0
 1108 0052 2961     		str	r1, [r5, #16]
 333:src/command_parser.c ****     stages[stage_id].regime_ph_id = 0;
 1109              		.loc 1 333 0
 1110 0054 E960     		str	r1, [r5, #12]
 334:src/command_parser.c ****     stages[stage_id].length = 0;
 1111              		.loc 1 334 0
 1112 0056 6960     		str	r1, [r5, #4]
 335:src/command_parser.c **** 
 336:src/command_parser.c ****     USART_rtos_sputs(&packet, "Succesfully deleted stage id: %d\r\n", stage_id+1);
 1113              		.loc 1 336 0
 1114 0058 6846     		mov	r0, sp
 1115 005a 40F20001 		movw	r1, #:lower16:.LC9
 1116 005e C0F20001 		movt	r1, #:upper16:.LC9
 1117 0062 FFF7FEFF 		bl	USART_rtos_sputs
 1118              	.LVL151:
 1119              	.L71:
 337:src/command_parser.c **** }
 1120              		.loc 1 337 0
 1121 0066 05B0     		add	sp, sp, #20
 1122              		@ sp needed
 1123 0068 30BD     		pop	{r4, r5, pc}
 1124              		.cfi_endproc
 1125              	.LFE119:
 1127 006a 00BF     		.section	.text.command_del,"ax",%progbits
 1128              		.align	2
 1129              		.global	command_del
 1130              		.thumb
 1131              		.thumb_func
 1133              	command_del:
 1134              	.LFB120:
 338:src/command_parser.c **** 
 339:src/command_parser.c **** void command_del(char *pos, char term) {
 1135              		.loc 1 339 0
 1136              		.cfi_startproc
 1137              		@ args = 0, pretend = 0, frame = 16
 1138              		@ frame_needed = 0, uses_anonymous_args = 0
 1139              	.LVL152:
 1140 0000 30B5     		push	{r4, r5, lr}
 1141              	.LCFI12:
 1142              		.cfi_def_cfa_offset 12
 1143              		.cfi_offset 4, -12
 1144              		.cfi_offset 5, -8
 1145              		.cfi_offset 14, -4
 1146 0002 85B0     		sub	sp, sp, #20
 1147              	.LCFI13:
 1148              		.cfi_def_cfa_offset 32
 1149 0004 0D46     		mov	r5, r1
 340:src/command_parser.c ****     USART_rtos_packet packet;
 341:src/command_parser.c ****     packet.USARTx_rtos = USARTOutput_rtos;
 1150              		.loc 1 341 0
 1151 0006 40F20003 		movw	r3, #:lower16:USARTOutput_rtos
 1152 000a C0F20003 		movt	r3, #:upper16:USARTOutput_rtos
 1153 000e 1B68     		ldr	r3, [r3]
 1154 0010 0093     		str	r3, [sp]
 342:src/command_parser.c ****     pos+=4;
 1155              		.loc 1 342 0
 1156 0012 041D     		adds	r4, r0, #4
 1157              	.LVL153:
 343:src/command_parser.c ****     USART_puts(USARTOutput_rtos->id, "COOL\r\n");
 1158              		.loc 1 343 0
 1159 0014 9868     		ldr	r0, [r3, #8]
 1160 0016 40F20001 		movw	r1, #:lower16:.LC10
 1161              	.LVL154:
 1162 001a C0F20001 		movt	r1, #:upper16:.LC10
 1163 001e FFF7FEFF 		bl	USART_puts
 1164              	.LVL155:
 344:src/command_parser.c **** 
 345:src/command_parser.c ****     if (str_compare(pos, "REGIME_PH\003", term)) {
 1165              		.loc 1 345 0
 1166 0022 2046     		mov	r0, r4
 1167 0024 40F20001 		movw	r1, #:lower16:.LC2
 1168 0028 C0F20001 		movt	r1, #:upper16:.LC2
 1169 002c 2A46     		mov	r2, r5
 1170 002e FFF7FEFF 		bl	str_compare
 1171              	.LVL156:
 1172 0032 20B1     		cbz	r0, .L75
 346:src/command_parser.c ****         command_del_regime_ph(pos, term);
 1173              		.loc 1 346 0
 1174 0034 2046     		mov	r0, r4
 1175 0036 2946     		mov	r1, r5
 1176 0038 FFF7FEFF 		bl	command_del_regime_ph
 1177              	.LVL157:
 1178 003c 21E0     		b	.L74
 1179              	.L75:
 347:src/command_parser.c ****     }
 348:src/command_parser.c **** 
 349:src/command_parser.c ****     else if (str_compare(pos, "STAGE\003", term)) {
 1180              		.loc 1 349 0
 1181 003e 2046     		mov	r0, r4
 1182 0040 40F20001 		movw	r1, #:lower16:.LC3
 1183 0044 C0F20001 		movt	r1, #:upper16:.LC3
 1184 0048 2A46     		mov	r2, r5
 1185 004a FFF7FEFF 		bl	str_compare
 1186              	.LVL158:
 1187 004e 20B1     		cbz	r0, .L77
 350:src/command_parser.c ****         command_del_stage(pos, term);
 1188              		.loc 1 350 0
 1189 0050 2046     		mov	r0, r4
 1190 0052 2946     		mov	r1, r5
 1191 0054 FFF7FEFF 		bl	command_del_stage
 1192              	.LVL159:
 1193 0058 13E0     		b	.L74
 1194              	.L77:
 351:src/command_parser.c ****     }
 352:src/command_parser.c **** 
 353:src/command_parser.c ****     else if (str_compare(pos, "REGIME_LIGHTING\003", term)) {
 1195              		.loc 1 353 0
 1196 005a 2046     		mov	r0, r4
 1197 005c 40F20001 		movw	r1, #:lower16:.LC4
 1198 0060 C0F20001 		movt	r1, #:upper16:.LC4
 1199 0064 2A46     		mov	r2, r5
 1200 0066 FFF7FEFF 		bl	str_compare
 1201              	.LVL160:
 1202 006a 50B9     		cbnz	r0, .L74
 354:src/command_parser.c **** //        printf("OK LIGHTING SHIT\n");
 355:src/command_parser.c ****     }
 356:src/command_parser.c **** 
 357:src/command_parser.c ****     else {
 358:src/command_parser.c ****         USART_rtos_sputs(&packet, "Error: Unknown Object '%s'\r\n", pos);
 1203              		.loc 1 358 0
 1204 006c 6846     		mov	r0, sp
 1205 006e 40F20001 		movw	r1, #:lower16:.LC11
 1206 0072 C0F20001 		movt	r1, #:upper16:.LC11
 1207 0076 2246     		mov	r2, r4
 1208 0078 FFF7FEFF 		bl	USART_rtos_sputs
 1209              	.LVL161:
 359:src/command_parser.c ****         USART_rtos_wait_send(&packet);
 1210              		.loc 1 359 0
 1211 007c 6846     		mov	r0, sp
 1212 007e FFF7FEFF 		bl	USART_rtos_wait_send
 1213              	.LVL162:
 1214              	.L74:
 360:src/command_parser.c ****     }
 361:src/command_parser.c **** }
 1215              		.loc 1 361 0
 1216 0082 05B0     		add	sp, sp, #20
 1217              		@ sp needed
 1218 0084 30BD     		pop	{r4, r5, pc}
 1219              		.cfi_endproc
 1220              	.LFE120:
 1222 0086 00BF     		.section	.text.stage_print,"ax",%progbits
 1223              		.align	2
 1224              		.global	stage_print
 1225              		.thumb
 1226              		.thumb_func
 1228              	stage_print:
 1229              	.LFB121:
 362:src/command_parser.c **** 
 363:src/command_parser.c **** void stage_print(Stage *stage) {
 1230              		.loc 1 363 0
 1231              		.cfi_startproc
 1232              		@ args = 0, pretend = 0, frame = 120
 1233              		@ frame_needed = 0, uses_anonymous_args = 0
 1234              	.LVL163:
 1235 0000 00B5     		push	{lr}
 1236              	.LCFI14:
 1237              		.cfi_def_cfa_offset 4
 1238              		.cfi_offset 14, -4
 1239 0002 A3B0     		sub	sp, sp, #140
 1240              	.LCFI15:
 1241              		.cfi_def_cfa_offset 144
 364:src/command_parser.c ****     USART_rtos_packet packet;
 365:src/command_parser.c ****     packet.USARTx_rtos = USARTOutput_rtos;
 1242              		.loc 1 365 0
 1243 0004 40F20003 		movw	r3, #:lower16:USARTOutput_rtos
 1244 0008 C0F20003 		movt	r3, #:upper16:USARTOutput_rtos
 1245 000c 1B68     		ldr	r3, [r3]
 1246 000e 1E93     		str	r3, [sp, #120]
 366:src/command_parser.c ****     char buffer[100];
 367:src/command_parser.c ****     packet.msg = buffer;
 1247              		.loc 1 367 0
 1248 0010 05AB     		add	r3, sp, #20
 1249 0012 1F93     		str	r3, [sp, #124]
 368:src/command_parser.c **** 
 369:src/command_parser.c ****     USART_rtos_sputs(
 1250              		.loc 1 369 0
 1251 0014 0268     		ldr	r2, [r0]
 1252 0016 4368     		ldr	r3, [r0, #4]
 1253 0018 8168     		ldr	r1, [r0, #8]
 1254 001a 0091     		str	r1, [sp]
 1255 001c C168     		ldr	r1, [r0, #12]
 1256 001e 0191     		str	r1, [sp, #4]
 1257 0020 0169     		ldr	r1, [r0, #16]
 1258 0022 0291     		str	r1, [sp, #8]
 1259 0024 4169     		ldr	r1, [r0, #20]
 1260 0026 0391     		str	r1, [sp, #12]
 1261 0028 1EA8     		add	r0, sp, #120
 1262              	.LVL164:
 1263 002a 40F20001 		movw	r1, #:lower16:.LC12
 1264 002e C0F20001 		movt	r1, #:upper16:.LC12
 1265 0032 FFF7FEFF 		bl	USART_rtos_sputs
 1266              	.LVL165:
 370:src/command_parser.c ****             &packet,
 371:src/command_parser.c ****             "{'id': %d, 'length': %d, 'order':%d, 'ph_id': %d, 'lighting_id':%d, 'using':%d}\r\n", 
 372:src/command_parser.c ****             stage->id,
 373:src/command_parser.c ****             stage->length,
 374:src/command_parser.c ****             stage->order,
 375:src/command_parser.c ****             stage->regime_ph_id,
 376:src/command_parser.c ****             stage->regime_lighting_id,
 377:src/command_parser.c ****             stage->using
 378:src/command_parser.c ****     );
 379:src/command_parser.c ****     USART_rtos_wait_send(&packet);
 1267              		.loc 1 379 0
 1268 0036 1EA8     		add	r0, sp, #120
 1269 0038 FFF7FEFF 		bl	USART_rtos_wait_send
 1270              	.LVL166:
 380:src/command_parser.c **** 
 381:src/command_parser.c **** }
 1271              		.loc 1 381 0
 1272 003c 23B0     		add	sp, sp, #140
 1273              		@ sp needed
 1274 003e 5DF804FB 		ldr	pc, [sp], #4
 1275              		.cfi_endproc
 1276              	.LFE121:
 1278 0042 00BF     		.section	.text.regime_ph_print,"ax",%progbits
 1279              		.align	2
 1280              		.global	regime_ph_print
 1281              		.thumb
 1282              		.thumb_func
 1284              	regime_ph_print:
 1285              	.LFB122:
 382:src/command_parser.c **** 
 383:src/command_parser.c **** void regime_ph_print(int *regime_ph, int regime_id) {
 1286              		.loc 1 383 0
 1287              		.cfi_startproc
 1288              		@ args = 0, pretend = 0, frame = 72
 1289              		@ frame_needed = 0, uses_anonymous_args = 0
 1290              	.LVL167:
 1291 0000 00B5     		push	{lr}
 1292              	.LCFI16:
 1293              		.cfi_def_cfa_offset 4
 1294              		.cfi_offset 14, -4
 1295 0002 95B0     		sub	sp, sp, #84
 1296              	.LCFI17:
 1297              		.cfi_def_cfa_offset 88
 384:src/command_parser.c ****     USART_rtos_packet packet;
 385:src/command_parser.c ****     packet.USARTx_rtos = USARTOutput_rtos;
 1298              		.loc 1 385 0
 1299 0004 40F20003 		movw	r3, #:lower16:USARTOutput_rtos
 1300 0008 C0F20003 		movt	r3, #:upper16:USARTOutput_rtos
 1301 000c 1B68     		ldr	r3, [r3]
 1302 000e 1093     		str	r3, [sp, #64]
 386:src/command_parser.c ****     char buffer[50];
 387:src/command_parser.c ****     packet.msg = buffer;
 1303              		.loc 1 387 0
 1304 0010 03AB     		add	r3, sp, #12
 1305 0012 1193     		str	r3, [sp, #68]
 388:src/command_parser.c **** 
 389:src/command_parser.c ****     USART_rtos_sputs(&packet, "{'id': %d, 'ph': %d, 'delay': %d}\r\n", regime_id+1, regime_ph[0], r
 1306              		.loc 1 389 0
 1307 0014 4A1C     		adds	r2, r1, #1
 1308 0016 0368     		ldr	r3, [r0]
 1309 0018 4068     		ldr	r0, [r0, #4]
 1310              	.LVL168:
 1311 001a 0090     		str	r0, [sp]
 1312 001c 10A8     		add	r0, sp, #64
 1313 001e 40F20001 		movw	r1, #:lower16:.LC13
 1314              	.LVL169:
 1315 0022 C0F20001 		movt	r1, #:upper16:.LC13
 1316 0026 FFF7FEFF 		bl	USART_rtos_sputs
 1317              	.LVL170:
 390:src/command_parser.c ****     USART_rtos_wait_send(&packet);
 1318              		.loc 1 390 0
 1319 002a 10A8     		add	r0, sp, #64
 1320 002c FFF7FEFF 		bl	USART_rtos_wait_send
 1321              	.LVL171:
 391:src/command_parser.c **** 
 392:src/command_parser.c **** }
 1322              		.loc 1 392 0
 1323 0030 15B0     		add	sp, sp, #84
 1324              		@ sp needed
 1325 0032 5DF804FB 		ldr	pc, [sp], #4
 1326              		.cfi_endproc
 1327              	.LFE122:
 1329 0036 00BF     		.section	.text.command_get,"ax",%progbits
 1330              		.align	2
 1331              		.global	command_get
 1332              		.thumb
 1333              		.thumb_func
 1335              	command_get:
 1336              	.LFB123:
 393:src/command_parser.c **** 
 394:src/command_parser.c **** void command_get(char *pos, char term) {
 1337              		.loc 1 394 0
 1338              		.cfi_startproc
 1339              		@ args = 0, pretend = 0, frame = 16
 1340              		@ frame_needed = 0, uses_anonymous_args = 0
 1341              	.LVL172:
 1342 0000 F0B5     		push	{r4, r5, r6, r7, lr}
 1343              	.LCFI18:
 1344              		.cfi_def_cfa_offset 20
 1345              		.cfi_offset 4, -20
 1346              		.cfi_offset 5, -16
 1347              		.cfi_offset 6, -12
 1348              		.cfi_offset 7, -8
 1349              		.cfi_offset 14, -4
 1350 0002 85B0     		sub	sp, sp, #20
 1351              	.LCFI19:
 1352              		.cfi_def_cfa_offset 40
 1353 0004 0E46     		mov	r6, r1
 395:src/command_parser.c **** 
 396:src/command_parser.c ****     USART_rtos_packet packet;
 397:src/command_parser.c ****     packet.USARTx_rtos = USARTOutput_rtos;
 1354              		.loc 1 397 0
 1355 0006 40F20003 		movw	r3, #:lower16:USARTOutput_rtos
 1356 000a C0F20003 		movt	r3, #:upper16:USARTOutput_rtos
 1357 000e 1B68     		ldr	r3, [r3]
 1358 0010 0093     		str	r3, [sp]
 398:src/command_parser.c **** 
 399:src/command_parser.c ****     pos+=4; //moves cursor 4 chars to right to access next word. ex( |get ...  --> get |...) 
 1359              		.loc 1 399 0
 1360 0012 051D     		adds	r5, r0, #4
 1361              	.LVL173:
 400:src/command_parser.c **** 
 401:src/command_parser.c ****     if (str_compare(pos, "REGIME_PH\003", term)) {
 1362              		.loc 1 401 0
 1363 0014 2846     		mov	r0, r5
 1364 0016 40F20001 		movw	r1, #:lower16:.LC2
 1365              	.LVL174:
 1366 001a C0F20001 		movt	r1, #:upper16:.LC2
 1367 001e 3246     		mov	r2, r6
 1368 0020 FFF7FEFF 		bl	str_compare
 1369              	.LVL175:
 1370 0024 A0B3     		cbz	r0, .L81
 1371              	.LBB10:
 402:src/command_parser.c **** 
 403:src/command_parser.c ****         int idx = find_next_char(pos, 0, term);
 1372              		.loc 1 403 0
 1373 0026 2846     		mov	r0, r5
 1374 0028 0021     		movs	r1, #0
 1375 002a 3246     		mov	r2, r6
 1376 002c FFF7FEFF 		bl	find_next_char
 1377              	.LVL176:
 404:src/command_parser.c ****         pos+=idx+1;
 1378              		.loc 1 404 0
 1379 0030 0130     		adds	r0, r0, #1
 1380              	.LVL177:
 1381 0032 0544     		add	r5, r5, r0
 1382              	.LVL178:
 405:src/command_parser.c ****         int regime_id = str_to_int(pos, '\003')-1;
 1383              		.loc 1 405 0
 1384 0034 2846     		mov	r0, r5
 1385              	.LVL179:
 1386 0036 0321     		movs	r1, #3
 1387 0038 FFF7FEFF 		bl	str_to_int
 1388              	.LVL180:
 1389 003c 411E     		subs	r1, r0, #1
 1390              	.LVL181:
 406:src/command_parser.c **** 
 407:src/command_parser.c ****         if (regime_id >= 0 && regime_id <MAX_REGIME_PH) {
 1391              		.loc 1 407 0
 1392 003e 0929     		cmp	r1, #9
 1393 0040 08D8     		bhi	.L82
 408:src/command_parser.c ****             regime_ph_print(REGIME_PH[regime_id], regime_id);
 1394              		.loc 1 408 0
 1395 0042 40F20000 		movw	r0, #:lower16:.LANCHOR0
 1396 0046 C0F20000 		movt	r0, #:upper16:.LANCHOR0
 1397 004a 00EBC100 		add	r0, r0, r1, lsl #3
 1398 004e FFF7FEFF 		bl	regime_ph_print
 1399              	.LVL182:
 1400 0052 1DE0     		b	.L81
 1401              	.LVL183:
 1402              	.L82:
 409:src/command_parser.c **** 
 410:src/command_parser.c ****         }
 411:src/command_parser.c ****         else if(regime_id == -1) {
 1403              		.loc 1 411 0
 1404 0054 B1F1FF3F 		cmp	r1, #-1
 1405 0058 0FD1     		bne	.L95
 1406 005a 06E0     		b	.L93
 1407              	.LVL184:
 1408              	.L85:
 1409              	.LBB11:
 412:src/command_parser.c ****             int i;
 413:src/command_parser.c ****             for(i=0; i<MAX_REGIME_PH; i++) {
 414:src/command_parser.c ****                 regime_ph_print(REGIME_PH[i], i);
 1410              		.loc 1 414 0 discriminator 2
 1411 005c 07EBC400 		add	r0, r7, r4, lsl #3
 1412 0060 2146     		mov	r1, r4
 1413 0062 FFF7FEFF 		bl	regime_ph_print
 1414              	.LVL185:
 413:src/command_parser.c ****                 regime_ph_print(REGIME_PH[i], i);
 1415              		.loc 1 413 0 discriminator 2
 1416 0066 0134     		adds	r4, r4, #1
 1417              	.LVL186:
 1418 0068 04E0     		b	.L83
 1419              	.LVL187:
 1420              	.L93:
 1421              	.LBE11:
 1422 006a 0024     		movs	r4, #0
 1423              	.LBB12:
 1424              		.loc 1 414 0
 1425 006c 40F20007 		movw	r7, #:lower16:.LANCHOR0
 1426 0070 C0F20007 		movt	r7, #:upper16:.LANCHOR0
 1427              	.LVL188:
 1428              	.L83:
 413:src/command_parser.c ****                 regime_ph_print(REGIME_PH[i], i);
 1429              		.loc 1 413 0 discriminator 1
 1430 0074 092C     		cmp	r4, #9
 1431 0076 F1DD     		ble	.L85
 1432 0078 0AE0     		b	.L81
 1433              	.LVL189:
 1434              	.L95:
 1435              	.LBE12:
 415:src/command_parser.c ****             }
 416:src/command_parser.c ****         }
 417:src/command_parser.c **** 
 418:src/command_parser.c ****         else {
 419:src/command_parser.c **** 
 420:src/command_parser.c ****             USART_rtos_puts(&packet, "Error: Invalid regime_ph_id\r\n");
 1436              		.loc 1 420 0
 1437 007a 6846     		mov	r0, sp
 1438 007c 40F20001 		movw	r1, #:lower16:.LC14
 1439              	.LVL190:
 1440 0080 C0F20001 		movt	r1, #:upper16:.LC14
 1441 0084 FFF7FEFF 		bl	USART_rtos_puts
 1442              	.LVL191:
 421:src/command_parser.c ****             USART_rtos_wait_send(&packet);
 1443              		.loc 1 421 0
 1444 0088 6846     		mov	r0, sp
 1445 008a FFF7FEFF 		bl	USART_rtos_wait_send
 1446              	.LVL192:
 422:src/command_parser.c ****             return;
 1447              		.loc 1 422 0
 1448 008e 3CE0     		b	.L80
 1449              	.L81:
 1450              	.LBE10:
 423:src/command_parser.c ****         }
 424:src/command_parser.c **** 
 425:src/command_parser.c ****     }
 426:src/command_parser.c **** 
 427:src/command_parser.c ****     if (str_compare(pos, "STAGE\003", term)) {
 1451              		.loc 1 427 0
 1452 0090 2846     		mov	r0, r5
 1453 0092 40F20001 		movw	r1, #:lower16:.LC3
 1454 0096 C0F20001 		movt	r1, #:upper16:.LC3
 1455 009a 3246     		mov	r2, r6
 1456 009c FFF7FEFF 		bl	str_compare
 1457              	.LVL193:
 1458 00a0 98B3     		cbz	r0, .L80
 1459              	.LBB13:
 428:src/command_parser.c **** 
 429:src/command_parser.c ****         int idx = find_next_char(pos, 0, term);
 1460              		.loc 1 429 0
 1461 00a2 2846     		mov	r0, r5
 1462 00a4 0021     		movs	r1, #0
 1463 00a6 3246     		mov	r2, r6
 1464 00a8 FFF7FEFF 		bl	find_next_char
 1465              	.LVL194:
 430:src/command_parser.c ****         pos+=idx+1;
 1466              		.loc 1 430 0
 1467 00ac 0130     		adds	r0, r0, #1
 1468              	.LVL195:
 431:src/command_parser.c ****         int stage_id = str_to_int(pos, '\003')-1;
 1469              		.loc 1 431 0
 1470 00ae 2844     		add	r0, r0, r5
 1471              	.LVL196:
 1472 00b0 0321     		movs	r1, #3
 1473 00b2 FFF7FEFF 		bl	str_to_int
 1474              	.LVL197:
 432:src/command_parser.c ****         if (stage_id == -1) {
 1475              		.loc 1 432 0
 1476 00b6 431E     		subs	r3, r0, #1
 1477              	.LVL198:
 1478 00b8 80B9     		cbnz	r0, .L96
 1479 00ba 07E0     		b	.L94
 1480              	.LVL199:
 1481              	.L90:
 1482              	.LBB14:
 433:src/command_parser.c ****             int i;
 434:src/command_parser.c ****             for(i=0; i<MAX_STAGES; i++) {
 435:src/command_parser.c ****                 stage_print(&stages[i]);
 1483              		.loc 1 435 0 discriminator 2
 1484 00bc 04EB4400 		add	r0, r4, r4, lsl #1
 1485 00c0 05EBC000 		add	r0, r5, r0, lsl #3
 1486 00c4 FFF7FEFF 		bl	stage_print
 1487              	.LVL200:
 434:src/command_parser.c ****                 stage_print(&stages[i]);
 1488              		.loc 1 434 0 discriminator 2
 1489 00c8 0134     		adds	r4, r4, #1
 1490              	.LVL201:
 1491 00ca 04E0     		b	.L88
 1492              	.LVL202:
 1493              	.L94:
 1494              	.LBE14:
 1495 00cc 0024     		movs	r4, #0
 1496              	.LBB15:
 1497              		.loc 1 435 0
 1498 00ce 40F20005 		movw	r5, #:lower16:stages
 1499 00d2 C0F20005 		movt	r5, #:upper16:stages
 1500              	.LVL203:
 1501              	.L88:
 434:src/command_parser.c ****                 stage_print(&stages[i]);
 1502              		.loc 1 434 0 discriminator 1
 1503 00d6 092C     		cmp	r4, #9
 1504 00d8 F0DD     		ble	.L90
 1505 00da 16E0     		b	.L80
 1506              	.LVL204:
 1507              	.L96:
 1508              	.LBE15:
 436:src/command_parser.c ****             }
 437:src/command_parser.c ****         }
 438:src/command_parser.c ****         else if (stage_id >= 0 && stage_id <MAX_STAGES) {
 1509              		.loc 1 438 0
 1510 00dc 092B     		cmp	r3, #9
 1511 00de 0AD8     		bhi	.L91
 439:src/command_parser.c ****             stage_print(stages+stage_id);
 1512              		.loc 1 439 0
 1513 00e0 03EB4303 		add	r3, r3, r3, lsl #1
 1514              	.LVL205:
 1515 00e4 40F20000 		movw	r0, #:lower16:stages
 1516              	.LVL206:
 1517 00e8 C0F20000 		movt	r0, #:upper16:stages
 1518 00ec 00EBC300 		add	r0, r0, r3, lsl #3
 1519 00f0 FFF7FEFF 		bl	stage_print
 1520              	.LVL207:
 1521 00f4 09E0     		b	.L80
 1522              	.LVL208:
 1523              	.L91:
 440:src/command_parser.c **** 
 441:src/command_parser.c ****         }
 442:src/command_parser.c ****         else {
 443:src/command_parser.c ****             USART_rtos_puts(&packet, "Error: Invalid stage_id\r\n");
 1524              		.loc 1 443 0
 1525 00f6 6846     		mov	r0, sp
 1526 00f8 40F20001 		movw	r1, #:lower16:.LC15
 1527 00fc C0F20001 		movt	r1, #:upper16:.LC15
 1528 0100 FFF7FEFF 		bl	USART_rtos_puts
 1529              	.LVL209:
 444:src/command_parser.c ****             USART_rtos_wait_send(&packet);
 1530              		.loc 1 444 0
 1531 0104 6846     		mov	r0, sp
 1532 0106 FFF7FEFF 		bl	USART_rtos_wait_send
 1533              	.LVL210:
 1534              	.L80:
 1535              	.LBE13:
 445:src/command_parser.c ****             return;
 446:src/command_parser.c ****         }
 447:src/command_parser.c **** 
 448:src/command_parser.c ****     }
 449:src/command_parser.c **** 
 450:src/command_parser.c ****     else {
 451:src/command_parser.c ****         //USART_rtos_sputs(&packet, "Error: Unknown Object '%s'\r\n", pos);
 452:src/command_parser.c ****         //USART_rtos_wait_send(&packet);
 453:src/command_parser.c **** 
 454:src/command_parser.c ****     }
 455:src/command_parser.c **** }
 1536              		.loc 1 455 0
 1537 010a 05B0     		add	sp, sp, #20
 1538              		@ sp needed
 1539 010c F0BD     		pop	{r4, r5, r6, r7, pc}
 1540              		.cfi_endproc
 1541              	.LFE123:
 1543 010e 00BF     		.section	.text.command_config_clock,"ax",%progbits
 1544              		.align	2
 1545              		.global	command_config_clock
 1546              		.thumb
 1547              		.thumb_func
 1549              	command_config_clock:
 1550              	.LFB124:
 456:src/command_parser.c **** 
 457:src/command_parser.c **** void command_config_clock(char *pos, char term) {
 1551              		.loc 1 457 0
 1552              		.cfi_startproc
 1553              		@ args = 0, pretend = 0, frame = 192
 1554              		@ frame_needed = 0, uses_anonymous_args = 0
 1555              	.LVL211:
 1556 0000 2DE9F04F 		push	{r4, r5, r6, r7, r8, r9, r10, fp, lr}
 1557              	.LCFI20:
 1558              		.cfi_def_cfa_offset 36
 1559              		.cfi_offset 4, -36
 1560              		.cfi_offset 5, -32
 1561              		.cfi_offset 6, -28
 1562              		.cfi_offset 7, -24
 1563              		.cfi_offset 8, -20
 1564              		.cfi_offset 9, -16
 1565              		.cfi_offset 10, -12
 1566              		.cfi_offset 11, -8
 1567              		.cfi_offset 14, -4
 1568 0004 B3B0     		sub	sp, sp, #204
 1569              	.LCFI21:
 1570              		.cfi_def_cfa_offset 240
 1571 0006 0446     		mov	r4, r0
 1572 0008 8846     		mov	r8, r1
 1573              	.LVL212:
 458:src/command_parser.c ****     unsigned error_code = 99; //unknown error
 459:src/command_parser.c ****     USART_rtos_packet packet;
 460:src/command_parser.c ****     char buffer[80];
 461:src/command_parser.c ****     char msg[] = "{'object_type': 'CLOCK', 'method': 'config', 'error':%u, h=%d, m=%d, s=%d}\r\n";
 1574              		.loc 1 461 0
 1575 000a 06A8     		add	r0, sp, #24
 1576              	.LVL213:
 1577 000c 40F20001 		movw	r1, #:lower16:.LC16
 1578              	.LVL214:
 1579 0010 C0F20001 		movt	r1, #:upper16:.LC16
 1580 0014 4D22     		movs	r2, #77
 1581 0016 FFF7FEFF 		bl	memcpy
 1582              	.LVL215:
 462:src/command_parser.c ****     packet.msg = buffer;
 1583              		.loc 1 462 0
 1584 001a 1AAB     		add	r3, sp, #104
 1585 001c 2F93     		str	r3, [sp, #188]
 463:src/command_parser.c ****     packet.USARTx_rtos = USARTOutput_rtos;
 1586              		.loc 1 463 0
 1587 001e 40F20003 		movw	r3, #:lower16:USARTOutput_rtos
 1588 0022 C0F20003 		movt	r3, #:upper16:USARTOutput_rtos
 1589 0026 1B68     		ldr	r3, [r3]
 1590 0028 2E93     		str	r3, [sp, #184]
 1591              	.LVL216:
 464:src/command_parser.c **** 
 465:src/command_parser.c ****     int NEW_ITEM = 0;
 466:src/command_parser.c **** 
 467:src/command_parser.c ****     int idx = find_next_char(pos, 0, term);
 1592              		.loc 1 467 0
 1593 002a 2046     		mov	r0, r4
 1594 002c 0021     		movs	r1, #0
 1595 002e 4246     		mov	r2, r8
 1596 0030 FFF7FEFF 		bl	find_next_char
 1597              	.LVL217:
 468:src/command_parser.c ****     pos+=idx+1;
 1598              		.loc 1 468 0
 1599 0034 431C     		adds	r3, r0, #1
 1600 0036 1C44     		add	r4, r4, r3
 1601              	.LVL218:
 469:src/command_parser.c ****    
 470:src/command_parser.c ****     int i;
 471:src/command_parser.c **** 
 472:src/command_parser.c ****     int hours = 0, minutes = 0, seconds = 0;
 1602              		.loc 1 472 0
 1603 0038 4FF00009 		mov	r9, #0
 1604 003c CDF80C90 		str	r9, [sp, #12]
 1605 0040 CA46     		mov	r10, r9
 473:src/command_parser.c ****     for(i=0; i<4 && idx!=0; i++) {
 1606              		.loc 1 473 0
 1607 0042 4D46     		mov	r5, r9
 458:src/command_parser.c ****     USART_rtos_packet packet;
 1608              		.loc 1 458 0
 1609 0044 6326     		movs	r6, #99
 474:src/command_parser.c ****         //pos++;
 475:src/command_parser.c ****         switch (*pos) {
 476:src/command_parser.c ****             case 'h': //hours
 477:src/command_parser.c ****                pos++;
 478:src/command_parser.c ****                hours = str_to_int(pos, '\003'); 
 479:src/command_parser.c ****                if (!(hours >= 0 && hours <=23)) {
 480:src/command_parser.c ****                    hours = 0;
 481:src/command_parser.c ****                    error_code = 400;
 482:src/command_parser.c ****                }
 483:src/command_parser.c ****                break;
 484:src/command_parser.c **** 
 485:src/command_parser.c ****             case 'm': //minutes 
 486:src/command_parser.c ****                pos++;
 487:src/command_parser.c ****                minutes = str_to_int(pos, '\003'); 
 1610              		.loc 1 487 0
 1611 0046 4FF0030B 		mov	fp, #3
 488:src/command_parser.c ****                if (!(minutes >= 0 && minutes <=59)) {
 489:src/command_parser.c ****                    minutes = 0;
 1612              		.loc 1 489 0
 1613 004a 4F46     		mov	r7, r9
 473:src/command_parser.c ****         //pos++;
 1614              		.loc 1 473 0
 1615 004c 3BE0     		b	.L98
 1616              	.LVL219:
 1617              	.L104:
 475:src/command_parser.c ****             case 'h': //hours
 1618              		.loc 1 475 0
 1619 004e 2378     		ldrb	r3, [r4]	@ zero_extendqisi2
 1620 0050 6D2B     		cmp	r3, #109
 1621 0052 13D0     		beq	.L100
 1622 0054 732B     		cmp	r3, #115
 1623 0056 1ED0     		beq	.L101
 1624 0058 682B     		cmp	r3, #104
 490:src/command_parser.c ****                    error_code = 400;
 491:src/command_parser.c ****                }
 492:src/command_parser.c ****                break;
 493:src/command_parser.c **** 
 494:src/command_parser.c ****             case 's': //seconds 
 495:src/command_parser.c ****                pos++;
 496:src/command_parser.c ****                seconds = str_to_int(pos, '\003'); 
 497:src/command_parser.c ****                if (!(seconds >= 0 && seconds <=59)) {
 498:src/command_parser.c ****                    seconds = 0;
 499:src/command_parser.c ****                    error_code = 400;
 500:src/command_parser.c ****                }
 501:src/command_parser.c ****                break;
 502:src/command_parser.c **** 
 503:src/command_parser.c ****             default:
 504:src/command_parser.c ****                error_code = 401;
 1625              		.loc 1 504 0
 1626 005a 18BF     		it	ne
 1627 005c 40F29116 		movwne	r6, #401
 1628              	.LVL220:
 475:src/command_parser.c ****             case 'h': //hours
 1629              		.loc 1 475 0
 1630 0060 24D1     		bne	.L99
 477:src/command_parser.c ****                hours = str_to_int(pos, '\003'); 
 1631              		.loc 1 477 0
 1632 0062 0134     		adds	r4, r4, #1
 1633              	.LVL221:
 478:src/command_parser.c ****                if (!(hours >= 0 && hours <=23)) {
 1634              		.loc 1 478 0
 1635 0064 2046     		mov	r0, r4
 1636              	.LVL222:
 1637 0066 5946     		mov	r1, fp
 1638 0068 FFF7FEFF 		bl	str_to_int
 1639              	.LVL223:
 1640 006c 8246     		mov	r10, r0
 1641              	.LVL224:
 479:src/command_parser.c ****                    hours = 0;
 1642              		.loc 1 479 0
 1643 006e 1728     		cmp	r0, #23
 480:src/command_parser.c ****                    error_code = 400;
 1644              		.loc 1 480 0
 1645 0070 84BF     		itt	hi
 1646 0072 BA46     		movhi	r10, r7
 481:src/command_parser.c ****                }
 1647              		.loc 1 481 0
 1648 0074 4FF4C876 		movhi	r6, #400
 479:src/command_parser.c ****                    hours = 0;
 1649              		.loc 1 479 0
 1650 0078 18D8     		bhi	.L99
 1651 007a 17E0     		b	.L99
 1652              	.LVL225:
 1653              	.L100:
 486:src/command_parser.c ****                minutes = str_to_int(pos, '\003'); 
 1654              		.loc 1 486 0
 1655 007c 0134     		adds	r4, r4, #1
 1656              	.LVL226:
 487:src/command_parser.c ****                if (!(minutes >= 0 && minutes <=59)) {
 1657              		.loc 1 487 0
 1658 007e 2046     		mov	r0, r4
 1659              	.LVL227:
 1660 0080 5946     		mov	r1, fp
 1661 0082 FFF7FEFF 		bl	str_to_int
 1662              	.LVL228:
 1663 0086 0390     		str	r0, [sp, #12]
 1664              	.LVL229:
 488:src/command_parser.c ****                    minutes = 0;
 1665              		.loc 1 488 0
 1666 0088 3B28     		cmp	r0, #59
 489:src/command_parser.c ****                    error_code = 400;
 1667              		.loc 1 489 0
 1668 008a 84BF     		itt	hi
 1669 008c 0397     		strhi	r7, [sp, #12]
 490:src/command_parser.c ****                }
 1670              		.loc 1 490 0
 1671 008e 4FF4C876 		movhi	r6, #400
 1672              	.LVL230:
 488:src/command_parser.c ****                    minutes = 0;
 1673              		.loc 1 488 0
 1674 0092 0BD8     		bhi	.L99
 1675 0094 0AE0     		b	.L99
 1676              	.LVL231:
 1677              	.L101:
 495:src/command_parser.c ****                seconds = str_to_int(pos, '\003'); 
 1678              		.loc 1 495 0
 1679 0096 0134     		adds	r4, r4, #1
 1680              	.LVL232:
 496:src/command_parser.c ****                if (!(seconds >= 0 && seconds <=59)) {
 1681              		.loc 1 496 0
 1682 0098 2046     		mov	r0, r4
 1683              	.LVL233:
 1684 009a 5946     		mov	r1, fp
 1685 009c FFF7FEFF 		bl	str_to_int
 1686              	.LVL234:
 1687 00a0 8146     		mov	r9, r0
 1688              	.LVL235:
 497:src/command_parser.c ****                    seconds = 0;
 1689              		.loc 1 497 0
 1690 00a2 3B28     		cmp	r0, #59
 498:src/command_parser.c ****                    error_code = 400;
 1691              		.loc 1 498 0
 1692 00a4 84BF     		itt	hi
 1693 00a6 B946     		movhi	r9, r7
 499:src/command_parser.c ****                }
 1694              		.loc 1 499 0
 1695 00a8 4FF4C876 		movhi	r6, #400
 1696              	.LVL236:
 1697              	.L99:
 505:src/command_parser.c ****                break;
 506:src/command_parser.c ****         }
 507:src/command_parser.c **** 
 508:src/command_parser.c ****         if (error_code != 99) break;
 1698              		.loc 1 508 0
 1699 00ac 632E     		cmp	r6, #99
 1700 00ae 13D1     		bne	.L103
 509:src/command_parser.c **** 
 510:src/command_parser.c ****         idx = find_next_char(pos, 0, term);
 1701              		.loc 1 510 0
 1702 00b0 2046     		mov	r0, r4
 1703 00b2 3946     		mov	r1, r7
 1704 00b4 4246     		mov	r2, r8
 1705 00b6 FFF7FEFF 		bl	find_next_char
 1706              	.LVL237:
 511:src/command_parser.c ****         if (idx == -1) break;
 1707              		.loc 1 511 0
 1708 00ba B0F1FF3F 		cmp	r0, #-1
 1709 00be 0BD0     		beq	.L103
 512:src/command_parser.c ****         pos+=idx+1;
 1710              		.loc 1 512 0
 1711 00c0 431C     		adds	r3, r0, #1
 1712 00c2 1C44     		add	r4, r4, r3
 1713              	.LVL238:
 473:src/command_parser.c ****         //pos++;
 1714              		.loc 1 473 0
 1715 00c4 0135     		adds	r5, r5, #1
 1716              	.LVL239:
 1717              	.L98:
 473:src/command_parser.c ****         //pos++;
 1718              		.loc 1 473 0 is_stmt 0 discriminator 1
 1719 00c6 032D     		cmp	r5, #3
 1720 00c8 CCBF     		ite	gt
 1721 00ca 0023     		movgt	r3, #0
 1722 00cc 0123     		movle	r3, #1
 1723 00ce 0028     		cmp	r0, #0
 1724 00d0 08BF     		it	eq
 1725 00d2 0023     		moveq	r3, #0
 1726 00d4 002B     		cmp	r3, #0
 1727 00d6 BAD1     		bne	.L104
 1728              	.LVL240:
 1729              	.L103:
 513:src/command_parser.c ****     }
 514:src/command_parser.c **** 
 515:src/command_parser.c ****     RTC_TimeTypeDef t;
 516:src/command_parser.c ****     if (error_code == 99) {
 1730              		.loc 1 516 0 is_stmt 1
 1731 00d8 632E     		cmp	r6, #99
 1732 00da 0FD1     		bne	.L105
 1733              	.LBB16:
 517:src/command_parser.c ****         getTime(&t);
 1734              		.loc 1 517 0
 1735 00dc 05A8     		add	r0, sp, #20
 1736 00de FFF7FEFF 		bl	getTime
 1737              	.LVL241:
 518:src/command_parser.c ****         unsigned int c = getEpoch(&t, getSystemDay());
 1738              		.loc 1 518 0
 1739 00e2 FFF7FEFF 		bl	getSystemDay
 1740              	.LVL242:
 1741 00e6 0146     		mov	r1, r0
 1742 00e8 05A8     		add	r0, sp, #20
 1743 00ea FFF7FEFF 		bl	getEpoch
 1744              	.LVL243:
 1745 00ee 0346     		mov	r3, r0
 1746              	.LVL244:
 519:src/command_parser.c ****         setTimeSafely(hours, minutes, seconds, c);
 1747              		.loc 1 519 0
 1748 00f0 5046     		mov	r0, r10
 1749              	.LVL245:
 1750 00f2 0399     		ldr	r1, [sp, #12]
 1751 00f4 4A46     		mov	r2, r9
 1752 00f6 FFF7FEFF 		bl	setTimeSafely
 1753              	.LVL246:
 520:src/command_parser.c ****         //RTC_GetTime(RTC_Format_BIN, &t);
 521:src/command_parser.c **** 
 522:src/command_parser.c ****         error_code = 0;
 1754              		.loc 1 522 0
 1755 00fa 0026     		movs	r6, #0
 1756              	.LVL247:
 1757              	.L105:
 1758              	.LBE16:
 523:src/command_parser.c ****     }
 524:src/command_parser.c ****         getTime(&t);
 1759              		.loc 1 524 0
 1760 00fc 05A8     		add	r0, sp, #20
 1761 00fe FFF7FEFF 		bl	getTime
 1762              	.LVL248:
 525:src/command_parser.c **** 
 526:src/command_parser.c **** 
 527:src/command_parser.c **** 
 528:src/command_parser.c **** 
 529:src/command_parser.c **** 
 530:src/command_parser.c **** 
 531:src/command_parser.c ****     /* FOR DEBUGGING 
 532:src/command_parser.c ****     USART_puts(USARTOutput_rtos->id, "debug3: ");
 533:src/command_parser.c ****     USART_put_unsigned_int(USARTOutput_rtos->id, timer_list_head->debug3);
 534:src/command_parser.c ****     USART_puts(USARTOutput_rtos->id, "\r\n");
 535:src/command_parser.c **** 
 536:src/command_parser.c ****     
 537:src/command_parser.c ****     USART_puts(USARTOutput_rtos->id, "prev: ");
 538:src/command_parser.c ****     USART_put_unsigned_int(USARTOutput_rtos->id, timer_list_head->debug);
 539:src/command_parser.c ****     USART_puts(USARTOutput_rtos->id, "\r\n");
 540:src/command_parser.c **** 
 541:src/command_parser.c **** 
 542:src/command_parser.c ****     USART_puts(USARTOutput_rtos->id, "prev timer: ");
 543:src/command_parser.c ****     USART_put_unsigned_int(USARTOutput_rtos->id, timer_list_head->debug2);
 544:src/command_parser.c ****     USART_puts(USARTOutput_rtos->id, "\r\n");
 545:src/command_parser.c **** 
 546:src/command_parser.c ****     USART_puts(USARTOutput_rtos->id, "prev set timer: ");
 547:src/command_parser.c ****     USART_put_unsigned_int(USARTOutput_rtos->id, timer_list_head->debug0);
 548:src/command_parser.c ****     USART_puts(USARTOutput_rtos->id, "\r\n");
 549:src/command_parser.c **** 
 550:src/command_parser.c **** 
 551:src/command_parser.c **** 
 552:src/command_parser.c ****     USART_puts(USARTOutput_rtos->id, "current: ");
 553:src/command_parser.c ****     USART_put_unsigned_int(USARTOutput_rtos->id, timer_list_head->debug1);
 554:src/command_parser.c **** 
 555:src/command_parser.c ****     USART_puts(USARTOutput_rtos->id, "\r\n");
 556:src/command_parser.c **** 
 557:src/command_parser.c ****     USART_puts(USARTOutput_rtos->id, "current timer: ");
 558:src/command_parser.c ****     USART_put_unsigned_int(USARTOutput_rtos->id, timer_list_head->epoch);
 559:src/command_parser.c ****     USART_puts(USARTOutput_rtos->id, "\r\n");
 560:src/command_parser.c **** 
 561:src/command_parser.c **** 
 562:src/command_parser.c ****     */
 563:src/command_parser.c **** 
 564:src/command_parser.c **** 
 565:src/command_parser.c ****     USART_rtos_sputs(&packet, msg, error_code, hours, minutes, seconds);
 1763              		.loc 1 565 0
 1764 0102 039B     		ldr	r3, [sp, #12]
 1765 0104 0093     		str	r3, [sp]
 1766 0106 CDF80490 		str	r9, [sp, #4]
 1767 010a 2EA8     		add	r0, sp, #184
 1768 010c 06A9     		add	r1, sp, #24
 1769 010e 3246     		mov	r2, r6
 1770 0110 5346     		mov	r3, r10
 1771 0112 FFF7FEFF 		bl	USART_rtos_sputs
 1772              	.LVL249:
 566:src/command_parser.c ****     USART_rtos_wait_send(&packet);
 1773              		.loc 1 566 0
 1774 0116 2EA8     		add	r0, sp, #184
 1775 0118 FFF7FEFF 		bl	USART_rtos_wait_send
 1776              	.LVL250:
 567:src/command_parser.c **** }
 1777              		.loc 1 567 0
 1778 011c 33B0     		add	sp, sp, #204
 1779              		@ sp needed
 1780 011e BDE8F08F 		pop	{r4, r5, r6, r7, r8, r9, r10, fp, pc}
 1781              		.cfi_endproc
 1782              	.LFE124:
 1784 0122 00BF     		.section	.text.command_config,"ax",%progbits
 1785              		.align	2
 1786              		.global	command_config
 1787              		.thumb
 1788              		.thumb_func
 1790              	command_config:
 1791              	.LFB125:
 568:src/command_parser.c **** 
 569:src/command_parser.c **** void command_config(char *pos, char term) {
 1792              		.loc 1 569 0
 1793              		.cfi_startproc
 1794              		@ args = 0, pretend = 0, frame = 0
 1795              		@ frame_needed = 0, uses_anonymous_args = 0
 1796              	.LVL251:
 1797 0000 38B5     		push	{r3, r4, r5, lr}
 1798              	.LCFI22:
 1799              		.cfi_def_cfa_offset 16
 1800              		.cfi_offset 3, -16
 1801              		.cfi_offset 4, -12
 1802              		.cfi_offset 5, -8
 1803              		.cfi_offset 14, -4
 1804 0002 0C46     		mov	r4, r1
 570:src/command_parser.c ****     USART_rtos_packet packet;
 571:src/command_parser.c ****     packet.USARTx_rtos = USARTOutput_rtos;
 572:src/command_parser.c **** 
 573:src/command_parser.c ****     pos+=7; //move cursor to next word
 1805              		.loc 1 573 0
 1806 0004 C51D     		adds	r5, r0, #7
 1807              	.LVL252:
 574:src/command_parser.c ****     if (str_compare(pos, "CLOCK\003", term)) {
 1808              		.loc 1 574 0
 1809 0006 2846     		mov	r0, r5
 1810 0008 40F20001 		movw	r1, #:lower16:.LC17
 1811              	.LVL253:
 1812 000c C0F20001 		movt	r1, #:upper16:.LC17
 1813 0010 2246     		mov	r2, r4
 1814 0012 FFF7FEFF 		bl	str_compare
 1815              	.LVL254:
 1816 0016 18B1     		cbz	r0, .L111
 575:src/command_parser.c ****         command_config_clock(pos, term);
 1817              		.loc 1 575 0
 1818 0018 2846     		mov	r0, r5
 1819 001a 2146     		mov	r1, r4
 1820 001c FFF7FEFF 		bl	command_config_clock
 1821              	.LVL255:
 1822              	.L111:
 1823 0020 38BD     		pop	{r3, r4, r5, pc}
 1824              		.cfi_endproc
 1825              	.LFE125:
 1827 0022 00BF     		.section	.text.command_routing,"ax",%progbits
 1828              		.align	2
 1829              		.global	command_routing
 1830              		.thumb
 1831              		.thumb_func
 1833              	command_routing:
 1834              	.LFB126:
 576:src/command_parser.c **** //        USART_rtos_puts(&packet, "OK!\r\n");
 577:src/command_parser.c ****  //       USART_rtos_wait_send(&packet);
 578:src/command_parser.c ****         return;
 579:src/command_parser.c ****     }
 580:src/command_parser.c **** }
 581:src/command_parser.c **** 
 582:src/command_parser.c **** 
 583:src/command_parser.c **** 
 584:src/command_parser.c **** int command_routing(char *pos, char term) {
 1835              		.loc 1 584 0
 1836              		.cfi_startproc
 1837              		@ args = 0, pretend = 0, frame = 16
 1838              		@ frame_needed = 0, uses_anonymous_args = 0
 1839              	.LVL256:
 1840 0000 30B5     		push	{r4, r5, lr}
 1841              	.LCFI23:
 1842              		.cfi_def_cfa_offset 12
 1843              		.cfi_offset 4, -12
 1844              		.cfi_offset 5, -8
 1845              		.cfi_offset 14, -4
 1846 0002 85B0     		sub	sp, sp, #20
 1847              	.LCFI24:
 1848              		.cfi_def_cfa_offset 32
 1849 0004 0546     		mov	r5, r0
 1850 0006 0C46     		mov	r4, r1
 585:src/command_parser.c ****     USART_rtos_packet packet;
 586:src/command_parser.c ****     packet.USARTx_rtos = USARTOutput_rtos;
 1851              		.loc 1 586 0
 1852 0008 40F20003 		movw	r3, #:lower16:USARTOutput_rtos
 1853 000c C0F20003 		movt	r3, #:upper16:USARTOutput_rtos
 1854 0010 1B68     		ldr	r3, [r3]
 1855 0012 0093     		str	r3, [sp]
 1856              	.LVL257:
 587:src/command_parser.c ****     int r = 0;
 588:src/command_parser.c ****     
 589:src/command_parser.c ****     if (str_compare(pos, "get\003", term)) {
 1857              		.loc 1 589 0
 1858 0014 40F20001 		movw	r1, #:lower16:.LC18
 1859              	.LVL258:
 1860 0018 C0F20001 		movt	r1, #:upper16:.LC18
 1861 001c 2246     		mov	r2, r4
 1862 001e FFF7FEFF 		bl	str_compare
 1863              	.LVL259:
 1864 0022 28B1     		cbz	r0, .L114
 590:src/command_parser.c ****         command_get(pos, term);
 1865              		.loc 1 590 0
 1866 0024 2846     		mov	r0, r5
 1867 0026 2146     		mov	r1, r4
 1868 0028 FFF7FEFF 		bl	command_get
 1869              	.LVL260:
 587:src/command_parser.c ****     int r = 0;
 1870              		.loc 1 587 0
 1871 002c 0020     		movs	r0, #0
 1872 002e 3DE0     		b	.L115
 1873              	.L114:
 591:src/command_parser.c ****     }
 592:src/command_parser.c **** 
 593:src/command_parser.c ****     else if (str_compare(pos, "set\003", term)) {
 1874              		.loc 1 593 0
 1875 0030 2846     		mov	r0, r5
 1876 0032 40F20001 		movw	r1, #:lower16:.LC19
 1877 0036 C0F20001 		movt	r1, #:upper16:.LC19
 1878 003a 2246     		mov	r2, r4
 1879 003c FFF7FEFF 		bl	str_compare
 1880              	.LVL261:
 1881 0040 28B1     		cbz	r0, .L116
 594:src/command_parser.c ****         command_set(pos, term);
 1882              		.loc 1 594 0
 1883 0042 2846     		mov	r0, r5
 1884 0044 2146     		mov	r1, r4
 1885 0046 FFF7FEFF 		bl	command_set
 1886              	.LVL262:
 587:src/command_parser.c ****     
 1887              		.loc 1 587 0
 1888 004a 0020     		movs	r0, #0
 1889 004c 2EE0     		b	.L115
 1890              	.L116:
 595:src/command_parser.c ****     }
 596:src/command_parser.c **** 
 597:src/command_parser.c ****     else if (str_compare(pos, "del\003", term)) {
 1891              		.loc 1 597 0
 1892 004e 2846     		mov	r0, r5
 1893 0050 40F20001 		movw	r1, #:lower16:.LC20
 1894 0054 C0F20001 		movt	r1, #:upper16:.LC20
 1895 0058 2246     		mov	r2, r4
 1896 005a FFF7FEFF 		bl	str_compare
 1897              	.LVL263:
 1898 005e 28B1     		cbz	r0, .L117
 598:src/command_parser.c ****         command_del(pos, term);
 1899              		.loc 1 598 0
 1900 0060 2846     		mov	r0, r5
 1901 0062 2146     		mov	r1, r4
 1902 0064 FFF7FEFF 		bl	command_del
 1903              	.LVL264:
 587:src/command_parser.c ****     
 1904              		.loc 1 587 0
 1905 0068 0020     		movs	r0, #0
 1906 006a 1FE0     		b	.L115
 1907              	.L117:
 599:src/command_parser.c ****     }
 600:src/command_parser.c **** 
 601:src/command_parser.c ****     else if(str_compare(pos, "config\003", term)) {
 1908              		.loc 1 601 0
 1909 006c 2846     		mov	r0, r5
 1910 006e 40F20001 		movw	r1, #:lower16:.LC21
 1911 0072 C0F20001 		movt	r1, #:upper16:.LC21
 1912 0076 2246     		mov	r2, r4
 1913 0078 FFF7FEFF 		bl	str_compare
 1914              	.LVL265:
 1915 007c 28B1     		cbz	r0, .L118
 602:src/command_parser.c ****         command_config(pos, term);
 1916              		.loc 1 602 0
 1917 007e 2846     		mov	r0, r5
 1918 0080 2146     		mov	r1, r4
 1919 0082 FFF7FEFF 		bl	command_config
 1920              	.LVL266:
 587:src/command_parser.c ****     
 1921              		.loc 1 587 0
 1922 0086 0020     		movs	r0, #0
 1923 0088 10E0     		b	.L115
 1924              	.L118:
 603:src/command_parser.c ****     }
 604:src/command_parser.c **** 
 605:src/command_parser.c ****     else if (*pos != term){
 1925              		.loc 1 605 0
 1926 008a 2B78     		ldrb	r3, [r5]	@ zero_extendqisi2
 1927 008c A342     		cmp	r3, r4
 587:src/command_parser.c ****     
 1928              		.loc 1 587 0
 1929 008e 08BF     		it	eq
 1930 0090 0020     		moveq	r0, #0
 1931              		.loc 1 605 0
 1932 0092 0BD0     		beq	.L115
 606:src/command_parser.c ****         USART_rtos_puts(&packet, "{'method': '', 'error': 9}\r\n"); //error 9: Unknown start comman
 1933              		.loc 1 606 0
 1934 0094 6846     		mov	r0, sp
 1935 0096 40F20001 		movw	r1, #:lower16:.LC22
 1936 009a C0F20001 		movt	r1, #:upper16:.LC22
 1937 009e FFF7FEFF 		bl	USART_rtos_puts
 1938              	.LVL267:
 607:src/command_parser.c ****         USART_rtos_wait_send(&packet);
 1939              		.loc 1 607 0
 1940 00a2 6846     		mov	r0, sp
 1941 00a4 FFF7FEFF 		bl	USART_rtos_wait_send
 1942              	.LVL268:
 608:src/command_parser.c ****         r = 1;
 1943              		.loc 1 608 0
 1944 00a8 0120     		movs	r0, #1
 1945 00aa FFE7     		b	.L115
 1946              	.LVL269:
 1947              	.L115:
 609:src/command_parser.c ****     }
 610:src/command_parser.c ****     return r; //1 = Error
 611:src/command_parser.c **** }
 1948              		.loc 1 611 0
 1949 00ac 05B0     		add	sp, sp, #20
 1950              		@ sp needed
 1951 00ae 30BD     		pop	{r4, r5, pc}
 1952              		.cfi_endproc
 1953              	.LFE126:
 1955              		.global	REGIME_LIGHTING
 1956              		.global	REGIME_PH
 1957              		.comm	stages,240,4
 1958              		.comm	USARTOutput_rtos,4,4
 1959              		.section	.rodata.str1.4,"aMS",%progbits,1
 1960              		.align	2
 1961              	.LC0:
 1962 0000 7B276F62 		.ascii	"{'object_type': 'REGIME_PH', 'method': 'set', 'erro"
 1962      6A656374 
 1962      5F747970 
 1962      65273A20 
 1962      27524547 
 1963 0033 72273A25 		.ascii	"r':%d, 'object_id':%d}\015\012\000"
 1963      642C2027 
 1963      6F626A65 
 1963      63745F69 
 1963      64273A25 
 1964              	.LC1:
 1965 004c 7B276F62 		.ascii	"{'object_type': 'STAGE', 'method': 'set', 'error':%"
 1965      6A656374 
 1965      5F747970 
 1965      65273A20 
 1965      27535441 
 1966 007f 642C2027 		.ascii	"d, 'object_id':%d}\015\012\000"
 1966      6F626A65 
 1966      63745F69 
 1966      64273A25 
 1966      647D0D0A 
 1967              	.LC2:
 1968 0094 52454749 		.ascii	"REGIME_PH\003\000"
 1968      4D455F50 
 1968      480300
 1969 009f 00       		.space	1
 1970              	.LC3:
 1971 00a0 53544147 		.ascii	"STAGE\003\000"
 1971      450300
 1972 00a7 00       		.space	1
 1973              	.LC4:
 1974 00a8 52454749 		.ascii	"REGIME_LIGHTING\003\000"
 1974      4D455F4C 
 1974      49474854 
 1974      494E4703 
 1974      00
 1975 00b9 000000   		.space	3
 1976              	.LC5:
 1977 00bc 7B276F62 		.ascii	"{'object_type': '', method: 'set', error: 10, 'obje"
 1977      6A656374 
 1977      5F747970 
 1977      65273A20 
 1977      27272C20 
 1978 00ef 63745F69 		.ascii	"ct_id': -1}\015\012\000"
 1978      64273A20 
 1978      2D317D0D 
 1978      0A00
 1979 00fd 000000   		.space	3
 1980              	.LC6:
 1981 0100 4572726F 		.ascii	"Error: Incorrect REGIME_PH id\015\012\000"
 1981      723A2049 
 1981      6E636F72 
 1981      72656374 
 1981      20524547 
 1982              	.LC7:
 1983 0120 44454255 		.ascii	"DEBUG: DELETING REGIME_ID %d\015\012\000"
 1983      473A2044 
 1983      454C4554 
 1983      494E4720 
 1983      52454749 
 1984 013f 00       		.space	1
 1985              	.LC8:
 1986 0140 4572726F 		.ascii	"Error: Incorrect stage id\015\012\000"
 1986      723A2049 
 1986      6E636F72 
 1986      72656374 
 1986      20737461 
 1987              	.LC9:
 1988 015c 53756363 		.ascii	"Succesfully deleted stage id: %d\015\012\000"
 1988      65736675 
 1988      6C6C7920 
 1988      64656C65 
 1988      74656420 
 1989 017f 00       		.space	1
 1990              	.LC10:
 1991 0180 434F4F4C 		.ascii	"COOL\015\012\000"
 1991      0D0A00
 1992 0187 00       		.space	1
 1993              	.LC11:
 1994 0188 4572726F 		.ascii	"Error: Unknown Object '%s'\015\012\000"
 1994      723A2055 
 1994      6E6B6E6F 
 1994      776E204F 
 1994      626A6563 
 1995 01a5 000000   		.space	3
 1996              	.LC12:
 1997 01a8 7B276964 		.ascii	"{'id': %d, 'length': %d, 'order':%d, 'ph_id': %d, '"
 1997      273A2025 
 1997      642C2027 
 1997      6C656E67 
 1997      7468273A 
 1998 01db 6C696768 		.ascii	"lighting_id':%d, 'using':%d}\015\012\000"
 1998      74696E67 
 1998      5F696427 
 1998      3A25642C 
 1998      20277573 
 1999 01fa 0000     		.space	2
 2000              	.LC13:
 2001 01fc 7B276964 		.ascii	"{'id': %d, 'ph': %d, 'delay': %d}\015\012\000"
 2001      273A2025 
 2001      642C2027 
 2001      7068273A 
 2001      2025642C 
 2002              	.LC14:
 2003 0220 4572726F 		.ascii	"Error: Invalid regime_ph_id\015\012\000"
 2003      723A2049 
 2003      6E76616C 
 2003      69642072 
 2003      6567696D 
 2004 023e 0000     		.space	2
 2005              	.LC15:
 2006 0240 4572726F 		.ascii	"Error: Invalid stage_id\015\012\000"
 2006      723A2049 
 2006      6E76616C 
 2006      69642073 
 2006      74616765 
 2007 025a 0000     		.space	2
 2008              	.LC16:
 2009 025c 7B276F62 		.ascii	"{'object_type': 'CLOCK', 'method': 'config', 'error"
 2009      6A656374 
 2009      5F747970 
 2009      65273A20 
 2009      27434C4F 
 2010 028f 273A2575 		.ascii	"':%u, h=%d, m=%d, s=%d}\015\012\000"
 2010      2C20683D 
 2010      25642C20 
 2010      6D3D2564 
 2010      2C20733D 
 2011 02a9 000000   		.space	3
 2012              	.LC17:
 2013 02ac 434C4F43 		.ascii	"CLOCK\003\000"
 2013      4B0300
 2014 02b3 00       		.space	1
 2015              	.LC18:
 2016 02b4 67657403 		.ascii	"get\003\000"
 2016      00
 2017 02b9 000000   		.space	3
 2018              	.LC19:
 2019 02bc 73657403 		.ascii	"set\003\000"
 2019      00
 2020 02c1 000000   		.space	3
 2021              	.LC20:
 2022 02c4 64656C03 		.ascii	"del\003\000"
 2022      00
 2023 02c9 000000   		.space	3
 2024              	.LC21:
 2025 02cc 636F6E66 		.ascii	"config\003\000"
 2025      69670300 
 2026              	.LC22:
 2027 02d4 7B276D65 		.ascii	"{'method': '', 'error': 9}\015\012\000"
 2027      74686F64 
 2027      273A2027 
 2027      272C2027 
 2027      6572726F 
 2028 02f1 000000   		.section	.data.REGIME_LIGHTING,"aw",%progbits
 2029              		.align	2
 2032              	REGIME_LIGHTING:
 2033 0000 FFFFFFFF 		.word	-1
 2034 0004 FFFFFFFF 		.word	-1
 2035 0008 00000000 		.space	72
 2035      00000000 
 2035      00000000 
 2035      00000000 
 2035      00000000 
 2036              		.section	.data.REGIME_PH,"aw",%progbits
 2037              		.align	2
 2038              		.set	.LANCHOR0,. + 0
 2041              	REGIME_PH:
 2042 0000 FFFFFFFF 		.word	-1
 2043 0004 FFFFFFFF 		.word	-1
 2044 0008 FFFFFFFF 		.word	-1
 2045 000c FFFFFFFF 		.word	-1
 2046 0010 FFFFFFFF 		.word	-1
 2047 0014 FFFFFFFF 		.word	-1
 2048 0018 FFFFFFFF 		.word	-1
 2049 001c FFFFFFFF 		.word	-1
 2050 0020 FFFFFFFF 		.word	-1
 2051 0024 FFFFFFFF 		.word	-1
 2052 0028 FFFFFFFF 		.word	-1
 2053 002c FFFFFFFF 		.word	-1
 2054 0030 FFFFFFFF 		.word	-1
 2055 0034 FFFFFFFF 		.word	-1
 2056 0038 FFFFFFFF 		.word	-1
 2057 003c FFFFFFFF 		.word	-1
 2058 0040 FFFFFFFF 		.word	-1
 2059 0044 FFFFFFFF 		.word	-1
 2060 0048 FFFFFFFF 		.word	-1
 2061 004c FFFFFFFF 		.word	-1
 2062              		.text
 2063              	.Letext0:
 2064              		.file 2 "/usr/include/newlib/machine/_default_types.h"
 2065              		.file 3 "/usr/include/newlib/stdint.h"
 2066              		.file 4 "libs/Device/STM32F4xx/Include/stm32f4xx.h"
 2067              		.file 5 "libs/STM32F4xx_StdPeriph_Driver/inc/stm32f4xx_rtc.h"
 2068              		.file 6 "FreeRTOS/Source/include/../../Source/portable/GCC/ARM_CM4F/portmacro.h"
 2069              		.file 7 "FreeRTOS/Source/include/queue.h"
 2070              		.file 8 "FreeRTOS/Source/include/semphr.h"
 2071              		.file 9 "src/usart_rtos.h"
 2072              		.file 10 "src/command_parser.h"
 2073              		.file 11 "libs/CMSIS/Include/core_cm4.h"
 2074              		.file 12 "src/hbfuncs.h"
 2075              		.file 13 "src/hb_structs.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 command_parser.c
     /tmp/ccBPcgJ1.s:20     .text.setup_output:0000000000000000 $t
     /tmp/ccBPcgJ1.s:25     .text.setup_output:0000000000000000 setup_output
                            *COM*:0000000000000004 USARTOutput_rtos
     /tmp/ccBPcgJ1.s:43     .text.replace_char:0000000000000000 $t
     /tmp/ccBPcgJ1.s:48     .text.replace_char:0000000000000000 replace_char
     /tmp/ccBPcgJ1.s:77     .text.str_compare:0000000000000000 $t
     /tmp/ccBPcgJ1.s:82     .text.str_compare:0000000000000000 str_compare
     /tmp/ccBPcgJ1.s:131    .text.find_next_char:0000000000000000 $t
     /tmp/ccBPcgJ1.s:136    .text.find_next_char:0000000000000000 find_next_char
     /tmp/ccBPcgJ1.s:175    .text.str_to_int:0000000000000000 $t
     /tmp/ccBPcgJ1.s:180    .text.str_to_int:0000000000000000 str_to_int
     /tmp/ccBPcgJ1.s:247    .text.command_set_regime_ph:0000000000000000 $t
     /tmp/ccBPcgJ1.s:252    .text.command_set_regime_ph:0000000000000000 command_set_regime_ph
     /tmp/ccBPcgJ1.s:1961   .rodata.str1.4:0000000000000000 .LC0
     /tmp/ccBPcgJ1.s:2038   .data.REGIME_PH:0000000000000000 .LANCHOR0
     /tmp/ccBPcgJ1.s:526    .text.command_set_stage:0000000000000000 $t
     /tmp/ccBPcgJ1.s:531    .text.command_set_stage:0000000000000000 command_set_stage
     /tmp/ccBPcgJ1.s:1964   .rodata.str1.4:000000000000004c .LC1
                            *COM*:00000000000000f0 stages
     /tmp/ccBPcgJ1.s:716    .text.command_set_stage:00000000000000fa $d
     /tmp/ccBPcgJ1.s:724    .text.command_set_stage:0000000000000102 $t
     /tmp/ccBPcgJ1.s:873    .text.command_set:0000000000000000 $t
     /tmp/ccBPcgJ1.s:878    .text.command_set:0000000000000000 command_set
     /tmp/ccBPcgJ1.s:1967   .rodata.str1.4:0000000000000094 .LC2
     /tmp/ccBPcgJ1.s:1970   .rodata.str1.4:00000000000000a0 .LC3
     /tmp/ccBPcgJ1.s:1973   .rodata.str1.4:00000000000000a8 .LC4
     /tmp/ccBPcgJ1.s:1976   .rodata.str1.4:00000000000000bc .LC5
     /tmp/ccBPcgJ1.s:961    .text.command_del_regime_ph:0000000000000000 $t
     /tmp/ccBPcgJ1.s:966    .text.command_del_regime_ph:0000000000000000 command_del_regime_ph
     /tmp/ccBPcgJ1.s:1980   .rodata.str1.4:0000000000000100 .LC6
     /tmp/ccBPcgJ1.s:1982   .rodata.str1.4:0000000000000120 .LC7
     /tmp/ccBPcgJ1.s:1040   .text.command_del_stage:0000000000000000 $t
     /tmp/ccBPcgJ1.s:1045   .text.command_del_stage:0000000000000000 command_del_stage
     /tmp/ccBPcgJ1.s:1985   .rodata.str1.4:0000000000000140 .LC8
     /tmp/ccBPcgJ1.s:1987   .rodata.str1.4:000000000000015c .LC9
     /tmp/ccBPcgJ1.s:1128   .text.command_del:0000000000000000 $t
     /tmp/ccBPcgJ1.s:1133   .text.command_del:0000000000000000 command_del
     /tmp/ccBPcgJ1.s:1990   .rodata.str1.4:0000000000000180 .LC10
     /tmp/ccBPcgJ1.s:1993   .rodata.str1.4:0000000000000188 .LC11
     /tmp/ccBPcgJ1.s:1223   .text.stage_print:0000000000000000 $t
     /tmp/ccBPcgJ1.s:1228   .text.stage_print:0000000000000000 stage_print
     /tmp/ccBPcgJ1.s:1996   .rodata.str1.4:00000000000001a8 .LC12
     /tmp/ccBPcgJ1.s:1279   .text.regime_ph_print:0000000000000000 $t
     /tmp/ccBPcgJ1.s:1284   .text.regime_ph_print:0000000000000000 regime_ph_print
     /tmp/ccBPcgJ1.s:2000   .rodata.str1.4:00000000000001fc .LC13
     /tmp/ccBPcgJ1.s:1330   .text.command_get:0000000000000000 $t
     /tmp/ccBPcgJ1.s:1335   .text.command_get:0000000000000000 command_get
     /tmp/ccBPcgJ1.s:2002   .rodata.str1.4:0000000000000220 .LC14
     /tmp/ccBPcgJ1.s:2005   .rodata.str1.4:0000000000000240 .LC15
     /tmp/ccBPcgJ1.s:1544   .text.command_config_clock:0000000000000000 $t
     /tmp/ccBPcgJ1.s:1549   .text.command_config_clock:0000000000000000 command_config_clock
     /tmp/ccBPcgJ1.s:2008   .rodata.str1.4:000000000000025c .LC16
     /tmp/ccBPcgJ1.s:1785   .text.command_config:0000000000000000 $t
     /tmp/ccBPcgJ1.s:1790   .text.command_config:0000000000000000 command_config
     /tmp/ccBPcgJ1.s:2012   .rodata.str1.4:00000000000002ac .LC17
     /tmp/ccBPcgJ1.s:1828   .text.command_routing:0000000000000000 $t
     /tmp/ccBPcgJ1.s:1833   .text.command_routing:0000000000000000 command_routing
     /tmp/ccBPcgJ1.s:2015   .rodata.str1.4:00000000000002b4 .LC18
     /tmp/ccBPcgJ1.s:2018   .rodata.str1.4:00000000000002bc .LC19
     /tmp/ccBPcgJ1.s:2021   .rodata.str1.4:00000000000002c4 .LC20
     /tmp/ccBPcgJ1.s:2024   .rodata.str1.4:00000000000002cc .LC21
     /tmp/ccBPcgJ1.s:2026   .rodata.str1.4:00000000000002d4 .LC22
     /tmp/ccBPcgJ1.s:2032   .data.REGIME_LIGHTING:0000000000000000 REGIME_LIGHTING
     /tmp/ccBPcgJ1.s:2041   .data.REGIME_PH:0000000000000000 REGIME_PH
     /tmp/ccBPcgJ1.s:1960   .rodata.str1.4:0000000000000000 $d
     /tmp/ccBPcgJ1.s:2029   .data.REGIME_LIGHTING:0000000000000000 $d
     /tmp/ccBPcgJ1.s:2037   .data.REGIME_PH:0000000000000000 $d
                     .debug_frame:0000000000000010 $d
                           .group:0000000000000000 wm4.1.7402b5479d3fa4780665141f585fc0ee
                           .group:0000000000000000 wm4.stddef.h.39.daafd3d79fe2f3a84d2d73d7d4e706f8
                           .group:0000000000000000 wm4.projdefs.h.55.cdae9ead80b5a2ac004f41bb277aad45
                           .group:0000000000000000 wm4.FreeRTOSConfig.h.55.a343614a17c4367a6359a1f530d6d32b
                           .group:0000000000000000 wm4.stm32f4xx.h.48.a3308e16720c7afc3eb28e585e628ce6
                           .group:0000000000000000 wm4.core_cm4.h.32.5f62939b60122629d60d85d0c4a14709
                           .group:0000000000000000 wm4.features.h.22.6a4ca7cd053637cc1d0db6c16f39b2d7
                           .group:0000000000000000 wm4._default_types.h.15.8b2cb27e528498f8ff711db085d6e489
                           .group:0000000000000000 wm4.stdint.h.20.796e373797e732130a803d4c0338fa1b
                           .group:0000000000000000 wm4.core_cmInstr.h.25.f50f886f2edf670cf199b35fd96f5c91
                           .group:0000000000000000 wm4.core_cm4_simd.h.29.b4a3fdfb606cb3b26119424324d4b963
                           .group:0000000000000000 wm4.core_cm4.h.153.5393ef7e6cebf34dd51ca528f9218ab3
                           .group:0000000000000000 wm4.stm32f4xx.h.282.95bae448a91bccfbf24a6f9d95904bb8
                           .group:0000000000000000 wm4.stm32f4xx_adc.h.102.2061aa73008746f3c2cc6ce8f635cad3
                           .group:0000000000000000 wm4.stm32f4xx_can.h.25.87f18ca48b2692d39f76e87b1f07c953
                           .group:0000000000000000 wm4.stm32f4xx_cryp.h.25.db1951c06ee684df97ea3a11aba6cb51
                           .group:0000000000000000 wm4.stm32f4xx_dac.h.25.c43557a6416ea4dfa986c1209c2558d6
                           .group:0000000000000000 wm4.stm32f4xx_dbgmcu.h.24.7aedfdcf091890b5cb96019bd29a2bfc
                           .group:0000000000000000 wm4.stm32f4xx_dcmi.h.24.64883d9be802a535b1d7770d14da73e0
                           .group:0000000000000000 wm4.stm32f4xx_dma.h.25.c1fa1d44ae0bc9c2b3a0d1d355d8c1e6
                           .group:0000000000000000 wm4.stm32f4xx_exti.h.25.620998268d5d3d9042a8297fbe07d507
                           .group:0000000000000000 wm4.stm32f4xx_flash.h.25.65d4f351b72ee41355279f70305f361a
                           .group:0000000000000000 wm4.stm32f4xx_fsmc.h.25.b907ac7bd9bec46e02d06b137d53cfd8
                           .group:0000000000000000 wm4.stm32f4xx_hash.h.25.633fb84f031cf2ab1bd834e536716dfa
                           .group:0000000000000000 wm4.stm32f4xx_gpio.h.25.5bd1d790d742a307b55aea5fa8fcdae8
                           .group:0000000000000000 wm4.stm32f4xx_i2c.h.25.8fcdb817a00a67d4624d79bab0d9275f
                           .group:0000000000000000 wm4.stm32f4xx_iwdg.h.25.3013e8d2058415cb9d51af77f748a146
                           .group:0000000000000000 wm4.stm32f4xx_pwr.h.25.48b68c1f3a894ab012f9c2a2c222f159
                           .group:0000000000000000 wm4.stm32f4xx_rcc.h.24.c15e7c8dc065bb29146f29591b195c87
                           .group:0000000000000000 wm4.stm32f4xx_rng.h.25.cdb5c5c07de6a48aedfde608da3f447e
                           .group:0000000000000000 wm4.stm32f4xx_rtc.h.25.4809a79ad46ad97b4a01e735a96738eb
                           .group:0000000000000000 wm4.stm32f4xx_sdio.h.25.406302aabae34eada94e5f2cde635a3e
                           .group:0000000000000000 wm4.stm32f4xx_spi.h.25.46c61b79ff8408da93e2e90cf9b717d6
                           .group:0000000000000000 wm4.stm32f4xx_syscfg.h.25.9d5caab5677661b69e959531364e23d7
                           .group:0000000000000000 wm4.stm32f4xx_tim.h.25.948f7fc943f34bd206e29758e77ee0a2
                           .group:0000000000000000 wm4.stm32f4xx_usart.h.25.b64697dad017ba547dd272c2cdb5846a
                           .group:0000000000000000 wm4.stm32f4xx_wwdg.h.25.09d70b7849c6894ddf1e83c8e86b70e1
                           .group:0000000000000000 wm4.misc.h.25.a0cb758c1f091b46f201b19cec9e63a1
                           .group:0000000000000000 wm4.stm32f4xx.h.6913.da011404ccb203790556c86f10c46b18
                           .group:0000000000000000 wm4.FreeRTOSConfig.h.74.fc794e36cd6c91c3b4695c74d78d9ccd
                           .group:0000000000000000 wm4.portmacro.h.69.a7e264ae32accd81a6ffb6f75a8356fe
                           .group:0000000000000000 wm4.portable.h.315.489c085dbd13c768c8594a7d23ef5545
                           .group:0000000000000000 wm4.mpu_wrappers.h.55.46a4a008a193040c38098e9a5f07ff9d
                           .group:0000000000000000 wm4.FreeRTOS.h.136.a1d4f27d190f434afd0502fdd510d30a
                           .group:0000000000000000 wm4.list.h.84.e713c47e239b06424d7c93968625e34d
                           .group:0000000000000000 wm4.task.h.73.ea72fb74b80a9cae261e97c6a9e3f3a7
                           .group:0000000000000000 wm4.queue.h.56.a4282b659085ac883e461fc7ab8aecd1
                           .group:0000000000000000 wm4.semphr.h.65.53591bdf1c84eee2eae05897a780c325
                           .group:0000000000000000 wm4.command_parser.h.4.a7fe1e2e0543fcd71ddefe80e3bbf4f3
                           .group:0000000000000000 wm4.hbfuncs.h.2.e3da3dcc1ea881ecd2d374365b99900a

UNDEFINED SYMBOLS
memcpy
USART_rtos_sputs
USART_rtos_wait_send
USART_rtos_puts
USART_puts
getTime
getSystemDay
getEpoch
setTimeSafely
