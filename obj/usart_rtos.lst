   1              		.syntax unified
   2              		.cpu cortex-m4
   3              		.eabi_attribute 27, 3
   4              		.fpu fpv4-sp-d16
   5              		.eabi_attribute 20, 1
   6              		.eabi_attribute 21, 1
   7              		.eabi_attribute 23, 3
   8              		.eabi_attribute 24, 1
   9              		.eabi_attribute 25, 1
  10              		.eabi_attribute 26, 1
  11              		.eabi_attribute 30, 1
  12              		.eabi_attribute 34, 1
  13              		.eabi_attribute 18, 4
  14              		.thumb
  15              		.file	"usart_rtos.c"
  16              		.text
  17              	.Ltext0:
  18              		.cfi_sections	.debug_frame
  19              		.section	.text.USART_rtos_wait_send,"ax",%progbits
  20              		.align	2
  21              		.global	USART_rtos_wait_send
  22              		.thumb
  23              		.thumb_func
  25              	USART_rtos_wait_send:
  26              	.LFB110:
  27              		.file 1 "src/usart_rtos.c"
   1:src/usart_rtos.c **** #include "usart_rtos.h"
   2:src/usart_rtos.c **** #include <stdlib.h>
   3:src/usart_rtos.c **** #include <stdarg.h>
   4:src/usart_rtos.c **** 
   5:src/usart_rtos.c **** 
   6:src/usart_rtos.c **** int USART_rtos_wait_send(USART_rtos_packet *packet) {
  28              		.loc 1 6 0
  29              		.cfi_startproc
  30              		@ args = 0, pretend = 0, frame = 0
  31              		@ frame_needed = 0, uses_anonymous_args = 0
  32              	.LVL0:
  33 0000 08B5     		push	{r3, lr}
  34              	.LCFI0:
  35              		.cfi_def_cfa_offset 8
  36              		.cfi_offset 3, -8
  37              		.cfi_offset 14, -4
  38 0002 0346     		mov	r3, r0
   7:src/usart_rtos.c ****     
   8:src/usart_rtos.c ****     return (xSemaphoreTake(packet->sent_mutex, packet->max_block) == pdTRUE);
  39              		.loc 1 8 0
  40 0004 8068     		ldr	r0, [r0, #8]
  41              	.LVL1:
  42 0006 0021     		movs	r1, #0
  43 0008 DA68     		ldr	r2, [r3, #12]
  44 000a 0B46     		mov	r3, r1
  45              	.LVL2:
  46 000c FFF7FEFF 		bl	xQueueGenericReceive
  47              	.LVL3:
   9:src/usart_rtos.c **** }
  48              		.loc 1 9 0
  49 0010 0128     		cmp	r0, #1
  50 0012 14BF     		ite	ne
  51 0014 0020     		movne	r0, #0
  52 0016 0120     		moveq	r0, #1
  53 0018 08BD     		pop	{r3, pc}
  54              		.cfi_endproc
  55              	.LFE110:
  57 001a 00BF     		.section	.text.USART_rtos_init,"ax",%progbits
  58              		.align	2
  59              		.global	USART_rtos_init
  60              		.thumb
  61              		.thumb_func
  63              	USART_rtos_init:
  64              	.LFB114:
  10:src/usart_rtos.c **** 
  11:src/usart_rtos.c **** void vUSART_puts(USART_rtos_packet *packet) {
  12:src/usart_rtos.c **** 
  13:src/usart_rtos.c ****     if (xSemaphoreTake(packet->USARTx_rtos->transmit_mutex, portMAX_DELAY) == pdTRUE) {
  14:src/usart_rtos.c ****         taskENTER_CRITICAL();
  15:src/usart_rtos.c ****         USART_puts(packet->USARTx_rtos->id, packet->msg);
  16:src/usart_rtos.c **** 
  17:src/usart_rtos.c ****         xSemaphoreGive(packet->USARTx_rtos->transmit_event_mutex);
  18:src/usart_rtos.c ****         xSemaphoreGive(packet->USARTx_rtos->transmit_mutex);
  19:src/usart_rtos.c **** 
  20:src/usart_rtos.c ****         xSemaphoreGive(packet->sent_mutex); 
  21:src/usart_rtos.c ****         taskEXIT_CRITICAL();
  22:src/usart_rtos.c **** 
  23:src/usart_rtos.c ****     }
  24:src/usart_rtos.c ****     vTaskDelete(NULL);
  25:src/usart_rtos.c **** }
  26:src/usart_rtos.c **** 
  27:src/usart_rtos.c **** void USART_rtos_puts(USART_rtos_packet *packet, char *msg) {
  28:src/usart_rtos.c **** 
  29:src/usart_rtos.c ****     packet->msg = msg;
  30:src/usart_rtos.c ****     packet->sent_mutex = xSemaphoreCreateMutex();
  31:src/usart_rtos.c **** 
  32:src/usart_rtos.c **** 
  33:src/usart_rtos.c ****     if (xSemaphoreTake(packet->sent_mutex, portMAX_DELAY) == pdTRUE) { //change this from max_delay
  34:src/usart_rtos.c **** 
  35:src/usart_rtos.c ****         //if (packet->task_handle == NULL) //allow to assign different tasks wont work now tho
  36:src/usart_rtos.c ****         //if (packet->max_block == NULL) packet->max_block = 
  37:src/usart_rtos.c ****         packet->max_block = portMAX_DELAY;
  38:src/usart_rtos.c **** 
  39:src/usart_rtos.c ****         xTaskCreate(vUSART_puts, (signed char*)"vUSART_puts", 128, packet, tskIDLE_PRIORITY+8, NULL
  40:src/usart_rtos.c **** 
  41:src/usart_rtos.c ****     }
  42:src/usart_rtos.c ****     else {
  43:src/usart_rtos.c ****         USART_puts(USART1, "ERROR483\r\n");
  44:src/usart_rtos.c ****         USART_puts(USART2, "ERROR483\r\n");
  45:src/usart_rtos.c **** 
  46:src/usart_rtos.c ****     }
  47:src/usart_rtos.c **** 
  48:src/usart_rtos.c **** };
  49:src/usart_rtos.c **** 
  50:src/usart_rtos.c **** int USART_rtos_sputs(USART_rtos_packet *packet, const char *format, ...) {
  51:src/usart_rtos.c ****     if (packet->msg){
  52:src/usart_rtos.c **** 
  53:src/usart_rtos.c **** 
  54:src/usart_rtos.c ****         va_list ap;
  55:src/usart_rtos.c ****         int rv;
  56:src/usart_rtos.c **** 
  57:src/usart_rtos.c ****         va_start(ap, format);
  58:src/usart_rtos.c ****         rv = vsprintf(packet->msg, format, ap);
  59:src/usart_rtos.c ****         va_end(ap);
  60:src/usart_rtos.c **** 
  61:src/usart_rtos.c ****         USART_rtos_puts(packet, packet->msg);
  62:src/usart_rtos.c **** 
  63:src/usart_rtos.c ****         return rv;
  64:src/usart_rtos.c ****     }
  65:src/usart_rtos.c ****     return -1;
  66:src/usart_rtos.c **** }
  67:src/usart_rtos.c **** 
  68:src/usart_rtos.c **** 
  69:src/usart_rtos.c **** void USART_rtos_init(USART_rtos *USARTx_rtos,USART_TypeDef *USARTx) { //pass usart_Rtos and usartx
  65              		.loc 1 69 0
  66              		.cfi_startproc
  67              		@ args = 0, pretend = 0, frame = 0
  68              		@ frame_needed = 0, uses_anonymous_args = 0
  69              	.LVL4:
  70 0000 10B5     		push	{r4, lr}
  71              	.LCFI1:
  72              		.cfi_def_cfa_offset 8
  73              		.cfi_offset 4, -8
  74              		.cfi_offset 14, -4
  75 0002 0446     		mov	r4, r0
  70:src/usart_rtos.c ****     USARTx_rtos->id = USARTx;
  76              		.loc 1 70 0
  77 0004 8160     		str	r1, [r0, #8]
  71:src/usart_rtos.c ****     USARTx_rtos->write_pos = 0;
  78              		.loc 1 71 0
  79 0006 0023     		movs	r3, #0
  80 0008 0360     		str	r3, [r0]
  72:src/usart_rtos.c ****     USARTx_rtos->read_pos = 0;
  81              		.loc 1 72 0
  82 000a 4360     		str	r3, [r0, #4]
  73:src/usart_rtos.c **** 
  74:src/usart_rtos.c ****     USARTx_rtos->transmit_mutex = xSemaphoreCreateMutex(); 
  83              		.loc 1 74 0
  84 000c FFF7FEFF 		bl	xQueueCreateMutex
  85              	.LVL5:
  86 0010 E060     		str	r0, [r4, #12]
  75:src/usart_rtos.c ****     USARTx_rtos->receive_mutex = xSemaphoreCreateMutex(); 
  87              		.loc 1 75 0
  88 0012 FFF7FEFF 		bl	xQueueCreateMutex
  89              	.LVL6:
  90 0016 2061     		str	r0, [r4, #16]
  76:src/usart_rtos.c **** 
  77:src/usart_rtos.c ****     USARTx_rtos->transmit_event_mutex = xSemaphoreCreateMutex(); 
  91              		.loc 1 77 0
  92 0018 FFF7FEFF 		bl	xQueueCreateMutex
  93              	.LVL7:
  94 001c A061     		str	r0, [r4, #24]
  78:src/usart_rtos.c ****     USARTx_rtos->receive_event_mutex = xSemaphoreCreateMutex(); 
  95              		.loc 1 78 0
  96 001e FFF7FEFF 		bl	xQueueCreateMutex
  97              	.LVL8:
  98 0022 6061     		str	r0, [r4, #20]
  99 0024 10BD     		pop	{r4, pc}
 100              		.cfi_endproc
 101              	.LFE114:
 103 0026 00BF     		.section	.text.USART_put,"ax",%progbits
 104              		.align	2
 105              		.global	USART_put
 106              		.thumb
 107              		.thumb_func
 109              	USART_put:
 110              	.LFB115:
  79:src/usart_rtos.c **** } 
  80:src/usart_rtos.c **** 
  81:src/usart_rtos.c **** void USART_put(USART_TypeDef* USARTx, volatile char c) {
 111              		.loc 1 81 0
 112              		.cfi_startproc
 113              		@ args = 0, pretend = 0, frame = 8
 114              		@ frame_needed = 0, uses_anonymous_args = 0
 115              	.LVL9:
 116 0000 00B5     		push	{lr}
 117              	.LCFI2:
 118              		.cfi_def_cfa_offset 4
 119              		.cfi_offset 14, -4
 120 0002 83B0     		sub	sp, sp, #12
 121              	.LCFI3:
 122              		.cfi_def_cfa_offset 16
 123 0004 8DF80710 		strb	r1, [sp, #7]
 124              	.L4:
  82:src/usart_rtos.c ****     // wait until data register is empty
  83:src/usart_rtos.c ****     while(!(USARTx->SR & 0x00000040) );
 125              		.loc 1 83 0 discriminator 1
 126 0008 0388     		ldrh	r3, [r0]
 127 000a 03F04003 		and	r3, r3, #64
 128 000e 9BB2     		uxth	r3, r3
 129 0010 002B     		cmp	r3, #0
 130 0012 F9D0     		beq	.L4
  84:src/usart_rtos.c ****     USART_SendData(USARTx, c);
 131              		.loc 1 84 0
 132 0014 9DF80710 		ldrb	r1, [sp, #7]	@ zero_extendqisi2
 133              	.LVL10:
 134 0018 FFF7FEFF 		bl	USART_SendData
 135              	.LVL11:
  85:src/usart_rtos.c **** }
 136              		.loc 1 85 0
 137 001c 03B0     		add	sp, sp, #12
 138              		@ sp needed
 139 001e 5DF804FB 		ldr	pc, [sp], #4
 140              		.cfi_endproc
 141              	.LFE115:
 143 0022 00BF     		.section	.text.USART_puts,"ax",%progbits
 144              		.align	2
 145              		.global	USART_puts
 146              		.thumb
 147              		.thumb_func
 149              	USART_puts:
 150              	.LFB116:
  86:src/usart_rtos.c **** 
  87:src/usart_rtos.c **** void USART_puts(USART_TypeDef* USARTx, volatile char *s){
 151              		.loc 1 87 0
 152              		.cfi_startproc
 153              		@ args = 0, pretend = 0, frame = 0
 154              		@ frame_needed = 0, uses_anonymous_args = 0
 155              	.LVL12:
 156 0000 70B5     		push	{r4, r5, r6, lr}
 157              	.LCFI4:
 158              		.cfi_def_cfa_offset 16
 159              		.cfi_offset 4, -16
 160              		.cfi_offset 5, -12
 161              		.cfi_offset 6, -8
 162              		.cfi_offset 14, -4
 163 0002 0646     		mov	r6, r0
 164 0004 0C46     		mov	r4, r1
  88:src/usart_rtos.c **** 	while(*s){
 165              		.loc 1 88 0
 166 0006 07E0     		b	.L7
 167              	.LVL13:
 168              	.L8:
  89:src/usart_rtos.c ****         USART_put(USARTx, *s);
 169              		.loc 1 89 0
 170 0008 2546     		mov	r5, r4
 171 000a 15F8011B 		ldrb	r1, [r5], #1	@ zero_extendqisi2
 172 000e 3046     		mov	r0, r6
 173 0010 FFF7FEFF 		bl	USART_put
 174              	.LVL14:
  90:src/usart_rtos.c **** 		*s++;
 175              		.loc 1 90 0
 176 0014 2378     		ldrb	r3, [r4]	@ zero_extendqisi2
 177 0016 2C46     		mov	r4, r5
 178              	.LVL15:
 179              	.L7:
  88:src/usart_rtos.c **** 	while(*s){
 180              		.loc 1 88 0 discriminator 1
 181 0018 2378     		ldrb	r3, [r4]	@ zero_extendqisi2
 182 001a 13F0FF0F 		tst	r3, #255
 183 001e F3D1     		bne	.L8
  91:src/usart_rtos.c **** 	}
  92:src/usart_rtos.c **** }
 184              		.loc 1 92 0
 185 0020 70BD     		pop	{r4, r5, r6, pc}
 186              		.cfi_endproc
 187              	.LFE116:
 189 0022 00BF     		.section	.text.vUSART_puts,"ax",%progbits
 190              		.align	2
 191              		.global	vUSART_puts
 192              		.thumb
 193              		.thumb_func
 195              	vUSART_puts:
 196              	.LFB111:
  11:src/usart_rtos.c **** 
 197              		.loc 1 11 0
 198              		.cfi_startproc
 199              		@ args = 0, pretend = 0, frame = 0
 200              		@ frame_needed = 0, uses_anonymous_args = 0
 201              	.LVL16:
 202 0000 10B5     		push	{r4, lr}
 203              	.LCFI5:
 204              		.cfi_def_cfa_offset 8
 205              		.cfi_offset 4, -8
 206              		.cfi_offset 14, -4
 207 0002 0446     		mov	r4, r0
  13:src/usart_rtos.c ****         taskENTER_CRITICAL();
 208              		.loc 1 13 0
 209 0004 0368     		ldr	r3, [r0]
 210 0006 D868     		ldr	r0, [r3, #12]
 211              	.LVL17:
 212 0008 0021     		movs	r1, #0
 213 000a 4FF0FF32 		mov	r2, #-1
 214 000e 0B46     		mov	r3, r1
 215 0010 FFF7FEFF 		bl	xQueueGenericReceive
 216              	.LVL18:
 217 0014 0128     		cmp	r0, #1
 218 0016 1CD1     		bne	.L10
  14:src/usart_rtos.c ****         USART_puts(packet->USARTx_rtos->id, packet->msg);
 219              		.loc 1 14 0
 220 0018 FFF7FEFF 		bl	vPortEnterCritical
 221              	.LVL19:
  15:src/usart_rtos.c **** 
 222              		.loc 1 15 0
 223 001c 2368     		ldr	r3, [r4]
 224 001e 9868     		ldr	r0, [r3, #8]
 225 0020 6168     		ldr	r1, [r4, #4]
 226 0022 FFF7FEFF 		bl	USART_puts
 227              	.LVL20:
  17:src/usart_rtos.c ****         xSemaphoreGive(packet->USARTx_rtos->transmit_mutex);
 228              		.loc 1 17 0
 229 0026 2368     		ldr	r3, [r4]
 230 0028 9869     		ldr	r0, [r3, #24]
 231 002a 0021     		movs	r1, #0
 232 002c 0A46     		mov	r2, r1
 233 002e 0B46     		mov	r3, r1
 234 0030 FFF7FEFF 		bl	xQueueGenericSend
 235              	.LVL21:
  18:src/usart_rtos.c **** 
 236              		.loc 1 18 0
 237 0034 2368     		ldr	r3, [r4]
 238 0036 D868     		ldr	r0, [r3, #12]
 239 0038 0021     		movs	r1, #0
 240 003a 0A46     		mov	r2, r1
 241 003c 0B46     		mov	r3, r1
 242 003e FFF7FEFF 		bl	xQueueGenericSend
 243              	.LVL22:
  20:src/usart_rtos.c ****         taskEXIT_CRITICAL();
 244              		.loc 1 20 0
 245 0042 A068     		ldr	r0, [r4, #8]
 246 0044 0021     		movs	r1, #0
 247 0046 0A46     		mov	r2, r1
 248 0048 0B46     		mov	r3, r1
 249 004a FFF7FEFF 		bl	xQueueGenericSend
 250              	.LVL23:
  21:src/usart_rtos.c **** 
 251              		.loc 1 21 0
 252 004e FFF7FEFF 		bl	vPortExitCritical
 253              	.LVL24:
 254              	.L10:
  24:src/usart_rtos.c **** }
 255              		.loc 1 24 0
 256 0052 0020     		movs	r0, #0
 257 0054 FFF7FEFF 		bl	vTaskDelete
 258              	.LVL25:
 259 0058 10BD     		pop	{r4, pc}
 260              		.cfi_endproc
 261              	.LFE111:
 263 005a 00BF     		.section	.text.USART_rtos_puts,"ax",%progbits
 264              		.align	2
 265              		.global	USART_rtos_puts
 266              		.thumb
 267              		.thumb_func
 269              	USART_rtos_puts:
 270              	.LFB112:
  27:src/usart_rtos.c **** 
 271              		.loc 1 27 0
 272              		.cfi_startproc
 273              		@ args = 0, pretend = 0, frame = 0
 274              		@ frame_needed = 0, uses_anonymous_args = 0
 275              	.LVL26:
 276 0000 10B5     		push	{r4, lr}
 277              	.LCFI6:
 278              		.cfi_def_cfa_offset 8
 279              		.cfi_offset 4, -8
 280              		.cfi_offset 14, -4
 281 0002 84B0     		sub	sp, sp, #16
 282              	.LCFI7:
 283              		.cfi_def_cfa_offset 24
 284 0004 0446     		mov	r4, r0
  29:src/usart_rtos.c ****     packet->sent_mutex = xSemaphoreCreateMutex();
 285              		.loc 1 29 0
 286 0006 4160     		str	r1, [r0, #4]
  30:src/usart_rtos.c **** 
 287              		.loc 1 30 0
 288 0008 FFF7FEFF 		bl	xQueueCreateMutex
 289              	.LVL27:
 290 000c A060     		str	r0, [r4, #8]
  33:src/usart_rtos.c **** 
 291              		.loc 1 33 0
 292 000e 0021     		movs	r1, #0
 293 0010 4FF0FF32 		mov	r2, #-1
 294 0014 0B46     		mov	r3, r1
 295 0016 FFF7FEFF 		bl	xQueueGenericReceive
 296              	.LVL28:
 297 001a 0128     		cmp	r0, #1
 298 001c 15D1     		bne	.L12
  37:src/usart_rtos.c **** 
 299              		.loc 1 37 0
 300 001e 4FF0FF33 		mov	r3, #-1
 301 0022 E360     		str	r3, [r4, #12]
  39:src/usart_rtos.c **** 
 302              		.loc 1 39 0
 303 0024 0823     		movs	r3, #8
 304 0026 0093     		str	r3, [sp]
 305 0028 0023     		movs	r3, #0
 306 002a 0193     		str	r3, [sp, #4]
 307 002c 0293     		str	r3, [sp, #8]
 308 002e 0393     		str	r3, [sp, #12]
 309 0030 40F20000 		movw	r0, #:lower16:vUSART_puts
 310 0034 C0F20000 		movt	r0, #:upper16:vUSART_puts
 311 0038 40F20001 		movw	r1, #:lower16:.LC0
 312 003c C0F20001 		movt	r1, #:upper16:.LC0
 313 0040 8022     		movs	r2, #128
 314 0042 2346     		mov	r3, r4
 315 0044 FFF7FEFF 		bl	xTaskGenericCreate
 316              	.LVL29:
 317 0048 11E0     		b	.L11
 318              	.L12:
  43:src/usart_rtos.c ****         USART_puts(USART2, "ERROR483\r\n");
 319              		.loc 1 43 0
 320 004a 40F20004 		movw	r4, #:lower16:.LC1
 321              	.LVL30:
 322 004e C0F20004 		movt	r4, #:upper16:.LC1
 323 0052 4FF48050 		mov	r0, #4096
 324 0056 C4F20100 		movt	r0, 16385
 325 005a 2146     		mov	r1, r4
 326 005c FFF7FEFF 		bl	USART_puts
 327              	.LVL31:
  44:src/usart_rtos.c **** 
 328              		.loc 1 44 0
 329 0060 4FF48840 		mov	r0, #17408
 330 0064 C4F20000 		movt	r0, 16384
 331 0068 2146     		mov	r1, r4
 332 006a FFF7FEFF 		bl	USART_puts
 333              	.LVL32:
 334              	.L11:
  48:src/usart_rtos.c **** 
 335              		.loc 1 48 0
 336 006e 04B0     		add	sp, sp, #16
 337              		@ sp needed
 338 0070 10BD     		pop	{r4, pc}
 339              		.cfi_endproc
 340              	.LFE112:
 342 0072 00BF     		.section	.text.USART_rtos_sputs,"ax",%progbits
 343              		.align	2
 344              		.global	USART_rtos_sputs
 345              		.thumb
 346              		.thumb_func
 348              	USART_rtos_sputs:
 349              	.LFB113:
  50:src/usart_rtos.c ****     if (packet->msg){
 350              		.loc 1 50 0
 351              		.cfi_startproc
 352              		@ args = 4, pretend = 12, frame = 8
 353              		@ frame_needed = 0, uses_anonymous_args = 1
 354              	.LVL33:
 355 0000 0EB4     		push	{r1, r2, r3}
 356              	.LCFI8:
 357              		.cfi_def_cfa_offset 12
 358              		.cfi_offset 1, -12
 359              		.cfi_offset 2, -8
 360              		.cfi_offset 3, -4
 361 0002 30B5     		push	{r4, r5, lr}
 362              	.LCFI9:
 363              		.cfi_def_cfa_offset 24
 364              		.cfi_offset 4, -24
 365              		.cfi_offset 5, -20
 366              		.cfi_offset 14, -16
 367 0004 82B0     		sub	sp, sp, #8
 368              	.LCFI10:
 369              		.cfi_def_cfa_offset 32
 370 0006 0446     		mov	r4, r0
  51:src/usart_rtos.c **** 
 371              		.loc 1 51 0
 372 0008 4368     		ldr	r3, [r0, #4]
 373 000a 63B1     		cbz	r3, .L16
 374              	.LBB9:
  57:src/usart_rtos.c ****         rv = vsprintf(packet->msg, format, ap);
 375              		.loc 1 57 0
 376 000c 06AA     		add	r2, sp, #24
 377 000e 0192     		str	r2, [sp, #4]
  58:src/usart_rtos.c ****         va_end(ap);
 378              		.loc 1 58 0
 379 0010 1846     		mov	r0, r3
 380              	.LVL34:
 381 0012 0599     		ldr	r1, [sp, #20]
 382 0014 FFF7FEFF 		bl	vsprintf
 383              	.LVL35:
 384 0018 0546     		mov	r5, r0
 385              	.LVL36:
  61:src/usart_rtos.c **** 
 386              		.loc 1 61 0
 387 001a 2046     		mov	r0, r4
 388              	.LVL37:
 389 001c 6168     		ldr	r1, [r4, #4]
 390 001e FFF7FEFF 		bl	USART_rtos_puts
 391              	.LVL38:
  63:src/usart_rtos.c ****     }
 392              		.loc 1 63 0
 393 0022 2846     		mov	r0, r5
 394 0024 01E0     		b	.L15
 395              	.LVL39:
 396              	.L16:
 397              	.LBE9:
  65:src/usart_rtos.c **** }
 398              		.loc 1 65 0
 399 0026 4FF0FF30 		mov	r0, #-1
 400              	.LVL40:
 401              	.L15:
  66:src/usart_rtos.c **** 
 402              		.loc 1 66 0
 403 002a 02B0     		add	sp, sp, #8
 404              		@ sp needed
 405 002c BDE83040 		pop	{r4, r5, lr}
 406              	.LVL41:
 407 0030 03B0     		add	sp, sp, #12
 408 0032 7047     		bx	lr
 409              		.cfi_endproc
 410              	.LFE113:
 412              		.section	.text.USART_put_unsigned_int,"ax",%progbits
 413              		.align	2
 414              		.global	USART_put_unsigned_int
 415              		.thumb
 416              		.thumb_func
 418              	USART_put_unsigned_int:
 419              	.LFB117:
  93:src/usart_rtos.c **** 
  94:src/usart_rtos.c **** void USART_put_unsigned_int(USART_TypeDef* USARTx, unsigned int number) {
 420              		.loc 1 94 0
 421              		.cfi_startproc
 422              		@ args = 0, pretend = 0, frame = 16
 423              		@ frame_needed = 0, uses_anonymous_args = 0
 424              	.LVL42:
 425 0000 70B5     		push	{r4, r5, r6, lr}
 426              	.LCFI11:
 427              		.cfi_def_cfa_offset 16
 428              		.cfi_offset 4, -16
 429              		.cfi_offset 5, -12
 430              		.cfi_offset 6, -8
 431              		.cfi_offset 14, -4
 432 0002 84B0     		sub	sp, sp, #16
 433              	.LCFI12:
 434              		.cfi_def_cfa_offset 32
 435 0004 0646     		mov	r6, r0
 436              	.LVL43:
  95:src/usart_rtos.c ****     char value[10];
  96:src/usart_rtos.c ****     int i=0;
 437              		.loc 1 96 0
 438 0006 0022     		movs	r2, #0
  97:src/usart_rtos.c ****     do {
  98:src/usart_rtos.c ****         value[i++] = (char)(number % 10) + '0';
 439              		.loc 1 98 0
 440 0008 4CF6CD40 		movw	r0, #52429
 441              	.LVL44:
 442 000c CCF6CC40 		movt	r0, 52428
 443              	.LVL45:
 444              	.L18:
 445              		.loc 1 98 0 is_stmt 0 discriminator 1
 446 0010 541C     		adds	r4, r2, #1
 447              	.LVL46:
 448 0012 A0FB0153 		umull	r5, r3, r0, r1
 449 0016 DB08     		lsrs	r3, r3, #3
 450 0018 1D46     		mov	r5, r3
 451 001a 03EB8303 		add	r3, r3, r3, lsl #2
 452 001e A1EB4303 		sub	r3, r1, r3, lsl #1
 453 0022 DBB2     		uxtb	r3, r3
 454 0024 04A9     		add	r1, sp, #16
 455              	.LVL47:
 456 0026 0A44     		add	r2, r2, r1
 457 0028 3033     		adds	r3, r3, #48
 458 002a 02F80C3C 		strb	r3, [r2, #-12]
  99:src/usart_rtos.c ****         number /= 10;
 459              		.loc 1 99 0 is_stmt 1 discriminator 1
 460 002e 2946     		mov	r1, r5
 461              	.LVL48:
  98:src/usart_rtos.c ****         number /= 10;
 462              		.loc 1 98 0 discriminator 1
 463 0030 2246     		mov	r2, r4
 100:src/usart_rtos.c ****     } while (number);
 464              		.loc 1 100 0 discriminator 1
 465 0032 002D     		cmp	r5, #0
 466 0034 ECD1     		bne	.L18
 467 0036 07E0     		b	.L22
 468              	.LVL49:
 469              	.L20:
 101:src/usart_rtos.c **** 
 102:src/usart_rtos.c ****     while(i) {
 103:src/usart_rtos.c ****         USART_put(USARTx, value[--i]);
 470              		.loc 1 103 0
 471 0038 013C     		subs	r4, r4, #1
 472              	.LVL50:
 473 003a 04AB     		add	r3, sp, #16
 474 003c 2344     		add	r3, r3, r4
 475 003e 3046     		mov	r0, r6
 476 0040 13F80C1C 		ldrb	r1, [r3, #-12]	@ zero_extendqisi2
 477 0044 FFF7FEFF 		bl	USART_put
 478              	.LVL51:
 479              	.L22:
 102:src/usart_rtos.c ****         USART_put(USARTx, value[--i]);
 480              		.loc 1 102 0 discriminator 1
 481 0048 002C     		cmp	r4, #0
 482 004a F5D1     		bne	.L20
 104:src/usart_rtos.c ****     }
 105:src/usart_rtos.c **** }
 483              		.loc 1 105 0
 484 004c 04B0     		add	sp, sp, #16
 485              		@ sp needed
 486 004e 70BD     		pop	{r4, r5, r6, pc}
 487              		.cfi_endproc
 488              	.LFE117:
 490              		.section	.text.USART_put_int,"ax",%progbits
 491              		.align	2
 492              		.global	USART_put_int
 493              		.thumb
 494              		.thumb_func
 496              	USART_put_int:
 497              	.LFB118:
 106:src/usart_rtos.c **** 
 107:src/usart_rtos.c **** 
 108:src/usart_rtos.c **** void USART_put_int(USART_TypeDef* USARTx, int number) {
 498              		.loc 1 108 0
 499              		.cfi_startproc
 500              		@ args = 0, pretend = 0, frame = 16
 501              		@ frame_needed = 0, uses_anonymous_args = 0
 502              	.LVL52:
 503 0000 F0B5     		push	{r4, r5, r6, r7, lr}
 504              	.LCFI13:
 505              		.cfi_def_cfa_offset 20
 506              		.cfi_offset 4, -20
 507              		.cfi_offset 5, -16
 508              		.cfi_offset 6, -12
 509              		.cfi_offset 7, -8
 510              		.cfi_offset 14, -4
 511 0002 85B0     		sub	sp, sp, #20
 512              	.LCFI14:
 513              		.cfi_def_cfa_offset 40
 514 0004 0646     		mov	r6, r0
 515              	.LVL53:
 109:src/usart_rtos.c ****     uint8_t neg = 0;
 110:src/usart_rtos.c **** 
 111:src/usart_rtos.c ****     if (number < 0) {
 516              		.loc 1 111 0
 517 0006 0029     		cmp	r1, #0
 112:src/usart_rtos.c ****         number*=-1;
 518              		.loc 1 112 0
 519 0008 BABF     		itte	lt
 520 000a 4942     		rsblt	r1, r1, #0
 521              	.LVL54:
 113:src/usart_rtos.c ****         neg = 1;
 522              		.loc 1 113 0
 523 000c 0127     		movlt	r7, #1
 109:src/usart_rtos.c ****     uint8_t neg = 0;
 524              		.loc 1 109 0
 525 000e 0027     		movge	r7, #0
 526              	.LVL55:
 114:src/usart_rtos.c ****     }
 115:src/usart_rtos.c ****     char value[10];
 116:src/usart_rtos.c ****     int i=0;
 527              		.loc 1 116 0
 528 0010 0022     		movs	r2, #0
 117:src/usart_rtos.c ****     do {
 118:src/usart_rtos.c ****         value[i++] = (char)(number % 10) + '0';
 529              		.loc 1 118 0
 530 0012 46F26760 		movw	r0, #26215
 531              	.LVL56:
 532 0016 C6F26660 		movt	r0, 26214
 533              	.LVL57:
 534              	.L25:
 535              		.loc 1 118 0 is_stmt 0 discriminator 1
 536 001a 541C     		adds	r4, r2, #1
 537              	.LVL58:
 538 001c 80FB0135 		smull	r3, r5, r0, r1
 539 0020 CB17     		asrs	r3, r1, #31
 540 0022 C3EBA503 		rsb	r3, r3, r5, asr #2
 541 0026 1D46     		mov	r5, r3
 542 0028 03EB8303 		add	r3, r3, r3, lsl #2
 543 002c A1EB4303 		sub	r3, r1, r3, lsl #1
 544 0030 DBB2     		uxtb	r3, r3
 545 0032 04A9     		add	r1, sp, #16
 546              	.LVL59:
 547 0034 0A44     		add	r2, r2, r1
 548 0036 3033     		adds	r3, r3, #48
 549 0038 02F80C3C 		strb	r3, [r2, #-12]
 119:src/usart_rtos.c ****         number /= 10;
 550              		.loc 1 119 0 is_stmt 1 discriminator 1
 551 003c 2946     		mov	r1, r5
 552              	.LVL60:
 118:src/usart_rtos.c ****         number /= 10;
 553              		.loc 1 118 0 discriminator 1
 554 003e 2246     		mov	r2, r4
 120:src/usart_rtos.c ****     } while (number);
 555              		.loc 1 120 0 discriminator 1
 556 0040 002D     		cmp	r5, #0
 557 0042 EAD1     		bne	.L25
 121:src/usart_rtos.c **** 
 122:src/usart_rtos.c ****     if (neg) USART_put(USARTx, '-');    
 558              		.loc 1 122 0
 559 0044 67B1     		cbz	r7, .L31
 560              		.loc 1 122 0 is_stmt 0 discriminator 1
 561 0046 3046     		mov	r0, r6
 562 0048 2D21     		movs	r1, #45
 563              	.LVL61:
 564 004a FFF7FEFF 		bl	USART_put
 565              	.LVL62:
 566 004e 07E0     		b	.L31
 567              	.L28:
 123:src/usart_rtos.c ****     while(i) {
 124:src/usart_rtos.c ****         USART_put(USARTx, value[--i]);
 568              		.loc 1 124 0 is_stmt 1
 569 0050 013C     		subs	r4, r4, #1
 570              	.LVL63:
 571 0052 04AB     		add	r3, sp, #16
 572 0054 2344     		add	r3, r3, r4
 573 0056 3046     		mov	r0, r6
 574 0058 13F80C1C 		ldrb	r1, [r3, #-12]	@ zero_extendqisi2
 575 005c FFF7FEFF 		bl	USART_put
 576              	.LVL64:
 577              	.L31:
 123:src/usart_rtos.c ****     while(i) {
 578              		.loc 1 123 0 discriminator 1
 579 0060 002C     		cmp	r4, #0
 580 0062 F5D1     		bne	.L28
 125:src/usart_rtos.c ****     }
 126:src/usart_rtos.c **** }
 581              		.loc 1 126 0
 582 0064 05B0     		add	sp, sp, #20
 583              		@ sp needed
 584 0066 F0BD     		pop	{r4, r5, r6, r7, pc}
 585              		.cfi_endproc
 586              	.LFE118:
 588              		.section	.text.USART_getline,"ax",%progbits
 589              		.align	2
 590              		.global	USART_getline
 591              		.thumb
 592              		.thumb_func
 594              	USART_getline:
 595              	.LFB119:
 127:src/usart_rtos.c **** 
 128:src/usart_rtos.c **** void USART_getline(USART_rtos *USARTx_rtos, int timeout) {
 596              		.loc 1 128 0
 597              		.cfi_startproc
 598              		@ args = 0, pretend = 0, frame = 0
 599              		@ frame_needed = 0, uses_anonymous_args = 0
 600              	.LVL65:
 601 0000 38B5     		push	{r3, r4, r5, lr}
 602              	.LCFI15:
 603              		.cfi_def_cfa_offset 16
 604              		.cfi_offset 3, -16
 605              		.cfi_offset 4, -12
 606              		.cfi_offset 5, -8
 607              		.cfi_offset 14, -4
 608 0002 0446     		mov	r4, r0
 609 0004 0D46     		mov	r5, r1
 129:src/usart_rtos.c **** 
 130:src/usart_rtos.c ****     if (xSemaphoreTake(USARTx_rtos->receive_event_mutex, (portTickType)(timeout) / portTICK_RATE_MS
 610              		.loc 1 130 0
 611 0006 4069     		ldr	r0, [r0, #20]
 612              	.LVL66:
 613 0008 0021     		movs	r1, #0
 614              	.LVL67:
 615 000a 012D     		cmp	r5, #1
 616 000c 14BF     		ite	ne
 617 000e 0022     		movne	r2, #0
 618 0010 0122     		moveq	r2, #1
 619 0012 0B46     		mov	r3, r1
 620 0014 FFF7FEFF 		bl	xQueueGenericReceive
 621              	.LVL68:
 622 0018 58B1     		cbz	r0, .L32
 131:src/usart_rtos.c ****         //Takes the mutex.
 132:src/usart_rtos.c ****         //Next time USART_IRQ executes it releases mutex 
 133:src/usart_rtos.c ****         if (xSemaphoreTake(USARTx_rtos->receive_event_mutex, (portTickType)(timeout) / portTICK_RAT
 623              		.loc 1 133 0
 624 001a 6069     		ldr	r0, [r4, #20]
 625 001c 0021     		movs	r1, #0
 626 001e 2A46     		mov	r2, r5
 627 0020 0B46     		mov	r3, r1
 628 0022 FFF7FEFF 		bl	xQueueGenericReceive
 629              	.LVL69:
 134:src/usart_rtos.c ****             //USART_IRQ exexcuted and relased mutex
 135:src/usart_rtos.c ****         }
 136:src/usart_rtos.c ****         xSemaphoreGive(USARTx_rtos->receive_event_mutex);
 630              		.loc 1 136 0
 631 0026 6069     		ldr	r0, [r4, #20]
 632 0028 0021     		movs	r1, #0
 633 002a 0A46     		mov	r2, r1
 634 002c 0B46     		mov	r3, r1
 635 002e FFF7FEFF 		bl	xQueueGenericSend
 636              	.LVL70:
 637              	.L32:
 638 0032 38BD     		pop	{r3, r4, r5, pc}
 639              		.cfi_endproc
 640              	.LFE119:
 642              		.section	.text.USART_nextline_length,"ax",%progbits
 643              		.align	2
 644              		.global	USART_nextline_length
 645              		.thumb
 646              		.thumb_func
 648              	USART_nextline_length:
 649              	.LFB120:
 137:src/usart_rtos.c ****     }
 138:src/usart_rtos.c **** 
 139:src/usart_rtos.c **** }
 140:src/usart_rtos.c **** 
 141:src/usart_rtos.c **** int USART_nextline_length(USART_rtos *USARTx_rtos) {
 650              		.loc 1 141 0
 651              		.cfi_startproc
 652              		@ args = 0, pretend = 0, frame = 0
 653              		@ frame_needed = 0, uses_anonymous_args = 0
 654              	.LVL71:
 655 0000 38B5     		push	{r3, r4, r5, lr}
 656              	.LCFI16:
 657              		.cfi_def_cfa_offset 16
 658              		.cfi_offset 3, -16
 659              		.cfi_offset 4, -12
 660              		.cfi_offset 5, -8
 661              		.cfi_offset 14, -4
 142:src/usart_rtos.c ****     if (!USARTx_rtos) return -1;
 662              		.loc 1 142 0
 663 0002 0546     		mov	r5, r0
 664 0004 F8B1     		cbz	r0, .L38
 143:src/usart_rtos.c **** 
 144:src/usart_rtos.c ****     //add some mutex on read_pos;
 145:src/usart_rtos.c ****     USART_put_int(USARTx_rtos->id, USARTx_rtos->read_pos);
 665              		.loc 1 145 0
 666 0006 8068     		ldr	r0, [r0, #8]
 667              	.LVL72:
 668 0008 6968     		ldr	r1, [r5, #4]
 669 000a FFF7FEFF 		bl	USART_put_int
 670              	.LVL73:
 146:src/usart_rtos.c ****     USART_puts(USARTx_rtos->id, "PRINTING NEXT LINE: ");
 671              		.loc 1 146 0
 672 000e A868     		ldr	r0, [r5, #8]
 673 0010 40F20001 		movw	r1, #:lower16:.LC2
 674 0014 C0F20001 		movt	r1, #:upper16:.LC2
 675 0018 FFF7FEFF 		bl	USART_puts
 676              	.LVL74:
 147:src/usart_rtos.c **** 
 148:src/usart_rtos.c ****     int pos = USARTx_rtos->read_pos;
 677              		.loc 1 148 0
 678 001c 6C68     		ldr	r4, [r5, #4]
 679              	.LVL75:
 149:src/usart_rtos.c ****     for(pos; USARTx_rtos->buffer[pos]!='\r'; pos++) {
 680              		.loc 1 149 0
 681 001e 03E0     		b	.L36
 682              	.L37:
 150:src/usart_rtos.c ****         USART_put(USARTx_rtos->id, USARTx_rtos->buffer[pos]);
 683              		.loc 1 150 0 discriminator 2
 684 0020 A868     		ldr	r0, [r5, #8]
 685 0022 FFF7FEFF 		bl	USART_put
 686              	.LVL76:
 149:src/usart_rtos.c ****     for(pos; USARTx_rtos->buffer[pos]!='\r'; pos++) {
 687              		.loc 1 149 0 discriminator 2
 688 0026 0134     		adds	r4, r4, #1
 689              	.LVL77:
 690              	.L36:
 149:src/usart_rtos.c ****     for(pos; USARTx_rtos->buffer[pos]!='\r'; pos++) {
 691              		.loc 1 149 0 is_stmt 0 discriminator 1
 692 0028 2B19     		adds	r3, r5, r4
 693 002a 197F     		ldrb	r1, [r3, #28]	@ zero_extendqisi2
 694 002c 0D29     		cmp	r1, #13
 695 002e F7D1     		bne	.L37
 151:src/usart_rtos.c **** 
 152:src/usart_rtos.c ****     }
 153:src/usart_rtos.c ****     USART_puts(USARTx_rtos->id, "\r\n");
 696              		.loc 1 153 0 is_stmt 1
 697 0030 A868     		ldr	r0, [r5, #8]
 698 0032 40F20001 		movw	r1, #:lower16:.LC3
 699 0036 C0F20001 		movt	r1, #:upper16:.LC3
 700 003a FFF7FEFF 		bl	USART_puts
 701              	.LVL78:
 154:src/usart_rtos.c ****     /*
 155:src/usart_rtos.c ****     USART_puts(USART1, buffer[*read_pos-1]);
 156:src/usart_rtos.c ****     USART_puts(USART1, buffer[*read_pos+1]);
 157:src/usart_rtos.c **** 
 158:src/usart_rtos.c **** 
 159:src/usart_rtos.c ****     USART_puts(USART1, "-\r\n");
 160:src/usart_rtos.c ****     */
 161:src/usart_rtos.c **** 
 162:src/usart_rtos.c ****     return (pos - USARTx_rtos->read_pos)+1;
 702              		.loc 1 162 0
 703 003e 6868     		ldr	r0, [r5, #4]
 704 0040 201A     		subs	r0, r4, r0
 705 0042 0130     		adds	r0, r0, #1
 706 0044 38BD     		pop	{r3, r4, r5, pc}
 707              	.LVL79:
 708              	.L38:
 142:src/usart_rtos.c **** 
 709              		.loc 1 142 0
 710 0046 4FF0FF30 		mov	r0, #-1
 711              	.LVL80:
 163:src/usart_rtos.c **** }
 712              		.loc 1 163 0
 713 004a 38BD     		pop	{r3, r4, r5, pc}
 714              		.cfi_endproc
 715              	.LFE120:
 717              		.section	.text.handle_usart_command,"ax",%progbits
 718              		.align	2
 719              		.global	handle_usart_command
 720              		.thumb
 721              		.thumb_func
 723              	handle_usart_command:
 724              	.LFB121:
 164:src/usart_rtos.c **** 
 165:src/usart_rtos.c **** void handle_usart_command(char *command) {
 725              		.loc 1 165 0
 726              		.cfi_startproc
 727              		@ args = 0, pretend = 0, frame = 0
 728              		@ frame_needed = 0, uses_anonymous_args = 0
 729              	.LVL81:
 730 0000 38B5     		push	{r3, r4, r5, lr}
 731              	.LCFI17:
 732              		.cfi_def_cfa_offset 16
 733              		.cfi_offset 3, -16
 734              		.cfi_offset 4, -12
 735              		.cfi_offset 5, -8
 736              		.cfi_offset 14, -4
 737 0002 0546     		mov	r5, r0
 166:src/usart_rtos.c ****     USART_puts(USART2, "Command: ");
 738              		.loc 1 166 0
 739 0004 4FF48844 		mov	r4, #17408
 740 0008 C4F20004 		movt	r4, 16384
 741 000c 2046     		mov	r0, r4
 742              	.LVL82:
 743 000e 40F20001 		movw	r1, #:lower16:.LC4
 744 0012 C0F20001 		movt	r1, #:upper16:.LC4
 745 0016 FFF7FEFF 		bl	USART_puts
 746              	.LVL83:
 747              	.LBB10:
 167:src/usart_rtos.c ****     if (str_compare(command, "overview\r", '\r')) {}
 748              		.loc 1 167 0
 749 001a 2846     		mov	r0, r5
 750 001c 40F20001 		movw	r1, #:lower16:.LC5
 751 0020 C0F20001 		movt	r1, #:upper16:.LC5
 752 0024 0D22     		movs	r2, #13
 753 0026 FFF7FEFF 		bl	str_compare
 754              	.LVL84:
 755              	.LBE10:
 168:src/usart_rtos.c **** 
 169:src/usart_rtos.c ****     //if (str_compare)
 170:src/usart_rtos.c **** 
 171:src/usart_rtos.c ****     //char *pos = command;
 172:src/usart_rtos.c **** /*
 173:src/usart_rtos.c ****     while(*command != '\r') {
 174:src/usart_rtos.c ****         if (*command == ' ') {
 175:src/usart_rtos.c ****             while (pos != command) {
 176:src/usart_rtos.c ****                 if (pos == )
 177:src/usart_rtos.c ****                 //something like this in python command[pos1:pos2] == "command1"
 178:src/usart_rtos.c ****                 pos++;
 179:src/usart_rtos.c ****             }
 180:src/usart_rtos.c ****         }
 181:src/usart_rtos.c ****         USART_put(USART2, *command);
 182:src/usart_rtos.c ****         command++;
 183:src/usart_rtos.c ****     }
 184:src/usart_rtos.c ****     */
 185:src/usart_rtos.c **** 
 186:src/usart_rtos.c ****     USART_puts(USART2, "\r\n");
 756              		.loc 1 186 0
 757 002a 2046     		mov	r0, r4
 758 002c 40F20001 		movw	r1, #:lower16:.LC3
 759 0030 C0F20001 		movt	r1, #:upper16:.LC3
 760 0034 FFF7FEFF 		bl	USART_puts
 761              	.LVL85:
 187:src/usart_rtos.c ****     vTaskDelete(NULL);
 762              		.loc 1 187 0
 763 0038 0020     		movs	r0, #0
 764 003a FFF7FEFF 		bl	vTaskDelete
 765              	.LVL86:
 766 003e 38BD     		pop	{r3, r4, r5, pc}
 767              		.cfi_endproc
 768              	.LFE121:
 770              		.section	.text.USART_readline,"ax",%progbits
 771              		.align	2
 772              		.global	USART_readline
 773              		.thumb
 774              		.thumb_func
 776              	USART_readline:
 777              	.LFB122:
 188:src/usart_rtos.c **** }
 189:src/usart_rtos.c **** 
 190:src/usart_rtos.c **** void USART_readline(USART_rtos *USARTx_rtos, char *buffer, uint8_t length) {
 778              		.loc 1 190 0
 779              		.cfi_startproc
 780              		@ args = 0, pretend = 0, frame = 0
 781              		@ frame_needed = 0, uses_anonymous_args = 0
 782              	.LVL87:
 783 0000 2DE9F843 		push	{r3, r4, r5, r6, r7, r8, r9, lr}
 784              	.LCFI18:
 785              		.cfi_def_cfa_offset 32
 786              		.cfi_offset 3, -32
 787              		.cfi_offset 4, -28
 788              		.cfi_offset 5, -24
 789              		.cfi_offset 6, -20
 790              		.cfi_offset 7, -16
 791              		.cfi_offset 8, -12
 792              		.cfi_offset 9, -8
 793              		.cfi_offset 14, -4
 794 0004 0446     		mov	r4, r0
 795 0006 8846     		mov	r8, r1
 191:src/usart_rtos.c ****  //   static uint8_t first=1;
 192:src/usart_rtos.c **** 
 193:src/usart_rtos.c ****     buffer[length-1] = '\0';
 796              		.loc 1 193 0
 797 0008 531E     		subs	r3, r2, #1
 798 000a 0021     		movs	r1, #0
 799              	.LVL88:
 800 000c 08F80310 		strb	r1, [r8, r3]
 194:src/usart_rtos.c **** 
 195:src/usart_rtos.c ****     for(USARTx_rtos->read_pos; USARTx_rtos->read_pos<length-2; USARTx_rtos->read_pos++){
 801              		.loc 1 195 0
 802 0010 961E     		subs	r6, r2, #2
 803              	.LBB11:
 196:src/usart_rtos.c ****         uint32_t prim;
 197:src/usart_rtos.c **** 
 198:src/usart_rtos.c ****         if (xSemaphoreTake(USARTx_rtos->receive_mutex, portMAX_DELAY) == pdTRUE) {
 804              		.loc 1 198 0
 805 0012 0D46     		mov	r5, r1
 806 0014 4FF0FF37 		mov	r7, #-1
 199:src/usart_rtos.c **** 
 200:src/usart_rtos.c ****             prim = __get_PRIMASK(); //returns if irq were disable already
 201:src/usart_rtos.c ****             __disable_irq(); 
 202:src/usart_rtos.c ****             if (!prim) __enable_irq(); //only enables irq if it recieved it in a disabled state
 203:src/usart_rtos.c **** 
 204:src/usart_rtos.c ****             if (USARTx_rtos->read_pos == USART_BUFFER_LEN-1) USARTx_rtos->read_pos=0;
 807              		.loc 1 204 0
 808 0018 40F22B19 		movw	r9, #299
 809              	.LBE11:
 195:src/usart_rtos.c ****         uint32_t prim;
 810              		.loc 1 195 0
 811 001c 1EE0     		b	.L41
 812              	.LVL89:
 813              	.L45:
 814              	.LBB18:
 198:src/usart_rtos.c **** 
 815              		.loc 1 198 0
 816 001e 2069     		ldr	r0, [r4, #16]
 817 0020 2946     		mov	r1, r5
 818 0022 3A46     		mov	r2, r7
 819 0024 2B46     		mov	r3, r5
 820 0026 FFF7FEFF 		bl	xQueueGenericReceive
 821              	.LVL90:
 822 002a 0128     		cmp	r0, #1
 823 002c 13D1     		bne	.L42
 824              	.LBB12:
 825              	.LBB13:
 826              		.file 2 "libs/CMSIS/Include/core_cmFunc.h"
   1:libs/CMSIS/Include/core_cmFunc.h **** /**************************************************************************//**
   2:libs/CMSIS/Include/core_cmFunc.h ****  * @file     core_cmFunc.h
   3:libs/CMSIS/Include/core_cmFunc.h ****  * @brief    CMSIS Cortex-M Core Function Access Header File
   4:libs/CMSIS/Include/core_cmFunc.h ****  * @version  V2.10
   5:libs/CMSIS/Include/core_cmFunc.h ****  * @date     26. July 2011
   6:libs/CMSIS/Include/core_cmFunc.h ****  *
   7:libs/CMSIS/Include/core_cmFunc.h ****  * @note
   8:libs/CMSIS/Include/core_cmFunc.h ****  * Copyright (C) 2009-2011 ARM Limited. All rights reserved.
   9:libs/CMSIS/Include/core_cmFunc.h ****  *
  10:libs/CMSIS/Include/core_cmFunc.h ****  * @par
  11:libs/CMSIS/Include/core_cmFunc.h ****  * ARM Limited (ARM) is supplying this software for use with Cortex-M 
  12:libs/CMSIS/Include/core_cmFunc.h ****  * processor based microcontrollers.  This file can be freely distributed 
  13:libs/CMSIS/Include/core_cmFunc.h ****  * within development tools that are supporting such ARM based processors. 
  14:libs/CMSIS/Include/core_cmFunc.h ****  *
  15:libs/CMSIS/Include/core_cmFunc.h ****  * @par
  16:libs/CMSIS/Include/core_cmFunc.h ****  * THIS SOFTWARE IS PROVIDED "AS IS".  NO WARRANTIES, WHETHER EXPRESS, IMPLIED
  17:libs/CMSIS/Include/core_cmFunc.h ****  * OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
  18:libs/CMSIS/Include/core_cmFunc.h ****  * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
  19:libs/CMSIS/Include/core_cmFunc.h ****  * ARM SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR
  20:libs/CMSIS/Include/core_cmFunc.h ****  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
  21:libs/CMSIS/Include/core_cmFunc.h ****  *
  22:libs/CMSIS/Include/core_cmFunc.h ****  ******************************************************************************/
  23:libs/CMSIS/Include/core_cmFunc.h **** 
  24:libs/CMSIS/Include/core_cmFunc.h **** #ifndef __CORE_CMFUNC_H
  25:libs/CMSIS/Include/core_cmFunc.h **** #define __CORE_CMFUNC_H
  26:libs/CMSIS/Include/core_cmFunc.h **** 
  27:libs/CMSIS/Include/core_cmFunc.h **** 
  28:libs/CMSIS/Include/core_cmFunc.h **** /* ###########################  Core Function Access  ########################### */
  29:libs/CMSIS/Include/core_cmFunc.h **** /** \ingroup  CMSIS_Core_FunctionInterface   
  30:libs/CMSIS/Include/core_cmFunc.h ****     \defgroup CMSIS_Core_RegAccFunctions CMSIS Core Register Access Functions
  31:libs/CMSIS/Include/core_cmFunc.h ****   @{
  32:libs/CMSIS/Include/core_cmFunc.h ****  */
  33:libs/CMSIS/Include/core_cmFunc.h **** 
  34:libs/CMSIS/Include/core_cmFunc.h **** #if   defined ( __CC_ARM ) /*------------------RealView Compiler -----------------*/
  35:libs/CMSIS/Include/core_cmFunc.h **** /* ARM armcc specific functions */
  36:libs/CMSIS/Include/core_cmFunc.h **** 
  37:libs/CMSIS/Include/core_cmFunc.h **** #if (__ARMCC_VERSION < 400677)
  38:libs/CMSIS/Include/core_cmFunc.h ****   #error "Please use ARM Compiler Toolchain V4.0.677 or later!"
  39:libs/CMSIS/Include/core_cmFunc.h **** #endif
  40:libs/CMSIS/Include/core_cmFunc.h **** 
  41:libs/CMSIS/Include/core_cmFunc.h **** /* intrinsic void __enable_irq();     */
  42:libs/CMSIS/Include/core_cmFunc.h **** /* intrinsic void __disable_irq();    */
  43:libs/CMSIS/Include/core_cmFunc.h **** 
  44:libs/CMSIS/Include/core_cmFunc.h **** /** \brief  Get Control Register
  45:libs/CMSIS/Include/core_cmFunc.h **** 
  46:libs/CMSIS/Include/core_cmFunc.h ****     This function returns the content of the Control Register.
  47:libs/CMSIS/Include/core_cmFunc.h **** 
  48:libs/CMSIS/Include/core_cmFunc.h ****     \return               Control Register value
  49:libs/CMSIS/Include/core_cmFunc.h ****  */
  50:libs/CMSIS/Include/core_cmFunc.h **** static __INLINE uint32_t __get_CONTROL(void)
  51:libs/CMSIS/Include/core_cmFunc.h **** {
  52:libs/CMSIS/Include/core_cmFunc.h ****   register uint32_t __regControl         __ASM("control");
  53:libs/CMSIS/Include/core_cmFunc.h ****   return(__regControl);
  54:libs/CMSIS/Include/core_cmFunc.h **** }
  55:libs/CMSIS/Include/core_cmFunc.h **** 
  56:libs/CMSIS/Include/core_cmFunc.h **** 
  57:libs/CMSIS/Include/core_cmFunc.h **** /** \brief  Set Control Register
  58:libs/CMSIS/Include/core_cmFunc.h **** 
  59:libs/CMSIS/Include/core_cmFunc.h ****     This function writes the given value to the Control Register.
  60:libs/CMSIS/Include/core_cmFunc.h **** 
  61:libs/CMSIS/Include/core_cmFunc.h ****     \param [in]    control  Control Register value to set
  62:libs/CMSIS/Include/core_cmFunc.h ****  */
  63:libs/CMSIS/Include/core_cmFunc.h **** static __INLINE void __set_CONTROL(uint32_t control)
  64:libs/CMSIS/Include/core_cmFunc.h **** {
  65:libs/CMSIS/Include/core_cmFunc.h ****   register uint32_t __regControl         __ASM("control");
  66:libs/CMSIS/Include/core_cmFunc.h ****   __regControl = control;
  67:libs/CMSIS/Include/core_cmFunc.h **** }
  68:libs/CMSIS/Include/core_cmFunc.h **** 
  69:libs/CMSIS/Include/core_cmFunc.h **** 
  70:libs/CMSIS/Include/core_cmFunc.h **** /** \brief  Get ISPR Register
  71:libs/CMSIS/Include/core_cmFunc.h **** 
  72:libs/CMSIS/Include/core_cmFunc.h ****     This function returns the content of the ISPR Register.
  73:libs/CMSIS/Include/core_cmFunc.h **** 
  74:libs/CMSIS/Include/core_cmFunc.h ****     \return               ISPR Register value
  75:libs/CMSIS/Include/core_cmFunc.h ****  */
  76:libs/CMSIS/Include/core_cmFunc.h **** static __INLINE uint32_t __get_IPSR(void)
  77:libs/CMSIS/Include/core_cmFunc.h **** {
  78:libs/CMSIS/Include/core_cmFunc.h ****   register uint32_t __regIPSR          __ASM("ipsr");
  79:libs/CMSIS/Include/core_cmFunc.h ****   return(__regIPSR);
  80:libs/CMSIS/Include/core_cmFunc.h **** }
  81:libs/CMSIS/Include/core_cmFunc.h **** 
  82:libs/CMSIS/Include/core_cmFunc.h **** 
  83:libs/CMSIS/Include/core_cmFunc.h **** /** \brief  Get APSR Register
  84:libs/CMSIS/Include/core_cmFunc.h **** 
  85:libs/CMSIS/Include/core_cmFunc.h ****     This function returns the content of the APSR Register.
  86:libs/CMSIS/Include/core_cmFunc.h **** 
  87:libs/CMSIS/Include/core_cmFunc.h ****     \return               APSR Register value
  88:libs/CMSIS/Include/core_cmFunc.h ****  */
  89:libs/CMSIS/Include/core_cmFunc.h **** static __INLINE uint32_t __get_APSR(void)
  90:libs/CMSIS/Include/core_cmFunc.h **** {
  91:libs/CMSIS/Include/core_cmFunc.h ****   register uint32_t __regAPSR          __ASM("apsr");
  92:libs/CMSIS/Include/core_cmFunc.h ****   return(__regAPSR);
  93:libs/CMSIS/Include/core_cmFunc.h **** }
  94:libs/CMSIS/Include/core_cmFunc.h **** 
  95:libs/CMSIS/Include/core_cmFunc.h **** 
  96:libs/CMSIS/Include/core_cmFunc.h **** /** \brief  Get xPSR Register
  97:libs/CMSIS/Include/core_cmFunc.h **** 
  98:libs/CMSIS/Include/core_cmFunc.h ****     This function returns the content of the xPSR Register.
  99:libs/CMSIS/Include/core_cmFunc.h **** 
 100:libs/CMSIS/Include/core_cmFunc.h ****     \return               xPSR Register value
 101:libs/CMSIS/Include/core_cmFunc.h ****  */
 102:libs/CMSIS/Include/core_cmFunc.h **** static __INLINE uint32_t __get_xPSR(void)
 103:libs/CMSIS/Include/core_cmFunc.h **** {
 104:libs/CMSIS/Include/core_cmFunc.h ****   register uint32_t __regXPSR          __ASM("xpsr");
 105:libs/CMSIS/Include/core_cmFunc.h ****   return(__regXPSR);
 106:libs/CMSIS/Include/core_cmFunc.h **** }
 107:libs/CMSIS/Include/core_cmFunc.h **** 
 108:libs/CMSIS/Include/core_cmFunc.h **** 
 109:libs/CMSIS/Include/core_cmFunc.h **** /** \brief  Get Process Stack Pointer
 110:libs/CMSIS/Include/core_cmFunc.h **** 
 111:libs/CMSIS/Include/core_cmFunc.h ****     This function returns the current value of the Process Stack Pointer (PSP).
 112:libs/CMSIS/Include/core_cmFunc.h **** 
 113:libs/CMSIS/Include/core_cmFunc.h ****     \return               PSP Register value
 114:libs/CMSIS/Include/core_cmFunc.h ****  */
 115:libs/CMSIS/Include/core_cmFunc.h **** static __INLINE uint32_t __get_PSP(void)
 116:libs/CMSIS/Include/core_cmFunc.h **** {
 117:libs/CMSIS/Include/core_cmFunc.h ****   register uint32_t __regProcessStackPointer  __ASM("psp");
 118:libs/CMSIS/Include/core_cmFunc.h ****   return(__regProcessStackPointer);
 119:libs/CMSIS/Include/core_cmFunc.h **** }
 120:libs/CMSIS/Include/core_cmFunc.h **** 
 121:libs/CMSIS/Include/core_cmFunc.h **** 
 122:libs/CMSIS/Include/core_cmFunc.h **** /** \brief  Set Process Stack Pointer
 123:libs/CMSIS/Include/core_cmFunc.h **** 
 124:libs/CMSIS/Include/core_cmFunc.h ****     This function assigns the given value to the Process Stack Pointer (PSP).
 125:libs/CMSIS/Include/core_cmFunc.h **** 
 126:libs/CMSIS/Include/core_cmFunc.h ****     \param [in]    topOfProcStack  Process Stack Pointer value to set
 127:libs/CMSIS/Include/core_cmFunc.h ****  */
 128:libs/CMSIS/Include/core_cmFunc.h **** static __INLINE void __set_PSP(uint32_t topOfProcStack)
 129:libs/CMSIS/Include/core_cmFunc.h **** {
 130:libs/CMSIS/Include/core_cmFunc.h ****   register uint32_t __regProcessStackPointer  __ASM("psp");
 131:libs/CMSIS/Include/core_cmFunc.h ****   __regProcessStackPointer = topOfProcStack;
 132:libs/CMSIS/Include/core_cmFunc.h **** }
 133:libs/CMSIS/Include/core_cmFunc.h **** 
 134:libs/CMSIS/Include/core_cmFunc.h **** 
 135:libs/CMSIS/Include/core_cmFunc.h **** /** \brief  Get Main Stack Pointer
 136:libs/CMSIS/Include/core_cmFunc.h **** 
 137:libs/CMSIS/Include/core_cmFunc.h ****     This function returns the current value of the Main Stack Pointer (MSP).
 138:libs/CMSIS/Include/core_cmFunc.h **** 
 139:libs/CMSIS/Include/core_cmFunc.h ****     \return               MSP Register value
 140:libs/CMSIS/Include/core_cmFunc.h ****  */
 141:libs/CMSIS/Include/core_cmFunc.h **** static __INLINE uint32_t __get_MSP(void)
 142:libs/CMSIS/Include/core_cmFunc.h **** {
 143:libs/CMSIS/Include/core_cmFunc.h ****   register uint32_t __regMainStackPointer     __ASM("msp");
 144:libs/CMSIS/Include/core_cmFunc.h ****   return(__regMainStackPointer);
 145:libs/CMSIS/Include/core_cmFunc.h **** }
 146:libs/CMSIS/Include/core_cmFunc.h **** 
 147:libs/CMSIS/Include/core_cmFunc.h **** 
 148:libs/CMSIS/Include/core_cmFunc.h **** /** \brief  Set Main Stack Pointer
 149:libs/CMSIS/Include/core_cmFunc.h **** 
 150:libs/CMSIS/Include/core_cmFunc.h ****     This function assigns the given value to the Main Stack Pointer (MSP).
 151:libs/CMSIS/Include/core_cmFunc.h **** 
 152:libs/CMSIS/Include/core_cmFunc.h ****     \param [in]    topOfMainStack  Main Stack Pointer value to set
 153:libs/CMSIS/Include/core_cmFunc.h ****  */
 154:libs/CMSIS/Include/core_cmFunc.h **** static __INLINE void __set_MSP(uint32_t topOfMainStack)
 155:libs/CMSIS/Include/core_cmFunc.h **** {
 156:libs/CMSIS/Include/core_cmFunc.h ****   register uint32_t __regMainStackPointer     __ASM("msp");
 157:libs/CMSIS/Include/core_cmFunc.h ****   __regMainStackPointer = topOfMainStack;
 158:libs/CMSIS/Include/core_cmFunc.h **** }
 159:libs/CMSIS/Include/core_cmFunc.h **** 
 160:libs/CMSIS/Include/core_cmFunc.h **** 
 161:libs/CMSIS/Include/core_cmFunc.h **** /** \brief  Get Priority Mask
 162:libs/CMSIS/Include/core_cmFunc.h **** 
 163:libs/CMSIS/Include/core_cmFunc.h ****     This function returns the current state of the priority mask bit from the Priority Mask Registe
 164:libs/CMSIS/Include/core_cmFunc.h **** 
 165:libs/CMSIS/Include/core_cmFunc.h ****     \return               Priority Mask value
 166:libs/CMSIS/Include/core_cmFunc.h ****  */
 167:libs/CMSIS/Include/core_cmFunc.h **** static __INLINE uint32_t __get_PRIMASK(void)
 168:libs/CMSIS/Include/core_cmFunc.h **** {
 169:libs/CMSIS/Include/core_cmFunc.h ****   register uint32_t __regPriMask         __ASM("primask");
 170:libs/CMSIS/Include/core_cmFunc.h ****   return(__regPriMask);
 171:libs/CMSIS/Include/core_cmFunc.h **** }
 172:libs/CMSIS/Include/core_cmFunc.h **** 
 173:libs/CMSIS/Include/core_cmFunc.h **** 
 174:libs/CMSIS/Include/core_cmFunc.h **** /** \brief  Set Priority Mask
 175:libs/CMSIS/Include/core_cmFunc.h **** 
 176:libs/CMSIS/Include/core_cmFunc.h ****     This function assigns the given value to the Priority Mask Register.
 177:libs/CMSIS/Include/core_cmFunc.h **** 
 178:libs/CMSIS/Include/core_cmFunc.h ****     \param [in]    priMask  Priority Mask
 179:libs/CMSIS/Include/core_cmFunc.h ****  */
 180:libs/CMSIS/Include/core_cmFunc.h **** static __INLINE void __set_PRIMASK(uint32_t priMask)
 181:libs/CMSIS/Include/core_cmFunc.h **** {
 182:libs/CMSIS/Include/core_cmFunc.h ****   register uint32_t __regPriMask         __ASM("primask");
 183:libs/CMSIS/Include/core_cmFunc.h ****   __regPriMask = (priMask);
 184:libs/CMSIS/Include/core_cmFunc.h **** }
 185:libs/CMSIS/Include/core_cmFunc.h ****  
 186:libs/CMSIS/Include/core_cmFunc.h **** 
 187:libs/CMSIS/Include/core_cmFunc.h **** #if       (__CORTEX_M >= 0x03)
 188:libs/CMSIS/Include/core_cmFunc.h **** 
 189:libs/CMSIS/Include/core_cmFunc.h **** /** \brief  Enable FIQ
 190:libs/CMSIS/Include/core_cmFunc.h **** 
 191:libs/CMSIS/Include/core_cmFunc.h ****     This function enables FIQ interrupts by clearing the F-bit in the CPSR.
 192:libs/CMSIS/Include/core_cmFunc.h ****     Can only be executed in Privileged modes.
 193:libs/CMSIS/Include/core_cmFunc.h ****  */
 194:libs/CMSIS/Include/core_cmFunc.h **** #define __enable_fault_irq                __enable_fiq
 195:libs/CMSIS/Include/core_cmFunc.h **** 
 196:libs/CMSIS/Include/core_cmFunc.h **** 
 197:libs/CMSIS/Include/core_cmFunc.h **** /** \brief  Disable FIQ
 198:libs/CMSIS/Include/core_cmFunc.h **** 
 199:libs/CMSIS/Include/core_cmFunc.h ****     This function disables FIQ interrupts by setting the F-bit in the CPSR.
 200:libs/CMSIS/Include/core_cmFunc.h ****     Can only be executed in Privileged modes.
 201:libs/CMSIS/Include/core_cmFunc.h ****  */
 202:libs/CMSIS/Include/core_cmFunc.h **** #define __disable_fault_irq               __disable_fiq
 203:libs/CMSIS/Include/core_cmFunc.h **** 
 204:libs/CMSIS/Include/core_cmFunc.h **** 
 205:libs/CMSIS/Include/core_cmFunc.h **** /** \brief  Get Base Priority
 206:libs/CMSIS/Include/core_cmFunc.h **** 
 207:libs/CMSIS/Include/core_cmFunc.h ****     This function returns the current value of the Base Priority register.
 208:libs/CMSIS/Include/core_cmFunc.h **** 
 209:libs/CMSIS/Include/core_cmFunc.h ****     \return               Base Priority register value
 210:libs/CMSIS/Include/core_cmFunc.h ****  */
 211:libs/CMSIS/Include/core_cmFunc.h **** static __INLINE uint32_t  __get_BASEPRI(void)
 212:libs/CMSIS/Include/core_cmFunc.h **** {
 213:libs/CMSIS/Include/core_cmFunc.h ****   register uint32_t __regBasePri         __ASM("basepri");
 214:libs/CMSIS/Include/core_cmFunc.h ****   return(__regBasePri);
 215:libs/CMSIS/Include/core_cmFunc.h **** }
 216:libs/CMSIS/Include/core_cmFunc.h **** 
 217:libs/CMSIS/Include/core_cmFunc.h **** 
 218:libs/CMSIS/Include/core_cmFunc.h **** /** \brief  Set Base Priority
 219:libs/CMSIS/Include/core_cmFunc.h **** 
 220:libs/CMSIS/Include/core_cmFunc.h ****     This function assigns the given value to the Base Priority register.
 221:libs/CMSIS/Include/core_cmFunc.h **** 
 222:libs/CMSIS/Include/core_cmFunc.h ****     \param [in]    basePri  Base Priority value to set
 223:libs/CMSIS/Include/core_cmFunc.h ****  */
 224:libs/CMSIS/Include/core_cmFunc.h **** static __INLINE void __set_BASEPRI(uint32_t basePri)
 225:libs/CMSIS/Include/core_cmFunc.h **** {
 226:libs/CMSIS/Include/core_cmFunc.h ****   register uint32_t __regBasePri         __ASM("basepri");
 227:libs/CMSIS/Include/core_cmFunc.h ****   __regBasePri = (basePri & 0xff);
 228:libs/CMSIS/Include/core_cmFunc.h **** }
 229:libs/CMSIS/Include/core_cmFunc.h ****  
 230:libs/CMSIS/Include/core_cmFunc.h **** 
 231:libs/CMSIS/Include/core_cmFunc.h **** /** \brief  Get Fault Mask
 232:libs/CMSIS/Include/core_cmFunc.h **** 
 233:libs/CMSIS/Include/core_cmFunc.h ****     This function returns the current value of the Fault Mask register.
 234:libs/CMSIS/Include/core_cmFunc.h **** 
 235:libs/CMSIS/Include/core_cmFunc.h ****     \return               Fault Mask register value
 236:libs/CMSIS/Include/core_cmFunc.h ****  */
 237:libs/CMSIS/Include/core_cmFunc.h **** static __INLINE uint32_t __get_FAULTMASK(void)
 238:libs/CMSIS/Include/core_cmFunc.h **** {
 239:libs/CMSIS/Include/core_cmFunc.h ****   register uint32_t __regFaultMask       __ASM("faultmask");
 240:libs/CMSIS/Include/core_cmFunc.h ****   return(__regFaultMask);
 241:libs/CMSIS/Include/core_cmFunc.h **** }
 242:libs/CMSIS/Include/core_cmFunc.h **** 
 243:libs/CMSIS/Include/core_cmFunc.h **** 
 244:libs/CMSIS/Include/core_cmFunc.h **** /** \brief  Set Fault Mask
 245:libs/CMSIS/Include/core_cmFunc.h **** 
 246:libs/CMSIS/Include/core_cmFunc.h ****     This function assigns the given value to the Fault Mask register.
 247:libs/CMSIS/Include/core_cmFunc.h **** 
 248:libs/CMSIS/Include/core_cmFunc.h ****     \param [in]    faultMask  Fault Mask value to set
 249:libs/CMSIS/Include/core_cmFunc.h ****  */
 250:libs/CMSIS/Include/core_cmFunc.h **** static __INLINE void __set_FAULTMASK(uint32_t faultMask)
 251:libs/CMSIS/Include/core_cmFunc.h **** {
 252:libs/CMSIS/Include/core_cmFunc.h ****   register uint32_t __regFaultMask       __ASM("faultmask");
 253:libs/CMSIS/Include/core_cmFunc.h ****   __regFaultMask = (faultMask & (uint32_t)1);
 254:libs/CMSIS/Include/core_cmFunc.h **** }
 255:libs/CMSIS/Include/core_cmFunc.h **** 
 256:libs/CMSIS/Include/core_cmFunc.h **** #endif /* (__CORTEX_M >= 0x03) */
 257:libs/CMSIS/Include/core_cmFunc.h **** 
 258:libs/CMSIS/Include/core_cmFunc.h **** 
 259:libs/CMSIS/Include/core_cmFunc.h **** #if       (__CORTEX_M == 0x04)
 260:libs/CMSIS/Include/core_cmFunc.h **** 
 261:libs/CMSIS/Include/core_cmFunc.h **** /** \brief  Get FPSCR
 262:libs/CMSIS/Include/core_cmFunc.h **** 
 263:libs/CMSIS/Include/core_cmFunc.h ****     This function returns the current value of the Floating Point Status/Control register.
 264:libs/CMSIS/Include/core_cmFunc.h **** 
 265:libs/CMSIS/Include/core_cmFunc.h ****     \return               Floating Point Status/Control register value
 266:libs/CMSIS/Include/core_cmFunc.h ****  */
 267:libs/CMSIS/Include/core_cmFunc.h **** static __INLINE uint32_t __get_FPSCR(void)
 268:libs/CMSIS/Include/core_cmFunc.h **** {
 269:libs/CMSIS/Include/core_cmFunc.h **** #if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
 270:libs/CMSIS/Include/core_cmFunc.h ****   register uint32_t __regfpscr         __ASM("fpscr");
 271:libs/CMSIS/Include/core_cmFunc.h ****   return(__regfpscr);
 272:libs/CMSIS/Include/core_cmFunc.h **** #else
 273:libs/CMSIS/Include/core_cmFunc.h ****    return(0);
 274:libs/CMSIS/Include/core_cmFunc.h **** #endif
 275:libs/CMSIS/Include/core_cmFunc.h **** }
 276:libs/CMSIS/Include/core_cmFunc.h **** 
 277:libs/CMSIS/Include/core_cmFunc.h **** 
 278:libs/CMSIS/Include/core_cmFunc.h **** /** \brief  Set FPSCR
 279:libs/CMSIS/Include/core_cmFunc.h **** 
 280:libs/CMSIS/Include/core_cmFunc.h ****     This function assigns the given value to the Floating Point Status/Control register.
 281:libs/CMSIS/Include/core_cmFunc.h **** 
 282:libs/CMSIS/Include/core_cmFunc.h ****     \param [in]    fpscr  Floating Point Status/Control value to set
 283:libs/CMSIS/Include/core_cmFunc.h ****  */
 284:libs/CMSIS/Include/core_cmFunc.h **** static __INLINE void __set_FPSCR(uint32_t fpscr)
 285:libs/CMSIS/Include/core_cmFunc.h **** {
 286:libs/CMSIS/Include/core_cmFunc.h **** #if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
 287:libs/CMSIS/Include/core_cmFunc.h ****   register uint32_t __regfpscr         __ASM("fpscr");
 288:libs/CMSIS/Include/core_cmFunc.h ****   __regfpscr = (fpscr);
 289:libs/CMSIS/Include/core_cmFunc.h **** #endif
 290:libs/CMSIS/Include/core_cmFunc.h **** }
 291:libs/CMSIS/Include/core_cmFunc.h **** 
 292:libs/CMSIS/Include/core_cmFunc.h **** #endif /* (__CORTEX_M == 0x04) */
 293:libs/CMSIS/Include/core_cmFunc.h **** 
 294:libs/CMSIS/Include/core_cmFunc.h **** 
 295:libs/CMSIS/Include/core_cmFunc.h **** #elif defined ( __ICCARM__ ) /*------------------ ICC Compiler -------------------*/
 296:libs/CMSIS/Include/core_cmFunc.h **** /* IAR iccarm specific functions */
 297:libs/CMSIS/Include/core_cmFunc.h **** 
 298:libs/CMSIS/Include/core_cmFunc.h **** #include <cmsis_iar.h>
 299:libs/CMSIS/Include/core_cmFunc.h **** 
 300:libs/CMSIS/Include/core_cmFunc.h **** #elif defined ( __GNUC__ ) /*------------------ GNU Compiler ---------------------*/
 301:libs/CMSIS/Include/core_cmFunc.h **** /* GNU gcc specific functions */
 302:libs/CMSIS/Include/core_cmFunc.h **** 
 303:libs/CMSIS/Include/core_cmFunc.h **** /** \brief  Enable IRQ Interrupts
 304:libs/CMSIS/Include/core_cmFunc.h **** 
 305:libs/CMSIS/Include/core_cmFunc.h ****   This function enables IRQ interrupts by clearing the I-bit in the CPSR.
 306:libs/CMSIS/Include/core_cmFunc.h ****   Can only be executed in Privileged modes.
 307:libs/CMSIS/Include/core_cmFunc.h ****  */
 308:libs/CMSIS/Include/core_cmFunc.h **** __attribute__( ( always_inline ) ) static __INLINE void __enable_irq(void)
 309:libs/CMSIS/Include/core_cmFunc.h **** {
 310:libs/CMSIS/Include/core_cmFunc.h ****   __ASM volatile ("cpsie i");
 311:libs/CMSIS/Include/core_cmFunc.h **** }
 312:libs/CMSIS/Include/core_cmFunc.h **** 
 313:libs/CMSIS/Include/core_cmFunc.h **** 
 314:libs/CMSIS/Include/core_cmFunc.h **** /** \brief  Disable IRQ Interrupts
 315:libs/CMSIS/Include/core_cmFunc.h **** 
 316:libs/CMSIS/Include/core_cmFunc.h ****   This function disables IRQ interrupts by setting the I-bit in the CPSR.
 317:libs/CMSIS/Include/core_cmFunc.h ****   Can only be executed in Privileged modes.
 318:libs/CMSIS/Include/core_cmFunc.h ****  */
 319:libs/CMSIS/Include/core_cmFunc.h **** __attribute__( ( always_inline ) ) static __INLINE void __disable_irq(void)
 320:libs/CMSIS/Include/core_cmFunc.h **** {
 321:libs/CMSIS/Include/core_cmFunc.h ****   __ASM volatile ("cpsid i");
 322:libs/CMSIS/Include/core_cmFunc.h **** }
 323:libs/CMSIS/Include/core_cmFunc.h **** 
 324:libs/CMSIS/Include/core_cmFunc.h **** 
 325:libs/CMSIS/Include/core_cmFunc.h **** /** \brief  Get Control Register
 326:libs/CMSIS/Include/core_cmFunc.h **** 
 327:libs/CMSIS/Include/core_cmFunc.h ****     This function returns the content of the Control Register.
 328:libs/CMSIS/Include/core_cmFunc.h **** 
 329:libs/CMSIS/Include/core_cmFunc.h ****     \return               Control Register value
 330:libs/CMSIS/Include/core_cmFunc.h ****  */
 331:libs/CMSIS/Include/core_cmFunc.h **** __attribute__( ( always_inline ) ) static __INLINE uint32_t __get_CONTROL(void)
 332:libs/CMSIS/Include/core_cmFunc.h **** {
 333:libs/CMSIS/Include/core_cmFunc.h ****   uint32_t result;
 334:libs/CMSIS/Include/core_cmFunc.h **** 
 335:libs/CMSIS/Include/core_cmFunc.h ****   __ASM volatile ("MRS %0, control" : "=r" (result) );
 336:libs/CMSIS/Include/core_cmFunc.h ****   return(result);
 337:libs/CMSIS/Include/core_cmFunc.h **** }
 338:libs/CMSIS/Include/core_cmFunc.h **** 
 339:libs/CMSIS/Include/core_cmFunc.h **** 
 340:libs/CMSIS/Include/core_cmFunc.h **** /** \brief  Set Control Register
 341:libs/CMSIS/Include/core_cmFunc.h **** 
 342:libs/CMSIS/Include/core_cmFunc.h ****     This function writes the given value to the Control Register.
 343:libs/CMSIS/Include/core_cmFunc.h **** 
 344:libs/CMSIS/Include/core_cmFunc.h ****     \param [in]    control  Control Register value to set
 345:libs/CMSIS/Include/core_cmFunc.h ****  */
 346:libs/CMSIS/Include/core_cmFunc.h **** __attribute__( ( always_inline ) ) static __INLINE void __set_CONTROL(uint32_t control)
 347:libs/CMSIS/Include/core_cmFunc.h **** {
 348:libs/CMSIS/Include/core_cmFunc.h ****   __ASM volatile ("MSR control, %0" : : "r" (control) );
 349:libs/CMSIS/Include/core_cmFunc.h **** }
 350:libs/CMSIS/Include/core_cmFunc.h **** 
 351:libs/CMSIS/Include/core_cmFunc.h **** 
 352:libs/CMSIS/Include/core_cmFunc.h **** /** \brief  Get ISPR Register
 353:libs/CMSIS/Include/core_cmFunc.h **** 
 354:libs/CMSIS/Include/core_cmFunc.h ****     This function returns the content of the ISPR Register.
 355:libs/CMSIS/Include/core_cmFunc.h **** 
 356:libs/CMSIS/Include/core_cmFunc.h ****     \return               ISPR Register value
 357:libs/CMSIS/Include/core_cmFunc.h ****  */
 358:libs/CMSIS/Include/core_cmFunc.h **** __attribute__( ( always_inline ) ) static __INLINE uint32_t __get_IPSR(void)
 359:libs/CMSIS/Include/core_cmFunc.h **** {
 360:libs/CMSIS/Include/core_cmFunc.h ****   uint32_t result;
 361:libs/CMSIS/Include/core_cmFunc.h **** 
 362:libs/CMSIS/Include/core_cmFunc.h ****   __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 363:libs/CMSIS/Include/core_cmFunc.h ****   return(result);
 364:libs/CMSIS/Include/core_cmFunc.h **** }
 365:libs/CMSIS/Include/core_cmFunc.h **** 
 366:libs/CMSIS/Include/core_cmFunc.h **** 
 367:libs/CMSIS/Include/core_cmFunc.h **** /** \brief  Get APSR Register
 368:libs/CMSIS/Include/core_cmFunc.h **** 
 369:libs/CMSIS/Include/core_cmFunc.h ****     This function returns the content of the APSR Register.
 370:libs/CMSIS/Include/core_cmFunc.h **** 
 371:libs/CMSIS/Include/core_cmFunc.h ****     \return               APSR Register value
 372:libs/CMSIS/Include/core_cmFunc.h ****  */
 373:libs/CMSIS/Include/core_cmFunc.h **** __attribute__( ( always_inline ) ) static __INLINE uint32_t __get_APSR(void)
 374:libs/CMSIS/Include/core_cmFunc.h **** {
 375:libs/CMSIS/Include/core_cmFunc.h ****   uint32_t result;
 376:libs/CMSIS/Include/core_cmFunc.h **** 
 377:libs/CMSIS/Include/core_cmFunc.h ****   __ASM volatile ("MRS %0, apsr" : "=r" (result) );
 378:libs/CMSIS/Include/core_cmFunc.h ****   return(result);
 379:libs/CMSIS/Include/core_cmFunc.h **** }
 380:libs/CMSIS/Include/core_cmFunc.h **** 
 381:libs/CMSIS/Include/core_cmFunc.h **** 
 382:libs/CMSIS/Include/core_cmFunc.h **** /** \brief  Get xPSR Register
 383:libs/CMSIS/Include/core_cmFunc.h **** 
 384:libs/CMSIS/Include/core_cmFunc.h ****     This function returns the content of the xPSR Register.
 385:libs/CMSIS/Include/core_cmFunc.h **** 
 386:libs/CMSIS/Include/core_cmFunc.h ****     \return               xPSR Register value
 387:libs/CMSIS/Include/core_cmFunc.h ****  */
 388:libs/CMSIS/Include/core_cmFunc.h **** __attribute__( ( always_inline ) ) static __INLINE uint32_t __get_xPSR(void)
 389:libs/CMSIS/Include/core_cmFunc.h **** {
 390:libs/CMSIS/Include/core_cmFunc.h ****   uint32_t result;
 391:libs/CMSIS/Include/core_cmFunc.h **** 
 392:libs/CMSIS/Include/core_cmFunc.h ****   __ASM volatile ("MRS %0, xpsr" : "=r" (result) );
 393:libs/CMSIS/Include/core_cmFunc.h ****   return(result);
 394:libs/CMSIS/Include/core_cmFunc.h **** }
 395:libs/CMSIS/Include/core_cmFunc.h **** 
 396:libs/CMSIS/Include/core_cmFunc.h **** 
 397:libs/CMSIS/Include/core_cmFunc.h **** /** \brief  Get Process Stack Pointer
 398:libs/CMSIS/Include/core_cmFunc.h **** 
 399:libs/CMSIS/Include/core_cmFunc.h ****     This function returns the current value of the Process Stack Pointer (PSP).
 400:libs/CMSIS/Include/core_cmFunc.h **** 
 401:libs/CMSIS/Include/core_cmFunc.h ****     \return               PSP Register value
 402:libs/CMSIS/Include/core_cmFunc.h ****  */
 403:libs/CMSIS/Include/core_cmFunc.h **** __attribute__( ( always_inline ) ) static __INLINE uint32_t __get_PSP(void)
 404:libs/CMSIS/Include/core_cmFunc.h **** {
 405:libs/CMSIS/Include/core_cmFunc.h ****   register uint32_t result;
 406:libs/CMSIS/Include/core_cmFunc.h **** 
 407:libs/CMSIS/Include/core_cmFunc.h ****   __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
 408:libs/CMSIS/Include/core_cmFunc.h ****   return(result);
 409:libs/CMSIS/Include/core_cmFunc.h **** }
 410:libs/CMSIS/Include/core_cmFunc.h ****  
 411:libs/CMSIS/Include/core_cmFunc.h **** 
 412:libs/CMSIS/Include/core_cmFunc.h **** /** \brief  Set Process Stack Pointer
 413:libs/CMSIS/Include/core_cmFunc.h **** 
 414:libs/CMSIS/Include/core_cmFunc.h ****     This function assigns the given value to the Process Stack Pointer (PSP).
 415:libs/CMSIS/Include/core_cmFunc.h **** 
 416:libs/CMSIS/Include/core_cmFunc.h ****     \param [in]    topOfProcStack  Process Stack Pointer value to set
 417:libs/CMSIS/Include/core_cmFunc.h ****  */
 418:libs/CMSIS/Include/core_cmFunc.h **** __attribute__( ( always_inline ) ) static __INLINE void __set_PSP(uint32_t topOfProcStack)
 419:libs/CMSIS/Include/core_cmFunc.h **** {
 420:libs/CMSIS/Include/core_cmFunc.h ****   __ASM volatile ("MSR psp, %0\n" : : "r" (topOfProcStack) );
 421:libs/CMSIS/Include/core_cmFunc.h **** }
 422:libs/CMSIS/Include/core_cmFunc.h **** 
 423:libs/CMSIS/Include/core_cmFunc.h **** 
 424:libs/CMSIS/Include/core_cmFunc.h **** /** \brief  Get Main Stack Pointer
 425:libs/CMSIS/Include/core_cmFunc.h **** 
 426:libs/CMSIS/Include/core_cmFunc.h ****     This function returns the current value of the Main Stack Pointer (MSP).
 427:libs/CMSIS/Include/core_cmFunc.h **** 
 428:libs/CMSIS/Include/core_cmFunc.h ****     \return               MSP Register value
 429:libs/CMSIS/Include/core_cmFunc.h ****  */
 430:libs/CMSIS/Include/core_cmFunc.h **** __attribute__( ( always_inline ) ) static __INLINE uint32_t __get_MSP(void)
 431:libs/CMSIS/Include/core_cmFunc.h **** {
 432:libs/CMSIS/Include/core_cmFunc.h ****   register uint32_t result;
 433:libs/CMSIS/Include/core_cmFunc.h **** 
 434:libs/CMSIS/Include/core_cmFunc.h ****   __ASM volatile ("MRS %0, msp\n" : "=r" (result) );
 435:libs/CMSIS/Include/core_cmFunc.h ****   return(result);
 436:libs/CMSIS/Include/core_cmFunc.h **** }
 437:libs/CMSIS/Include/core_cmFunc.h ****  
 438:libs/CMSIS/Include/core_cmFunc.h **** 
 439:libs/CMSIS/Include/core_cmFunc.h **** /** \brief  Set Main Stack Pointer
 440:libs/CMSIS/Include/core_cmFunc.h **** 
 441:libs/CMSIS/Include/core_cmFunc.h ****     This function assigns the given value to the Main Stack Pointer (MSP).
 442:libs/CMSIS/Include/core_cmFunc.h **** 
 443:libs/CMSIS/Include/core_cmFunc.h ****     \param [in]    topOfMainStack  Main Stack Pointer value to set
 444:libs/CMSIS/Include/core_cmFunc.h ****  */
 445:libs/CMSIS/Include/core_cmFunc.h **** __attribute__( ( always_inline ) ) static __INLINE void __set_MSP(uint32_t topOfMainStack)
 446:libs/CMSIS/Include/core_cmFunc.h **** {
 447:libs/CMSIS/Include/core_cmFunc.h ****   __ASM volatile ("MSR msp, %0\n" : : "r" (topOfMainStack) );
 448:libs/CMSIS/Include/core_cmFunc.h **** }
 449:libs/CMSIS/Include/core_cmFunc.h **** 
 450:libs/CMSIS/Include/core_cmFunc.h **** 
 451:libs/CMSIS/Include/core_cmFunc.h **** /** \brief  Get Priority Mask
 452:libs/CMSIS/Include/core_cmFunc.h **** 
 453:libs/CMSIS/Include/core_cmFunc.h ****     This function returns the current state of the priority mask bit from the Priority Mask Registe
 454:libs/CMSIS/Include/core_cmFunc.h **** 
 455:libs/CMSIS/Include/core_cmFunc.h ****     \return               Priority Mask value
 456:libs/CMSIS/Include/core_cmFunc.h ****  */
 457:libs/CMSIS/Include/core_cmFunc.h **** __attribute__( ( always_inline ) ) static __INLINE uint32_t __get_PRIMASK(void)
 458:libs/CMSIS/Include/core_cmFunc.h **** {
 459:libs/CMSIS/Include/core_cmFunc.h ****   uint32_t result;
 460:libs/CMSIS/Include/core_cmFunc.h **** 
 461:libs/CMSIS/Include/core_cmFunc.h ****   __ASM volatile ("MRS %0, primask" : "=r" (result) );
 827              		.loc 2 461 0
 828              	@ 461 "libs/CMSIS/Include/core_cmFunc.h" 1
 829 002e EFF31083 		MRS r3, primask
 830              	@ 0 "" 2
 831              	.LVL91:
 832              		.thumb
 833              	.LBE13:
 834              	.LBE12:
 835              	.LBB14:
 836              	.LBB15:
 321:libs/CMSIS/Include/core_cmFunc.h **** }
 837              		.loc 2 321 0
 838              	@ 321 "libs/CMSIS/Include/core_cmFunc.h" 1
 839 0032 72B6     		cpsid i
 840              	@ 0 "" 2
 841              		.thumb
 842              	.LBE15:
 843              	.LBE14:
 202:src/usart_rtos.c **** 
 844              		.loc 1 202 0
 845 0034 03B9     		cbnz	r3, .L43
 846              	.LBB16:
 847              	.LBB17:
 310:libs/CMSIS/Include/core_cmFunc.h **** }
 848              		.loc 2 310 0
 849              	@ 310 "libs/CMSIS/Include/core_cmFunc.h" 1
 850 0036 62B6     		cpsie i
 851              	@ 0 "" 2
 852              		.thumb
 853              	.L43:
 854              	.LBE17:
 855              	.LBE16:
 856              		.loc 1 204 0
 857 0038 6368     		ldr	r3, [r4, #4]
 858 003a 4B45     		cmp	r3, r9
 859 003c 08BF     		it	eq
 860 003e 6560     		streq	r5, [r4, #4]
 205:src/usart_rtos.c ****             buffer[USARTx_rtos->read_pos] = USARTx_rtos->buffer[USARTx_rtos->read_pos];
 861              		.loc 1 205 0
 862 0040 6368     		ldr	r3, [r4, #4]
 863 0042 E218     		adds	r2, r4, r3
 864 0044 127F     		ldrb	r2, [r2, #28]	@ zero_extendqisi2
 865 0046 08F80320 		strb	r2, [r8, r3]
 206:src/usart_rtos.c ****             xSemaphoreGive(USARTx_rtos->receive_mutex);
 866              		.loc 1 206 0
 867 004a 2069     		ldr	r0, [r4, #16]
 868 004c 2946     		mov	r1, r5
 869 004e 2A46     		mov	r2, r5
 870 0050 2B46     		mov	r3, r5
 871 0052 FFF7FEFF 		bl	xQueueGenericSend
 872              	.LVL92:
 873              	.L42:
 874              	.LBE18:
 195:src/usart_rtos.c ****         uint32_t prim;
 875              		.loc 1 195 0
 876 0056 6368     		ldr	r3, [r4, #4]
 877 0058 0133     		adds	r3, r3, #1
 878 005a 6360     		str	r3, [r4, #4]
 879              	.L41:
 195:src/usart_rtos.c ****         uint32_t prim;
 880              		.loc 1 195 0 is_stmt 0 discriminator 1
 881 005c 6368     		ldr	r3, [r4, #4]
 882 005e B342     		cmp	r3, r6
 883 0060 DDDB     		blt	.L45
 207:src/usart_rtos.c ****         }
 208:src/usart_rtos.c ****     }
 209:src/usart_rtos.c ****    // if (!first) read_pos++; //This skips the previous Carriage return added to the end of data ad
 210:src/usart_rtos.c ****     //else first = 0;
 211:src/usart_rtos.c ****     USARTx_rtos->read_pos++;
 884              		.loc 1 211 0 is_stmt 1
 885 0062 0133     		adds	r3, r3, #1
 886 0064 6360     		str	r3, [r4, #4]
 887 0066 BDE8F883 		pop	{r3, r4, r5, r6, r7, r8, r9, pc}
 888              		.cfi_endproc
 889              	.LFE122:
 891 006a 00BF     		.section	.text.USART_readline_int,"ax",%progbits
 892              		.align	2
 893              		.global	USART_readline_int
 894              		.thumb
 895              		.thumb_func
 897              	USART_readline_int:
 898              	.LFB123:
 212:src/usart_rtos.c **** 
 213:src/usart_rtos.c **** }
 214:src/usart_rtos.c **** 
 215:src/usart_rtos.c **** void USART_readline_int(USART_rtos *USARTx_rtos, int *num) {
 899              		.loc 1 215 0
 900              		.cfi_startproc
 901              		@ args = 0, pretend = 0, frame = 0
 902              		@ frame_needed = 1, uses_anonymous_args = 0
 903              	.LVL93:
 904 0000 F8B5     		push	{r3, r4, r5, r6, r7, lr}
 905              	.LCFI19:
 906              		.cfi_def_cfa_offset 24
 907              		.cfi_offset 3, -24
 908              		.cfi_offset 4, -20
 909              		.cfi_offset 5, -16
 910              		.cfi_offset 6, -12
 911              		.cfi_offset 7, -8
 912              		.cfi_offset 14, -4
 913 0002 00AF     		add	r7, sp, #0
 914              	.LCFI20:
 915              		.cfi_def_cfa_register 7
 916 0004 0646     		mov	r6, r0
 917 0006 0C46     		mov	r4, r1
 216:src/usart_rtos.c ****     *(num) = 0;
 918              		.loc 1 216 0
 919 0008 0023     		movs	r3, #0
 920 000a 0B60     		str	r3, [r1]
 921              	.LVL94:
 217:src/usart_rtos.c ****     int i=0;
 218:src/usart_rtos.c ****     uint8_t neg = 0;
 219:src/usart_rtos.c **** 
 220:src/usart_rtos.c ****     int len = USART_nextline_length(USARTx_rtos)+1; //add for str terminator
 922              		.loc 1 220 0
 923 000c FFF7FEFF 		bl	USART_nextline_length
 924              	.LVL95:
 925 0010 421C     		adds	r2, r0, #1
 926              	.LVL96:
 221:src/usart_rtos.c ****     char buffer[len];
 927              		.loc 1 221 0
 928 0012 0830     		adds	r0, r0, #8
 929              	.LVL97:
 930 0014 20F00700 		bic	r0, r0, #7
 931              	.LVL98:
 932 0018 ADEB000D 		sub	sp, sp, r0
 933 001c 6D46     		mov	r5, sp
 934              	.LVL99:
 222:src/usart_rtos.c ****     USART_readline(USARTx_rtos->id, buffer, len);
 935              		.loc 1 222 0
 936 001e B068     		ldr	r0, [r6, #8]
 937 0020 6946     		mov	r1, sp
 938 0022 D2B2     		uxtb	r2, r2
 939              	.LVL100:
 940 0024 FFF7FEFF 		bl	USART_readline
 941              	.LVL101:
 223:src/usart_rtos.c **** 
 224:src/usart_rtos.c ****     if (buffer[i] == '-') {
 942              		.loc 1 224 0
 943 0028 9DF80030 		ldrb	r3, [sp]	@ zero_extendqisi2
 944 002c 2D2B     		cmp	r3, #45
 218:src/usart_rtos.c **** 
 945              		.loc 1 218 0
 946 002e 14BF     		ite	ne
 947 0030 0020     		movne	r0, #0
 225:src/usart_rtos.c ****         i++;
 226:src/usart_rtos.c ****         neg = 1;
 948              		.loc 1 226 0
 949 0032 0120     		moveq	r0, #1
 225:src/usart_rtos.c ****         i++;
 950              		.loc 1 225 0
 951 0034 0346     		mov	r3, r0
 952 0036 0CE0     		b	.L53
 953              	.LVL102:
 954              	.L50:
 227:src/usart_rtos.c ****     }
 228:src/usart_rtos.c **** 
 229:src/usart_rtos.c ****     for(i; buffer[i]!='\0'; i++) {
 230:src/usart_rtos.c ****         if (buffer[i] >= '0' && buffer[i]<='9'){
 955              		.loc 1 230 0
 956 0038 303A     		subs	r2, r2, #48
 957 003a D2B2     		uxtb	r2, r2
 958 003c 092A     		cmp	r2, #9
 959 003e 0BD8     		bhi	.L49
 231:src/usart_rtos.c ****             *(num) *= 10; 
 960              		.loc 1 231 0
 961 0040 2268     		ldr	r2, [r4]
 962 0042 02EB8202 		add	r2, r2, r2, lsl #2
 232:src/usart_rtos.c ****             *(num) += buffer[i]-'0';
 963              		.loc 1 232 0
 964 0046 E95C     		ldrb	r1, [r5, r3]	@ zero_extendqisi2
 965 0048 3039     		subs	r1, r1, #48
 966 004a 01EB4202 		add	r2, r1, r2, lsl #1
 967 004e 2260     		str	r2, [r4]
 229:src/usart_rtos.c ****         if (buffer[i] >= '0' && buffer[i]<='9'){
 968              		.loc 1 229 0
 969 0050 0133     		adds	r3, r3, #1
 970              	.LVL103:
 971              	.L53:
 229:src/usart_rtos.c ****         if (buffer[i] >= '0' && buffer[i]<='9'){
 972              		.loc 1 229 0 is_stmt 0 discriminator 1
 973 0052 EA5C     		ldrb	r2, [r5, r3]	@ zero_extendqisi2
 974 0054 002A     		cmp	r2, #0
 975 0056 EFD1     		bne	.L50
 976              	.L49:
 233:src/usart_rtos.c ****         }
 234:src/usart_rtos.c **** 
 235:src/usart_rtos.c ****         else {
 236:src/usart_rtos.c ****             break;
 237:src/usart_rtos.c ****         }    
 238:src/usart_rtos.c ****     }
 239:src/usart_rtos.c **** 
 240:src/usart_rtos.c ****     if (neg) {
 977              		.loc 1 240 0 is_stmt 1
 978 0058 10B1     		cbz	r0, .L46
 241:src/usart_rtos.c ****         *(num) *= -1;
 979              		.loc 1 241 0
 980 005a 2368     		ldr	r3, [r4]
 981              	.LVL104:
 982 005c 5B42     		negs	r3, r3
 983 005e 2360     		str	r3, [r4]
 984              	.L46:
 242:src/usart_rtos.c ****     }
 243:src/usart_rtos.c **** 
 244:src/usart_rtos.c **** }
 985              		.loc 1 244 0
 986 0060 BD46     		mov	sp, r7
 987              		@ sp needed
 988 0062 F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 989              		.cfi_endproc
 990              	.LFE123:
 992              		.section	.rodata.str1.4,"aMS",%progbits,1
 993              		.align	2
 994              	.LC0:
 995 0000 76555341 		.ascii	"vUSART_puts\000"
 995      52545F70 
 995      75747300 
 996              	.LC1:
 997 000c 4552524F 		.ascii	"ERROR483\015\012\000"
 997      52343833 
 997      0D0A00
 998 0017 00       		.space	1
 999              	.LC2:
 1000 0018 5052494E 		.ascii	"PRINTING NEXT LINE: \000"
 1000      54494E47 
 1000      204E4558 
 1000      54204C49 
 1000      4E453A20 
 1001 002d 000000   		.space	3
 1002              	.LC3:
 1003 0030 0D0A00   		.ascii	"\015\012\000"
 1004 0033 00       		.space	1
 1005              	.LC4:
 1006 0034 436F6D6D 		.ascii	"Command: \000"
 1006      616E643A 
 1006      2000
 1007 003e 0000     		.space	2
 1008              	.LC5:
 1009 0040 6F766572 		.ascii	"overview\015\000"
 1009      76696577 
 1009      0D00
 1010 004a 0000     		.text
 1011              	.Letext0:
 1012              		.file 3 "FreeRTOS/Source/include/projdefs.h"
 1013              		.file 4 "/usr/include/newlib/machine/_default_types.h"
 1014              		.file 5 "/usr/include/newlib/stdint.h"
 1015              		.file 6 "libs/Device/STM32F4xx/Include/stm32f4xx.h"
 1016              		.file 7 "FreeRTOS/Source/include/../../Source/portable/GCC/ARM_CM4F/portmacro.h"
 1017              		.file 8 "FreeRTOS/Source/include/task.h"
 1018              		.file 9 "FreeRTOS/Source/include/queue.h"
 1019              		.file 10 "FreeRTOS/Source/include/semphr.h"
 1020              		.file 11 "src/usart_rtos.h"
 1021              		.file 12 "/usr/lib/gcc/arm-none-eabi/4.8.2/include/stdarg.h"
 1022              		.file 13 "<built-in>"
 1023              		.file 14 "libs/STM32F4xx_StdPeriph_Driver/inc/stm32f4xx_usart.h"
 1024              		.file 15 "libs/CMSIS/Include/core_cm4.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 usart_rtos.c
     /tmp/ccEWLIcG.s:20     .text.USART_rtos_wait_send:0000000000000000 $t
     /tmp/ccEWLIcG.s:25     .text.USART_rtos_wait_send:0000000000000000 USART_rtos_wait_send
     /tmp/ccEWLIcG.s:58     .text.USART_rtos_init:0000000000000000 $t
     /tmp/ccEWLIcG.s:63     .text.USART_rtos_init:0000000000000000 USART_rtos_init
     /tmp/ccEWLIcG.s:104    .text.USART_put:0000000000000000 $t
     /tmp/ccEWLIcG.s:109    .text.USART_put:0000000000000000 USART_put
     /tmp/ccEWLIcG.s:144    .text.USART_puts:0000000000000000 $t
     /tmp/ccEWLIcG.s:149    .text.USART_puts:0000000000000000 USART_puts
     /tmp/ccEWLIcG.s:190    .text.vUSART_puts:0000000000000000 $t
     /tmp/ccEWLIcG.s:195    .text.vUSART_puts:0000000000000000 vUSART_puts
     /tmp/ccEWLIcG.s:264    .text.USART_rtos_puts:0000000000000000 $t
     /tmp/ccEWLIcG.s:269    .text.USART_rtos_puts:0000000000000000 USART_rtos_puts
     /tmp/ccEWLIcG.s:994    .rodata.str1.4:0000000000000000 .LC0
     /tmp/ccEWLIcG.s:996    .rodata.str1.4:000000000000000c .LC1
     /tmp/ccEWLIcG.s:343    .text.USART_rtos_sputs:0000000000000000 $t
     /tmp/ccEWLIcG.s:348    .text.USART_rtos_sputs:0000000000000000 USART_rtos_sputs
     /tmp/ccEWLIcG.s:413    .text.USART_put_unsigned_int:0000000000000000 $t
     /tmp/ccEWLIcG.s:418    .text.USART_put_unsigned_int:0000000000000000 USART_put_unsigned_int
     /tmp/ccEWLIcG.s:491    .text.USART_put_int:0000000000000000 $t
     /tmp/ccEWLIcG.s:496    .text.USART_put_int:0000000000000000 USART_put_int
     /tmp/ccEWLIcG.s:589    .text.USART_getline:0000000000000000 $t
     /tmp/ccEWLIcG.s:594    .text.USART_getline:0000000000000000 USART_getline
     /tmp/ccEWLIcG.s:643    .text.USART_nextline_length:0000000000000000 $t
     /tmp/ccEWLIcG.s:648    .text.USART_nextline_length:0000000000000000 USART_nextline_length
     /tmp/ccEWLIcG.s:999    .rodata.str1.4:0000000000000018 .LC2
     /tmp/ccEWLIcG.s:1002   .rodata.str1.4:0000000000000030 .LC3
     /tmp/ccEWLIcG.s:718    .text.handle_usart_command:0000000000000000 $t
     /tmp/ccEWLIcG.s:723    .text.handle_usart_command:0000000000000000 handle_usart_command
     /tmp/ccEWLIcG.s:1005   .rodata.str1.4:0000000000000034 .LC4
     /tmp/ccEWLIcG.s:1008   .rodata.str1.4:0000000000000040 .LC5
     /tmp/ccEWLIcG.s:771    .text.USART_readline:0000000000000000 $t
     /tmp/ccEWLIcG.s:776    .text.USART_readline:0000000000000000 USART_readline
     /tmp/ccEWLIcG.s:892    .text.USART_readline_int:0000000000000000 $t
     /tmp/ccEWLIcG.s:897    .text.USART_readline_int:0000000000000000 USART_readline_int
     /tmp/ccEWLIcG.s:993    .rodata.str1.4:0000000000000000 $d
                     .debug_frame:0000000000000010 $d
                           .group:0000000000000000 wm4.1.7402b5479d3fa4780665141f585fc0ee
                           .group:0000000000000000 wm4.stddef.h.39.daafd3d79fe2f3a84d2d73d7d4e706f8
                           .group:0000000000000000 wm4.projdefs.h.55.cdae9ead80b5a2ac004f41bb277aad45
                           .group:0000000000000000 wm4.FreeRTOSConfig.h.55.a343614a17c4367a6359a1f530d6d32b
                           .group:0000000000000000 wm4.stm32f4xx.h.48.a3308e16720c7afc3eb28e585e628ce6
                           .group:0000000000000000 wm4.core_cm4.h.32.5f62939b60122629d60d85d0c4a14709
                           .group:0000000000000000 wm4.features.h.22.6a4ca7cd053637cc1d0db6c16f39b2d7
                           .group:0000000000000000 wm4._default_types.h.15.8b2cb27e528498f8ff711db085d6e489
                           .group:0000000000000000 wm4.stdint.h.20.796e373797e732130a803d4c0338fa1b
                           .group:0000000000000000 wm4.core_cmInstr.h.25.f50f886f2edf670cf199b35fd96f5c91
                           .group:0000000000000000 wm4.core_cm4_simd.h.29.b4a3fdfb606cb3b26119424324d4b963
                           .group:0000000000000000 wm4.core_cm4.h.153.5393ef7e6cebf34dd51ca528f9218ab3
                           .group:0000000000000000 wm4.stm32f4xx.h.282.95bae448a91bccfbf24a6f9d95904bb8
                           .group:0000000000000000 wm4.stm32f4xx_adc.h.102.2061aa73008746f3c2cc6ce8f635cad3
                           .group:0000000000000000 wm4.stm32f4xx_can.h.25.87f18ca48b2692d39f76e87b1f07c953
                           .group:0000000000000000 wm4.stm32f4xx_cryp.h.25.db1951c06ee684df97ea3a11aba6cb51
                           .group:0000000000000000 wm4.stm32f4xx_dac.h.25.c43557a6416ea4dfa986c1209c2558d6
                           .group:0000000000000000 wm4.stm32f4xx_dbgmcu.h.24.7aedfdcf091890b5cb96019bd29a2bfc
                           .group:0000000000000000 wm4.stm32f4xx_dcmi.h.24.64883d9be802a535b1d7770d14da73e0
                           .group:0000000000000000 wm4.stm32f4xx_dma.h.25.c1fa1d44ae0bc9c2b3a0d1d355d8c1e6
                           .group:0000000000000000 wm4.stm32f4xx_exti.h.25.620998268d5d3d9042a8297fbe07d507
                           .group:0000000000000000 wm4.stm32f4xx_flash.h.25.65d4f351b72ee41355279f70305f361a
                           .group:0000000000000000 wm4.stm32f4xx_fsmc.h.25.b907ac7bd9bec46e02d06b137d53cfd8
                           .group:0000000000000000 wm4.stm32f4xx_hash.h.25.633fb84f031cf2ab1bd834e536716dfa
                           .group:0000000000000000 wm4.stm32f4xx_gpio.h.25.5bd1d790d742a307b55aea5fa8fcdae8
                           .group:0000000000000000 wm4.stm32f4xx_i2c.h.25.8fcdb817a00a67d4624d79bab0d9275f
                           .group:0000000000000000 wm4.stm32f4xx_iwdg.h.25.3013e8d2058415cb9d51af77f748a146
                           .group:0000000000000000 wm4.stm32f4xx_pwr.h.25.48b68c1f3a894ab012f9c2a2c222f159
                           .group:0000000000000000 wm4.stm32f4xx_rcc.h.24.c15e7c8dc065bb29146f29591b195c87
                           .group:0000000000000000 wm4.stm32f4xx_rng.h.25.cdb5c5c07de6a48aedfde608da3f447e
                           .group:0000000000000000 wm4.stm32f4xx_rtc.h.25.4809a79ad46ad97b4a01e735a96738eb
                           .group:0000000000000000 wm4.stm32f4xx_sdio.h.25.406302aabae34eada94e5f2cde635a3e
                           .group:0000000000000000 wm4.stm32f4xx_spi.h.25.46c61b79ff8408da93e2e90cf9b717d6
                           .group:0000000000000000 wm4.stm32f4xx_syscfg.h.25.9d5caab5677661b69e959531364e23d7
                           .group:0000000000000000 wm4.stm32f4xx_tim.h.25.948f7fc943f34bd206e29758e77ee0a2
                           .group:0000000000000000 wm4.stm32f4xx_usart.h.25.b64697dad017ba547dd272c2cdb5846a
                           .group:0000000000000000 wm4.stm32f4xx_wwdg.h.25.09d70b7849c6894ddf1e83c8e86b70e1
                           .group:0000000000000000 wm4.misc.h.25.a0cb758c1f091b46f201b19cec9e63a1
                           .group:0000000000000000 wm4.stm32f4xx.h.6913.da011404ccb203790556c86f10c46b18
                           .group:0000000000000000 wm4.FreeRTOSConfig.h.74.fc794e36cd6c91c3b4695c74d78d9ccd
                           .group:0000000000000000 wm4.portmacro.h.69.a7e264ae32accd81a6ffb6f75a8356fe
                           .group:0000000000000000 wm4.portable.h.315.489c085dbd13c768c8594a7d23ef5545
                           .group:0000000000000000 wm4.mpu_wrappers.h.55.46a4a008a193040c38098e9a5f07ff9d
                           .group:0000000000000000 wm4.FreeRTOS.h.136.a1d4f27d190f434afd0502fdd510d30a
                           .group:0000000000000000 wm4.list.h.84.e713c47e239b06424d7c93968625e34d
                           .group:0000000000000000 wm4.task.h.73.ea72fb74b80a9cae261e97c6a9e3f3a7
                           .group:0000000000000000 wm4.queue.h.56.a4282b659085ac883e461fc7ab8aecd1
                           .group:0000000000000000 wm4.semphr.h.65.53591bdf1c84eee2eae05897a780c325
                           .group:0000000000000000 wm4.newlib.h.8.fec018e441fee7bfa1923812ad010f97
                           .group:0000000000000000 wm4.config.h.212.4163ef2871a828c674038d036b081cfd
                           .group:0000000000000000 wm4._ansi.h.23.2147fde150631f5584b9dc29b914d1b8
                           .group:0000000000000000 wm4.stdlib.h.13.4ed386f5c1a80d71e72172885d946ef2
                           .group:0000000000000000 wm4.stddef.h.158.a7efb00f6cbc6f43213b50e183c9830c
                           .group:0000000000000000 wm4.lock.h.2.9bc98482741e5e2a9450b12934a684ea
                           .group:0000000000000000 wm4._types.h.54.d3d34a3b7f3cc230cd159baf022b4b08
                           .group:0000000000000000 wm4.stddef.h.158.61317cdbfb4026324507d123a50b0fd6
                           .group:0000000000000000 wm4.reent.h.17.8bd9e4098e0428508c282cad794fae43
                           .group:0000000000000000 wm4.alloca.h.8.dfc0c703c47ec3e69746825b17d9e66d
                           .group:0000000000000000 wm4.stdlib.h.53.1a82a3cc35cb0a04319c41bcf41d2a02
                           .group:0000000000000000 wm4.stdarg.h.31.72c3aa8d68b291953fa52b9471bcdff7

UNDEFINED SYMBOLS
xQueueGenericReceive
xQueueCreateMutex
USART_SendData
vPortEnterCritical
xQueueGenericSend
vPortExitCritical
vTaskDelete
xTaskGenericCreate
vsprintf
str_compare
